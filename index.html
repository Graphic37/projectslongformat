<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Corefall: Idle Dungeon RPG</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');
    
    * { margin: 0; padding: 0; box-sizing: border-box; }
    
    body {
      background: #0a0a0a;
      font-family: 'Inter', sans-serif;
      overflow: hidden;
    }
    
    #gameCanvas {
      display: block;
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: #0a0a08;
    }
    
    /* Greater Rift Overlay */
    #greaterRiftOverlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      pointer-events: none;
      z-index: 1;
      opacity: 0;
      transition: opacity 0.5s;
      background: radial-gradient(ellipse at center, 
        transparent 30%,
        rgba(40, 20, 80, 0.3) 60%,
        rgba(30, 10, 60, 0.5) 80%,
        rgba(20, 5, 50, 0.7) 100%);
      box-shadow: inset 0 0 150px rgba(100, 50, 180, 0.4);
    }
    
    #greaterRiftOverlay.active {
      opacity: 1;
    }
    
    /* Bottom HUD */
    #bottomHUD {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      align-items: flex-end;
      gap: 15px;
      z-index: 100;
    }
    
    /* Character Portrait */
    .portrait-container {
      position: relative;
      width: 90px;
      height: 90px;
    }
    
    .portrait {
      width: 100%;
      height: 100%;
      border-radius: 50%;
      background: linear-gradient(135deg, #3a3a4a 0%, #1a1a2a 100%);
      border: 3px solid #2a2a3a;
      overflow: hidden;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 40px;
      box-shadow: 0 4px 20px rgba(0,0,0,0.5);
    }
    
    .portrait-img {
      width: 70px;
      height: 70px;
      object-fit: contain;
      display: none;
    }
    
    .portrait-icon {
      font-size: 40px;
    }
    
    .portrait-ring {
      position: absolute;
      inset: -4px;
      border-radius: 50%;
      background: conic-gradient(#c9a227 0%, #c9a227 var(--exp-pct, 0%), transparent var(--exp-pct, 0%), transparent 100%);
      -webkit-mask: radial-gradient(transparent 42px, #000 43px);
      mask: radial-gradient(transparent 42px, #000 43px);
    }
    
    .level-badge {
      position: absolute;
      bottom: -5px;
      left: 50%;
      transform: translateX(-50%);
      background: linear-gradient(180deg, #1a1a2a 0%, #0a0a1a 100%);
      border: 2px solid #3a3a4a;
      border-radius: 10px;
      padding: 2px 12px;
      font-size: 14px;
      font-weight: 700;
      color: #c9a227;
    }
    
    /* Stats Panel */
    .stats-panel {
      display: flex;
      flex-direction: column;
      gap: 6px;
      min-width: 200px;
    }
    
    .stat-bar-container {
      position: relative;
      height: 26px;
      background: #0a0a0f;
      border-radius: 4px;
      overflow: hidden;
      border: 1px solid #2a2a35;
      cursor: help;
      transition: border-color 0.15s;
    }
    
    .stat-bar-container:hover {
      border-color: #4a4a55;
    }
    
    .stat-bar {
      height: 100%;
      transition: width 0.3s ease-out, left 0.15s ease-out;
      position: absolute;
      top: 0;
      left: 0;
    }
    
    .stat-bar.health {
      background: linear-gradient(180deg, #3a8a3a 0%, #2a6a2a 50%, #1a5a1a 100%);
      box-shadow: inset 0 1px 0 rgba(255,255,255,0.15), 0 0 10px rgba(50,150,50,0.3);
      z-index: 1;
    }
    
    .stat-bar.mana {
      background: linear-gradient(180deg, #3a6aaa 0%, #2a5090 50%, #1a4080 100%);
      box-shadow: inset 0 1px 0 rgba(255,255,255,0.15), 0 0 10px rgba(50,100,200,0.3);
    }
    
    .stat-bar.shield-overlay {
      position: absolute;
      top: 0;
      left: 0;
      height: 100%;
      background: linear-gradient(180deg, #7070cc 0%, #5555aa 50%, #454588 100%);
      box-shadow: inset 0 1px 0 rgba(255,255,255,0.3), 0 0 8px rgba(120,120,220,0.6);
      z-index: 2;
      transition: width 0.15s ease-out;
      border-right: 2px solid rgba(180,180,255,0.6);
    }
    
    .stat-bar-text {
      position: absolute;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 0 10px;
      font-size: 12px;
      font-weight: 600;
      color: #fff;
      text-shadow: 0 1px 2px rgba(0,0,0,0.8);
      z-index: 3;
    }
    
    .stat-bar-text .regen {
      position: absolute;
      right: 10px;
      color: rgba(255,255,255,0.6);
      font-size: 11px;
    }
    
    /* Potion Bar */
    .potion-bar {
      display: flex;
      gap: 6px;
      margin-bottom: 8px;
    }
    
    .potion-btn {
      position: relative;
      width: 40px;
      height: 40px;
      background: linear-gradient(180deg, #2a2525 0%, #1a1515 100%);
      border: 2px solid #4a3030;
      border-radius: 8px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: all 0.15s;
    }
    
    .potion-btn:hover {
      border-color: #6a4040;
      transform: scale(1.05);
    }
    
    .potion-btn:active {
      transform: scale(0.95);
    }
    
    .potion-btn.empty {
      opacity: 0.4;
      filter: grayscale(0.8);
    }
    
    .potion-btn.on-cooldown {
      border-color: #333;
      position: relative;
    }
    
    .potion-btn .cooldown-ring {
      position: absolute;
      inset: 2px;
      border-radius: 6px;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.2s;
    }
    
    .potion-btn.on-cooldown .cooldown-ring {
      opacity: 1;
      background: conic-gradient(
        rgba(0,0,0,0.7) var(--cooldown-pct, 0%),
        transparent var(--cooldown-pct, 0%)
      );
    }
    
    .potion-btn.on-cooldown .potion-icon {
      opacity: 0.6;
    }
    
    .potion-icon {
      font-size: 20px;
    }
    
    .potion-icon-img {
      width: 32px;
      height: 32px;
      object-fit: contain;
    }
    
    .potion-btn.on-cooldown .potion-icon-img {
      opacity: 0.6;
    }
    
    .potion-charges {
      position: absolute;
      bottom: -2px;
      right: -2px;
      background: #1a1a1a;
      color: #ddd;
      font-size: 11px;
      font-weight: bold;
      padding: 1px 4px;
      border-radius: 4px;
      border: 1px solid #444;
    }
    
    #lifePotionBtn { border-color: #5a2020; }
    #lifePotionBtn:hover { border-color: #8a3030; box-shadow: 0 0 10px rgba(255,50,50,0.3); }
    #manaPotionBtn { border-color: #203050; }
    #manaPotionBtn:hover { border-color: #304080; box-shadow: 0 0 10px rgba(50,100,255,0.3); }
    
    /* Buff/Debuff Bar */
    .buff-bar {
      display: flex;
      gap: 4px;
      margin-bottom: 8px;
      min-height: 32px;
      align-items: center;
      justify-content: center;
    }
    .buff-icon {
      position: relative;
      width: 28px;
      height: 28px;
      background: rgba(20, 20, 25, 0.9);
      border: 2px solid #444;
      border-radius: 4px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 16px;
      cursor: default;
    }
    .buff-icon.buff { border-color: #4a9; }
    .buff-icon.debuff { border-color: #c44; }
    .buff-icon .buff-duration {
      position: absolute;
      bottom: -2px;
      right: -2px;
      font-size: 9px;
      background: rgba(0,0,0,0.8);
      padding: 1px 3px;
      border-radius: 3px;
      color: #fff;
    }
    .buff-tooltip {
      position: fixed;
      background: rgba(20, 20, 28, 0.98);
      border: 1px solid #444;
      border-radius: 6px;
      padding: 8px 12px;
      z-index: 10001;
      pointer-events: none;
      font-size: 12px;
      max-width: 200px;
      display: none;
    }
    .buff-tooltip.visible { display: block; }
    .buff-tooltip-name { color: #fff; font-weight: bold; margin-bottom: 4px; }
    .buff-tooltip-name.buff { color: #6fc; }
    .buff-tooltip-name.debuff { color: #f66; }
    .buff-tooltip-desc { color: #aaa; font-size: 11px; }
    .buff-tooltip-time { color: #888; font-size: 10px; margin-top: 4px; }
    
    /* Skill Bar */
    .skill-bar {
      display: flex;
      gap: 5px;
      align-items: flex-end;
    }
    
    .skill-slot {
      position: relative;
      width: 54px;
      height: 54px;
      background: linear-gradient(180deg, #252530 0%, #15151a 100%);
      border: 2px solid #3a3a45;
      border-radius: 6px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: all 0.15s;
      overflow: hidden;
    }
    
    .skill-slot:hover {
      border-color: #5a5a65;
      transform: translateY(-2px);
    }
    
    .skill-slot.active {
      border-color: #c9a227;
      box-shadow: 0 0 15px rgba(200,160,40,0.3);
    }
    
    .skill-icon {
      font-size: 26px;
      filter: drop-shadow(0 2px 4px rgba(0,0,0,0.5));
    }
    
    .skill-icon-img {
      width: 44px;
      height: 44px;
      object-fit: contain;
      filter: drop-shadow(0 2px 4px rgba(0,0,0,0.5));
    }
    
    .skill-slot.fire .skill-icon, .skill-slot.fire .skill-icon-img { filter: drop-shadow(0 0 8px rgba(255,100,50,0.5)); }
    .skill-slot.ice .skill-icon, .skill-slot.ice .skill-icon-img { filter: drop-shadow(0 0 8px rgba(100,200,255,0.5)); }
    .skill-slot.lightning .skill-icon, .skill-slot.lightning .skill-icon-img { filter: drop-shadow(0 0 8px rgba(200,150,255,0.5)); }
    .skill-slot.vaal { border-color: #aa3333; }
    .skill-slot.vaal .skill-icon, .skill-slot.vaal .skill-icon-img { filter: drop-shadow(0 0 10px rgba(255,50,50,0.7)); }
    
    /* Primary Slot Styling */
    .skill-slot.primary-slot {
      border-color: #c9a227;
      box-shadow: 0 0 8px rgba(200,160,40,0.2);
    }
    .skill-slot.primary-slot:hover {
      border-color: #e5c13d;
      box-shadow: 0 0 12px rgba(200,160,40,0.3);
    }
    .primary-label {
      position: absolute;
      top: 2px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 6px;
      font-weight: bold;
      color: #c9a227;
      text-shadow: 0 1px 2px rgba(0,0,0,0.8);
      letter-spacing: 0.5px;
    }
    
    .skill-key {
      position: absolute;
      bottom: 4px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 11px;
      font-weight: 600;
      color: #888;
      text-shadow: 0 1px 2px rgba(0,0,0,0.8);
    }
    
    .skill-cd {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      height: 0%;
      background: rgba(0,0,0,0.8);
      transition: height 0.1s;
      pointer-events: none;
    }
    
    .skill-cd-text {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 14px;
      font-weight: bold;
      color: #fff;
      text-shadow: 0 0 4px #000, 0 0 4px #000;
      pointer-events: none;
      z-index: 5;
    }
    
    .skill-slot.on-cooldown {
      filter: saturate(0.3);
    }
    
    .skill-slot.no-mana {
      border-color: #664444;
    }
    
    .skill-slot.no-mana .skill-icon {
      filter: grayscale(0.5) brightness(0.7);
    }
    
    /* AI Priority Pips */
    .ai-pips {
      position: absolute;
      top: 2px;
      right: 2px;
      display: flex;
      gap: 2px;
      z-index: 10;
      cursor: pointer;
      padding: 1px 3px;
      background: rgba(0,0,0,0.7);
      border-radius: 6px;
    }
    .ai-pips:hover {
      background: rgba(60,60,80,0.9);
      transform: scale(1.1);
    }
    .ai-pip {
      width: 5px;
      height: 5px;
      border-radius: 50%;
      background: #222;
      border: 1px solid #444;
      transition: all 0.15s;
    }
    .ai-pip.active {
      background: #4a9;
      border-color: #6cb;
      box-shadow: 0 0 3px rgba(100, 200, 150, 0.5);
    }
    /* Priority colors */
    .ai-pips[data-priority="0"] .ai-pip {
      background: #333;
      border-color: #444;
      opacity: 0.4;
    }
    .ai-pips[data-priority="1"] .ai-pip.active {
      background: #555;
      border-color: #777;
      box-shadow: 0 0 2px rgba(100, 100, 100, 0.3);
    }
    .ai-pips[data-priority="2"] .ai-pip.active {
      background: #4a9;
      border-color: #6cb;
      box-shadow: 0 0 3px rgba(100, 200, 150, 0.5);
    }
    .ai-pips[data-priority="3"] .ai-pip.active {
      background: #c84;
      border-color: #ea6;
      box-shadow: 0 0 4px rgba(200, 150, 80, 0.6);
    }
    /* Hide pips on primary slot (slot 0) */
    .skill-slot.primary-slot .ai-pips {
      display: none;
    }
    
    /* AI Priority feedback animation */
    @keyframes aiFeedbackFloat {
      0% { opacity: 1; transform: translateY(0); }
      100% { opacity: 0; transform: translateY(-15px); }
    }
    
    /* Summoner Spell Style (same size as skills) */
    .spell-slot {
      width: 54px;
      height: 54px;
      border-radius: 6px;
    }
    
    .spell-slot .skill-icon {
      font-size: 26px;
    }
    
    /* Passive Slot Style */
    .passive-slot {
      width: 54px;
      height: 54px;
      border-radius: 6px;
      border-color: #5a4a8a !important;
      background: linear-gradient(180deg, #1a152a 0%, #0a0812 100%) !important;
    }
    
    .passive-slot:hover {
      border-color: #8a6aaa !important;
      box-shadow: 0 0 12px rgba(138, 106, 170, 0.5);
    }
    
    .passive-slot .skill-icon {
      font-size: 26px;
      filter: drop-shadow(0 0 6px rgba(150, 100, 200, 0.4));
    }
    
    .passive-label-top {
      position: absolute;
      top: 2px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 6px;
      font-weight: bold;
      color: #8a6aaa;
      text-shadow: 0 1px 2px rgba(0,0,0,0.8);
      letter-spacing: 0.5px;
    }
    
    .skill-passive-badge {
      font-size: 8px;
      padding: 2px 5px;
      background: linear-gradient(180deg, #6a5a9a 0%, #4a3a7a 100%);
      color: #e0d0ff;
      border-radius: 3px;
      margin-left: 6px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    
    /* Skill Tooltip */
    .skill-tooltip {
      position: fixed;
      z-index: 10001;
      pointer-events: none;
      min-width: 220px;
      max-width: 300px;
      background: linear-gradient(180deg, #151520 0%, #0a0a12 100%);
      border: 2px solid #4a4a60;
      border-radius: 6px;
      padding: 12px 14px;
      font-family: 'Inter', sans-serif;
      display: none;
      box-shadow: 0 8px 25px rgba(0,0,0,0.9);
    }
    
    .skill-tooltip.visible { display: block; }
    
    .skill-tooltip-name {
      font-size: 16px;
      font-weight: bold;
      color: #ffcc44;
      margin-bottom: 4px;
    }
    
    .skill-tooltip-type {
      font-size: 11px;
      color: #888;
      text-transform: uppercase;
      letter-spacing: 1px;
      margin-bottom: 10px;
    }
    
    .skill-tooltip-desc {
      font-size: 13px;
      color: #aaa;
      line-height: 1.4;
      margin-bottom: 10px;
    }
    
    .skill-tooltip-stat {
      font-size: 12px;
      color: #8888ff;
      padding: 2px 0;
    }
    
    .skill-tooltip-cost {
      font-size: 12px;
      color: #6688ff;
      margin-top: 8px;
      padding-top: 8px;
      border-top: 1px solid #3a3a50;
    }
    
    .skill-tooltip-cooldown {
      font-size: 11px;
      color: #888;
    }
    
    /* Potion Tooltip - styled like skill tooltips */
    .potion-tooltip {
      position: fixed;
      z-index: 10001;
      pointer-events: none;
      min-width: 200px;
      max-width: 260px;
      background: linear-gradient(180deg, #151520 0%, #0a0a12 100%);
      border: 2px solid #4a4a60;
      border-radius: 6px;
      padding: 12px 14px;
      font-family: 'Inter', sans-serif;
      display: none;
      box-shadow: 0 8px 25px rgba(0,0,0,0.9);
    }
    
    .potion-tooltip.visible { display: block; }
    
    .potion-tooltip.life { border-color: #6a3030; }
    .potion-tooltip.mana { border-color: #304060; }
    
    .potion-tooltip-name {
      font-size: 16px;
      font-weight: bold;
      margin-bottom: 4px;
    }
    
    .potion-tooltip-name.life { color: #ff6666; }
    .potion-tooltip-name.mana { color: #6688ff; }
    
    .potion-tooltip-type {
      font-size: 11px;
      color: #888;
      text-transform: uppercase;
      letter-spacing: 1px;
      margin-bottom: 10px;
    }
    
    .potion-tooltip-desc {
      font-size: 13px;
      color: #ccc;
      line-height: 1.4;
      margin-bottom: 10px;
    }
    
    .potion-tooltip-stat {
      font-size: 12px;
      color: #88ffaa;
      padding: 2px 0;
    }
    
    .potion-tooltip-stat.warning {
      color: #ffaa66;
    }
    
    .potion-tooltip-footer {
      font-size: 11px;
      color: #666;
      margin-top: 8px;
      padding-top: 8px;
      border-top: 1px solid #3a3a50;
    }
    
    .potion-tooltip-key {
      display: inline-block;
      background: #333;
      border: 1px solid #555;
      border-radius: 3px;
      padding: 1px 6px;
      font-size: 11px;
      color: #ccc;
      margin-left: 8px;
    }
    
    /* AI Priority Tooltip */
    .ai-priority-tooltip {
      position: fixed;
      z-index: 10002;
      pointer-events: none;
      min-width: 200px;
      max-width: 260px;
      background: linear-gradient(180deg, #151525 0%, #0a0a15 100%);
      border: 2px solid #4a6a5a;
      border-radius: 6px;
      padding: 10px 12px;
      font-family: 'Inter', sans-serif;
      display: none;
      box-shadow: 0 6px 20px rgba(0,0,0,0.9);
    }
    .ai-priority-tooltip.visible { display: block; }
    .ai-tooltip-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 6px;
    }
    .ai-tooltip-title {
      font-size: 10px;
      color: #666;
      text-transform: uppercase;
      letter-spacing: 1px;
    }
    .ai-tooltip-level {
      font-size: 13px;
      font-weight: bold;
      color: #4a9;
    }
    .ai-tooltip-level.disabled { color: #666; }
    .ai-tooltip-level.conservative { color: #888; }
    .ai-tooltip-level.normal { color: #4a9; }
    .ai-tooltip-level.aggressive { color: #c84; }
    .ai-tooltip-desc {
      font-size: 12px;
      color: #aaa;
      margin-bottom: 8px;
    }
    .ai-tooltip-details {
      font-size: 11px;
      color: #7a9a8a;
      line-height: 1.5;
    }
    .ai-tooltip-details div {
      padding: 2px 0;
    }
    .ai-tooltip-hint {
      font-size: 10px;
      color: #555;
      margin-top: 8px;
      padding-top: 6px;
      border-top: 1px solid #2a3a30;
      font-style: italic;
    }
    
    /* Enemy Tooltip */
    .enemy-tooltip {
      position: fixed;
      z-index: 10002;
      pointer-events: none;
      min-width: 200px;
      max-width: 280px;
      background: linear-gradient(180deg, #1a1015 0%, #0d0810 100%);
      border: 2px solid #aa4040;
      border-radius: 8px;
      padding: 12px 16px;
      font-family: 'Inter', sans-serif;
      display: none;
      box-shadow: 0 8px 30px rgba(0,0,0,0.95), 0 0 20px rgba(100,20,20,0.3);
    }
    
    .enemy-tooltip.visible { display: block; }
    
    .enemy-tooltip.boss-tooltip {
      border: 3px solid #d4a520;
      background: linear-gradient(180deg, #1a1510 0%, #0d0a08 100%);
      box-shadow: 0 8px 30px rgba(0,0,0,0.95), 0 0 30px rgba(212,165,32,0.4);
    }
    
    .enemy-tooltip-name {
      font-size: 18px;
      font-weight: bold;
      color: #ff7755;
      margin-bottom: 4px;
      text-shadow: 0 1px 3px rgba(0,0,0,0.8);
    }
    
    .enemy-tooltip-name.boss {
      color: #ffd700;
      font-size: 22px;
      text-shadow: 0 0 15px rgba(255,215,0,0.5), 0 2px 4px rgba(0,0,0,0.8);
      letter-spacing: 0.5px;
    }
    
    .enemy-tooltip-type {
      font-size: 11px;
      color: #999;
      text-transform: uppercase;
      letter-spacing: 1.5px;
      margin-bottom: 10px;
      font-weight: 500;
    }
    
    .enemy-tooltip-type.boss-type {
      color: #d4a520;
      font-size: 12px;
      letter-spacing: 2px;
      text-shadow: 0 0 8px rgba(212,165,32,0.3);
    }
    
    .enemy-tooltip-hp {
      font-size: 15px;
      margin-bottom: 8px;
      color: #ddd;
      font-weight: 500;
    }
    
    .enemy-tooltip-hp-bar {
      height: 10px;
      background: #2a1515;
      border-radius: 5px;
      overflow: hidden;
      margin-bottom: 12px;
      border: 1px solid #3a2020;
    }
    
    .enemy-tooltip.boss-tooltip .enemy-tooltip-hp-bar {
      height: 12px;
      background: #2a2010;
      border: 1px solid #4a3a20;
    }
    
    .enemy-tooltip-hp-fill {
      height: 100%;
      background: linear-gradient(90deg, #aa2222 0%, #ff4444 100%);
      transition: width 0.1s;
      box-shadow: 0 0 8px rgba(255,50,50,0.4);
    }
    
    .enemy-tooltip.boss-tooltip .enemy-tooltip-hp-fill {
      background: linear-gradient(90deg, #aa8800 0%, #ffc000 100%);
      box-shadow: 0 0 10px rgba(255,192,0,0.5);
    }
    
    /* Greater Rift Guardian - Purple theme (only in Greater Rifts) */
    .enemy-tooltip.guardian-tooltip {
      border: 3px solid #8040c0;
      background: linear-gradient(180deg, rgba(60,20,80,0.98) 0%, rgba(30,10,40,0.98) 100%);
      box-shadow: 0 8px 30px rgba(0,0,0,0.95), 0 0 30px rgba(128,64,192,0.5);
    }
    
    .enemy-tooltip.guardian-tooltip .enemy-tooltip-hp-bar {
      height: 14px;
      background: #1a0a2a;
      border: 2px solid #8040c0;
      box-shadow: 0 0 15px rgba(160,80,255,0.4);
    }
    
    .enemy-tooltip.guardian-tooltip .enemy-tooltip-hp-fill {
      background: linear-gradient(90deg, #6020a0 0%, #a050ff 50%, #c080ff 100%);
      box-shadow: 0 0 15px rgba(160,80,255,0.6);
      animation: guardian-pulse 1.5s ease-in-out infinite;
    }
    
    @keyframes guardian-pulse {
      0%, 100% { filter: brightness(1); }
      50% { filter: brightness(1.3); }
    }
    
    .enemy-tooltip.guardian-tooltip .enemy-tooltip-name {
      color: #c080ff;
      text-shadow: 0 0 10px rgba(160,80,255,0.8);
    }
    
    .enemy-tooltip.guardian-tooltip .enemy-tooltip-stat span {
      color: #c080ff;
    }
    
    .enemy-tooltip-stat {
      font-size: 14px;
      color: #bbb;
      padding: 3px 0;
    }
    
    .enemy-tooltip-stat span {
      color: #ffaa77;
      font-weight: 600;
    }
    
    .enemy-tooltip.boss-tooltip .enemy-tooltip-stat span {
      color: #ffd060;
    }

    /* Experience Bar */
    #expContainer {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      height: 8px;
      background: #0a0a0f;
      z-index: 100;
      cursor: pointer;
    }
    
    #expBar {
      height: 100%;
      background: linear-gradient(90deg, #8b6914, #c9a227, #e8c847);
      transition: width 0.3s;
      box-shadow: 0 0 10px rgba(200,160,40,0.4);
    }
    
    .exp-segments {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      display: flex;
      pointer-events: none;
    }
    
    .exp-segment {
      flex: 1;
      border-right: 2px solid #1a1a25;
    }
    
    .exp-segment:last-child {
      border-right: none;
    }
    
    #expTooltip {
      position: fixed;
      bottom: 16px;
      left: 50%;
      transform: translateX(-50%);
      background: linear-gradient(180deg, #1a1a22 0%, #0f0f15 100%);
      border: 2px solid #3a3a4a;
      border-radius: 8px;
      padding: 10px 16px;
      z-index: 101;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.2s;
      white-space: nowrap;
    }
    
    #expTooltip.visible {
      opacity: 1;
    }
    
    .exp-tooltip-title {
      color: #c9a227;
      font-size: 13px;
      font-weight: bold;
      margin-bottom: 6px;
    }
    
    .exp-tooltip-progress {
      display: flex;
      align-items: center;
      gap: 10px;
      margin-bottom: 4px;
    }
    
    .exp-tooltip-bar {
      width: 150px;
      height: 10px;
      background: #1a1a25;
      border-radius: 5px;
      overflow: hidden;
      position: relative;
    }
    
    .exp-tooltip-bar-fill {
      height: 100%;
      background: linear-gradient(90deg, #8b6914, #c9a227);
      border-radius: 5px;
    }
    
    .exp-tooltip-bar-segments {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      display: flex;
    }
    
    .exp-tooltip-bar-segment {
      flex: 1;
      border-right: 1px solid #0a0a0f;
    }
    
    .exp-tooltip-bar-segment:last-child {
      border-right: none;
    }
    
    .exp-tooltip-percent {
      color: #c9a227;
      font-size: 14px;
      font-weight: bold;
      min-width: 45px;
    }
    
    .exp-tooltip-values {
      color: #888;
      font-size: 11px;
    }
    
    .exp-tooltip-values span {
      color: #aaa;
    }
    
    /* Top Stats */
    #topStats {
      position: fixed;
      top: 15px;
      left: 15px;
      display: flex;
      gap: 20px;
      z-index: 100;
    }
    
    .top-stat {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 8px 14px;
      background: rgba(10,10,15,0.9);
      border: 1px solid #2a2a35;
      border-radius: 6px;
      font-size: 13px;
      color: #aaa;
    }
    
    .top-stat .value {
      color: #fff;
      font-weight: 600;
    }
    
    .top-stat .value.gold { color: #f0c040; }
    .top-stat .value.damage { color: #ff8866; }
    
    /* Zone Title */
    #zoneTitle {
      position: fixed;
      top: 15px;
      left: 50%;
      transform: translateX(-50%);
      text-align: center;
      z-index: 100;
      opacity: 0;
      transition: opacity 0.5s;
    }
    
    #zoneTitle.visible { opacity: 1; }
    
    #zoneTitle h1 {
      font-size: 28px;
      font-weight: 600;
      color: #e8d8c8;
      text-shadow: 0 2px 10px rgba(0,0,0,0.8);
      letter-spacing: 2px;
    }
    
    #zoneTitle p {
      font-size: 13px;
      color: #888;
      margin-top: 4px;
    }
    
    /* Dungeon Info - Minimal inline text (top right) */
    #dungeonInfo {
      position: fixed;
      top: 10px;
      right: 320px;
      z-index: 100;
      display: flex;
      align-items: baseline;
      gap: 10px;
      pointer-events: none;
      font-size: 13px;
      background: rgba(0,0,0,0.5);
      padding: 6px 12px;
      border-radius: 3px;
      border: 1px solid rgba(255,255,255,0.1);
    }
    
    #dungeonInfo .dungeon-name {
      font-weight: 600;
      color: #e8d8c0;
      text-transform: uppercase;
      letter-spacing: 1px;
      text-shadow: 0 1px 3px rgba(0,0,0,1), 0 0 8px rgba(0,0,0,0.8);
    }
    
    #dungeonInfo.greater-rift-active .dungeon-name {
      color: #c8a0ff;
      text-shadow: 0 0 10px rgba(160, 100, 255, 0.8), 0 1px 3px rgba(0,0,0,1);
    }
    
    #dungeonInfo.greater-rift-active {
      background: rgba(60, 20, 80, 0.7);
      border-color: rgba(160, 100, 255, 0.3);
    }
    
    #dungeonInfo.greater-rift-active .dungeon-details {
      color: #b090d0;
    }
    
    #dungeonInfo.greater-rift-active .dungeon-details .timer {
      color: #c8a0ff;
    }
    
    #dungeonInfo .dungeon-details {
      color: #aaa;
      text-shadow: 0 1px 3px rgba(0,0,0,1);
    }
    
    #dungeonInfo .dungeon-details .timer {
      color: #8c8;
      font-weight: 500;
    }
    
    /* Debug Panel */
    #debugPanel {
      position: fixed;
      bottom: 120px;
      left: 10px;
      width: 220px;
      background: rgba(0,0,0,0.85);
      border: 2px solid #444;
      border-radius: 4px;
      padding: 10px;
      font-family: monospace;
      font-size: 11px;
      color: #0f0;
      z-index: 500;
      display: none;
    }
    #debugPanel.visible { display: block; }
    #debugPanel .debug-title {
      color: #ff0;
      font-weight: bold;
      margin-bottom: 8px;
      border-bottom: 1px solid #444;
      padding-bottom: 4px;
    }
    #debugPanel .debug-line {
      margin: 3px 0;
    }
    #debugPanel .debug-line span { color: #fff; }
    #debugPanel .debug-warn { color: #f80; }
    #debugPanel .debug-error { color: #f00; }
    
    /* Hotkey Menu (Escape) */
    #hotkeyMenu {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%) scale(0.95);
      width: 320px;
      background: linear-gradient(180deg, #1a1a1f 0%, #0d0d10 100%);
      border: 3px solid #4a4540;
      border-radius: 8px;
      z-index: 3000;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.2s, transform 0.2s;
      box-shadow: 0 0 60px rgba(0,0,0,0.9);
    }
    #hotkeyMenu.visible {
      opacity: 1;
      pointer-events: auto;
      transform: translate(-50%, -50%) scale(1);
    }
    .hotkey-header {
      background: linear-gradient(90deg, #2a2520 0%, #3a3530 50%, #2a2520 100%);
      padding: 12px 20px;
      text-align: center;
      border-bottom: 2px solid #4a4540;
    }
    .hotkey-header h2 {
      color: #d4af37;
      font-size: 16px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 2px;
      margin: 0;
    }
    .hotkey-close {
      position: absolute;
      right: 10px;
      top: 10px;
      width: 24px;
      height: 24px;
      background: #8b0000;
      border: 1px solid #aa2020;
      border-radius: 4px;
      color: #fff;
      cursor: pointer;
      font-size: 12px;
      line-height: 22px;
      text-align: center;
    }
    .hotkey-close:hover { background: #aa2020; }
    .hotkey-content {
      padding: 15px 20px;
    }
    .hotkey-section {
      margin-bottom: 12px;
    }
    .hotkey-section-title {
      color: #888;
      font-size: 10px;
      text-transform: uppercase;
      letter-spacing: 1px;
      margin-bottom: 6px;
      border-bottom: 1px solid #333;
      padding-bottom: 3px;
    }
    .hotkey-row {
      display: flex;
      justify-content: space-between;
      padding: 4px 0;
    }
    .hotkey-action {
      color: #ccc;
      font-size: 12px;
    }
    .hotkey-key {
      color: #d4af37;
      font-size: 11px;
      font-weight: bold;
      background: rgba(0,0,0,0.3);
      padding: 2px 8px;
      border-radius: 3px;
      border: 1px solid #555;
    }
    .hotkey-footer {
      padding: 10px 20px;
      background: rgba(0,0,0,0.3);
      border-top: 1px solid #333;
      text-align: center;
      display: flex;
      gap: 12px;
      justify-content: center;
    }
    .hotkey-resume-btn {
      background: linear-gradient(180deg, #2a5030 0%, #1a3020 100%);
      border: 2px solid #4a8050;
      border-radius: 4px;
      padding: 8px 24px;
      color: #8c8;
      font-size: 12px;
      font-weight: 600;
      letter-spacing: 1px;
      cursor: pointer;
      text-transform: uppercase;
    }
    .hotkey-resume-btn:hover {
      background: linear-gradient(180deg, #3a6040 0%, #2a4030 100%);
      border-color: #5a9060;
    }
    .hotkey-mainmenu-btn {
      background: linear-gradient(180deg, #4a3020 0%, #2a1810 100%);
      border: 2px solid #6a4030;
      border-radius: 4px;
      padding: 8px 24px;
      color: #a88;
      font-size: 12px;
      font-weight: 600;
      letter-spacing: 1px;
      cursor: pointer;
      text-transform: uppercase;
    }
    .hotkey-mainmenu-btn:hover {
      background: linear-gradient(180deg, #5a4030 0%, #3a2820 100%);
      border-color: #8a5040;
      color: #c99;
    }
    
    /* Hotkey Legend (bottom right) */
    #hotkeyLegend {
      position: fixed;
      bottom: 12px;
      right: 12px;
      z-index: 100;
      display: none; /* Hidden by default, shown when playing */
    }
    #hotkeyLegend.visible {
      display: flex;
      flex-direction: column;
      gap: 4px;
    }
    .hotkey-btn {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      background: linear-gradient(180deg, rgba(40,40,50,0.95) 0%, rgba(25,25,35,0.95) 100%);
      border: 1px solid #3a3a4a;
      border-radius: 4px;
      padding: 6px 10px;
      cursor: pointer;
      transition: all 0.15s ease;
      min-width: 110px;
    }
    .hotkey-btn:hover {
      background: linear-gradient(180deg, rgba(60,60,75,0.95) 0%, rgba(40,40,55,0.95) 100%);
      border-color: #5a5a6a;
      transform: translateX(-2px);
    }
    .hotkey-btn:active {
      background: linear-gradient(180deg, rgba(70,70,90,0.95) 0%, rgba(50,50,70,0.95) 100%);
      transform: translateX(-2px) scale(0.98);
    }
    .hotkey-btn .btn-label {
      color: #aaa;
      font-size: 11px;
      font-weight: 500;
    }
    .hotkey-btn:hover .btn-label {
      color: #ddd;
    }
    .hotkey-btn .btn-key {
      background: rgba(0,0,0,0.4);
      border: 1px solid #4a4a5a;
      border-radius: 3px;
      padding: 2px 6px;
      font-family: monospace;
      font-size: 10px;
      color: #8af;
      min-width: 24px;
      text-align: center;
    }
    .hotkey-btn:hover .btn-key {
      background: rgba(80,120,180,0.3);
      border-color: #6a8acf;
      color: #adf;
    }
    .hotkey-btn .btn-key.coming-soon {
      background: rgba(201, 160, 80, 0.2);
      border-color: #8a6a30;
      color: #c9a050;
      font-family: inherit;
      font-size: 8px;
      min-width: auto;
      padding: 2px 4px;
    }
    
    /* Skill Selector Panel */
    #skillSelector {
      position: fixed;
      bottom: 80px;
      left: 50%;
      transform: translateX(-50%) scale(0.95);
      width: 320px;
      background: linear-gradient(180deg, #1a1a20 0%, #0a0a0f 100%);
      border: 2px solid #3a3a50;
      border-radius: 8px;
      z-index: 2500;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.15s, transform 0.15s;
      box-shadow: 0 -5px 30px rgba(0,0,0,0.8);
    }
    #skillSelector.visible {
      opacity: 1;
      pointer-events: auto;
      transform: translateX(-50%) scale(1);
    }
    .skill-selector-header {
      background: linear-gradient(90deg, #252530 0%, #35354a 50%, #252530 100%);
      padding: 10px 15px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      border-bottom: 1px solid #4a4a60;
    }
    .skill-selector-title {
      color: #d4af37;
      font-size: 14px;
      font-weight: bold;
      text-transform: uppercase;
      letter-spacing: 1px;
    }
    .skill-selector-close {
      color: #888;
      font-size: 18px;
      cursor: pointer;
      width: 24px;
      height: 24px;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 4px;
    }
    .skill-selector-close:hover { color: #fff; background: rgba(255,255,255,0.1); }
    .skill-selector-content {
      padding: 15px;
      max-height: 350px;
      overflow-y: auto;
    }
    .skill-selector-grid {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 8px;
    }
    .skill-select-item {
      aspect-ratio: 1;
      background: linear-gradient(180deg, #1e1e28 0%, #12121a 100%);
      border: 2px solid #3a3a4a;
      border-radius: 6px;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: all 0.15s;
      padding: 8px 4px;
      position: relative;
    }
    .skill-select-item:hover {
      border-color: #6a6a8a;
      background: linear-gradient(180deg, #282838 0%, #1a1a28 100%);
      transform: scale(1.05);
    }
    .skill-select-item.selected {
      border-color: #d4af37;
      box-shadow: 0 0 10px rgba(212,175,55,0.3);
    }
    .skill-select-item.equipped {
      opacity: 0.4;
      cursor: not-allowed;
    }
    .skill-select-item.equipped:hover {
      transform: none;
    }
    .skill-select-item.locked {
      opacity: 0.5;
      cursor: not-allowed;
      background: linear-gradient(180deg, #1a1a20 0%, #0f0f15 100%);
      border-color: #2a2a35;
    }
    .skill-select-item.locked:hover {
      transform: none;
      border-color: #3a3a45;
    }
    .skill-select-item.locked .skill-select-icon,
    .skill-select-item.locked .skill-select-icon-img {
      filter: grayscale(80%) brightness(0.6);
    }
    .skill-lock-badge {
      position: absolute;
      top: 3px;
      left: 3px;
      background: linear-gradient(180deg, #4a3030 0%, #2a1818 100%);
      border: 1px solid #6a4040;
      border-radius: 3px;
      padding: 1px 4px;
      font-size: 8px;
      font-weight: bold;
      color: #c88;
      white-space: nowrap;
    }
    .skill-locked-text {
      font-size: 7px;
      color: #866;
      text-align: center;
      margin-top: 2px;
    }
    .skill-level-badge {
      position: absolute;
      top: 3px;
      left: 3px;
      background: linear-gradient(180deg, #4a3080 0%, #2a1860 100%);
      border: 1px solid #6040a0;
      border-radius: 3px;
      padding: 1px 4px;
      font-size: 9px;
      font-weight: bold;
      color: #c0a0ff;
      min-width: 14px;
      text-align: center;
    }
    .skill-level-badge.high {
      background: linear-gradient(180deg, #806020 0%, #503010 100%);
      border-color: #a08030;
      color: #ffd700;
    }
    .skill-select-icon {
      font-size: 28px;
      margin-bottom: 4px;
    }
    .skill-select-icon-img {
      width: 36px;
      height: 36px;
      object-fit: contain;
      margin-bottom: 4px;
    }
    .skill-select-name {
      font-size: 9px;
      color: #aaa;
      text-align: center;
      line-height: 1.1;
    }
    .skill-primary-badge {
      font-size: 7px;
      color: #ffcc00;
      background: rgba(255,200,0,0.15);
      padding: 1px 4px;
      border-radius: 3px;
      margin-top: 2px;
      font-weight: bold;
      letter-spacing: 0.5px;
    }
    .skill-selector-footer {
      background: #0a0a10;
      padding: 10px 15px;
      border-top: 1px solid #2a2a35;
      color: #666;
      font-size: 10px;
      text-align: center;
    }
    
    /* Minimap */
    #minimap {
      position: fixed;
      top: 15px;
      right: 15px;
      width: 180px;
      height: 180px;
      background: rgba(10,10,15,0.9);
      border: 2px solid #2a2a35;
      border-radius: 8px;
      z-index: 100;
      overflow: hidden;
    }
    
    #minimapCanvas {
      width: 100%;
      height: 100%;
    }
    
    /* Combat Log */
    #combatLog {
      position: fixed;
      bottom: 140px;
      left: 15px;
      width: 260px;
      max-height: 180px;
      overflow-y: auto;
      padding: 10px 12px;
      background: rgba(10,10,15,0.8);
      border: 1px solid #2a2a35;
      border-radius: 6px;
      font-size: 11px;
      color: #777;
      z-index: 100;
    }
    
    #combatLog::-webkit-scrollbar { width: 4px; }
    #combatLog::-webkit-scrollbar-thumb { background: #333; border-radius: 2px; }
    
    .log-damage { color: #c88; }
    .log-kill { color: #8c8; }
    .log-loot { color: #cc8; }
    .log-level { color: #c8c; }
    .log-zone { color: #8ac; }
    .log-skill { color: #8cf; font-weight: bold; }
    .log-warning { color: #f88; }
    
    /* Boss Bar - Minimal but impactful */
    #bossBar {
      position: fixed;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      width: 500px;
      z-index: 150;
      display: none;
    }
    
    #bossBar.visible { display: block; }
    
    #bossName {
      text-align: center;
      font-size: 20px;
      font-weight: 700;
      color: #f0d060;
      letter-spacing: 4px;
      text-transform: uppercase;
      margin-bottom: 8px;
      text-shadow: 0 0 10px rgba(255,200,100,0.6), 0 0 30px rgba(200,150,50,0.4), 0 2px 4px rgba(0,0,0,1);
    }
    
    #bossName::before {
      content: '☠ ';
      color: #c9a227;
    }
    
    #bossName::after {
      content: ' ☠';
      color: #c9a227;
    }
    
    #bossHealthContainer {
      position: relative;
      height: 28px;
      background: linear-gradient(180deg, #15100a 0%, #0a0604 50%, #050302 100%);
      border: 3px solid #8a6820;
      border-radius: 3px;
      overflow: visible;
      box-shadow: 
        0 0 0 1px #2a1a08,
        0 0 0 2px #503810,
        inset 0 0 15px rgba(0,0,0,0.9),
        0 4px 20px rgba(0,0,0,0.8),
        0 0 40px rgba(138,104,32,0.3);
    }
    
    /* Gold corner accents */
    #bossHealthContainer::before,
    #bossHealthContainer::after {
      content: '◆';
      position: absolute;
      top: 50%;
      transform: translateY(-50%);
      font-size: 14px;
      color: #c9a227;
      text-shadow: 0 0 8px rgba(200,160,40,0.8);
      z-index: 5;
    }
    
    #bossHealthContainer::before {
      left: -20px;
    }
    
    #bossHealthContainer::after {
      right: -20px;
    }
    
    #bossHealthFill {
      height: 100%;
      background: linear-gradient(180deg, 
        #dd3030 0%, 
        #bb2020 25%,
        #991515 50%, 
        #771010 75%,
        #550808 100%);
      box-shadow: 
        inset 0 2px 0 rgba(255,180,180,0.4),
        inset 0 -2px 4px rgba(0,0,0,0.5),
        0 0 25px rgba(255,50,50,0.5);
      transition: width 0.15s;
      position: relative;
    }
    
    /* Health bar shine effect */
    #bossHealthFill::after {
      content: '';
      position: absolute;
      top: 2px;
      left: 0;
      right: 0;
      height: 6px;
      background: linear-gradient(180deg, rgba(255,255,255,0.25) 0%, transparent 100%);
      pointer-events: none;
    }
    
    #bossHealthText {
      position: absolute;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 13px;
      font-weight: 700;
      color: #fff;
      text-shadow: 0 0 8px rgba(0,0,0,1), 0 1px 3px rgba(0,0,0,1);
      letter-spacing: 1px;
    }
    
    .boss-ticks {
      position: absolute;
      inset: 0;
      display: flex;
      pointer-events: none;
    }
    
    .boss-tick {
      flex: 1;
      border-right: 1px solid rgba(0,0,0,0.6);
      box-shadow: 1px 0 0 rgba(100,60,20,0.3);
    }
    
    .boss-tick:last-child { border-right: none; box-shadow: none; }
    
    #bossDebuffs {
      display: flex;
      justify-content: center;
      gap: 6px;
      margin-top: 8px;
    }
    
    .debuff-icon {
      width: 32px;
      height: 32px;
      background: linear-gradient(180deg, #2a1515 0%, #150808 100%);
      border: 2px solid #4a2020;
      border-radius: 4px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 18px;
      position: relative;
      box-shadow: 0 0 10px rgba(0,0,0,0.5);
    }
    
    .debuff-stacks {
      position: absolute;
      bottom: -4px;
      right: -4px;
      background: #000;
      border-radius: 50%;
      width: 16px;
      height: 16px;
      font-size: 10px;
      font-weight: 700;
      color: #fff;
      display: flex;
      align-items: center;
      justify-content: center;
      text-shadow: 0 1px 2px #000;
    }
    
    .debuff-icon:hover {
      border-color: #6a3030;
      transform: scale(1.1);
    }
    
    /* Debuff Tooltip */
    .debuff-tooltip {
      position: fixed;
      z-index: 10001;
      pointer-events: none;
      min-width: 180px;
      max-width: 250px;
      background: linear-gradient(180deg, #1a1010 0%, #0a0606 100%);
      border: 2px solid #4a2020;
      border-radius: 6px;
      padding: 10px 12px;
      font-family: 'Inter', sans-serif;
      display: none;
      box-shadow: 0 6px 20px rgba(0,0,0,0.9);
    }
    
    .debuff-tooltip.visible { display: block; }
    
    .debuff-tooltip-name {
      font-size: 14px;
      font-weight: bold;
      margin-bottom: 6px;
    }
    
    .debuff-tooltip-desc {
      font-size: 12px;
      color: #aaa;
      line-height: 1.4;
    }
    
    .debuff-tooltip-stacks {
      font-size: 11px;
      color: #888;
      margin-top: 6px;
    }
    
    /* Stats Dashboard Panel */
    #statsDashboard {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%) scale(0.9);
      width: 280px;
      background: linear-gradient(180deg, #1a1510 0%, #0d0a06 100%);
      border: 3px solid #4a3a20;
      border-radius: 10px;
      box-shadow: 0 10px 50px rgba(0,0,0,0.9), inset 0 0 30px rgba(0,0,0,0.5);
      z-index: 500;
      opacity: 0;
      pointer-events: none;
      transition: all 0.2s ease-out;
      font-family: 'Segoe UI', sans-serif;
    }
    
    #statsDashboard.visible {
      opacity: 1;
      pointer-events: auto;
      transform: translate(-50%, -50%) scale(1);
    }
    
    .stats-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px 15px;
      background: linear-gradient(180deg, #2a2015 0%, #1a1208 100%);
      border-bottom: 2px solid #3a2a15;
    }
    
    .stats-header h2 {
      margin: 0;
      font-size: 16px;
      color: #daa520;
      text-shadow: 0 1px 3px rgba(0,0,0,0.8);
    }
    
    .stats-header-buttons {
      display: flex;
      gap: 8px;
    }
    
    .stats-reset-btn, .stats-close-btn {
      background: rgba(80,60,40,0.5);
      border: 1px solid #5a4a30;
      color: #aa9060;
      width: 26px;
      height: 26px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
      transition: all 0.15s;
    }
    
    .stats-reset-btn:hover { background: #4a3a20; color: #ffcc44; }
    .stats-close-btn:hover { background: #5a3030; color: #ff6644; border-color: #7a4040; }
    
    .stats-duration {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 10px 15px;
      background: rgba(30,25,15,0.8);
      border-bottom: 1px solid #2a2015;
    }
    
    .stats-label {
      color: #887755;
      font-size: 12px;
      text-transform: uppercase;
      letter-spacing: 1px;
    }
    
    .stats-value.duration {
      font-size: 20px;
      font-weight: bold;
      color: #daa520;
      font-family: 'Consolas', monospace;
      text-shadow: 0 0 10px rgba(218,165,32,0.4);
    }
    
    .stats-grid {
      padding: 10px 12px;
    }
    
    .stat-row {
      display: grid;
      grid-template-columns: 24px 70px 1fr 60px;
      align-items: center;
      padding: 6px 8px;
      border-radius: 4px;
      margin-bottom: 2px;
      transition: background 0.15s;
    }
    
    .stat-row:hover {
      background: rgba(60,50,30,0.4);
    }
    
    .stat-row.gold .stat-total { color: #ffdd44; }
    .stat-row.gold .stat-rate { color: #ccaa33; }
    .stat-row.legendary .stat-total { color: #ff8844; text-shadow: 0 0 8px rgba(255,136,68,0.5); }
    .stat-row.deaths .stat-total { color: #ff4444; }
    
    .stat-icon {
      font-size: 14px;
      text-align: center;
    }
    
    .stat-name {
      color: #998866;
      font-size: 12px;
    }
    
    .stat-total {
      color: #ddccaa;
      font-size: 14px;
      font-weight: bold;
      text-align: right;
      padding-right: 10px;
    }
    
    .stat-total.stars {
      color: #ffdd00;
      text-shadow: 0 0 8px rgba(255,221,0,0.5);
      letter-spacing: 1px;
    }
    
    .stat-rate {
      color: #77aa55;
      font-size: 11px;
      text-align: right;
      font-family: 'Consolas', monospace;
    }
    
    /* Inventory Panel - Right Side - Large D3 Style */
    #inventoryPanel {
      position: fixed;
      top: 10px;
      bottom: 10px;
      right: -100%;
      width: clamp(300px, 28vw, 800px);
      background: linear-gradient(180deg, #1a1208 0%, #0d0906 100%);
      border: 4px solid #4a3018;
      border-radius: 8px;
      box-shadow: -8px 0 40px rgba(0,0,0,0.9), inset 0 0 30px rgba(0,0,0,0.5);
      z-index: 150;
      transition: right 0.15s ease-out;
      overflow: hidden;
      display: flex;
      flex-direction: column;
    }
    
    #inventoryPanel.visible { right: 10px; }
    
    /* Stash Panel - Left Side - POE2 Style */
    #stashPanel {
      position: fixed;
      top: 10px;
      bottom: 10px;
      left: -100%;
      width: clamp(300px, 28vw, 800px);
      background: linear-gradient(180deg, #1a1410 0%, #0d0a08 100%);
      border: 4px solid #4a3828;
      border-radius: 8px;
      box-shadow: 8px 0 40px rgba(0,0,0,0.9), inset 0 0 30px rgba(0,0,0,0.5);
      z-index: 150;
      transition: left 0.15s ease-out;
      overflow: hidden;
      display: flex;
      flex-direction: column;
    }
    
    #stashPanel.visible { left: 10px; }
    
    .stash-header {
      background: linear-gradient(180deg, #2a1a0a 0%, #1a0f05 100%);
      border-bottom: 3px solid #5a4020;
      padding: clamp(10px, 1.2vw, 18px) clamp(14px, 1.6vw, 24px);
      text-align: center;
      flex-shrink: 0;
    }
    
    .stash-header h2 {
      font-size: clamp(14px, 1.6vw, 24px);
      font-weight: 700;
      color: #c9a050;
      letter-spacing: 1px;
      text-transform: uppercase;
      margin: 0;
    }
    
    /* Stash Tabs - Two Rows like POE2 */
    .stash-tabs-container {
      background: #0a0806;
      border-bottom: 2px solid #3a2818;
      flex-shrink: 0;
    }
    
    .stash-tabs {
      display: flex;
      gap: 3px;
      padding: clamp(4px, 0.5vw, 8px) clamp(6px, 0.6vw, 10px) 0 clamp(6px, 0.6vw, 10px);
      flex-wrap: wrap;
    }
    
    .stash-tab {
      padding: clamp(6px, 0.8vw, 12px) clamp(12px, 1.4vw, 24px);
      background: linear-gradient(180deg, #2a2018 0%, #1a1008 100%);
      border: 2px solid #3a2818;
      border-bottom: none;
      border-radius: 4px 4px 0 0;
      color: #806040;
      font-size: clamp(10px, 1.1vw, 15px);
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
      position: relative;
    }
    
    .stash-tab:hover {
      background: linear-gradient(180deg, #3a3020 0%, #2a2010 100%);
      color: #a08060;
    }
    
    .stash-tab.active {
      background: linear-gradient(180deg, #3a3020 0%, #1a1410 100%);
      color: #c9a050;
      border-color: #5a4828;
    }
    
    .stash-tab.stash-main { border-top: 3px solid #c0a060; }
    .stash-tab.currency { border-top: 3px solid #c9a050; }
    .stash-tab.overflow { border-top: 3px solid #ff8844; }
    
    .stash-tab .overflow-badge {
      position: absolute;
      top: -6px;
      right: -6px;
      background: #ff6644;
      color: #fff;
      font-size: 9px;
      font-weight: bold;
      padding: 2px 5px;
      border-radius: 8px;
      min-width: 16px;
      text-align: center;
      box-shadow: 0 2px 4px rgba(0,0,0,0.5);
    }
    
    .stash-tab .overflow-badge.warning {
      background: #ffaa00;
      animation: pulse-badge 1s ease-in-out infinite;
    }
    
    .stash-tab .overflow-badge.full {
      background: #ff3333;
    }
    
    @keyframes pulse-badge {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.1); }
    }
    
    /* Loot Tab Content */
    .overflow-container {
      flex: 1;
      display: flex;
      flex-direction: column;
      padding: 10px;
      min-height: 0;
    }
    
    .overflow-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 8px 12px;
      background: rgba(40, 30, 20, 0.5);
      border: 1px solid #3a2818;
      border-radius: 4px;
      margin-bottom: 10px;
    }
    
    .overflow-info {
      color: #888;
      font-size: 12px;
    }
    
    .overflow-capacity {
      color: #aa8866;
      font-weight: bold;
    }
    
    .overflow-capacity.warning { color: #ffaa00; }
    .overflow-capacity.full { color: #ff4444; }
    
    .overflow-actions {
      display: flex;
      gap: 8px;
    }
    
    .overflow-btn {
      padding: 6px 12px;
      font-size: 11px;
      border: 1px solid #4a3828;
      background: linear-gradient(180deg, #2a2018 0%, #1a1008 100%);
      color: #aa8866;
      border-radius: 3px;
      cursor: pointer;
      transition: all 0.15s;
    }
    
    .overflow-btn:hover {
      background: linear-gradient(180deg, #3a3028 0%, #2a2018 100%);
      color: #ccaa88;
    }
    
    .overflow-btn.danger {
      border-color: #664422;
      color: #cc6644;
    }
    
    .overflow-btn.danger:hover {
      background: linear-gradient(180deg, #3a2018 0%, #2a1008 100%);
      color: #ff8866;
    }
    
    .overflow-btn.mode {
      border-color: #445566;
      color: #88aacc;
    }
    
    .overflow-btn.mode:hover {
      background: linear-gradient(180deg, #2a3038 0%, #1a2028 100%);
      color: #aaccee;
    }
    
    .overflow-btn.mode.active {
      background: linear-gradient(180deg, #2a4050 0%, #1a3040 100%);
      border-color: #66aacc;
      color: #88ddff;
      box-shadow: 0 0 8px rgba(100, 180, 255, 0.3);
    }
    
    .overflow-btn.mode.active.salvage {
      background: linear-gradient(180deg, #4a2020 0%, #3a1515 100%);
      border-color: #cc6644;
      color: #ff8866;
      box-shadow: 0 0 8px rgba(255, 100, 80, 0.3);
    }
    
    .overflow-mode-indicator {
      padding: 4px 10px;
      font-size: 10px;
      background: rgba(100, 180, 255, 0.2);
      border: 1px solid #66aacc;
      border-radius: 3px;
      color: #88ddff;
      display: none;
    }
    
    .overflow-mode-indicator.visible {
      display: block;
    }
    
    .overflow-mode-indicator.salvage {
      background: rgba(255, 100, 80, 0.2);
      border-color: #cc6644;
      color: #ff8866;
    }
    
    .overflow-list {
      flex: 1;
      overflow-y: auto;
      display: flex;
      flex-direction: column;
      gap: 4px;
    }
    
    .overflow-list::-webkit-scrollbar { width: 8px; }
    .overflow-list::-webkit-scrollbar-track { background: #0a0604; }
    .overflow-list::-webkit-scrollbar-thumb { background: #4a3018; border-radius: 4px; }
    
    .overflow-item {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 8px 12px;
      background: linear-gradient(180deg, #1a1410 0%, #0f0c0a 100%);
      border: 1px solid #2a2018;
      border-radius: 3px;
      cursor: pointer;
      transition: all 0.15s;
    }
    
    .overflow-item:hover {
      background: linear-gradient(180deg, #2a2018 0%, #1a1410 100%);
      border-color: #3a3028;
    }
    
    .overflow-item.new {
      animation: overflow-pulse 0.6s ease-out;
    }
    
    @keyframes overflow-pulse {
      0% { background: rgba(255, 136, 68, 0.4); border-color: #ff8844; }
      100% { background: linear-gradient(180deg, #1a1410 0%, #0f0c0a 100%); border-color: #2a2018; }
    }
    
    .overflow-item.normal { border-left: 3px solid #6a6a5a; }
    .overflow-item.magic { border-left: 3px solid #4466aa; }
    .overflow-item.rare { border-left: 3px solid #aa8822; }
    .overflow-item.unique { border-left: 3px solid #aa6622; }
    
    .overflow-item-icon {
      width: 32px;
      height: 32px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 20px;
      background: rgba(0,0,0,0.3);
      border-radius: 3px;
    }
    
    .overflow-item-icon img {
      width: 100%;
      height: 100%;
      object-fit: contain;
    }
    
    .overflow-item-info {
      flex: 1;
      min-width: 0;
    }
    
    .overflow-item-name {
      font-size: 13px;
      font-weight: 500;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    
    .overflow-item-name.normal { color: #aaa; }
    .overflow-item-name.magic { color: #6688cc; }
    .overflow-item-name.rare { color: #ccaa44; }
    .overflow-item-name.unique { color: #cc8844; }
    
    .overflow-item-stats {
      font-size: 10px;
      color: #666;
      margin-top: 2px;
    }
    
    .overflow-item-tier {
      padding: 2px 6px;
      font-size: 10px;
      font-weight: bold;
      border-radius: 3px;
      background: #222;
      color: #666;
    }
    
    .overflow-item-tier.t5 { background: #443300; color: #ffdd00; }
    .overflow-item-tier.t4 { background: #332200; color: #ff8844; }
    .overflow-item-tier.t3 { background: #333300; color: #ffff44; }
    .overflow-item-tier.t2 { background: #222233; color: #6688ff; }
    .overflow-item-tier.t1 { background: #1a1a1a; color: #666666; }
    .overflow-item-tier.t0 { background: #0a0a0a; color: #333333; }
    
    .overflow-empty {
      flex: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: #444;
      font-style: italic;
      text-align: center;
      padding: 40px;
    }
    
    .overflow-empty-icon {
      font-size: 48px;
      margin-bottom: 16px;
      opacity: 0.3;
    }
    
    /* Stash Content */
    .stash-content {
      flex: 1;
      display: flex;
      flex-direction: column;
      min-height: 0;
      overflow: hidden;
      background: linear-gradient(180deg, #151210 0%, #0a0908 100%);
    }
    
    .stash-tab-content {
      display: none;
      flex: 1;
      flex-direction: column;
      min-height: 0;
      overflow-y: auto;
    }
    
    .stash-tab-content.active {
      display: flex;
    }
    
    .stash-tab-content::-webkit-scrollbar { width: 8px; }
    .stash-tab-content::-webkit-scrollbar-track { background: #0a0604; }
    .stash-tab-content::-webkit-scrollbar-thumb { background: #4a3018; border-radius: 4px; }
    
    /* Large Stash Grid */
    .stash-large-grid {
      flex: 1;
      display: grid;
      grid-template-columns: repeat(12, 1fr);
      grid-template-rows: repeat(10, 1fr);
      gap: 1px;
      padding: clamp(3px, 0.4vw, 5px);
      background: #0a0806;
      border: 3px solid #c9a050;
      margin: clamp(6px, 0.8vw, 10px);
      border-radius: 4px;
      position: relative;
    }
    
    .stash-slot {
      background: linear-gradient(180deg, #1a1810 0%, #0e0c08 100%);
      border: 1px solid #2a2518;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: clamp(16px, 2vw, 26px);
      position: relative;
      cursor: pointer;
    }
    
    .stash-slot:hover {
      border-color: #4a8a4a;
      background: linear-gradient(180deg, #1a2018 0%, #0e140c 100%);
    }
    
    .stash-slot.has-item {
      border-color: #4a4030;
      background: linear-gradient(180deg, #201c14 0%, #14120c 100%);
    }
    
    .stash-slot .stack-count {
      position: absolute;
      top: 2px;
      left: 4px;
      font-size: clamp(9px, 1vw, 14px);
      color: #fff;
      font-weight: 700;
      text-shadow: 1px 1px 2px #000, -1px -1px 2px #000;
    }
    
    /* Stash items (multi-cell) */
    .stash-item {
      position: relative;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      border-radius: 3px;
      cursor: pointer;
      transition: all 0.15s ease;
      z-index: 10;
      padding: 2px;
    }
    
    .stash-item:hover {
      transform: scale(1.05);
      z-index: 20;
      box-shadow: 0 0 15px rgba(200, 180, 100, 0.4);
    }
    
    .stash-item .item-icon {
      font-size: clamp(18px, 2vw, 32px);
      filter: drop-shadow(1px 1px 2px rgba(0,0,0,0.8));
    }
    
    /* Slot-specific icon adjustments for stash */
    .stash-item[data-slot="boots"] {
      position: relative;
    }
    .stash-item[data-slot="boots"] .item-icon {
      /* Centered like other items */
    }
    .stash-item[data-slot="helmet"] .item-icon {
      font-size: clamp(20px, 2.4vw, 38px);
    }
    
    .stash-item.normal {
      background: linear-gradient(180deg, #2a2820 0%, #1a1810 100%);
      border: 2px solid #4a4538;
    }
    .stash-item.magic {
      background: linear-gradient(180deg, #1a1a30 0%, #101020 100%);
      border: 2px solid #4a4a8a;
    }
    .stash-item.rare {
      background: linear-gradient(180deg, #302a1a 0%, #201a10 100%);
      border: 2px solid #8a7a3a;
    }
    .stash-item.unique {
      background: linear-gradient(180deg, #302010 0%, #201008 100%);
      border: 2px solid #a06020;
    }
    
    /* Socket display on items */
    .item-sockets {
      position: absolute;
      bottom: 2px;
      right: 2px;
      display: flex;
      gap: 2px;
      flex-wrap: wrap;
      max-width: 38px;
      justify-content: flex-end;
    }
    .item-sockets .socket-pip {
      width: 12px;
      height: 12px;
      border-radius: 50%;
      border: 1px solid rgba(0,0,0,0.8);
      box-shadow: 0 0 3px rgba(0,0,0,0.9), inset 0 0 2px rgba(255,255,255,0.2);
    }
    .item-sockets .socket-pip.empty { background: #222; border-color: #444; }
    .item-sockets .socket-pip.filled { background: #fff; box-shadow: 0 0 6px #fff; }
    
    /* Crafting Area in Crafting Tab */
    .crafting-area {
      background: linear-gradient(180deg, #1a1510 0%, #0d0a08 100%);
      border: 3px solid #c9a050;
      border-radius: 6px;
      margin: clamp(6px, 1vh, 12px);
      padding: clamp(8px, 1.2vh, 16px);
      display: flex;
      gap: clamp(8px, 1.5vh, 18px);
      flex-shrink: 0;
    }
    
    .crafting-slot {
      width: clamp(80px, 12vh, 140px);
      height: clamp(110px, 16vh, 180px);
      background: linear-gradient(180deg, #151210 0%, #0a0908 100%);
      border: 2px dashed #4a4030;
      border-radius: 4px;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: all 0.2s;
      position: relative;
    }
    
    .crafting-slot:hover {
      border-color: #6a6050;
      background: linear-gradient(180deg, #1a1815 0%, #0f0d0a 100%);
    }
    
    .crafting-slot.has-item {
      border-style: solid;
      border-color: #5a5030;
    }
    
    .crafting-slot.normal { border-color: #6a6a5a; }
    .crafting-slot.magic { border-color: #4466aa; box-shadow: inset 0 0 15px rgba(68,102,170,0.3); }
    .crafting-slot.rare { border-color: #aa8822; box-shadow: inset 0 0 15px rgba(170,136,34,0.3); }
    .crafting-slot.unique { border-color: #aa6622; box-shadow: inset 0 0 15px rgba(170,102,34,0.3); }
    
    .crafting-slot .item-icon {
      font-size: clamp(32px, 4.5vh, 55px);
      margin-bottom: clamp(4px, 0.8vh, 10px);
      width: 70%;
      height: 60%;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    .crafting-slot .item-icon img {
      max-width: 100%;
      max-height: 100%;
      object-fit: contain;
    }
    
    .crafting-slot .item-name {
      font-size: clamp(9px, 1vh, 13px);
      text-align: center;
      padding: 0 5px;
      max-width: 100%;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }
    
    .crafting-slot .item-name.normal { color: #aaa; }
    .crafting-slot .item-name.magic { color: #6688cc; }
    .crafting-slot .item-name.rare { color: #ccaa44; }
    .crafting-slot .item-name.unique { color: #cc8844; }
    
    .crafting-slot .placeholder {
      color: #504030;
      font-size: clamp(9px, 1vh, 12px);
      text-align: center;
    }
    
    .crafting-info {
      flex: 1;
      display: flex;
      flex-direction: column;
      background: linear-gradient(180deg, #0a0906 0%, #121008 100%);
      border: 1px solid #3a3020;
      border-radius: 0;
      padding: 0;
      overflow: hidden;
    }
    
    .crafting-info-title {
      font-size: clamp(9px, 1vh, 11px);
      color: #888;
      text-transform: uppercase;
      letter-spacing: 1px;
      text-align: center;
      padding: clamp(4px, 0.5vh, 6px);
      background: rgba(60, 50, 40, 0.5);
      border-bottom: 1px solid #2a2018;
    }
    
    .crafting-mods {
      flex: 1;
      padding: clamp(6px, 0.8vh, 10px);
      font-size: clamp(10px, 1.1vh, 13px);
      line-height: 1.4;
      overflow-y: auto;
      opacity: 0.95; /* Slightly muted to differentiate from hover tooltip */
    }
    
    /* Crafting mods uses same styles as tooltip */
    .crafting-mods .tooltip-base-stats-section {
      background: rgba(50, 45, 38, 0.5);
      padding: 6px 8px;
      margin: 0 -6px 4px -6px;
      border-bottom: 1px solid #3a3020;
    }
    
    .crafting-mods .tooltip-base-stat {
      font-size: 12px;
      color: #a09080;
      padding: 2px 0;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    
    .crafting-mods .tooltip-base-stat .base-value {
      color: #e8e0d8;
      font-weight: 600;
    }
    
    .crafting-mods .tooltip-hybrid-hint {
      font-size: 9px;
      color: #666;
      font-style: italic;
      text-align: right;
      padding-top: 3px;
      border-top: 1px solid rgba(60, 50, 40, 0.5);
      margin-top: 3px;
    }
    
    .crafting-mods .tooltip-req {
      font-size: 11px;
      color: #606060;
      padding: 4px 0 0 0;
    }
    
    .crafting-mods .tooltip-sep {
      height: 1px;
      background: linear-gradient(90deg, transparent, #3a3020, transparent);
      margin: 8px 0;
    }
    
    .crafting-mods .tooltip-implicit-section {
      border-top: 1px solid #3a2840;
      padding: 6px 8px;
      margin: 8px -6px 0 -6px;
      background: rgba(80, 50, 90, 0.15);
    }
    
    .crafting-mods .tooltip-implicit {
      color: #9988aa;
      font-size: 12px;
      font-style: italic;
    }
    
    .crafting-mods .tooltip-section-header {
      font-size: 9px;
      color: #666;
      text-transform: uppercase;
      letter-spacing: 1px;
      margin: 8px 0 4px 0;
      padding-bottom: 2px;
      border-bottom: 1px solid #2a2a2a;
    }
    
    .crafting-mods .tooltip-section-header.implicit {
      color: #8877aa;
      border-bottom-color: #3a2840;
    }
    
    .crafting-mods .tooltip-sep + .tooltip-section-header {
      margin-top: 0;
    }
    
    .crafting-mods .tooltip-mod {
      font-size: 12px;
      padding: 2px 0;
      line-height: 1.4;
    }
    
    .crafting-mods .tooltip-mod-text {
      color: #8888ff;
    }
    
    .crafting-mods .tooltip-ele-group {
      background: rgba(60, 40, 30, 0.3);
      border-left: 2px solid #664422;
      padding: 4px 8px;
      margin: 4px 0;
    }
    
    .crafting-mods .tooltip-ele-header {
      color: #aa8866;
      font-size: 11px;
      margin-bottom: 2px;
    }
    
    .crafting-mods .tooltip-ele-line {
      font-size: 11px;
      padding: 1px 0;
    }
    
    .crafting-mods .tooltip-ele-line.fire { color: #e08866; }
    .crafting-mods .tooltip-ele-line.cold { color: #66aadd; }
    .crafting-mods .tooltip-ele-line.lightning { color: #ddcc77; }
    .crafting-mods .tooltip-ele-line.physical { color: #ccbbaa; }
    
    .crafting-mods .tooltip-immutable {
      color: #d02020;
      font-weight: bold;
      font-size: 14px;
      text-align: center;
      margin-top: 12px;
    }
    
    .crafting-mods .tooltip-sockets-section {
      padding: 2px 0;
    }
    
    .crafting-mods .tooltip-sockets {
      display: flex;
      align-items: center;
      gap: 4px;
      margin: 6px 0;
    }
    
    .crafting-mods .tooltip-socket-row {
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 2px 0;
    }
    
    .crafting-mods .socket-icon {
      font-size: 14px;
      min-width: 18px;
      text-align: center;
    }
    
    .crafting-mods .socket-gem-info {
      display: flex;
      flex-direction: column;
      gap: 1px;
    }
    
    .crafting-mods .socket-gem-name {
      font-size: 11px;
      color: #aaa;
    }
    
    .crafting-mods .socket-gem-effect {
      font-size: 10px;
      color: #777;
    }
    
    .crafting-mods .socket-empty-text {
      font-size: 10px;
      color: #555;
    }
    
    .crafting-mods .tooltip-tier-small {
      color: #666;
      font-size: 9px;
    }
    
    .crafting-mods .tooltip-hint {
      display: none; /* Hide Alt hint in crafting preview */
    }
    
    .crafting-buttons {
      display: flex;
      gap: clamp(3px, 0.4vh, 5px);
      margin-top: clamp(4px, 0.6vh, 8px);
      flex-wrap: wrap;
    }
    
    .craft-btn {
      padding: clamp(2px, 0.3vh, 4px) clamp(5px, 0.6vh, 8px);
      background: linear-gradient(180deg, #2a2018 0%, #1a1008 100%);
      border: 1px solid #4a3820;
      border-radius: 3px;
      color: #a08060;
      font-size: clamp(8px, 0.9vh, 11px);
      cursor: pointer;
      transition: all 0.15s;
    }
    
    .craft-btn:hover {
      background: linear-gradient(180deg, #3a3020 0%, #2a2010 100%);
      color: #c9a050;
    }
    
    .craft-btn:disabled {
      opacity: 0.4;
      cursor: not-allowed;
    }
    
    /* Crafting Tab - Organized Layout */
    .currency-layout {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: clamp(5px, 0.8vh, 8px);
      padding: clamp(5px, 0.8vh, 8px);
    }
    
    .currency-section {
      background: linear-gradient(180deg, #151210 0%, #0a0908 100%);
      border: 2px solid #2a2518;
      border-radius: 4px;
      padding: clamp(5px, 0.7vh, 8px);
    }
    
    .currency-section.full-width {
      grid-column: span 2;
    }
    
    .currency-section-title {
      font-size: clamp(9px, 1vh, 12px);
      color: #806850;
      margin-bottom: clamp(5px, 0.7vh, 8px);
      text-transform: uppercase;
      letter-spacing: 1px;
      border-bottom: 1px solid #2a2010;
      padding-bottom: clamp(2px, 0.3vh, 4px);
    }
    
    .currency-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(clamp(40px, 4vh, 55px), 1fr));
      gap: clamp(3px, 0.4vh, 5px);
    }
    
    .currency-item {
      aspect-ratio: 1;
      background: linear-gradient(180deg, #1a1810 0%, #100e08 100%);
      border: 2px solid #2a2518;
      border-radius: 3px;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      position: relative;
      cursor: pointer;
      transition: all 0.15s;
    }
    
    .currency-item:hover {
      border-color: #5a5030;
      background: linear-gradient(180deg, #252518 0%, #181510 100%);
      transform: scale(1.05);
    }
    
    .currency-item.clickable:active {
      transform: scale(0.95);
      filter: brightness(1.3);
    }
    
    .currency-item .icon {
      font-size: clamp(18px, 2.2vh, 30px);
    }
    
    .currency-item .count {
      position: absolute;
      top: 2px;
      left: 3px;
      font-size: clamp(9px, 1vh, 13px);
      color: #fff;
      font-weight: 700;
      text-shadow: 1px 1px 2px #000, -1px -1px 2px #000;
    }
    
    .currency-item.basic { border-color: #6a6a5a; }
    .currency-item.magic { border-color: #4466aa; }
    .currency-item.rare { border-color: #aa8822; }
    .currency-item.unique { border-color: #aa6622; }
    .currency-item.disabled {
      opacity: 0.4;
      filter: grayscale(40%);
    }
    .currency-item.disabled:hover {
      transform: scale(1.02);
      border-color: inherit;
      cursor: not-allowed;
    }
    .currency-item.legendary { border-color: #c9a050; box-shadow: 0 0 8px rgba(201,160,80,0.3); }
    
    /* Currency/Gem Tooltip */
    #currencyTooltip {
      position: fixed;
      z-index: 10003;
      pointer-events: none;
      display: none;
      min-width: 220px;
      max-width: 320px;
    }
    
    #currencyTooltip.visible {
      display: block;
    }
    
    .currency-tooltip-inner {
      background: linear-gradient(180deg, #1a1612 0%, #0d0b08 100%);
      border: 2px solid #4a3828;
      padding: 0;
      font-family: 'Inter', sans-serif;
    }
    
    .currency-tooltip-header {
      background: linear-gradient(180deg, #2a2218 0%, #1a1610 100%);
      padding: 10px 14px;
      border-bottom: 1px solid #3a3020;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    
    .currency-tooltip-name {
      font-size: 15px;
      font-weight: 600;
      color: #c9a050;
    }
    
    .currency-tooltip-name.magic { color: #6688cc; }
    .currency-tooltip-name.rare { color: #ccaa44; }
    .currency-tooltip-name.unique { color: #cc8844; }
    
    .currency-tooltip-stack {
      font-size: 11px;
      color: #666;
    }
    
    .currency-tooltip-body {
      padding: 10px 14px;
    }
    
    .currency-tooltip-desc {
      font-size: 12px;
      color: #888;
      margin-bottom: 10px;
      font-style: italic;
    }
    
    .currency-tooltip-section {
      margin-bottom: 8px;
    }
    
    .currency-tooltip-section:last-child {
      margin-bottom: 0;
    }
    
    .currency-tooltip-section-title {
      font-size: 10px;
      color: #666;
      text-transform: uppercase;
      letter-spacing: 1px;
      margin-bottom: 4px;
    }
    
    .currency-tooltip-effect {
      font-size: 13px;
      color: #aa9977;
      padding: 4px 0;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    
    .currency-tooltip-effect .effect-icon {
      font-size: 14px;
    }
    
    .currency-tooltip-effect .effect-text {
      color: #ccbb99;
    }
    
    .currency-tooltip-effect.fire .effect-text { color: #e08866; }
    .currency-tooltip-effect.cold .effect-text { color: #66aadd; }
    .currency-tooltip-effect.lightning .effect-text { color: #ddcc77; }
    .currency-tooltip-effect.life .effect-text { color: #cc6666; }
    .currency-tooltip-effect.mana .effect-text { color: #6688cc; }
    .currency-tooltip-effect.physical .effect-text { color: #ccbbaa; }
    
    .currency-tooltip-divider {
      height: 1px;
      background: linear-gradient(90deg, transparent, #3a3020, transparent);
      margin: 8px 0;
    }
    
    .currency-tooltip-useon {
      font-size: 12px;
      color: #8ac;
      padding: 6px 0 4px 0;
      border-top: 1px solid #2a2518;
      margin-top: 8px;
    }
    
    .currency-tooltip-tip {
      font-size: 11px;
      color: #a96;
      padding: 4px 0 0 0;
      font-style: italic;
    }
    
    /* Stash Footer */
    .stash-footer {
      padding: clamp(6px, 0.8vw, 10px);
      background: linear-gradient(180deg, #12100a 0%, #0a0805 100%);
      border-top: 2px solid #3a2818;
      text-align: center;
      font-size: clamp(9px, 0.9vw, 11px);
      color: #504030;
      flex-shrink: 0;
    }
    
    /* Item Context Menu */
    .item-context-menu {
      position: fixed;
      background: linear-gradient(180deg, #1a1510 0%, #0a0805 100%);
      border: 2px solid #5a4020;
      border-radius: 6px;
      padding: clamp(3px, 0.4vw, 5px) 0;
      z-index: 10001;
      min-width: clamp(120px, 12vw, 160px);
      box-shadow: 0 4px 20px rgba(0,0,0,0.8);
      display: none;
    }
    
    .item-context-menu.visible {
      display: block;
    }
    
    .context-menu-item {
      padding: clamp(6px, 0.7vw, 10px) clamp(12px, 1.3vw, 18px);
      color: #c9a050;
      cursor: pointer;
      font-size: clamp(11px, 1.1vw, 15px);
      display: flex;
      align-items: center;
      gap: clamp(6px, 0.7vw, 10px);
      transition: background 0.15s;
    }
    
    .context-menu-item:hover {
      background: rgba(201,160,80,0.15);
    }
    
    .context-menu-item.disabled {
      color: #555;
      cursor: not-allowed;
    }
    
    .context-menu-item.disabled:hover {
      background: transparent;
    }
    
    .context-menu-item .icon {
      width: 18px;
      text-align: center;
    }
    
    .context-menu-divider {
      height: 1px;
      background: #3a2818;
      margin: 4px 8px;
    }
    
    .context-menu-item.equip { color: #88cc44; }
    .context-menu-item.salvage { color: #cc4444; }
    .context-menu-item.craft { color: #88cc44; }
    .context-menu-item.drop { color: #aa6666; }
    
    /* Stash Tab Controls */
    .stash-tab-controls {
      display: flex;
      align-items: center;
      gap: 4px;
      margin-left: auto;
    }
    
    .stash-add-tab {
      background: #1a1510;
      border: 1px solid #3a3020;
      color: #6a6050;
      width: 28px;
      height: 28px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 18px;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.15s;
    }
    
    .stash-add-tab:hover {
      border-color: #c9a050;
      color: #c9a050;
      background: #252015;
    }
    
    /* Store Modal for Add-ons */
    #storeModal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0,0,0,0.85);
      z-index: 12000;
      justify-content: center;
      align-items: center;
    }
    
    #storeModal.visible { display: flex; }
    
    .store-content {
      background: linear-gradient(180deg, #1a1410 0%, #0a0806 100%);
      border: 2px solid #c9a050;
      border-radius: 6px;
      width: 450px;
      max-height: 80vh;
      overflow: hidden;
      box-shadow: 0 0 60px rgba(200,160,80,0.3);
    }
    
    .store-header {
      background: linear-gradient(180deg, #2a2015 0%, #1a1410 100%);
      padding: 15px 20px;
      border-bottom: 2px solid #3a3020;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    
    .store-title {
      font-size: 20px;
      font-weight: 700;
      color: #c9a050;
      letter-spacing: 2px;
    }
    
    .store-close {
      background: none;
      border: none;
      color: #666;
      font-size: 24px;
      cursor: pointer;
      padding: 0 5px;
    }
    
    .store-close:hover { color: #fff; }
    
    .store-body {
      padding: 20px;
    }
    
    .store-section-title {
      font-size: 14px;
      font-weight: 600;
      color: #888;
      letter-spacing: 1px;
      margin-bottom: 12px;
      padding-bottom: 6px;
      border-bottom: 1px solid #2a2018;
    }
    
    .store-item {
      background: linear-gradient(180deg, #1a1510 0%, #0f0c08 100%);
      border: 1px solid #2a2018;
      border-radius: 4px;
      padding: 15px;
      margin-bottom: 12px;
      display: flex;
      align-items: center;
      gap: 15px;
      transition: all 0.15s;
    }
    
    .store-item:hover {
      border-color: #4a4030;
      background: linear-gradient(180deg, #252015 0%, #1a1410 100%);
    }
    
    .store-item-icon {
      width: 50px;
      height: 50px;
      background: rgba(0,0,0,0.3);
      border-radius: 4px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 28px;
    }
    
    .store-item-info {
      flex: 1;
    }
    
    .store-item-name {
      font-size: 15px;
      font-weight: 600;
      color: #ddd;
      margin-bottom: 4px;
    }
    
    .store-item-desc {
      font-size: 11px;
      color: #777;
      line-height: 1.4;
    }
    
    .store-item-price {
      display: flex;
      flex-direction: column;
      align-items: flex-end;
      gap: 6px;
    }
    
    .store-price-tag {
      font-size: 16px;
      font-weight: 700;
      color: #c9a050;
    }
    
    .store-buy-btn {
      background: linear-gradient(180deg, #4a3820 0%, #3a2815 100%);
      border: 1px solid #6a5030;
      color: #c9a050;
      padding: 8px 16px;
      border-radius: 3px;
      cursor: pointer;
      font-size: 12px;
      font-weight: 600;
      transition: all 0.15s;
    }
    
    .store-buy-btn:hover {
      background: linear-gradient(180deg, #5a4830 0%, #4a3820 100%);
      border-color: #8a6040;
      color: #fff;
    }
    
    .store-buy-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    
    .store-gold-display {
      text-align: center;
      padding: 10px;
      background: rgba(0,0,0,0.3);
      border-radius: 4px;
      margin-top: 15px;
    }
    
    .store-gold-label {
      font-size: 11px;
      color: #666;
      margin-bottom: 4px;
    }
    
    .store-gold-amount {
      font-size: 20px;
      font-weight: 700;
      color: #c9a050;
    }
    
    .stash-tab {
      position: relative;
    }
    
    .inv-header {
      background: linear-gradient(180deg, #2a1a0a 0%, #1a0f05 100%);
      border-bottom: 3px solid #5a4020;
      padding: clamp(10px, 1.2vw, 18px) clamp(14px, 1.6vw, 24px);
      text-align: center;
      flex-shrink: 0;
    }
    
    .inv-header h2 {
      font-size: clamp(14px, 1.6vw, 24px);
      font-weight: 700;
      color: #c9a050;
      letter-spacing: 1px;
      text-transform: uppercase;
      margin: 0;
    }
    
    /* Main content - stats left, equipment right - scales with viewport */
    .inv-main {
      display: flex;
      gap: clamp(6px, 0.8vw, 10px);
      padding: clamp(6px, 0.8vw, 10px);
      flex-shrink: 0;
      height: clamp(180px, 26vh, 300px);
      justify-content: center;
    }
    
    /* Equipment Section - POE2 Style Character Panel */
    .inv-equipment-section {
      flex: 1;
      background: linear-gradient(180deg, #1a1a15 0%, #0f0f0c 100%);
      border: 2px solid #3a3528;
      border-radius: 4px;
      padding: clamp(4px, 0.6vw, 8px);
      display: flex;
      flex-direction: row;
      gap: clamp(8px, 1vw, 15px);
      overflow: hidden;
    }
    
    .inv-paperdoll {
      display: grid;
      grid-template-columns: 1fr 1.2fr 1fr;
      grid-template-rows: 1fr 1.2fr 1fr 1fr;
      gap: clamp(2px, 0.2vw, 3px);
      width: clamp(140px, 14vw, 200px);
      height: 100%;
      flex-shrink: 0;
    }
    
    /* Inline stats panel next to equipment */
    .equip-stats-container {
      display: flex;
      gap: 8px;
      flex: 1;
    }
    
    .equip-stats-panel {
      display: flex;
      flex-direction: column;
      gap: 2px;
      font-size: clamp(10px, 0.95vw, 14px);
      color: #b8a882;
      flex: 1;
      min-width: 80px;
    }
    
    .equip-stats-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 2px 8px;
      background: rgba(0,0,0,0.2);
      border-radius: 2px;
      line-height: 1.25;
    }
    
    .equip-stats-row .stat-label {
      color: #807060;
      font-size: clamp(9px, 0.85vw, 13px);
    }
    
    .equip-stats-row .stat-value {
      color: #d4c4a0;
      font-weight: 600;
      font-size: clamp(10px, 0.95vw, 14px);
    }
    
    .equip-stats-row .stat-value.life { color: #e85050; }
    .equip-stats-row .stat-value.mana { color: #5080d0; }
    .equip-stats-row .stat-value.damage { color: #e0a040; }
    .equip-stats-row .stat-value.defense { color: #70a0c0; }
    .equip-stats-row .stat-value.resist { color: #a0d080; }
    .equip-stats-row .stat-value.crit { color: #f0c060; }
    
    .equip-stats-divider {
      height: 1px;
      background: linear-gradient(90deg, transparent, #3a3528, transparent);
      margin: 2px 0;
    }
    
    .equip-slot {
      background: linear-gradient(180deg, #1a1a10 0%, #0a0a05 100%);
      border: 2px solid #3a3a28;
      border-radius: 4px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: clamp(10px, 1vw, 18px);
      position: relative;
      cursor: pointer;
      transition: border-color 0.2s;
      min-width: 0;
      min-height: 0;
      overflow: hidden;
    }
    
    .equip-slot:hover {
      border-color: #5a5a48;
    }
    
    /* Weapon slot - left side, spans rows 1-2 */
    .equip-slot.weapon {
      grid-column: 1;
      grid-row: 1 / 3;
      font-size: clamp(14px, 1.6vw, 28px);
    }
    
    /* Helm - top center */
    .equip-slot.helm {
      grid-column: 2;
      grid-row: 1;
    }
    
    /* Amulet - right side row 1 (smaller, matches rings) */
    .equip-slot.amulet {
      grid-column: 3;
      grid-row: 1;
      width: 70%;
      height: 70%;
      justify-self: center;
      align-self: center;
      font-size: clamp(8px, 0.9vw, 14px);
    }
    
    /* Body - rows 2-3 center */
    .equip-slot.body {
      grid-column: 2;
      grid-row: 2 / 4;
      font-size: clamp(14px, 1.6vw, 28px);
    }
    
    /* Boots - row 4 center (directly under body) */
    .equip-slot.boots {
      grid-column: 2;
      grid-row: 4;
    }
    
    /* Gloves - row 2 right (swapped with ring1, matches helmet size) */
    .equip-slot.gloves {
      grid-column: 3;
      grid-row: 2;
    }
    
    /* Ring1 - row 3 left (swapped with gloves) */
    .equip-slot.ring1 {
      grid-column: 1;
      grid-row: 3;
      width: 70%;
      height: 70%;
      justify-self: center;
      align-self: center;
      font-size: clamp(8px, 0.9vw, 14px);
    }
    
    /* Ring2 - row 3 right */
    .equip-slot.ring2 {
      grid-column: 3;
      grid-row: 3;
      width: 70%;
      height: 70%;
      justify-self: center;
      align-self: center;
      font-size: clamp(8px, 0.9vw, 14px);
    }
    
    .equip-slot.filled { border-color: #5a5030; background: linear-gradient(180deg, #252518 0%, #15150a 100%); }
    .equip-slot.magic { border-color: #4466aa; box-shadow: inset 0 0 10px rgba(68,102,170,0.4); }
    .equip-slot.rare { border-color: #aa8822; box-shadow: inset 0 0 10px rgba(170,136,34,0.4); }
    .equip-slot.unique { border-color: #af6025; box-shadow: inset 0 0 10px rgba(175,96,37,0.5); }
    
    /* Socket pips on equipped items */
    .equip-sockets {
      position: absolute;
      bottom: 2px;
      right: 2px;
      display: flex;
      gap: 2px;
      z-index: 2;
    }
    
    .equip-sockets .socket-pip {
      width: 10px;
      height: 10px;
      border-radius: 50%;
      border: 1px solid #555;
    }
    
    .equip-sockets .socket-pip.empty {
      background: radial-gradient(circle at 30% 30%, #333 0%, #111 100%);
    }
    
    .equip-sockets .socket-pip.filled {
      background: radial-gradient(circle at 30% 30%, #666 0%, #333 100%);
      border-color: #888;
    }
    
    /* Empty slot placeholder icons - dull and faded */
    .equip-slot:not(.filled) {
      opacity: 1;
    }
    .equip-slot:not(.filled)::after {
      content: attr(data-placeholder);
      font-size: inherit;
      opacity: 0.15;
      filter: grayscale(100%);
    }
    .equip-slot.filled::after {
      content: '';
    }
    
    /* Inventory Grid - proper ARPG grid system */
    .inv-grid-section {
      flex: 1;
      padding: clamp(6px, 0.8vw, 10px);
      border-top: 2px solid #3a2818;
      display: flex;
      flex-direction: column;
      min-height: clamp(160px, 22vh, 240px); /* Minimum height to prevent collapse */
      overflow: hidden;
    }
    
    .inv-grid {
      display: grid;
      grid-template-columns: repeat(12, 1fr);
      grid-template-rows: repeat(10, 1fr);
      gap: 1px;
      background: #1a1510;
      border: 2px solid #2a1808;
      border-radius: 3px;
      padding: clamp(1px, 0.2vw, 3px);
      width: 100%;
      height: 100%; /* Fill available space */
      flex: 1;
      min-height: 0;
      position: relative; /* For absolute positioning of items */
      box-sizing: border-box;
    }
    
    .inv-cell {
      background: linear-gradient(180deg, #1a1810 0%, #100e08 100%);
      border: 1px solid #2a2518;
      min-width: 0;
      min-height: 0;
    }
    
    .inv-item {
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      border: 2px solid;
      border-radius: 2px;
      box-sizing: border-box;
      z-index: 10;
      transition: filter 0.1s, transform 0.1s;
      min-width: 0;
      min-height: 0;
      overflow: hidden;
    }
    
    .inv-item:hover {
      z-index: 20;
      filter: brightness(1.2);
      transform: scale(1.02);
    }
    
    .inv-item.selected {
      border-color: #c9a050 !important;
      box-shadow: 0 0 10px rgba(201,160,80,0.6);
      z-index: 25;
    }
    
    .inv-item.normal { 
      border-color: #5a5a4a; 
      background: linear-gradient(180deg, #1a1a14 0%, #101008 100%); 
    }
    .inv-item.magic { 
      border-color: #4466aa; 
      background: linear-gradient(180deg, #14141f 0%, #0a0a12 100%); 
    }
    .inv-item.rare { 
      border-color: #aa8822; 
      background: linear-gradient(180deg, #1f1a10 0%, #120e06 100%); 
    }
    .inv-item.unique { 
      border-color: #af6025; 
      background: linear-gradient(180deg, #1f1510 0%, #120a06 100%); 
    }
    
    .inv-item .item-icon {
      font-size: clamp(14px, 1.5vw, 28px);
    }
    
    /* Slot-specific icon adjustments */
    .inv-item[data-slot="boots"] {
      position: relative;
    }
    .inv-item[data-slot="boots"] .item-icon {
      /* Centered like other items */
    }
    .inv-item[data-slot="helmet"] .item-icon {
      font-size: clamp(16px, 1.8vw, 32px);
    }
    
    /* POE2 Style Item Tooltip - Updated for better legibility */
    .item-tooltip {
      position: fixed;
      z-index: 10000;
      pointer-events: none;
      min-width: 260px;
      max-width: 360px;
      background: linear-gradient(180deg, #0a0906 0%, #121008 100%);
      border: 2px solid #4a3820;
      border-radius: 0;
      padding: 0;
      font-family: 'Fontin', Georgia, serif;
      display: none;
      box-shadow: 0 6px 30px rgba(0,0,0,0.9);
    }
    
    .item-tooltip.visible { display: block; }
    
    /* Equipped item comparison tooltip - positioned to left of main tooltip */
    .equipped-tooltip {
      z-index: 9999;
      border-color: #3a4828;
      min-width: 280px;
      max-width: 360px;
    }
    
    .equipped-tooltip-label {
      background: linear-gradient(90deg, #2a3820, #1a2810);
      color: #8a8;
      font-size: 11px;
      font-weight: bold;
      text-align: center;
      padding: 4px 10px;
      letter-spacing: 2px;
      border-bottom: 1px solid #3a4828;
    }
    
    .tooltip-header {
      padding: 14px 16px 10px 16px;
      text-align: center;
      border-bottom: 2px solid #3a3020;
    }
    
    .tooltip-header.normal { background: linear-gradient(180deg, #2a2820 0%, #1a1814 100%); border-top: 3px solid #888; }
    .tooltip-header.magic { background: linear-gradient(180deg, #1a2040 0%, #101830 100%); border-top: 3px solid #8888ff; }
    .tooltip-header.rare { background: linear-gradient(180deg, #3a3010 0%, #2a2008 100%); border-top: 3px solid #ffff77; }
    .tooltip-header.unique { background: linear-gradient(180deg, #4a2510 0%, #301808 100%); border-top: 3px solid #ff8833; }
    
    .tooltip-name {
      font-size: 18px;
      font-weight: bold;
      margin-bottom: 3px;
      text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
    }
    .tooltip-name.normal { color: #c8c8c8; }
    .tooltip-name.magic { color: #8888ff; }
    .tooltip-name.rare { color: #ffff77; }
    .tooltip-name.unique { color: #ff8833; }
    
    .tooltip-type {
      font-size: 13px;
      color: #888;
      font-style: italic;
    }
    
    .tooltip-body {
      padding: 10px 16px 14px 16px;
    }
    
    .tooltip-stat-line {
      font-size: 15px;
      color: #aaa;
      padding: 3px 0;
    }
    .tooltip-stat-line .stat-value {
      color: #fff;
    }
    
    .tooltip-section-title {
      font-size: 12px;
      color: #606060;
      text-transform: uppercase;
      letter-spacing: 1px;
      margin: 10px 0 6px 0;
      padding-bottom: 4px;
      border-bottom: 1px solid #2a2018;
    }
    
    .tooltip-separator {
      border: 0;
      height: 2px;
      background: linear-gradient(90deg, transparent, #4a4030, transparent);
      margin: 10px 0;
    }
    
    .tooltip-implicit {
      color: #9988aa;
      font-size: 12px;
      padding: 2px 0;
      font-style: italic;
    }
    
    .tooltip-implicit-section {
      border-top: 1px solid #3a2840;
      padding-top: 6px;
      margin-top: 6px;
      background: rgba(80, 50, 90, 0.15);
      padding: 6px 8px;
      margin: 8px -8px 0 -8px;
      border-radius: 0;
    }
    
    .tooltip-base-stats-section {
      background: rgba(50, 45, 38, 0.5);
      padding: 8px 10px;
      margin: 0 -8px 6px -8px;
      border-bottom: 1px solid #3a3020;
    }
    
    .tooltip-base-stat {
      font-size: 14px;
      color: #a09080;
      padding: 3px 0;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    
    .tooltip-base-stat .base-value {
      color: #e8e0d8;
      font-weight: 600;
      font-size: 15px;
    }
    
    .tooltip-base-stat .base-value.modified {
      color: #88ccff;
    }
    
    .tooltip-base-detail {
      font-size: 11px;
      color: #666;
      text-align: right;
      margin-top: -2px;
      margin-bottom: 2px;
    }
    
    .tooltip-base-stat .base-value.quality {
      color: #88aaff;
    }
    
    .tooltip-hybrid-hint {
      font-size: 10px;
      color: #666;
      font-style: italic;
      text-align: right;
      padding-top: 4px;
      border-top: 1px solid rgba(60, 50, 40, 0.5);
      margin-top: 4px;
    }
    
    .tooltip-mod {
      font-size: 14px;
      padding: 2px 0;
      line-height: 1.4;
    }
    
    .tooltip-mod-text {
      color: #8888ff;
    }
    
    .tooltip-mod-implicit {
      color: #777;
      font-style: italic;
    }
    
    .tooltip-affix-group {
      margin-bottom: 4px;
    }
    
    .tooltip-affix-group:last-child {
      margin-bottom: 0;
    }
    
    .tooltip-req {
      font-size: 13px;
      color: #606060;
      padding: 4px 0 0 0;
    }
    
    .tooltip-sep {
      height: 1px;
      background: linear-gradient(90deg, transparent, #3a3020, transparent);
      margin: 8px 0;
    }
    
    .tooltip-affix-divider {
      height: 1px;
      background: linear-gradient(90deg, transparent, #333, transparent);
      margin: 6px 0;
    }
    
    .tooltip-section-header {
      font-size: 10px;
      color: #666;
      text-transform: uppercase;
      letter-spacing: 1px;
      margin: 8px 0 4px 0;
      padding-bottom: 2px;
      border-bottom: 1px solid #2a2a2a;
    }
    
    .tooltip-section-header.implicit {
      color: #8877aa;
      border-bottom-color: #3a2840;
    }
    
    .tooltip-sep + .tooltip-section-header {
      margin-top: 0;
    }
    
    .tooltip-ele-group {
      background: rgba(60, 40, 30, 0.3);
      border-left: 2px solid #664422;
      padding: 4px 8px;
      margin: 4px 0;
    }
    
    .tooltip-ele-header {
      color: #aa8866;
      font-size: 12px;
      margin-bottom: 2px;
    }
    
    .tooltip-ele-line {
      font-size: 13px;
      padding: 1px 0;
    }
    
    .tooltip-ele-line.fire { color: #e08866; }
    .tooltip-ele-line.cold { color: #66aadd; }
    .tooltip-ele-line.lightning { color: #ddcc77; }
    .tooltip-ele-line.physical { color: #ccbbaa; }
    
    .tooltip-hint {
      font-size: 11px;
      color: #505050;
      text-align: center;
      padding-top: 8px;
      font-style: italic;
    }
    
    .tooltip-immutable {
      color: #d02020;
      font-weight: bold;
      font-size: 16px;
      text-align: center;
      margin-top: 12px;
    }
    
    .tooltip-sockets-section {
      padding: 4px 0;
    }
    
    .tooltip-sockets {
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 6px 0;
      flex-wrap: wrap;
    }
    
    .tooltip-socket-row {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 4px 0;
    }
    
    .tooltip-socket-row.empty {
      opacity: 0.5;
    }
    
    .socket-icon {
      font-size: 18px;
      text-shadow: 0 0 4px currentColor;
      min-width: 22px;
      text-align: center;
    }
    
    .socket-gem-info {
      display: flex;
      flex-direction: column;
      gap: 2px;
    }
    
    .socket-gem-name {
      font-size: 13px;
      color: #bbb;
      font-weight: 500;
    }
    
    .socket-gem-effect {
      font-size: 12px;
      color: #888;
    }
    
    .socket-gem-effect.fire { color: #e08866; }
    .socket-gem-effect.cold { color: #66aadd; }
    .socket-gem-effect.lightning { color: #ddcc77; }
    .socket-gem-effect.life { color: #cc8888; }
    .socket-gem-effect.physical { color: #ccbbaa; }
    
    .socket-empty-text {
      font-size: 12px;
      color: #555;
      font-style: italic;
    }
    
    .tooltip-requirements {
      font-size: 14px;
      color: #707070;
      padding-top: 10px;
      margin-top: 10px;
    }
    
    .tooltip-tier-detail {
      color: #808080;
      font-size: 12px;
      margin-left: 6px;
    }
    
    .tooltip-tier-small {
      color: #606060;
      font-size: 11px;
      margin-left: 4px;
    }
    
    .tooltip-alt-hint {
      font-size: 12px;
      color: #505050;
      text-align: center;
      margin-top: 10px;
      font-style: italic;
    }
    
    /* Comparison tooltip */
    .tooltip-comparison {
      margin-top: 12px;
      padding-top: 12px;
      border-top: 2px solid #4a4030;
    }
    
    .tooltip-comparison-title {
      font-size: 12px;
      color: #888;
      text-transform: uppercase;
      letter-spacing: 1px;
      margin-bottom: 8px;
    }
    
    .tooltip-stat-change {
      font-size: 13px;
      padding: 2px 0;
    }
    
    .tooltip-stat-change.positive { color: #44ff44; }
    .tooltip-stat-change.negative { color: #ff4444; }
    .tooltip-stat-change.neutral { color: #888888; }
    
    .stat-diff {
      font-size: 12px;
      font-weight: 600;
      margin-left: 4px;
    }
    
    .stat-diff.positive { color: #44ff44; }
    .stat-diff.negative { color: #ff4444; }
    
    .tooltip-lost-section {
      margin-top: 12px;
      padding-top: 10px;
      border-top: 1px solid #3a3030;
      background: rgba(60, 30, 30, 0.3);
      padding: 8px;
      margin-left: -8px;
      margin-right: -8px;
      margin-bottom: -8px;
    }
    
    .tooltip-lost-title {
      font-size: 11px;
      color: #ff8866;
      font-weight: 600;
      margin-bottom: 6px;
    }
    
    .tooltip-lost-mod {
      font-size: 12px;
      color: #cc8888;
      padding: 2px 0;
      padding-left: 4px;
    }
    
    .tooltip-comparison {
      margin-top: 12px;
      padding-top: 12px;
      border-top: 2px solid #4a4030;
    }
    
    .tooltip-comparison-title {
      font-size: 13px;
      color: #c9a050;
      font-weight: 600;
      margin-bottom: 8px;
    }
    
    .tooltip-flavor {
      font-size: 11px;
      color: #af6025;
      font-style: italic;
      text-align: center;
      padding-top: 8px;
      border-top: 1px solid #2a2018;
      margin-top: 8px;
    }
    

    
    /* Bottom Gold - scales with viewport */
    .inv-gold-bar {
      display: flex;
      justify-content: flex-end;
      align-items: center;
      gap: clamp(12px, 1.5vw, 24px);
      padding: clamp(8px, 1vw, 14px) clamp(12px, 1.5vw, 20px);
      background: linear-gradient(180deg, #12100a 0%, #0a0805 100%);
      border-top: 2px solid #3a2818;
      flex-shrink: 0;
    }
    
    .inv-gold-item {
      display: flex;
      align-items: center;
      gap: clamp(4px, 0.6vw, 10px);
    }
    
    .inv-gold-item .icon { font-size: clamp(14px, 1.4vw, 20px); }
    .inv-gold-item .count { font-size: clamp(12px, 1.3vw, 18px); font-weight: 600; color: #c9a050; }
    .inv-gold-item .count.blood { color: #c04040; }
    
    .inv-hint {
      padding: clamp(6px, 0.7vw, 10px);
      text-align: center;
      font-size: clamp(9px, 0.9vw, 12px);
      color: #504030;
      flex-shrink: 0;
    }
    
    /* ============ MENU SYSTEM ============ */
    #gameContainer.hidden { display: none; }
    
    .menu-screen {
      position: fixed;
      inset: 0;
      background: url('https://raw.githubusercontent.com/Graphic37/ARPG-/main/corefall%20grey%20without%20text.png') center center / cover no-repeat;
      z-index: 2000;
      display: flex;
      overflow: hidden;
    }
    
    .menu-screen.hidden { display: none; }
    
    .menu-bg {
      position: absolute;
      inset: 0;
      background: 
        radial-gradient(ellipse at 30% 50%, rgba(40, 60, 40, 0.2) 0%, transparent 50%),
        radial-gradient(ellipse at 70% 30%, rgba(30, 50, 30, 0.15) 0%, transparent 40%);
      pointer-events: none;
    }
    
    .menu-left-panel {
      width: 400px;
      background: linear-gradient(180deg, rgba(20, 18, 14, 0.95) 0%, rgba(10, 8, 6, 0.98) 100%);
      border-right: 3px solid #3a3020;
      display: flex;
      flex-direction: column;
      padding: 30px;
      z-index: 1;
    }
    
    .menu-logo {
      text-align: center;
      margin-bottom: 30px;
    }
    
    .menu-logo h1 {
      font-size: 48px;
      color: #4a8;
      text-shadow: 0 0 30px rgba(68, 170, 136, 0.5), 0 4px 8px rgba(0,0,0,0.8);
      margin: 0;
      letter-spacing: 8px;
    }
    
    .menu-logo h2 {
      font-size: 14px;
      color: #6a6;
      letter-spacing: 6px;
      margin: 5px 0 0 0;
      text-transform: uppercase;
    }
    
    .menu-btn {
      width: 100%;
      padding: 16px 24px;
      margin: 8px 0;
      background: linear-gradient(180deg, #2a4a2a 0%, #1a3a1a 100%);
      border: 2px solid #4a8a4a;
      color: #8f8;
      font-size: 16px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 2px;
      cursor: pointer;
      transition: all 0.2s;
    }
    
    .menu-btn:hover {
      background: linear-gradient(180deg, #3a6a3a 0%, #2a5a2a 100%);
      border-color: #6aba6a;
      transform: scale(1.02);
    }
    
    .menu-btn.secondary {
      background: linear-gradient(180deg, #2a2520 0%, #1a1510 100%);
      border-color: #4a4030;
      color: #aa9;
    }
    
    .menu-btn.secondary:hover {
      border-color: #6a6050;
    }
    
    .slots-info {
      text-align: center;
      color: #666;
      font-size: 13px;
      margin: 10px 0 20px;
    }
    
    .character-list {
      flex: 1;
      overflow-y: auto;
      margin: 10px 0;
    }
    
    .character-slot {
      position: relative;
      display: flex;
      align-items: center;
      padding: 12px;
      margin: 6px 0;
      background: linear-gradient(180deg, #1a1810 0%, #0f0d08 100%);
      border: 2px solid #2a2518;
      cursor: pointer;
      transition: all 0.2s;
    }
    
    .character-slot:hover {
      border-color: #4a4538;
    }
    
    .character-slot.selected {
      border-color: #6a8a4a;
      background: linear-gradient(180deg, #1f2018 0%, #15140c 100%);
    }
    
    .char-portrait {
      width: 60px;
      height: 60px;
      background: linear-gradient(180deg, #252520 0%, #151510 100%);
      border: 2px solid #3a3530;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 28px;
      margin-right: 15px;
      position: relative;
      overflow: hidden;
    }
    
    .char-portrait-img {
      width: 52px;
      height: 52px;
      object-fit: contain;
    }
    
    .char-level {
      position: absolute;
      bottom: -5px;
      left: -5px;
      background: #1a5a1a;
      border: 1px solid #2a8a2a;
      padding: 2px 6px;
      font-size: 11px;
      color: #8f8;
      font-weight: bold;
    }
    
    .char-info h3 {
      margin: 0;
      color: #ddc;
      font-size: 16px;
    }
    
    .char-info p {
      margin: 4px 0 0;
      color: #888;
      font-size: 12px;
    }
    
    .char-info .seasonal { color: #4a8; }
    
    .menu-right-panel {
      flex: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      position: relative;
    }
    
    .menu-char-display {
      display: flex;
      align-items: center;
      gap: 50px;
    }
    
    .char-standing-portrait {
      width: 300px;
      height: 420px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: radial-gradient(ellipse at center, rgba(0, 0, 0, 0.7) 0%, rgba(0, 0, 0, 0.4) 50%, transparent 70%);
      border-radius: 20px;
      position: relative;
    }
    
    .char-standing-portrait::before {
      content: '';
      position: absolute;
      inset: -5px;
      background: radial-gradient(ellipse at center bottom, rgba(100, 200, 150, 0.3) 0%, transparent 60%);
      border-radius: 25px;
      z-index: -1;
    }
    
    .char-standing-portrait img {
      max-width: 95%;
      max-height: 95%;
      object-fit: contain;
      filter: drop-shadow(0 0 20px rgba(0, 0, 0, 0.9)) drop-shadow(0 5px 15px rgba(0, 0, 0, 0.8));
    }
    
    .char-standing-portrait .portrait-emoji {
      font-size: 180px;
      opacity: 0.7;
      filter: drop-shadow(0 0 30px rgba(0, 0, 0, 0.6));
    }
    
    .character-preview {
      display: none;
    }
    
    .character-name-display {
      text-align: center;
      background: linear-gradient(180deg, rgba(20, 30, 35, 0.9) 0%, rgba(10, 15, 20, 0.95) 100%);
      padding: 45px 70px;
      border-radius: 16px;
      border: 2px solid rgba(100, 200, 150, 0.5);
      box-shadow: 0 0 50px rgba(0, 0, 0, 0.9), 0 0 30px rgba(100, 200, 150, 0.15), inset 0 1px 0 rgba(255, 255, 255, 0.05);
    }
    
    .character-name-display h2 {
      font-size: 52px;
      color: #fff;
      margin: 0;
      letter-spacing: 8px;
      text-transform: uppercase;
      text-shadow: 0 0 25px rgba(100, 200, 150, 0.5), 0 4px 8px rgba(0, 0, 0, 0.9);
    }
    
    .character-name-display .mode {
      color: #5fc;
      font-size: 20px;
      margin: 12px 0;
      font-weight: bold;
      text-shadow: 0 0 15px rgba(80, 255, 200, 0.6);
      letter-spacing: 3px;
    }
    
    .character-name-display .mode.seasonal {
      color: #5fc;
      text-shadow: 0 0 15px rgba(80, 255, 200, 0.6);
    }
    
    .character-name-display .mode.standard {
      color: #aaa;
      text-shadow: 0 0 10px rgba(150, 150, 150, 0.4);
    }
    
    .character-name-display .details {
      color: #aab;
      font-size: 18px;
      letter-spacing: 3px;
      text-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
    }
    
    .start-game-btn {
      margin-top: auto;
      padding: 18px 40px;
      background: linear-gradient(180deg, #2a5a2a 0%, #1a4a1a 100%);
      border: 3px solid #4a9a4a;
      color: #8f8;
      font-size: 18px;
      font-weight: 700;
      letter-spacing: 3px;
      cursor: pointer;
      transition: all 0.2s;
      width: 100%;
    }
    
    .start-game-btn:hover {
      background: linear-gradient(180deg, #3a7a3a 0%, #2a6a2a 100%);
      border-color: #6aca6a;
      transform: scale(1.02);
      box-shadow: 0 0 30px rgba(100, 200, 100, 0.3);
    }
    
    .start-game-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      transform: none;
      box-shadow: none;
    }
    
    /* Character Delete Button */
    .char-delete-btn {
      position: absolute;
      top: 5px;
      right: 5px;
      width: 24px;
      height: 24px;
      background: rgba(100, 30, 30, 0.8);
      border: 1px solid #6a3030;
      border-radius: 4px;
      color: #c66;
      font-size: 14px;
      cursor: pointer;
      opacity: 0;
      transition: all 0.2s;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    .character-slot:hover .char-delete-btn {
      opacity: 1;
    }
    
    .char-delete-btn:hover {
      background: rgba(150, 40, 40, 0.9);
      border-color: #a44;
      color: #f88;
      transform: scale(1.1);
    }
    
    /* Delete Confirmation Modal */
    .delete-confirm-modal {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.8);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 10000;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.2s;
    }
    
    .delete-confirm-modal.visible {
      opacity: 1;
      pointer-events: auto;
    }
    
    .delete-confirm-box {
      background: linear-gradient(180deg, #2a1a1a 0%, #1a0f0f 100%);
      border: 3px solid #8a4040;
      border-radius: 12px;
      padding: 35px 50px;
      text-align: center;
      max-width: 450px;
      box-shadow: 0 0 40px rgba(150, 50, 50, 0.4);
    }
    
    .delete-confirm-box h3 {
      color: #ff6666;
      font-size: 26px;
      margin-bottom: 20px;
      text-shadow: 0 0 10px rgba(255, 100, 100, 0.5);
    }
    
    .delete-confirm-box p {
      color: #ccc;
      font-size: 16px;
      margin-bottom: 12px;
    }
    
    .delete-confirm-box .char-name {
      color: #fff;
      font-size: 22px;
      font-weight: bold;
      margin-bottom: 20px;
      padding: 10px 20px;
      background: rgba(0, 0, 0, 0.3);
      border-radius: 6px;
      border: 1px solid #4a4a5a;
    }
    
    .delete-confirm-buttons {
      display: flex;
      gap: 20px;
      justify-content: center;
      margin-top: 25px;
    }
    
    .delete-confirm-btn {
      padding: 14px 35px;
      border-radius: 6px;
      font-size: 16px;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.2s;
      letter-spacing: 1px;
    }
    
    .delete-confirm-btn.cancel {
      background: linear-gradient(180deg, #2a2a35 0%, #1a1a25 100%);
      border: 2px solid #4a4a5a;
      color: #aaa;
    }
    
    .delete-confirm-btn.cancel:hover {
      background: linear-gradient(180deg, #3a3a45 0%, #2a2a35 100%);
      border-color: #6a6a7a;
      color: #ccc;
    }
    
    .delete-confirm-btn.delete {
      background: linear-gradient(180deg, #5a2020 0%, #4a1515 100%);
      border: 2px solid #8a3030;
      color: #f88;
    }
    
    .delete-confirm-btn.delete:hover {
      background: linear-gradient(180deg, #7a3030 0%, #5a2020 100%);
      border-color: #aa4040;
      color: #faa;
    }
    
    /* Skill Unlock Popup */
    .skill-unlock-modal {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.85);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 10000;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.3s;
    }
    
    .skill-unlock-modal.visible {
      opacity: 1;
      pointer-events: auto;
    }
    
    .skill-unlock-box {
      background: linear-gradient(180deg, #1a2520 0%, #0f1512 100%);
      border: 3px solid #4a9a6a;
      border-radius: 16px;
      padding: 40px 50px;
      text-align: center;
      max-width: 450px;
      box-shadow: 0 0 60px rgba(80, 200, 120, 0.3), 0 0 30px rgba(0, 0, 0, 0.8);
      animation: skillUnlockPop 0.4s ease-out;
    }
    
    @keyframes skillUnlockPop {
      0% { transform: scale(0.8); opacity: 0; }
      50% { transform: scale(1.05); }
      100% { transform: scale(1); opacity: 1; }
    }
    
    .skill-unlock-box h3 {
      color: #5fc;
      font-size: 28px;
      margin: 0 0 10px;
      letter-spacing: 4px;
      text-shadow: 0 0 20px rgba(80, 255, 200, 0.5);
    }
    
    .skill-unlock-box .unlock-subtitle {
      color: #8ab;
      font-size: 14px;
      margin-bottom: 25px;
    }
    
    .skill-unlock-icon {
      width: 100px;
      height: 100px;
      margin: 0 auto 20px;
      background: linear-gradient(180deg, rgba(40, 60, 50, 0.9) 0%, rgba(20, 35, 28, 0.95) 100%);
      border: 3px solid #4a9a6a;
      border-radius: 16px;
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: 0 0 30px rgba(80, 200, 120, 0.3);
    }
    
    .skill-unlock-icon img {
      width: 70px;
      height: 70px;
      object-fit: contain;
    }
    
    .skill-unlock-icon .emoji {
      font-size: 50px;
    }
    
    .skill-unlock-name {
      color: #fff;
      font-size: 24px;
      font-weight: bold;
      margin-bottom: 10px;
      text-shadow: 0 0 15px rgba(255, 255, 255, 0.3);
    }
    
    .skill-unlock-desc {
      color: #9ab;
      font-size: 14px;
      line-height: 1.5;
      margin-bottom: 25px;
    }
    
    .skill-unlock-hint {
      color: #6a8;
      font-size: 13px;
      padding: 12px 20px;
      background: rgba(0, 0, 0, 0.3);
      border-radius: 8px;
      margin-bottom: 25px;
    }
    
    .skill-unlock-hint strong {
      color: #5fc;
    }
    
    .skill-unlock-btn {
      padding: 14px 40px;
      background: linear-gradient(180deg, #2a5a3a 0%, #1a4a2a 100%);
      border: 2px solid #4a9a5a;
      border-radius: 8px;
      color: #8f8;
      font-size: 16px;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.2s;
      letter-spacing: 2px;
    }
    
    .skill-unlock-btn:hover {
      background: linear-gradient(180deg, #3a7a4a 0%, #2a6a3a 100%);
      border-color: #6aca6a;
      transform: scale(1.05);
      box-shadow: 0 0 20px rgba(100, 200, 100, 0.3);
    }
    
    /* Class Selection Screen */
    .class-select-content {
      flex: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 40px;
      position: relative;
      z-index: 10;
    }
    
    .class-preview {
      display: flex;
      align-items: center;
      justify-content: center;
      flex: 0 0 auto;
      gap: 30px;
    }
    
    .class-preview-left {
      width: 300px;
      text-align: center;
      padding: 35px;
      background: linear-gradient(180deg, rgba(20, 25, 30, 0.92) 0%, rgba(10, 12, 15, 0.95) 100%);
      border: 2px solid rgba(100, 200, 150, 0.3);
      border-radius: 12px;
      box-shadow: 0 0 40px rgba(0, 0, 0, 0.8);
    }
    
    .class-preview-left h2 {
      font-size: 36px;
      color: #fff;
      margin: 0 0 20px;
      letter-spacing: 6px;
      text-shadow: 0 0 20px rgba(100, 200, 150, 0.5), 0 3px 6px rgba(0, 0, 0, 0.8);
    }
    
    .class-preview-left p {
      color: #bbb;
      font-size: 15px;
      line-height: 1.7;
    }
    
    .class-icon-large {
      width: 280px;
      height: 350px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 180px;
      text-shadow: 0 0 60px rgba(100, 200, 150, 0.4);
      pointer-events: none;
      user-select: none;
      background: radial-gradient(ellipse at center, rgba(0, 0, 0, 0.6) 0%, rgba(0, 0, 0, 0.3) 50%, transparent 70%);
      border-radius: 20px;
    }
    
    .class-icon-large img {
      max-width: 100%;
      max-height: 320px;
      object-fit: contain;
      filter: drop-shadow(0 0 25px rgba(0, 0, 0, 0.9)) drop-shadow(0 5px 15px rgba(0, 0, 0, 0.8));
    }
    
    .class-preview-right {
      width: 340px;
      background: linear-gradient(180deg, rgba(20, 25, 30, 0.92) 0%, rgba(10, 12, 15, 0.95) 100%);
      border: 2px solid rgba(100, 200, 150, 0.3);
      border-radius: 12px;
      padding: 28px;
      box-shadow: 0 0 40px rgba(0, 0, 0, 0.8);
    }
    
    .class-preview-right h3 {
      color: #8ab;
      font-size: 15px;
      letter-spacing: 5px;
      margin: 0 0 20px;
      text-align: center;
      text-shadow: 0 0 10px rgba(100, 150, 180, 0.3);
    }
    
    .playstyle-item {
      display: flex;
      align-items: flex-start;
      padding: 14px 0;
      border-bottom: 1px solid rgba(100, 200, 150, 0.15);
    }
    
    .playstyle-item:last-child { border: none; }
    
    .playstyle-icon {
      font-size: 26px;
      margin-right: 16px;
      filter: drop-shadow(0 0 8px rgba(100, 200, 150, 0.4));
    }
    
    .playstyle-item h4 {
      margin: 0;
      color: #5fc;
      font-size: 14px;
      letter-spacing: 1px;
      text-shadow: 0 0 10px rgba(80, 255, 200, 0.3);
    }
    
    .playstyle-item p {
      margin: 5px 0 0;
      color: #9aa;
      font-size: 13px;
    }
    
    .class-selector {
      display: flex;
      gap: 20px;
      margin: 30px 0;
      padding: 15px 25px;
      background: rgba(0, 0, 0, 0.5);
      border-radius: 50px;
      border: 1px solid rgba(100, 200, 150, 0.2);
    }
    
    /* Skill Preview Section */
    .skill-preview-section {
      width: 100%;
      max-width: 900px;
      margin-top: 20px;
      background: linear-gradient(180deg, rgba(20, 25, 30, 0.92) 0%, rgba(10, 12, 15, 0.95) 100%);
      border: 2px solid rgba(100, 200, 150, 0.25);
      border-radius: 12px;
      padding: 20px 25px;
      box-shadow: 0 0 40px rgba(0, 0, 0, 0.7);
    }
    
    .skill-preview-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 15px;
    }
    
    .skill-preview-header h3 {
      color: #8ab;
      font-size: 13px;
      letter-spacing: 3px;
      margin: 0;
      text-shadow: 0 0 10px rgba(100, 150, 180, 0.3);
    }
    
    .skill-preview-hint {
      color: #667;
      font-size: 11px;
      font-style: italic;
    }
    
    .skill-preview-grid {
      display: flex;
      gap: 12px;
      flex-wrap: wrap;
      justify-content: center;
    }
    
    .skill-preview-item {
      width: 70px;
      height: 75px;
      background: linear-gradient(180deg, rgba(30, 35, 40, 0.9) 0%, rgba(15, 18, 22, 0.95) 100%);
      border: 2px solid rgba(100, 200, 150, 0.2);
      border-radius: 10px;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: all 0.2s;
      position: relative;
    }
    
    .skill-preview-item:hover {
      border-color: rgba(100, 200, 150, 0.5);
      transform: translateY(-3px);
      box-shadow: 0 6px 20px rgba(0, 0, 0, 0.5), 0 0 15px rgba(100, 200, 150, 0.15);
    }
    
    .skill-preview-item.primary {
      border-color: rgba(100, 200, 150, 0.4);
      background: linear-gradient(180deg, rgba(30, 50, 40, 0.9) 0%, rgba(15, 25, 20, 0.95) 100%);
    }
    
    .skill-preview-item.primary:hover {
      border-color: rgba(100, 200, 150, 0.7);
      box-shadow: 0 6px 20px rgba(0, 0, 0, 0.5), 0 0 20px rgba(100, 200, 150, 0.25);
    }
    
    .skill-preview-item .skill-icon {
      font-size: 26px;
    }
    
    .skill-preview-item .skill-icon-img {
      width: 40px;
      height: 40px;
      object-fit: contain;
    }
    
    .skill-preview-item .skill-name {
      font-size: 9px;
      color: #9aa;
      margin-top: 4px;
      text-align: center;
      max-width: 62px;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }
    
    .skill-unlock-level {
      position: absolute;
      top: 3px;
      left: 3px;
      background: linear-gradient(180deg, rgba(40, 60, 50, 0.95) 0%, rgba(20, 35, 25, 0.98) 100%);
      border: 1px solid rgba(100, 200, 150, 0.5);
      border-radius: 3px;
      padding: 1px 5px;
      font-size: 8px;
      font-weight: bold;
      color: #7cb;
    }
    
    .skill-preview-tooltip {
      position: fixed;
      background: linear-gradient(180deg, #1a1a22 0%, #12121a 100%);
      border: 2px solid #4a4a5a;
      border-radius: 8px;
      padding: 12px 15px;
      max-width: 280px;
      z-index: 10001;
      pointer-events: none;
      box-shadow: 0 5px 20px rgba(0, 0, 0, 0.8);
    }
    
    .skill-preview-tooltip h4 {
      color: #ddc;
      margin: 0 0 4px;
      font-size: 14px;
    }
    
    .skill-preview-tooltip .skill-type {
      color: #888;
      font-size: 11px;
      margin-bottom: 8px;
    }
    
    .skill-preview-tooltip .skill-desc {
      color: #aaa;
      font-size: 12px;
      line-height: 1.4;
      margin-bottom: 8px;
    }
    
    .skill-preview-tooltip .skill-stats {
      border-top: 1px solid #333;
      padding-top: 8px;
    }
    
    .skill-preview-tooltip .skill-stat {
      color: #8a8;
      font-size: 11px;
      margin: 3px 0;
    }
    
    .skill-preview-tooltip .skill-cost {
      color: #88f;
      font-size: 11px;
      margin-top: 6px;
    }
    
    .class-option {
      width: 85px;
      height: 85px;
      background: linear-gradient(180deg, rgba(25, 30, 35, 0.95) 0%, rgba(12, 15, 18, 0.98) 100%);
      border: 3px solid rgba(80, 100, 120, 0.4);
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 36px;
      cursor: pointer;
      transition: all 0.25s;
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.5);
    }
    
    .class-option:hover {
      border-color: rgba(100, 200, 150, 0.5);
      transform: scale(1.12);
      box-shadow: 0 6px 25px rgba(0, 0, 0, 0.6), 0 0 20px rgba(100, 200, 150, 0.2);
    }
    
    .class-option.selected {
      border-color: rgba(100, 200, 150, 0.8);
      box-shadow: 0 0 30px rgba(100, 200, 150, 0.4), 0 0 15px rgba(100, 200, 150, 0.3);
      background: linear-gradient(180deg, rgba(30, 50, 40, 0.95) 0%, rgba(15, 25, 20, 0.98) 100%);
    }
    
    .class-option.locked {
      cursor: not-allowed;
      opacity: 0.5;
      border-color: rgba(60, 60, 70, 0.5);
      background: linear-gradient(180deg, rgba(20, 20, 25, 0.95) 0%, rgba(10, 10, 12, 0.98) 100%);
      position: relative;
    }
    
    .class-option.locked:hover {
      transform: none;
      border-color: rgba(80, 80, 90, 0.5);
      box-shadow: none;
    }
    
    .class-option.locked::after {
      content: '🔒';
      position: absolute;
      bottom: 5px;
      right: 5px;
      font-size: 14px;
      opacity: 0.7;
    }
    
    /* Locked Class Tooltip */
    .locked-tooltip {
      position: fixed;
      background: linear-gradient(180deg, rgba(30, 25, 20, 0.98) 0%, rgba(15, 12, 8, 0.98) 100%);
      border: 2px solid #c9a050;
      border-radius: 8px;
      padding: 12px 16px;
      color: #ddc;
      font-size: 13px;
      text-align: center;
      z-index: 10000;
      pointer-events: none;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.6), 0 0 20px rgba(201, 160, 80, 0.2);
      max-width: 220px;
      display: none;
    }
    
    .locked-tooltip .tooltip-title {
      color: #c9a050;
      font-weight: bold;
      font-size: 14px;
      margin-bottom: 8px;
      text-shadow: 0 0 8px rgba(201, 160, 80, 0.4);
    }
    
    .locked-tooltip .tooltip-text {
      color: #aaa;
      line-height: 1.4;
    }
    
    .locked-tooltip .wishlist-cta {
      color: #6cf;
      margin-top: 8px;
      font-weight: bold;
    }
    
    /* DEMO Badge */
    .demo-badge {
      position: fixed;
      top: 15px;
      right: 15px;
      background: linear-gradient(180deg, #c9a050 0%, #8a6020 100%);
      border: 2px solid #ddc070;
      border-radius: 6px;
      padding: 8px 20px;
      font-size: 14px;
      font-weight: bold;
      color: #fff;
      letter-spacing: 3px;
      text-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.5), 0 0 20px rgba(201, 160, 80, 0.3);
      z-index: 9999;
    }
    
    .class-option span {
      display: block;
      text-align: center;
      margin-top: 8px;
      color: #888;
      font-size: 11px;
    }
    
    .class-buttons {
      display: flex;
      gap: 20px;
      position: fixed;
      bottom: 60px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 2100;
    }
    
    .class-buttons .menu-btn {
      width: auto;
      min-width: 180px;
      padding: 18px 50px;
      cursor: pointer;
      font-size: 18px;
    }
    
    /* Character Create Screen */
    .create-left-panel {
      width: 450px;
      background: linear-gradient(180deg, rgba(20, 18, 14, 0.95) 0%, rgba(10, 8, 6, 0.98) 100%);
      border-right: 3px solid #3a3020;
      padding: 40px;
      z-index: 1;
    }
    
    .create-section {
      margin-bottom: 30px;
    }
    
    .create-section h3 {
      color: #888;
      font-size: 12px;
      letter-spacing: 2px;
      margin: 0 0 15px;
    }
    
    .create-section h2 {
      color: #ddc;
      font-size: 20px;
      margin: 0 0 15px;
    }
    
    .option-row {
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 14px 20px;
      margin: 8px 0;
      background: linear-gradient(180deg, #1a1810 0%, #0f0d08 100%);
      border: 2px solid #2a2518;
      cursor: pointer;
      transition: all 0.2s;
      border-radius: 4px;
    }
    
    .option-row:hover {
      transform: translateY(-1px);
    }
    
    /* Seasonal - Green theme */
    .option-row.seasonal-btn {
      background: linear-gradient(180deg, #1a2a1a 0%, #0a150a 100%);
      border-color: #2a4a2a;
    }
    .option-row.seasonal-btn:hover {
      border-color: #3a6a3a;
      box-shadow: 0 0 10px rgba(60, 140, 60, 0.3);
    }
    .option-row.seasonal-btn.selected {
      border-color: #4a8a4a;
      background: linear-gradient(180deg, #1a3a1a 0%, #0c200c 100%);
      box-shadow: 0 0 15px rgba(60, 140, 60, 0.4);
    }
    .option-row.seasonal-btn .option-text {
      color: #6c6;
    }
    .option-row.seasonal-btn.selected .option-text {
      color: #8e8;
      text-shadow: 0 0 8px rgba(100, 200, 100, 0.5);
    }
    
    /* Hardcore - Red theme */
    .option-row.hardcore-btn {
      background: linear-gradient(180deg, #2a1a1a 0%, #150a0a 100%);
      border-color: #4a2a2a;
    }
    .option-row.hardcore-btn:hover {
      border-color: #6a3a3a;
      box-shadow: 0 0 10px rgba(140, 60, 60, 0.3);
    }
    .option-row.hardcore-btn.selected {
      border-color: #8a4a4a;
      background: linear-gradient(180deg, #3a1a1a 0%, #200c0c 100%);
      box-shadow: 0 0 15px rgba(140, 60, 60, 0.4);
    }
    .option-row.hardcore-btn .option-text {
      color: #c66;
    }
    .option-row.hardcore-btn.selected .option-text {
      color: #e88;
      text-shadow: 0 0 8px rgba(200, 100, 100, 0.5);
    }
    
    /* Demo Mode - Gold/Amber theme */
    .option-row.demo-mode-btn {
      background: linear-gradient(180deg, #2a2518 0%, #151008 100%);
      border-color: #4a3a20;
      cursor: default;
    }
    .option-row.demo-mode-btn:hover {
      border-color: #6a5a30;
      box-shadow: 0 0 10px rgba(180, 140, 60, 0.3);
    }
    .option-row.demo-mode-btn.selected {
      border-color: #8a7a40;
      background: linear-gradient(180deg, #3a2a18 0%, #201508 100%);
      box-shadow: 0 0 15px rgba(180, 140, 60, 0.4);
    }
    .option-row.demo-mode-btn .option-text {
      color: #c9a050;
    }
    .option-row.demo-mode-btn.selected .option-text {
      color: #ddc070;
      text-shadow: 0 0 8px rgba(200, 160, 80, 0.5);
    }
    
    .checkbox {
      width: 20px;
      height: 20px;
      border: 2px solid #4a4538;
      margin-right: 12px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 14px;
      border-radius: 3px;
    }
    
    .option-row.seasonal-btn .checkbox {
      border-color: #3a5a3a;
      color: #6c6;
    }
    .option-row.seasonal-btn.selected .checkbox {
      border-color: #4a8a4a;
      background: rgba(74, 138, 74, 0.3);
    }
    
    .option-row.hardcore-btn .checkbox {
      border-color: #5a3a3a;
      color: #c66;
    }
    .option-row.hardcore-btn.selected .checkbox {
      border-color: #8a4a4a;
      background: rgba(138, 74, 74, 0.3);
    }
    
    .option-text {
      color: #ccc;
      font-size: 15px;
    }
    
    .name-input {
      width: 100%;
      padding: 14px 18px;
      background: #0a0908;
      border: 2px solid #3a3020;
      color: #ccc;
      font-size: 16px;
      margin-bottom: 20px;
    }
    
    .name-input:focus {
      outline: none;
      border-color: #4a8a4a;
    }
    
    .create-character-preview {
      flex: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 280px;
      text-shadow: 0 0 100px rgba(100, 200, 150, 0.3);
    }
    
    /* Character Stats Panel (C key) */
    .char-panel {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%) scale(0.95);
      width: clamp(280px, 26vw, 520px);
      max-height: 95vh;
      background: linear-gradient(180deg, #1a1a1f 0%, #0d0d10 100%);
      border: 2px solid #3a3530;
      border-radius: 8px;
      z-index: 2000;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.1s, transform 0.1s;
      box-shadow: 0 0 60px rgba(0,0,0,0.8), inset 0 0 30px rgba(0,0,0,0.5);
      display: flex;
      flex-direction: column;
    }
    
    .char-panel.visible {
      opacity: 1;
      pointer-events: auto;
      transform: translate(-50%, -50%) scale(1);
    }
    
    .char-panel-header {
      background: linear-gradient(90deg, #2a2520 0%, #3a3530 50%, #2a2520 100%);
      padding: clamp(8px, 1vw, 12px) clamp(14px, 1.5vw, 22px);
      text-align: center;
      border-bottom: 1px solid #4a4540;
      position: relative;
      flex-shrink: 0;
    }
    
    .char-panel-header h2 {
      color: #d4af37;
      font-size: clamp(12px, 1.2vw, 18px);
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 1px;
      text-shadow: 0 2px 4px rgba(0,0,0,0.5);
    }
    
    .char-panel-close {
      position: absolute;
      right: 10px;
      top: 50%;
      transform: translateY(-50%);
      width: clamp(20px, 1.6vw, 28px);
      height: clamp(20px, 1.6vw, 28px);
      background: #8b0000;
      border: 1px solid #aa2020;
      border-radius: 4px;
      color: #fff;
      cursor: pointer;
      font-size: clamp(10px, 0.8vw, 14px);
      line-height: clamp(16px, 1.4vw, 24px);
    }
    
    .char-panel-close:hover {
      background: #aa2020;
    }
    
    .char-panel-content {
      padding: clamp(6px, 0.8vw, 12px);
      overflow-y: auto;
      flex: 1;
    }
    
    .char-info-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: clamp(4px, 0.6vw, 8px) clamp(6px, 0.8vw, 10px);
      background: rgba(30,30,35,0.8);
      border-radius: 6px;
      margin-bottom: clamp(6px, 0.6vw, 10px);
    }
    
    .char-info-left {
      color: #888;
      font-size: clamp(10px, 0.8vw, 13px);
    }
    
    .char-info-left .char-level {
      color: #c0c0c0;
      font-size: clamp(11px, 1vw, 16px);
      font-weight: 600;
    }
    
    .char-info-right {
      text-align: right;
    }
    
    .char-info-right div {
      color: #999;
      font-size: clamp(10px, 0.8vw, 13px);
    }
    
    .char-info-right span {
      color: #d0d0d0;
      font-weight: 500;
    }
    
    .char-attr-row {
      cursor: help;
      padding: 2px 6px;
      border-radius: 3px;
      transition: background 0.15s;
    }
    
    .char-attr-row:hover {
      background: rgba(200, 200, 255, 0.1);
    }
    
    /* Core Stats Grid */
    .char-stats-grid {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: clamp(4px, 0.5vw, 8px);
      margin-bottom: clamp(8px, 0.7vw, 12px);
    }
    
    .char-stat-box {
      background: linear-gradient(180deg, #1e1e24 0%, #141418 100%);
      border: 1px solid #2a2a30;
      border-radius: 6px;
      padding: clamp(6px, 0.8vw, 12px) clamp(4px, 0.5vw, 8px);
      text-align: center;
    }
    
    .char-stat-icon {
      font-size: clamp(18px, 1.6vw, 26px);
      margin-bottom: clamp(2px, 0.3vw, 4px);
    }
    
    .char-stat-label {
      color: #888;
      font-size: clamp(9px, 0.8vw, 12px);
      text-transform: uppercase;
      letter-spacing: 1px;
    }
    
    .char-stat-value {
      color: #fff;
      font-size: clamp(13px, 1.2vw, 18px);
      font-weight: 600;
    }
    
    .char-stat-box.life .char-stat-icon { color: #c44; }
    .char-stat-box.life .char-stat-value { color: #e66; }
    .char-stat-box.mana .char-stat-icon { color: #48f; }
    .char-stat-box.mana .char-stat-value { color: #6af; }
    .char-stat-box.armor .char-stat-icon { color: #a86; }
    .char-stat-box.armor .char-stat-value { color: #ca8; }
    .char-stat-box.damage .char-stat-icon { color: #fa4; }
    .char-stat-box.damage .char-stat-value { color: #fc6; }
    .char-stat-box.atkspd .char-stat-icon { color: #8af; }
    .char-stat-box.atkspd .char-stat-value { color: #adf; }
    
    /* Defense Stats Row */
    .char-defense-row {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: clamp(4px, 0.5vw, 8px);
      margin-bottom: clamp(8px, 0.7vw, 12px);
    }
    
    .char-defense-box {
      background: linear-gradient(180deg, #1a1a20 0%, #12121a 100%);
      border: 1px solid #2a2a35;
      border-radius: 6px;
      padding: clamp(6px, 0.7vw, 10px);
      text-align: center;
    }
    
    .char-defense-icon {
      font-size: clamp(16px, 1.3vw, 22px);
      margin-bottom: clamp(2px, 0.2vw, 4px);
      color: #888;
    }
    
    .char-defense-label {
      color: #777;
      font-size: clamp(9px, 0.8vw, 12px);
      text-transform: uppercase;
    }
    
    .char-defense-value {
      color: #aaa;
      font-size: clamp(13px, 1.2vw, 18px);
      font-weight: 600;
    }
    
    /* Resistances Section */
    .char-res-header {
      color: #888;
      font-size: clamp(10px, 0.9vw, 14px);
      text-transform: uppercase;
      letter-spacing: clamp(1px, 0.15vw, 3px);
      text-align: center;
      padding: clamp(6px, 0.6vw, 10px) 0;
      border-top: 1px solid #2a2a30;
      border-bottom: 1px solid #2a2a30;
      margin-bottom: clamp(6px, 0.6vw, 10px);
    }
    
    .char-res-grid {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: clamp(4px, 0.5vw, 8px);
    }
    
    .char-res-box {
      display: flex;
      align-items: center;
      gap: clamp(6px, 0.6vw, 10px);
      background: linear-gradient(90deg, #1a1a20 0%, #141418 100%);
      border: 1px solid #2a2a30;
      border-radius: 6px;
      padding: clamp(6px, 0.7vw, 10px) clamp(8px, 0.8vw, 12px);
    }
    
    .char-res-icon {
      width: clamp(26px, 2.4vw, 36px);
      height: clamp(26px, 2.4vw, 36px);
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: clamp(12px, 1.1vw, 18px);
    }
    
    .char-res-box.fire .char-res-icon { background: linear-gradient(135deg, #803020 0%, #401810 100%); border: 1px solid #a04030; }
    .char-res-box.cold .char-res-icon { background: linear-gradient(135deg, #204080 0%, #102040 100%); border: 1px solid #3060a0; }
    .char-res-box.lightning .char-res-icon { background: linear-gradient(135deg, #806020 0%, #403010 100%); border: 1px solid #a08030; }
    .char-res-box.nature .char-res-icon { background: linear-gradient(135deg, #208040 0%, #104020 100%); border: 1px solid #30a050; }
    
    .char-res-info {
      flex: 1;
    }
    
    .char-res-label {
      color: #888;
      font-size: clamp(9px, 0.8vw, 12px);
      text-transform: uppercase;
    }
    
    .char-res-value {
      font-size: clamp(13px, 1.2vw, 18px);
      font-weight: 600;
    }
    
    .char-res-box.fire .char-res-value { color: #d88866; }
    .char-res-box.cold .char-res-value { color: #77aacc; }
    .char-res-box.lightning .char-res-value { color: #ccbb77; }
    .char-res-box.nature .char-res-value { color: #77aa77; }
    
    .char-res-uncapped {
      color: #666;
      font-size: clamp(9px, 0.8vw, 12px);
    }
    
    /* On-Hit Stats */
    .char-onhit-row {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: clamp(4px, 0.5vw, 8px);
      margin-top: clamp(8px, 0.8vw, 12px);
      padding-top: clamp(8px, 0.8vw, 12px);
      border-top: 1px solid #2a2a30;
    }
    
    .char-onhit-box {
      display: flex;
      align-items: center;
      gap: clamp(4px, 0.5vw, 8px);
      padding: clamp(6px, 0.6vw, 10px) clamp(8px, 0.8vw, 12px);
      background: rgba(20,20,25,0.8);
      border-radius: 6px;
    }
    
    .char-onhit-icon {
      font-size: clamp(12px, 1.1vw, 16px);
    }
    
    .char-onhit-label {
      color: #777;
      font-size: clamp(8px, 0.6vw, 10px);
    }
    
    .char-onhit-value {
      color: #aaa;
      font-size: clamp(10px, 0.9vw, 14px);
      font-weight: 500;
    }
    
    /* Level Badge */
    .char-level-badge {
      margin-top: clamp(8px, 0.9vw, 12px);
      padding: clamp(6px, 0.6vw, 10px) clamp(10px, 1vw, 16px);
      background: linear-gradient(90deg, #2a5030 0%, #3a6040 50%, #2a5030 100%);
      border: 1px solid #4a8050;
      border-radius: 4px;
      color: #8f8;
      font-size: 14px;
      font-weight: 600;
      text-align: center;
      text-transform: uppercase;
      letter-spacing: 2px;
    }
    
    /* Character Name and Level */
    .char-name {
      color: #d4af37;
      font-size: 18px;
      font-weight: 600;
      margin-bottom: 4px;
    }
    
    .char-level-info {
      color: #888;
      font-size: 14px;
    }
    
    .char-level-info span {
      color: #aaa;
      font-weight: 500;
    }
    
    /* Aspect Codex Panel (A key) */
    /* Aspect Codex Panel */
    .aspect-panel {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%) scale(0.95);
      width: clamp(600px, 55vw, 850px);
      max-height: 85vh;
      background: linear-gradient(180deg, #1a1a1f 0%, #0d0d10 100%);
      border: 2px solid #3a3530;
      border-radius: 8px;
      z-index: 2000;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.15s, transform 0.15s;
      box-shadow: 0 0 60px rgba(0,0,0,0.8), inset 0 0 30px rgba(0,0,0,0.5);
      display: flex;
      flex-direction: column;
    }
    .aspect-panel.visible {
      opacity: 1;
      pointer-events: auto;
      transform: translate(-50%, -50%) scale(1);
    }
    .aspect-panel-header {
      background: linear-gradient(180deg, #1a1614 0%, #0f0d0b 100%);
      padding: 0;
      border-bottom: 1px solid #3a3530;
      position: relative;
    }
    .aspect-panel-title {
      color: #c9a050;
      font-size: 16px;
      font-weight: 500;
      text-transform: uppercase;
      letter-spacing: 2px;
      padding: 12px 20px;
      text-align: center;
    }
    .aspect-panel-close {
      position: absolute;
      right: 12px;
      top: 12px;
      width: 28px;
      height: 28px;
      background: #8b0000;
      border: 1px solid #aa2020;
      border-radius: 4px;
      color: #fff;
      cursor: pointer;
      font-size: 14px;
    }
    .aspect-panel-close:hover { background: #aa2020; }
    
    /* Category tabs */
    .aspect-tabs {
      display: flex;
      justify-content: center;
      gap: 4px;
      padding: 8px 15px;
      background: #0a0908;
      border-bottom: 1px solid #2a2520;
    }
    .aspect-tab {
      padding: 8px 16px;
      background: transparent;
      border: 1px solid transparent;
      border-radius: 3px;
      color: #666;
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 1px;
      cursor: pointer;
      transition: all 0.15s;
    }
    .aspect-tab:hover { color: #999; background: rgba(255,255,255,0.03); }
    .aspect-tab.active {
      background: linear-gradient(180deg, #8b2020 0%, #6b1515 100%);
      border-color: #aa3030;
      color: #fff;
    }
    
    .aspect-panel-body {
      display: flex;
      flex: 1;
      overflow: hidden;
      background: linear-gradient(180deg, #0d0b0a 0%, #080706 100%);
    }
    
    /* Active Aspects Section */
    .active-aspects-section {
      background: linear-gradient(180deg, #151210 0%, #0d0b0a 100%);
      border-bottom: 1px solid #2a2520;
      padding: 12px 16px;
    }
    
    .active-aspects-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 10px;
    }
    
    .active-aspects-title {
      font-size: 12px;
      font-weight: 600;
      color: #c9a050;
      text-transform: uppercase;
      letter-spacing: 1px;
    }
    
    .active-aspects-count {
      font-size: 11px;
      color: #666;
    }
    
    .active-aspects-slots {
      display: flex;
      gap: 10px;
      justify-content: center;
    }
    
    .active-aspect-slot {
      width: 56px;
      height: 56px;
      background: linear-gradient(180deg, #1a1815 0%, #0f0d0b 100%);
      border: 2px solid #3a3530;
      border-radius: 6px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: all 0.15s;
      position: relative;
    }
    
    .active-aspect-slot:hover:not(.locked) {
      border-color: #5a5040;
      transform: scale(1.05);
    }
    
    .active-aspect-slot.locked {
      opacity: 0.4;
      cursor: not-allowed;
    }
    
    .active-aspect-slot.locked::after {
      content: '🔒';
      font-size: 16px;
    }
    
    .active-aspect-slot.filled {
      border-color: #c9a050;
      box-shadow: 0 0 8px rgba(201,160,80,0.3), inset 0 0 10px rgba(201,160,80,0.1);
    }
    
    .active-aspect-slot .slot-icon {
      font-size: 24px;
    }
    
    .active-aspect-slot.empty:not(.locked)::after {
      content: '+';
      font-size: 20px;
      color: #444;
    }
    
    .active-aspect-slot.empty:not(.locked):hover::after {
      color: #666;
    }

    /* Left sidebar with rarity counts */
    .aspect-sidebar {
      width: 140px;
      background: rgba(0,0,0,0.4);
      border-right: 1px solid #2a2520;
      padding: 12px 10px;
      display: flex;
      flex-direction: column;
      gap: 4px;
    }
    .aspect-sidebar-section {
      margin-bottom: 8px;
    }
    .aspect-sidebar-label {
      color: #555;
      font-size: 9px;
      text-transform: uppercase;
      letter-spacing: 1px;
      padding: 4px 8px;
    }
    .aspect-rarity-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 8px 10px;
      border-radius: 3px;
      margin: 2px 0;
      cursor: pointer;
      transition: background 0.1s;
    }
    .aspect-rarity-row:hover { background: rgba(255,255,255,0.05); }
    .aspect-rarity-row.active { background: rgba(201,160,80,0.15); }
    .aspect-rarity-name { font-size: 12px; }
    .aspect-rarity-name.common { color: #888; }
    .aspect-rarity-name.rare { color: #6699ff; }
    .aspect-rarity-name.legendary { color: #ff9944; }
    .aspect-rarity-count {
      font-size: 11px;
      color: #555;
    }
    .aspect-rarity-row.active .aspect-rarity-count { color: #c9a050; }
    
    .aspect-myclass-toggle {
      margin-top: auto;
      padding: 10px 8px;
      border-top: 1px solid #2a2520;
      display: flex;
      align-items: center;
      gap: 6px;
      color: #666;
      font-size: 10px;
      cursor: pointer;
    }
    .aspect-myclass-toggle input { 
      accent-color: #8b2020;
      width: 14px;
      height: 14px;
    }
    .aspect-myclass-toggle:hover { color: #999; }
    
    /* Grid container */
    .aspect-grid-container {
      flex: 1;
      padding: 15px;
      overflow-y: auto;
      background: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><rect fill="%23080706" width="100" height="100"/><circle cx="50" cy="50" r="40" fill="none" stroke="%23151210" stroke-width="0.5"/></svg>');
      background-size: 200px 200px;
      background-position: center;
    }
    .aspect-grid-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 12px;
      padding-bottom: 8px;
      border-bottom: 1px solid #2a2520;
    }
    .aspect-grid-title {
      color: #888;
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 1px;
    }
    .aspect-grid-count {
      color: #c9a050;
      font-size: 12px;
    }
    .aspect-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(60px, 1fr));
      gap: 8px;
    }
    .aspect-slot {
      width: 60px;
      height: 60px;
      background: linear-gradient(180deg, #1a1816 0%, #0f0d0c 100%);
      border: 2px solid #2a2520;
      border-radius: 4px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      position: relative;
      transition: all 0.15s;
    }
    .aspect-slot:hover { 
      border-color: #4a4540; 
      transform: scale(1.08);
      z-index: 1;
    }
    .aspect-slot.locked {
      opacity: 0.35;
      cursor: default;
    }
    .aspect-slot.locked:hover { transform: none; border-color: #2a2520; }
    .aspect-slot.locked::after {
      content: '';
      position: absolute;
      inset: 0;
      background: radial-gradient(circle at center, transparent 30%, rgba(0,0,0,0.5) 100%);
    }
    .aspect-slot.wrong-class {
      opacity: 0.5;
      border-color: #4a3030 !important;
    }
    .aspect-slot.wrong-class::before {
      content: '🚫';
      position: absolute;
      top: -5px;
      right: -5px;
      font-size: 12px;
      z-index: 2;
    }
    .aspect-slot.selected { 
      border-color: #c9a050; 
      box-shadow: 0 0 15px rgba(201,160,80,0.4);
    }
    .aspect-slot .aspect-icon { font-size: 28px; filter: drop-shadow(0 2px 3px rgba(0,0,0,0.5)); }
    .aspect-slot .aspect-icon img { width: 28px; height: 28px; object-fit: contain; }
    .aspect-slot.common { border-color: #3a3835; }
    .aspect-slot.common.unlocked { border-color: #666; }
    .aspect-slot.rare { border-color: #2a4080; }
    .aspect-slot.rare.unlocked { 
      border-color: #5588cc; 
      box-shadow: inset 0 0 15px rgba(68,136,255,0.15);
    }
    .aspect-slot.legendary { border-color: #804020; }
    .aspect-slot.legendary.unlocked { 
      border-color: #cc7733; 
      box-shadow: inset 0 0 15px rgba(255,136,68,0.2);
    }
    .aspect-slot.active {
      box-shadow: 0 0 12px rgba(100,255,100,0.4), inset 0 0 15px rgba(100,255,100,0.15) !important;
    }
    .aspect-active-badge {
      position: absolute;
      top: -4px;
      right: -4px;
      width: 16px;
      height: 16px;
      background: #2a5a2a;
      border: 1px solid #4a8a4a;
      border-radius: 50%;
      color: #8f8;
      font-size: 10px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    /* Detail panel */
    .aspect-detail {
      width: 260px;
      background: linear-gradient(180deg, #141210 0%, #0a0908 100%);
      border-left: 1px solid #2a2520;
      padding: 0;
      display: flex;
      flex-direction: column;
    }
    .aspect-detail-empty {
      color: #444;
      text-align: center;
      margin-top: 60px;
      font-size: 12px;
      font-style: italic;
    }
    .aspect-detail-content {
      padding: 20px 16px;
      flex: 1;
      display: flex;
      flex-direction: column;
    }
    .aspect-detail-icon {
      font-size: 52px;
      text-align: center;
      margin-bottom: 15px;
      filter: drop-shadow(0 3px 6px rgba(0,0,0,0.6));
    }
    .aspect-detail-icon img { width: 52px; height: 52px; object-fit: contain; }
    .aspect-detail-name {
      font-size: 15px;
      font-weight: 500;
      margin-bottom: 8px;
      text-align: center;
      line-height: 1.3;
    }
    .aspect-detail-name.common { color: #aaa; }
    .aspect-detail-name.rare { color: #7799dd; }
    .aspect-detail-name.legendary { color: #dd9955; }
    .aspect-detail-tooltip {
      color: #8a8070;
      font-size: 11px;
      font-style: italic;
      text-align: center;
      margin-bottom: 8px;
      padding: 0 10px;
    }
    .aspect-detail-divider {
      width: 60%;
      height: 1px;
      background: linear-gradient(90deg, transparent 0%, #3a3530 50%, transparent 100%);
      margin: 12px auto;
    }
    .aspect-detail-desc {
      color: #999;
      font-size: 12px;
      line-height: 1.6;
      text-align: center;
      flex: 1;
      padding: 0 5px;
    }
    .aspect-detail-desc .highlight {
      color: #c9a050;
    }
    .aspect-detail-unlock {
      margin-top: 15px;
      padding: 12px;
      background: rgba(0,0,0,0.3);
      border: 1px solid #2a2520;
      border-radius: 4px;
      text-align: center;
    }
    .aspect-detail-unlock-label {
      color: #555;
      font-size: 9px;
      text-transform: uppercase;
      letter-spacing: 1px;
      margin-bottom: 4px;
    }
    .aspect-detail-unlock-text {
      color: #888;
      font-size: 11px;
    }
    .aspect-detail-unlock-text.unlocked { color: #6a6; }
    
    .aspect-equip-btn {
      margin-top: 12px;
      padding: 8px 20px;
      border: none;
      border-radius: 4px;
      font-size: 12px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.15s;
      text-transform: uppercase;
      letter-spacing: 1px;
    }
    .aspect-equip-btn.equip {
      background: linear-gradient(180deg, #2a5a2a 0%, #1a3a1a 100%);
      color: #8f8;
      border: 1px solid #3a6a3a;
    }
    .aspect-equip-btn.equip:hover {
      background: linear-gradient(180deg, #3a6a3a 0%, #2a4a2a 100%);
      transform: scale(1.02);
    }
    .aspect-equip-btn.unequip {
      background: linear-gradient(180deg, #5a2a2a 0%, #3a1a1a 100%);
      color: #f88;
      border: 1px solid #6a3a3a;
    }
    .aspect-equip-btn.unequip:hover {
      background: linear-gradient(180deg, #6a3a3a 0%, #4a2a2a 100%);
      transform: scale(1.02);
    }
    
    .aspect-detail-class-badge {
      margin-top: 12px;
      padding: 6px 12px;
      background: rgba(139,32,32,0.2);
      border: 1px solid #5a2020;
      border-radius: 3px;
      color: #aa6666;
      font-size: 10px;
      text-transform: uppercase;
      letter-spacing: 1px;
      text-align: center;
    }
    
    /* Info section at bottom of detail */
    .aspect-info-section {
      margin-top: auto;
      padding: 12px;
      background: rgba(0,0,0,0.3);
      border-top: 1px solid #2a2520;
    }
    .aspect-info-title {
      color: #666;
      font-size: 10px;
      text-transform: uppercase;
      letter-spacing: 1px;
      margin-bottom: 8px;
    }
    .aspect-info-text {
      color: #555;
      font-size: 10px;
      line-height: 1.5;
    }
    
    /* Aspect Discovery Popup */
    .aspect-discovery {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%) scale(0.8);
      background: linear-gradient(180deg, #1a1a22 0%, #0a0a10 100%);
      border: 3px solid #d4af37;
      border-radius: 12px;
      padding: 30px 50px;
      z-index: 10000;
      text-align: center;
      opacity: 0;
      pointer-events: none;
      transition: all 0.3s ease-out;
      box-shadow: 0 0 80px rgba(212,175,55,0.5), 0 0 200px rgba(212,175,55,0.2);
    }
    .aspect-discovery.visible {
      opacity: 1;
      pointer-events: auto;
      transform: translate(-50%, -50%) scale(1);
    }
    .aspect-discovery-title {
      color: #d4af37;
      font-size: 14px;
      text-transform: uppercase;
      letter-spacing: 3px;
      margin-bottom: 15px;
    }
    .aspect-discovery-icon {
      font-size: 64px;
      margin: 15px 0;
      animation: aspectPulse 1s ease-in-out infinite;
    }
    .aspect-discovery-icon img { width: 64px; height: 64px; object-fit: contain; }
    .aspect-discovery-name {
      font-size: 24px;
      font-weight: 600;
      margin-bottom: 10px;
    }
    .aspect-discovery-name.common { color: #ccc; }
    .aspect-discovery-name.rare { color: #66aaff; }
    .aspect-discovery-name.legendary { color: #ffaa66; }
    .aspect-discovery-desc {
      color: #999;
      font-size: 14px;
      margin-bottom: 12px;
      max-width: 300px;
    }
    .aspect-discovery-note {
      color: #6c6;
      font-size: 12px;
      margin-bottom: 18px;
      padding: 8px 12px;
      background: rgba(68, 170, 68, 0.15);
      border: 1px solid #4a4;
      border-radius: 4px;
    }
    .aspect-discovery-close {
      background: linear-gradient(180deg, #3a3530 0%, #2a2520 100%);
      border: 1px solid #d4af37;
      border-radius: 4px;
      color: #d4af37;
      padding: 10px 30px;
      cursor: pointer;
      font-size: 14px;
      text-transform: uppercase;
      letter-spacing: 1px;
    }
    .aspect-discovery-close:hover {
      background: linear-gradient(180deg, #4a4540 0%, #3a3530 100%);
    }
    @keyframes aspectPulse {
      0%, 100% { transform: scale(1); filter: brightness(1); }
      50% { transform: scale(1.1); filter: brightness(1.3); }
    }
    
    /* Resistance Tooltip */
    .res-tooltip {
      position: fixed;
      z-index: 10002;
      background: linear-gradient(180deg, #1a1a20 0%, #0d0d12 100%);
      border: 1px solid #4a4540;
      border-radius: 6px;
      padding: 14px 16px;
      max-width: 280px;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.15s;
      box-shadow: 0 4px 20px rgba(0,0,0,0.6);
    }
    
    .res-tooltip.visible {
      opacity: 1;
    }
    
    .res-tooltip-title {
      color: #d4af37;
      font-size: 15px;
      font-weight: 600;
      margin-bottom: 8px;
      padding-bottom: 6px;
      border-bottom: 1px solid #3a3530;
    }
    
    .res-tooltip-desc {
      color: #bbb;
      font-size: 13px;
      line-height: 1.5;
      margin-bottom: 10px;
    }
    
    .res-tooltip-cap {
      color: #888;
      font-size: 12px;
      line-height: 1.4;
      font-style: italic;
      padding-top: 8px;
      border-top: 1px solid #2a2520;
    }
    
    /* Shard Mechanic Tooltip (Rift/Echo) */
    #shardTooltip {
      display: none;
      position: fixed;
      z-index: 100000;
      background: linear-gradient(180deg, #1a1a22 0%, #0d0d14 100%);
      border: 2px solid #4a4550;
      border-radius: 8px;
      padding: 14px 18px;
      min-width: 220px;
      max-width: 280px;
      box-shadow: 0 6px 30px rgba(0,0,0,0.8);
      pointer-events: none;
    }
    .shard-tooltip-title {
      font-size: 14px;
      font-weight: 600;
      margin-bottom: 10px;
      padding-bottom: 8px;
      border-bottom: 1px solid #3a3540;
    }
    .shard-tooltip-title.rift { color: #4488cc; }
    .shard-tooltip-title.echo { color: #9966cc; }
    .shard-tooltip-section {
      margin-bottom: 10px;
    }
    .shard-tooltip-label {
      color: #888;
      font-size: 10px;
      text-transform: uppercase;
      letter-spacing: 1px;
      margin-bottom: 4px;
    }
    .shard-tooltip-text {
      color: #ccc;
      font-size: 12px;
      line-height: 1.5;
    }
    .shard-tooltip-aspect {
      margin-top: 10px;
      padding: 8px 10px;
      background: rgba(212, 175, 55, 0.1);
      border: 1px solid rgba(212, 175, 55, 0.3);
      border-radius: 4px;
    }
    .shard-tooltip-aspect-title {
      color: #d4af37;
      font-size: 10px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 1px;
      margin-bottom: 4px;
    }
    .shard-tooltip-aspect-text {
      color: #c4a77d;
      font-size: 11px;
      line-height: 1.4;
    }
    .shard-tooltip-req {
      color: #888;
      font-size: 10px;
      font-style: italic;
      margin-top: 4px;
    }
    
    /* Bar Tooltip (Health/Mana/Shield breakdown) */
    #barTooltip {
      position: fixed;
      z-index: 10003;
      background: linear-gradient(180deg, #1a1a22 0%, #0d0d14 100%);
      border: 1px solid #4a4550;
      border-radius: 8px;
      padding: 12px 16px;
      min-width: 180px;
      max-width: 260px;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.12s;
      box-shadow: 0 4px 24px rgba(0,0,0,0.7);
    }
    
    #barTooltip.visible {
      opacity: 1;
    }
    
    .bar-tooltip-title {
      font-size: 14px;
      font-weight: 600;
      margin-bottom: 10px;
      padding-bottom: 6px;
      border-bottom: 1px solid #3a3540;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    
    .bar-tooltip-title .current {
      font-size: 13px;
      font-weight: 400;
    }
    
    .bar-tooltip-section {
      margin-bottom: 8px;
    }
    
    .bar-tooltip-section:last-child {
      margin-bottom: 0;
    }
    
    .bar-tooltip-section-title {
      font-size: 11px;
      color: #888;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      margin-bottom: 4px;
    }
    
    .bar-tooltip-row {
      display: flex;
      justify-content: space-between;
      font-size: 12px;
      padding: 2px 0;
    }
    
    .bar-tooltip-row .label {
      color: #999;
    }
    
    .bar-tooltip-row .value {
      font-weight: 500;
    }
    
    .bar-tooltip-row.total {
      border-top: 1px solid #3a3540;
      margin-top: 4px;
      padding-top: 6px;
      font-weight: 600;
    }
    
    .bar-tooltip-status {
      font-size: 11px;
      color: #888;
      font-style: italic;
      margin-top: 8px;
      padding-top: 6px;
      border-top: 1px solid #2a2530;
    }
    
    /* Mini Stats Grid */
    .char-stats-mini-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 6px;
      margin-bottom: 10px;
    }
    
    .char-stat-mini {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 6px 10px;
      background: linear-gradient(180deg, #1e1e24 0%, #141418 100%);
      border: 1px solid #2a2a30;
      border-radius: 4px;
    }
    
    .char-stat-mini-label {
      color: #888;
      font-size: 13px;
    }
    
    .char-stat-mini-value {
      color: #ccc;
      font-size: 14px;
      font-weight: 500;
    }
    
    /* ============ SHOP PANEL ============ */
    #shopPanel {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0,0,0,0.95);
      z-index: 3000;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.15s;
      display: flex;
      flex-direction: column;
    }
    
    #shopPanel.visible {
      opacity: 1;
      pointer-events: auto;
    }
    
    .shop-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px 24px;
      background: linear-gradient(180deg, #1a1510 0%, #0d0a08 100%);
      border-bottom: 2px solid #3a3020;
    }
    
    .shop-header-left {
      display: flex;
      gap: 8px;
    }
    
    .shop-header-btn {
      padding: 10px 28px;
      font-size: 14px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 2px;
      border: none;
      cursor: pointer;
      transition: all 0.2s;
    }
    
    .shop-header-btn.play {
      background: transparent;
      color: #888;
    }
    
    .shop-header-btn.play:hover {
      color: #ccc;
    }
    
    .shop-header-btn.shop-active {
      background: linear-gradient(180deg, #8B0000 0%, #5a0000 100%);
      color: #fff;
      border-radius: 4px;
    }
    
    .shop-header-right {
      display: flex;
      gap: 4px;
    }
    
    .shop-tab {
      padding: 8px 20px;
      font-size: 12px;
      font-weight: 500;
      text-transform: uppercase;
      letter-spacing: 1px;
      background: transparent;
      border: 1px solid #3a3020;
      color: #888;
      cursor: pointer;
      transition: all 0.2s;
    }
    
    .shop-tab:first-child { border-radius: 4px 0 0 4px; }
    .shop-tab:last-child { border-radius: 0 4px 4px 0; }
    
    .shop-tab:hover {
      color: #ccc;
      border-color: #5a5040;
    }
    
    .shop-tab.active {
      background: linear-gradient(180deg, #c9a050 0%, #a08030 100%);
      color: #000;
      border-color: #c9a050;
    }
    
    .shop-close {
      position: absolute;
      top: 12px;
      right: 20px;
      width: 36px;
      height: 36px;
      background: #8B0000;
      border: 1px solid #aa2020;
      border-radius: 4px;
      color: #fff;
      font-size: 20px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    .shop-close:hover {
      background: #aa2020;
    }
    
    .shop-content {
      flex: 1;
      overflow-y: auto;
      padding: 30px 40px;
    }
    
    .shop-section-title {
      display: flex;
      align-items: center;
      gap: 12px;
      color: #c9a050;
      font-size: 18px;
      font-weight: 500;
      margin-bottom: 24px;
      padding-bottom: 12px;
      border-bottom: 1px solid #3a3020;
    }
    
    .shop-section-title::before {
      content: '⭐';
      font-size: 20px;
    }
    
    .shop-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
      gap: 20px;
      max-width: 1200px;
    }
    
    .shop-card {
      background: linear-gradient(180deg, #1a1510 0%, #0a0805 100%);
      border: 2px solid #3a3020;
      border-radius: 8px;
      overflow: hidden;
      cursor: pointer;
      transition: all 0.2s;
      position: relative;
    }
    
    .shop-card:hover {
      border-color: #c9a050;
      transform: translateY(-4px);
      box-shadow: 0 8px 24px rgba(0,0,0,0.5);
    }
    
    .shop-card.owned {
      border-color: #4a8050;
    }
    
    .shop-card.equipped {
      border-color: #50c060;
      box-shadow: 0 0 20px rgba(80,192,96,0.3);
    }
    
    .shop-card-image {
      width: 100%;
      aspect-ratio: 3/4;
      background: linear-gradient(180deg, #252015 0%, #151008 100%);
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
      overflow: hidden;
    }
    
    .shop-card-preview {
      width: 100%;
      height: 100%;
      position: relative;
    }
    
    .shop-card-badge {
      position: absolute;
      top: 8px;
      left: 8px;
      padding: 4px 8px;
      font-size: 10px;
      font-weight: 600;
      text-transform: uppercase;
      border-radius: 3px;
    }
    
    .shop-card-badge.owned {
      background: #2a5030;
      color: #8f8;
    }
    
    .shop-card-badge.equipped {
      background: #308040;
      color: #fff;
    }
    
    .shop-card-badge.new {
      background: #8B0000;
      color: #fff;
    }
    
    .shop-class-header {
      grid-column: 1 / -1;
      display: flex;
      align-items: center;
      gap: 10px;
      color: #c9a050;
      font-size: 16px;
      font-weight: 600;
      margin: 20px 0 10px 0;
      padding: 10px 0;
      border-bottom: 1px solid #3a3020;
    }
    
    .shop-class-header:first-child {
      margin-top: 0;
    }
    
    .shop-class-icon {
      font-size: 24px;
    }
    
    .current-class-badge {
      background: #308040;
      color: #fff;
      font-size: 10px;
      padding: 3px 8px;
      border-radius: 3px;
      margin-left: auto;
    }
    
    .shop-card.other-class {
      opacity: 0.6;
      border-color: #2a2520;
    }
    
    .shop-card.other-class:hover {
      opacity: 0.8;
      transform: translateY(-2px);
      border-color: #4a4030;
    }
    
    .shop-card-class-lock {
      position: absolute;
      bottom: 8px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0,0,0,0.8);
      color: #888;
      font-size: 10px;
      padding: 4px 10px;
      border-radius: 3px;
      white-space: nowrap;
    }
    
    .shop-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      background: #333 !important;
    }
    
    .shop-card-info {
      padding: 12px;
      text-align: center;
    }
    
    .shop-card-name {
      color: #e0d0b0;
      font-size: 13px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 1px;
      margin-bottom: 4px;
    }
    
    .shop-card-type {
      color: #888;
      font-size: 10px;
      text-transform: uppercase;
      letter-spacing: 1px;
    }
    
    .shop-card-price {
      margin-top: 8px;
      padding-top: 8px;
      border-top: 1px solid #2a2520;
      color: #c9a050;
      font-size: 14px;
      font-weight: 600;
    }
    
    .shop-card-price.free {
      color: #8f8;
    }
    
    .shop-card-actions {
      padding: 0 12px 12px;
      display: flex;
      gap: 8px;
    }
    
    .shop-btn {
      flex: 1;
      padding: 8px 12px;
      font-size: 11px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 1px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      transition: all 0.2s;
    }
    
    .shop-btn.buy {
      background: linear-gradient(180deg, #c9a050 0%, #a08030 100%);
      color: #000;
    }
    
    .shop-btn.buy:hover {
      background: linear-gradient(180deg, #d9b060 0%, #b09040 100%);
    }
    
    .shop-btn.buy:disabled {
      background: #333;
      color: #666;
      cursor: not-allowed;
    }
    
    .shop-btn.equip {
      background: linear-gradient(180deg, #308040 0%, #206030 100%);
      color: #fff;
    }
    
    .shop-btn.equip:hover {
      background: linear-gradient(180deg, #409050 0%, #307040 100%);
    }
    
    .shop-btn.unequip {
      background: linear-gradient(180deg, #604020 0%, #403010 100%);
      color: #ccc;
    }
    
    .shop-btn.unequip:hover {
      background: linear-gradient(180deg, #705030 0%, #504020 100%);
    }
    
    .shop-gold-display {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 8px 16px;
      background: rgba(30,25,15,0.8);
      border: 1px solid #3a3020;
      border-radius: 4px;
      color: #c9a050;
      font-size: 16px;
      font-weight: 600;
    }
    
    .shop-gold-display::before {
      content: '💰';
    }
    
    /* Add-Ons Tab Styles */
    .addon-card {
      display: flex;
      align-items: center;
      gap: 20px;
      background: linear-gradient(180deg, #2a2520 0%, #1e1a15 100%);
      border: 1px solid #3a3020;
      border-radius: 8px;
      padding: 20px;
      transition: all 0.2s;
      grid-column: 1 / -1;
      min-width: 400px;
    }
    
    .addon-card:hover {
      border-color: #5a5030;
    }
    
    .addon-card.maxed {
      opacity: 0.7;
      border-color: #308040;
    }
    
    .addon-card.coming-soon {
      opacity: 0.4;
      cursor: default;
    }
    
    .addon-icon {
      font-size: 40px;
      width: 60px;
      text-align: center;
      flex-shrink: 0;
    }
    
    .addon-info {
      flex: 1;
      min-width: 150px;
    }
    
    .addon-name {
      color: #e0d0b0;
      font-size: 16px;
      font-weight: 600;
      margin-bottom: 4px;
    }
    
    .addon-desc {
      color: #888;
      font-size: 12px;
      margin-bottom: 10px;
    }
    
    .addon-progress {
      width: 100%;
      max-width: 200px;
      height: 8px;
      background: #1a1510;
      border-radius: 4px;
      overflow: hidden;
      margin-bottom: 6px;
    }
    
    .addon-progress-bar {
      height: 100%;
      background: linear-gradient(90deg, #c9a050 0%, #a08030 100%);
      border-radius: 4px;
      transition: width 0.3s;
    }
    
    .addon-stats {
      color: #c9a050;
      font-size: 12px;
      font-weight: 600;
    }
    
    .addon-action {
      display: flex;
      flex-direction: column;
      align-items: center;
      flex-shrink: 0;
    }
    
    .addon-buy-btn {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 4px;
      padding: 12px 24px;
      background: linear-gradient(180deg, #c9a050 0%, #a08030 100%);
      border: none;
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.2s;
    }
    
    .addon-buy-btn:hover:not(:disabled) {
      background: linear-gradient(180deg, #d9b060 0%, #b09040 100%);
      transform: scale(1.05);
    }
    
    .addon-buy-btn:disabled {
      background: #333;
      opacity: 0.5;
      cursor: not-allowed;
    }
    
    .addon-cost {
      color: #000;
      font-size: 14px;
      font-weight: 600;
    }
    
    .addon-gain {
      color: #2a2010;
      font-size: 11px;
    }
    
    .addon-maxed {
      color: #8f8;
      font-size: 14px;
      font-weight: 600;
      padding: 12px 24px;
    }

    /* Responsive adjustments for smaller screens */
    @media (min-width: 2200px) {
      #inventoryPanel, #stashPanel {
        width: clamp(600px, 30vw, 800px);
      }
    }
    
    @media (max-width: 1200px) {
      .inv-main {
        height: clamp(160px, 24vh, 260px);
      }
      
      .inv-equipment-section {
        min-height: 140px;
        flex-direction: row;
      }
      
      .inv-paperdoll {
        width: clamp(90px, 9vw, 130px);
      }
      
      .equip-stats-panel {
        font-size: clamp(10px, 0.9vw, 14px);
      }
    }
    
    @media (max-width: 800px) {
      .currency-layout {
        grid-template-columns: 1fr;
      }
    }
    
    @media (max-width: 600px) {
      #inventoryPanel, #stashPanel {
        width: 95vw;
        left: 2.5vw !important;
        right: 2.5vw !important;
      }
      
      .stash-tabs {
        justify-content: center;
      }
      
      .stash-tab {
        padding: 4px 8px;
        font-size: 10px;
      }
    }
    
    /* Uncontrolled Core Confirmation Modal */
    .confirm-modal-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.85);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 10000;
      animation: fadeIn 0.2s;
    }
    
    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }
    
    /* Death Screen */
    .death-screen {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.85);
      display: none;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 15000;
    }
    
    .death-screen.visible {
      display: flex;
    }
    
    .death-title {
      font-size: 48px;
      font-weight: 700;
      color: #cc2222;
      text-shadow: 0 0 30px #cc2222, 0 0 60px #881111;
      margin-bottom: 20px;
      letter-spacing: 8px;
    }
    
    .death-report {
      background: linear-gradient(180deg, #1a1210 0%, #0f0a08 100%);
      border: 2px solid #4a2020;
      border-radius: 8px;
      padding: 24px 40px;
      text-align: center;
      min-width: 320px;
    }
    
    .death-killer {
      font-size: 18px;
      color: #cc8866;
      margin-bottom: 8px;
    }
    
    .death-damage {
      font-size: 14px;
      color: #888;
      margin-bottom: 16px;
    }
    
    .death-penalty {
      font-size: 13px;
      color: #cc6644;
      margin-bottom: 20px;
      padding: 8px 12px;
      background: rgba(100, 30, 20, 0.3);
      border-radius: 4px;
    }
    
    .death-timer {
      font-size: 32px;
      font-weight: 700;
      color: #fff;
      margin-bottom: 8px;
    }
    
    .death-timer-label {
      font-size: 12px;
      color: #666;
      text-transform: uppercase;
      letter-spacing: 2px;
    }

    .confirm-modal {
      background: linear-gradient(180deg, #1a1512 0%, #0d0a08 100%);
      border: 2px solid #8b0000;
      border-radius: 8px;
      padding: 24px 32px;
      max-width: 380px;
      text-align: center;
      box-shadow: 0 0 40px rgba(139, 0, 0, 0.5), inset 0 0 20px rgba(139, 0, 0, 0.1);
      animation: modalPop 0.2s ease-out;
    }
    
    @keyframes modalPop {
      from { transform: scale(0.9); opacity: 0; }
      to { transform: scale(1); opacity: 1; }
    }
    
    /* Dungeon Selector Modal */
    .dungeon-modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0,0,0,0.9);
      z-index: 12000;
      justify-content: center;
      align-items: center;
    }
    
    .dungeon-modal.visible { display: flex; }
    
    .dungeon-content {
      background: linear-gradient(180deg, #1a1410 0%, #0a0806 100%);
      border: 2px solid #c9a050;
      border-radius: 6px;
      width: 800px;
      max-width: 90vw;
      max-height: 80vh;
      overflow: hidden;
      box-shadow: 0 0 60px rgba(200,160,80,0.3);
    }
    
    .dungeon-header {
      background: linear-gradient(180deg, #2a2015 0%, #1a1410 100%);
      padding: 10px 16px;
      border-bottom: 2px solid #3a3020;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    
    .dungeon-title {
      font-size: 16px;
      font-weight: 700;
      color: #c9a050;
      letter-spacing: 2px;
    }
    
    .dungeon-close {
      background: none;
      border: none;
      color: #666;
      font-size: 20px;
      cursor: pointer;
      padding: 0 5px;
    }
    
    .dungeon-close:hover { color: #fff; }
    
    .dungeon-current {
      text-align: center;
      padding: 8px;
      background: rgba(0,0,0,0.3);
      color: #888;
      font-size: 12px;
      border-bottom: 1px solid #2a2018;
    }
    
    .dungeon-current span {
      color: #c9a050;
      font-weight: 600;
    }
    
    .dungeon-grid {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 10px;
      padding: 14px 16px;
      max-height: 55vh;
      overflow-y: auto;
    }
    
    .dungeon-option {
      background: linear-gradient(180deg, #1a1510 0%, #0f0c08 100%);
      border: 2px solid #2a2018;
      border-radius: 5px;
      padding: 12px;
      cursor: pointer;
      transition: all 0.2s;
      position: relative;
    }
    
    .dungeon-option:hover:not(.locked):not(.selected) {
      border-color: #4a4030;
      background: linear-gradient(180deg, #252015 0%, #1a1410 100%);
      transform: translateY(-2px);
    }
    
    .dungeon-option.selected {
      border-color: #c9a050;
      background: linear-gradient(180deg, #2a2010 0%, #1a1408 100%);
      box-shadow: 0 0 20px rgba(200,160,80,0.2);
    }
    
    .dungeon-option.locked {
      opacity: 0.5;
      cursor: not-allowed;
    }
    
    .dungeon-option-header {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-bottom: 4px;
    }
    
    .dungeon-option-icon {
      font-size: 22px;
      width: 30px;
      text-align: center;
    }
    
    .dungeon-option-name {
      font-size: 15px;
      font-weight: 700;
      color: #ddd;
    }
    
    .dungeon-option-subtitle {
      font-size: 10px;
      color: #666;
      margin-bottom: 6px;
      font-style: italic;
    }
    
    .dungeon-option-stats {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 2px;
      font-size: 10px;
    }
    
    .dungeon-stat {
      color: #888;
    }
    
    .dungeon-stat-value {
      color: #aaa;
      font-weight: 600;
    }
    
    .dungeon-stat-value.good { color: #8c8; }
    .dungeon-stat-value.danger { color: #c88; }
    
    .dungeon-option-aspect {
      margin-top: 8px;
      padding: 6px 8px;
      background: rgba(212, 175, 55, 0.1);
      border: 1px solid rgba(212, 175, 55, 0.3);
      border-radius: 3px;
      font-size: 9px;
      color: #d4af37;
      text-align: center;
    }
    
    .dungeon-unlock-req {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0,0,0,0.9);
      padding: 6px 12px;
      border-radius: 4px;
      border: 1px solid #444;
      color: #c44;
      font-size: 11px;
      font-weight: 600;
      white-space: nowrap;
    }
    
    .dungeon-footer {
      padding: 8px 16px;
      background: rgba(0,0,0,0.3);
      border-top: 1px solid #2a2018;
    }
    
    .dungeon-hint {
      font-size: 10px;
      color: #666;
      text-align: center;
      margin: 1px 0;
    }
    
    /* Dungeon Modal Tabs */
    .dungeon-tabs {
      display: flex;
      gap: 4px;
    }
    
    .dungeon-tab {
      background: rgba(0,0,0,0.3);
      border: 1px solid #3a3020;
      border-bottom: none;
      padding: 10px 20px;
      color: #888;
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      border-radius: 4px 4px 0 0;
      transition: all 0.2s;
    }
    
    .dungeon-tab:hover:not(.active) {
      background: rgba(60,50,30,0.3);
      color: #aaa;
    }
    
    .dungeon-tab.active {
      background: linear-gradient(180deg, #2a2015 0%, #1a1410 100%);
      border-color: #c9a050;
      color: #c9a050;
    }
    
    /* Greater Rifts tab - Purple theme */
    .dungeon-tab.gr-tab {
      border-color: #5a3080;
    }
    .dungeon-tab.gr-tab:hover:not(.active) {
      background: rgba(80,40,120,0.3);
      color: #b080d0;
    }
    .dungeon-tab.gr-tab.active {
      background: linear-gradient(180deg, #2a1530 0%, #1a0c20 100%);
      border-color: #a060d0;
      color: #c080f0;
    }
    
    .dungeon-tab-content {
      display: none;
    }
    
    .dungeon-tab-content.active {
      display: block;
    }
    
    /* Shards Tab Styles */
    .shards-intro {
      padding: 12px 20px;
      background: rgba(0,0,0,0.3);
      border-bottom: 1px solid #2a2018;
    }
    
    .shards-intro-text {
      font-size: 11px;
      color: #888;
      text-align: center;
      line-height: 1.4;
    }
    
    .shard-mechanics-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 14px;
      padding: 16px 20px;
    }
    
    .shard-mechanic {
      background: linear-gradient(180deg, #1a1510 0%, #0f0c08 100%);
      border: 2px solid #2a2018;
      border-radius: 8px;
      padding: 12px;
      text-align: center;
      position: relative;
      transition: all 0.2s;
      min-height: 300px;
      display: flex;
      flex-direction: column;
    }
    
    .shard-mechanic:not(.locked):hover {
      border-color: #4a4030;
      transform: translateY(-2px);
    }
    
    .shard-mechanic.locked {
      opacity: 0.6;
    }
    
    .shard-mechanic-header {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 6px;
      margin-bottom: 4px;
    }
    
    .shard-icon {
      font-size: 20px;
    }
    
    .shard-mechanic-name {
      font-size: 13px;
      font-weight: 700;
      color: #c9a050;
    }
    
    .shard-mechanic-desc {
      font-size: 9px;
      color: #666;
      font-style: italic;
      margin-bottom: 6px;
      min-height: 24px;
    }
    
    .shard-gate-visual {
      margin: 8px 0;
      flex-shrink: 0;
    }
    
    .shard-gate-frame {
      background: linear-gradient(180deg, #0a0806 0%, #151210 100%);
      border: 2px solid #3a3020;
      border-radius: 6px;
      padding: 12px 8px;
      position: relative;
    }
    
    .shard-gate-frame::before {
      content: '';
      position: absolute;
      inset: 3px;
      border: 1px solid #2a2018;
      border-radius: 3px;
      pointer-events: none;
    }
    
    .shard-gate-frame.locked {
      opacity: 0.5;
    }
    
    .shard-count-display {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 2px;
    }
    
    .shard-count {
      font-size: 24px;
      font-weight: 700;
      color: #8af;
    }
    
    .shard-label {
      font-size: 9px;
      color: #666;
      text-transform: uppercase;
      letter-spacing: 1px;
    }
    
    .shard-tiers {
      display: flex;
      justify-content: center;
      gap: 6px;
      margin: 12px 0;
    }
    
    .shard-tier {
      background: rgba(0,0,0,0.4);
      border: 1px solid #3a3020;
      border-radius: 4px;
      padding: 6px 10px;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 2px;
      cursor: pointer;
      transition: all 0.2s;
    }
    
    .shard-tier.unlocked:hover {
      border-color: #c9a050;
      background: rgba(60,50,30,0.3);
    }
    
    .shard-tier.locked {
      opacity: 0.4;
      cursor: not-allowed;
    }
    
    .shard-tier-cost {
      font-size: 11px;
      color: #8af;
      font-weight: 600;
    }
    
    .shard-tier-level {
      font-size: 10px;
      color: #888;
    }
    
    .shard-traverse-btn {
      width: 100%;
      padding: 10px;
      background: linear-gradient(180deg, #3a3020 0%, #2a2015 100%);
      border: 2px solid #c9a050;
      border-radius: 4px;
      color: #c9a050;
      font-size: 14px;
      font-weight: 700;
      letter-spacing: 2px;
      cursor: pointer;
      transition: all 0.2s;
    }
    
    .shard-traverse-btn:hover {
      background: linear-gradient(180deg, #4a4030 0%, #3a3020 100%);
      box-shadow: 0 0 15px rgba(200,160,80,0.3);
    }
    
    .shard-traverse-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    
    .shard-locked-overlay {
      position: absolute;
      inset: 0;
      background: rgba(0,0,0,0.8);
      border-radius: 6px;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 4px;
    }
    
    .shard-locked-icon {
      font-size: 20px;
    }
    
    .shard-locked-text {
      color: #888;
      font-size: 12px;
      font-weight: 600;
    }
    
    .shard-locked-hint {
      color: #555;
      font-size: 9px;
      font-style: italic;
      padding: 0 10px;
      text-align: center;
    }
    
    /* Enhanced Shards Intro */
    .shards-intro-title {
      font-size: 14px;
      font-weight: 700;
      color: #c9a050;
      margin-bottom: 4px;
      text-align: center;
    }
    
    .shard-mechanic.rift-surge {
      grid-column: 1;
      border-color: #4488cc;
      box-shadow: 0 0 15px rgba(68, 136, 204, 0.2);
    }
    
    .shard-mechanic.rift-surge .shard-mechanic-desc {
      font-size: 10px;
      line-height: 1.3;
      font-style: normal;
      color: #888;
      margin-bottom: 6px;
    }
    
    .shard-mechanic.rift-surge .shard-icon {
      color: #4488cc;
    }
    
    .shard-mechanic.echo-domain {
      grid-column: 2;
      border-color: #9966cc;
      box-shadow: 0 0 15px rgba(153, 102, 204, 0.2);
    }
    
    .shard-mechanic.echo-domain .shard-mechanic-desc {
      font-size: 10px;
      line-height: 1.3;
      font-style: normal;
      color: #888;
      margin-bottom: 6px;
    }
    
    .shard-mechanic.echo-domain .shard-icon {
      color: #9966cc;
    }
    
    /* Greater Rift UI Overlay */
    .greater-rift-ui {
      position: fixed;
      top: 80px;
      right: 20px;
      display: none;
      flex-direction: column;
      width: 280px;
      background: linear-gradient(180deg, rgba(30, 15, 10, 0.95) 0%, rgba(20, 10, 5, 0.98) 100%);
      border: 2px solid #4a3020;
      border-radius: 4px;
      padding: 0;
      z-index: 1000;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.8);
      font-family: 'Inter', sans-serif;
    }
    
    .gr-objectives-header {
      background: linear-gradient(90deg, #3a2515 0%, #4a3020 50%, #3a2515 100%);
      padding: 8px 12px;
      border-bottom: 1px solid #5a4030;
      display: flex;
      align-items: center;
      gap: 6px;
    }
    
    .gr-objectives-title {
      font-size: 13px;
      font-weight: bold;
      color: #c0a080;
      letter-spacing: 2px;
      text-transform: uppercase;
    }
    
    .gr-objectives-body {
      padding: 12px 14px;
    }
    
    .gr-rift-name {
      font-size: 15px;
      color: #d4a520;
      font-weight: 600;
      margin-bottom: 12px;
    }
    
    .gr-objective-item {
      display: flex;
      align-items: flex-start;
      gap: 8px;
      margin-bottom: 8px;
      font-size: 13px;
      color: #b0a090;
    }
    
    .gr-objective-item.completed {
      color: #60a060;
    }
    
    .gr-objective-checkbox {
      width: 14px;
      height: 14px;
      border: 1px solid #6a5a40;
      background: #1a1008;
      margin-top: 2px;
      flex-shrink: 0;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    .gr-objective-checkbox.checked {
      background: #3a6030;
      border-color: #4a8040;
    }
    
    .gr-objective-checkbox.checked::after {
      content: '✓';
      color: #80ff80;
      font-size: 10px;
    }
    
    .gr-bonus-item {
      display: flex;
      align-items: flex-start;
      gap: 8px;
      margin-top: 10px;
      padding-top: 10px;
      border-top: 1px solid #3a2a1a;
    }
    
    .gr-bonus-icon {
      width: 18px;
      height: 18px;
      background: linear-gradient(135deg, #ffd700, #ff8800);
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 10px;
      flex-shrink: 0;
    }
    
    .gr-bonus-text {
      font-size: 12px;
      color: #d4a520;
      line-height: 1.4;
    }
    
    .gr-progress-section {
      padding: 10px 14px 14px;
      border-top: 1px solid #3a2a1a;
    }
    
    .gr-progress-label {
      font-size: 11px;
      color: #8a7a6a;
      margin-bottom: 6px;
      text-transform: uppercase;
      letter-spacing: 1px;
    }
    
    .gr-progress-container {
      width: 100%;
      height: 20px;
      background: linear-gradient(180deg, #0a0305 0%, #150810 50%, #0a0305 100%);
      border: 2px solid #3a2030;
      border-radius: 2px;
      position: relative;
      overflow: hidden;
      box-shadow: inset 0 2px 8px rgba(0,0,0,0.8);
    }
    
    .gr-progress-behind {
      position: absolute;
      height: 100%;
      background: linear-gradient(180deg, 
        #802020 0%, 
        #601818 20%, 
        #401010 50%, 
        #601818 80%, 
        #802020 100%);
      opacity: 0.8;
      left: 0;
      top: 0;
      width: 0%;
      z-index: 0;
    }
    
    .gr-progress-bar {
      height: 100%;
      background: linear-gradient(180deg, 
        #b060ff 0%, 
        #8040d0 20%, 
        #6030a0 50%, 
        #8040d0 80%, 
        #b060ff 100%);
      transition: width 0.3s ease;
      width: 0%;
      box-shadow: 0 0 12px rgba(160, 80, 255, 0.6), inset 0 1px 0 rgba(255,255,255,0.2);
      position: absolute;
      left: 0;
      top: 0;
      z-index: 1;
    }
    
    .gr-progress-bar::after {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: linear-gradient(90deg, 
        transparent 0%, 
        rgba(255,255,255,0.1) 50%, 
        transparent 100%);
      animation: progress-shimmer 2s ease-in-out infinite;
    }
    
    @keyframes progress-shimmer {
      0%, 100% { opacity: 0.3; }
      50% { opacity: 0.8; }
    }
    
    .gr-progress-bar.guardian {
      background: linear-gradient(180deg, 
        #ff8800 0%, 
        #ff5500 20%, 
        #cc3300 50%, 
        #ff5500 80%, 
        #ff8800 100%);
      box-shadow: 0 0 12px rgba(255, 100, 0, 0.6), inset 0 1px 0 rgba(255,255,255,0.2);
    }
    
    .gr-timer-marker {
      position: absolute;
      top: 0;
      height: 100%;
      width: 4px;
      background: linear-gradient(180deg, #fff 0%, #ffd700 50%, #fff 100%);
      box-shadow: 0 0 8px #ffd700, 0 0 4px #fff;
      transition: left 0.5s linear;
      z-index: 2;
    }
    
    .gr-timer-display {
      position: absolute;
      top: 50%;
      right: 8px;
      transform: translateY(-50%);
      font-size: 11px;
      font-weight: bold;
      color: #fff;
      text-shadow: 0 0 4px #000, 0 0 2px #000;
      font-family: monospace;
    }
    
    .gr-timer-display.urgent {
      color: #ff4444;
      animation: timer-pulse 0.5s ease-in-out infinite;
    }
    
    @keyframes timer-pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }
    
    /* Skill Upgrade Modal - D3 Gem Style */
    .skill-upgrade-modal {
      width: 360px;
      background: linear-gradient(180deg, #0a0608 0%, #12080c 50%, #0a0608 100%);
      border: 3px solid #3a2830;
      border-radius: 4px;
      box-shadow: 0 0 80px rgba(0, 0, 0, 0.9), 0 0 40px rgba(60, 30, 50, 0.5);
      overflow: hidden;
    }
    
    .skill-upgrade-header {
      background: linear-gradient(90deg, #1a0c10 0%, #2a1420 50%, #1a0c10 100%);
      padding: 10px;
      font-size: 13px;
      font-weight: bold;
      color: #c09080;
      letter-spacing: 3px;
      text-transform: uppercase;
      text-align: center;
      border-bottom: 1px solid #3a2830;
    }
    
    .skill-upgrade-body {
      padding: 20px;
      position: relative;
    }
    
    /* Center display area */
    .skill-upgrade-display {
      text-align: center;
      margin-bottom: 16px;
      position: relative;
      padding: 20px 0;
    }
    
    .skill-upgrade-glow {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 180px;
      height: 180px;
      background: radial-gradient(circle, rgba(64, 160, 255, 0.3) 0%, rgba(32, 80, 160, 0.1) 40%, transparent 70%);
      animation: gem-glow-pulse 2s ease-in-out infinite;
      pointer-events: none;
    }
    
    @keyframes gem-glow-pulse {
      0%, 100% { opacity: 0.6; transform: translate(-50%, -50%) scale(1); }
      50% { opacity: 1; transform: translate(-50%, -50%) scale(1.1); }
    }
    
    .skill-upgrade-selected-icon {
      font-size: 64px;
      position: relative;
      z-index: 1;
      filter: drop-shadow(0 0 20px rgba(64, 160, 255, 0.8));
      margin-bottom: 12px;
      display: inline-block;
    }
    
    .skill-upgrade-selected-name {
      font-size: 18px;
      color: #d4a520;
      font-weight: 600;
      text-shadow: 0 0 10px rgba(212, 165, 32, 0.5);
      margin-bottom: 4px;
    }
    
    .skill-upgrade-selected-rank {
      font-size: 14px;
      color: #a08070;
      margin-bottom: 16px;
    }
    
    /* XP Progress Bar */
    .skill-upgrade-xp-container {
      margin-bottom: 16px;
    }
    
    .skill-upgrade-xp-bar {
      width: 100%;
      height: 22px;
      background: linear-gradient(180deg, #0a0408 0%, #150810 50%, #0a0408 100%);
      border: 2px solid #4a3040;
      border-radius: 11px;
      overflow: hidden;
      position: relative;
      box-shadow: inset 0 2px 6px rgba(0,0,0,0.8);
    }
    
    .skill-upgrade-xp-fill {
      height: 100%;
      background: linear-gradient(180deg, 
        #8060c0 0%, 
        #6040a0 30%, 
        #5030a0 50%, 
        #6040a0 70%, 
        #8060c0 100%);
      border-radius: 9px;
      transition: width 0.3s ease;
      box-shadow: 0 0 10px rgba(128, 96, 192, 0.5);
    }
    
    .skill-upgrade-xp-text {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 11px;
      font-weight: bold;
      color: #fff;
      text-shadow: 0 1px 2px #000, 0 0 4px #000;
      white-space: nowrap;
    }
    
    .skill-upgrade-xp-gain {
      text-align: center;
      font-size: 16px;
      font-weight: bold;
      color: #80ff80;
      text-shadow: 0 0 8px rgba(128, 255, 128, 0.5);
      margin-bottom: 12px;
    }
    
    /* Upgrade Button */
    .skill-upgrade-btn {
      width: 100%;
      padding: 12px;
      background: linear-gradient(180deg, #3a2830 0%, #2a1820 50%, #1a0c10 100%);
      border: 2px solid #5a4050;
      border-radius: 4px;
      color: #a08070;
      font-size: 14px;
      font-weight: bold;
      letter-spacing: 2px;
      text-transform: uppercase;
      cursor: pointer;
      transition: all 0.2s;
      margin-bottom: 16px;
    }
    
    .skill-upgrade-btn:hover {
      background: linear-gradient(180deg, #4a3840 0%, #3a2830 50%, #2a1820 100%);
      border-color: #8060a0;
      color: #d0b0a0;
    }
    
    .skill-upgrade-btn:disabled {
      background: linear-gradient(180deg, #1a1010 0%, #0d0808 100%);
      border-color: #2a1820;
      color: #4a3840;
      cursor: not-allowed;
    }
    
    /* Auto-assign Timer */
    .skill-upgrade-timer {
      text-align: center;
      font-size: 12px;
      color: #8a7060;
      margin-bottom: 12px;
      padding: 6px 12px;
      background: linear-gradient(180deg, #1a0c10 0%, #0d0608 100%);
      border: 1px solid #2a1820;
      border-radius: 4px;
    }
    
    .skill-upgrade-timer .timer-icon {
      margin-right: 4px;
    }
    
    .skill-upgrade-timer #upgradeTimerSeconds {
      color: #d4a520;
      font-weight: bold;
    }
    
    .skill-upgrade-auto-message {
      text-align: center;
      font-size: 13px;
      color: #a08070;
      margin-bottom: 12px;
      padding: 8px 12px;
      background: linear-gradient(180deg, #1a1410 0%, #0d0a08 100%);
      border: 1px solid #3a3020;
      border-radius: 4px;
      line-height: 1.4;
    }
    
    /* Skill Grid */
    .skill-upgrade-grid-label {
      font-size: 11px;
      color: #6a5a50;
      text-transform: uppercase;
      letter-spacing: 1px;
      margin-bottom: 8px;
      text-align: center;
    }
    
    .skill-upgrade-grid {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 8px;
      padding: 12px;
      background: linear-gradient(180deg, #0d0808 0%, #1a0c10 100%);
      border: 1px solid #2a1820;
      border-radius: 4px;
    }
    
    .skill-upgrade-grid-item {
      width: 56px;
      height: 56px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 28px;
      background: linear-gradient(180deg, #1a1018 0%, #0d080c 100%);
      border: 2px solid #3a2830;
      border-radius: 4px;
      cursor: pointer;
      transition: all 0.15s;
      position: relative;
    }
    
    .skill-upgrade-grid-item:hover {
      border-color: #6040a0;
      box-shadow: 0 0 15px rgba(96, 64, 160, 0.5);
      transform: scale(1.05);
    }
    
    .skill-upgrade-grid-item.selected {
      border-color: #80c0ff;
      box-shadow: 0 0 20px rgba(128, 192, 255, 0.6);
    }
    
    .skill-upgrade-grid-item-rank {
      position: absolute;
      top: 2px;
      left: 2px;
      font-size: 10px;
      color: #c0a0ff;
      font-weight: bold;
      background: linear-gradient(180deg, #4a3080 0%, #2a1860 100%);
      border: 1px solid #6040a0;
      border-radius: 3px;
      padding: 0px 4px;
      min-width: 12px;
      text-align: center;
    }
    
    /* Animated upgrade effects */
    .skill-upgrade-levelup {
      position: absolute;
      top: 10px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 16px;
      font-weight: bold;
      color: #ffd700;
      text-shadow: 0 0 15px rgba(255, 215, 0, 0.8);
      animation: levelup-pop 0.5s ease-out;
    }
    
    @keyframes levelup-pop {
      0% { transform: translateX(-50%) scale(0.5); opacity: 0; }
      50% { transform: translateX(-50%) scale(1.3); }
      100% { transform: translateX(-50%) scale(1); opacity: 1; }
    }
    
    /* Greater Rift Modal */
    .modal-overlay {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0,0,0,0.85);
      z-index: 20000;
      justify-content: center;
      align-items: center;
    }
    
    .modal-content {
      border-radius: 8px;
      overflow: hidden;
    }
    
    .modal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px 16px;
      background: linear-gradient(180deg, #2a1510 0%, #1a0a05 100%);
      border-bottom: 2px solid #553322;
    }
    
    .modal-header h2 {
      margin: 0;
      font-size: 18px;
      color: #ff8844;
    }
    
    .modal-close {
      background: none;
      border: none;
      color: #666;
      font-size: 20px;
      cursor: pointer;
      padding: 0 5px;
    }
    
    .modal-close:hover {
      color: #ff6644;
    }
    
    .greater-rift-modal {
      max-width: 400px;
      background: linear-gradient(135deg, #1a0a05 0%, #2a1510 100%);
      border: 2px solid #ff6600;
      border-radius: 8px;
      box-shadow: 0 0 40px rgba(255, 102, 0, 0.4);
    }
    
    /* D3-Style Greater Rift Modal - Complete Redesign */
    .gr-d3-modal {
      width: 340px;
      background: linear-gradient(180deg, #1a1008 0%, #0d0804 100%);
      border: 3px solid #3a2818;
      border-radius: 4px;
      box-shadow: 0 0 80px rgba(0,0,0,0.95), 0 0 40px rgba(139,69,19,0.3), inset 0 0 60px rgba(0,0,0,0.5);
      overflow: hidden;
    }
    
    .gr-d3-header {
      display: flex;
      justify-content: center;
      align-items: center;
      padding: 14px 20px;
      background: linear-gradient(180deg, #2a1a0a 0%, #1a0e04 100%);
      border-bottom: 2px solid #4a3018;
      position: relative;
    }
    
    .gr-d3-header-decor {
      position: absolute;
      width: 60px;
      height: 2px;
      background: linear-gradient(90deg, transparent, #8a6030, transparent);
    }
    .gr-d3-header-decor.left { left: 10px; }
    .gr-d3-header-decor.right { right: 10px; }
    
    .gr-d3-title {
      font-size: 15px;
      font-weight: bold;
      color: #d4a84b;
      letter-spacing: 4px;
      text-shadow: 0 2px 4px rgba(0,0,0,0.8);
    }
    
    .gr-d3-body {
      padding: 16px 20px;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 14px;
      background: linear-gradient(180deg, rgba(30,20,10,0.5) 0%, transparent 100%);
    }
    
    .gr-d3-subtitle {
      font-size: 11px;
      color: #887766;
      letter-spacing: 2px;
      text-transform: uppercase;
    }
    
    /* Portal Image */
    .gr-d3-portal {
      position: relative;
      width: 100%;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
    }
    
    .gr-d3-portal-img {
      width: 100%;
      max-width: 340px;
      height: auto;
      display: block;
    }
    
    /* Level Select Dropdown */
    .gr-d3-select-wrapper {
      width: 100%;
      position: relative;
    }
    
    .gr-d3-select-wrapper select {
      display: none;
    }
    
    .gr-custom-dropdown {
      width: 100%;
      position: relative;
    }
    
    .gr-custom-dropdown-selected {
      width: 100%;
      padding: 12px 40px 12px 16px;
      background: linear-gradient(180deg, #1a0e06 0%, #0a0502 100%);
      border: 2px solid #4a3020;
      border-radius: 3px;
      color: #e8c878;
      font-size: 15px;
      font-weight: bold;
      cursor: pointer;
      text-shadow: 0 1px 2px rgba(0,0,0,0.5);
      box-sizing: border-box;
    }
    
    .gr-custom-dropdown-selected:hover {
      border-color: #6a4830;
      background: linear-gradient(180deg, #241408 0%, #0e0804 100%);
    }
    
    .gr-custom-dropdown-arrow {
      position: absolute;
      right: 14px;
      top: 50%;
      transform: translateY(-50%);
      color: #8a6840;
      font-size: 10px;
      pointer-events: none;
    }
    
    .gr-custom-dropdown-list {
      display: none;
      position: absolute;
      top: 100%;
      left: 0;
      right: 0;
      max-height: 300px;
      overflow-y: auto;
      background: #1a0e06;
      border: 2px solid #4a3020;
      border-top: none;
      border-radius: 0 0 3px 3px;
      z-index: 1000;
    }
    
    .gr-custom-dropdown.open .gr-custom-dropdown-list {
      display: block;
    }
    
    .gr-custom-dropdown-item {
      padding: 10px 16px;
      cursor: pointer;
      font-size: 14px;
      font-weight: bold;
      text-shadow: 0 1px 2px rgba(0,0,0,0.5);
    }
    
    .gr-custom-dropdown-item:hover {
      background: #3a2010;
    }
    
    .gr-custom-dropdown-item.selected {
      background: #2a1808;
    }
    
    /* Tier Colors for Custom Dropdown */
    .gr-custom-dropdown-item.tier-normal { color: #ffffff; }
    .gr-custom-dropdown-item.tier-hard { color: #ffdd44; }
    .gr-custom-dropdown-item.tier-elite { color: #ff9933; }
    .gr-custom-dropdown-item.tier-nightmare { color: #ff5555; }
    .gr-custom-dropdown-item.tier-core { color: #ff3333; }
    .gr-custom-dropdown-item.tier-core2 { color: #ff44aa; }
    .gr-custom-dropdown-item.tier-core3 { color: #cc44ff; }
    .gr-custom-dropdown-item.tier-core4 { color: #9944ff; }
    .gr-custom-dropdown-item.tier-core5 { color: #6666ff; }
    
    .gr-custom-dropdown-selected.tier-normal { color: #ffffff; }
    .gr-custom-dropdown-selected.tier-hard { color: #ffdd44; }
    .gr-custom-dropdown-selected.tier-elite { color: #ff9933; }
    .gr-custom-dropdown-selected.tier-nightmare { color: #ff5555; }
    .gr-custom-dropdown-selected.tier-core { color: #ff3333; }
    .gr-custom-dropdown-selected.tier-core2 { color: #ff44aa; }
    .gr-custom-dropdown-selected.tier-core3 { color: #cc44ff; }
    .gr-custom-dropdown-selected.tier-core4 { color: #9944ff; }
    .gr-custom-dropdown-selected.tier-core5 { color: #6666ff; }
    
    /* Scrollbar styling for dropdown */
    .gr-custom-dropdown-list::-webkit-scrollbar {
      width: 8px;
    }
    .gr-custom-dropdown-list::-webkit-scrollbar-track {
      background: #0a0502;
    }
    .gr-custom-dropdown-list::-webkit-scrollbar-thumb {
      background: #4a3020;
      border-radius: 4px;
    }
    .gr-custom-dropdown-list::-webkit-scrollbar-thumb:hover {
      background: #6a4830;
    }
    
    /* Stats Box */
    .gr-d3-stats-box {
      width: 100%;
      background: rgba(0,0,0,0.4);
      border: 1px solid #2a1a0a;
      border-radius: 3px;
      padding: 10px 14px;
    }
    
    .gr-d3-stat-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 5px 0;
      border-bottom: 1px solid rgba(80,60,40,0.2);
    }
    
    .gr-d3-stat-row:last-child {
      border-bottom: none;
    }
    
    .gr-d3-stat-row.highlight {
      background: rgba(100,180,80,0.1);
      margin: 0 -14px;
      padding: 5px 14px;
      border-bottom: none;
    }
    
    .gr-d3-stat-label {
      color: #887766;
      font-size: 12px;
    }
    
    .gr-d3-stat-value {
      color: #d4a84b;
      font-weight: bold;
      font-size: 13px;
    }
    
    .gr-d3-stat-value.bonus {
      color: #88dd66;
    }
    
    /* Record Box */
    .gr-d3-record-box {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 8px 16px;
      background: rgba(60,40,20,0.3);
      border: 1px solid #3a2818;
      border-radius: 3px;
    }
    
    .gr-d3-record-label {
      color: #aa9977;
      font-size: 12px;
    }
    
    .gr-d3-record-value {
      color: #ffcc44;
      font-weight: bold;
      font-size: 14px;
    }
    
    /* Info Box */
    .gr-d3-info-box {
      width: 100%;
      padding: 12px;
      background: rgba(0,0,0,0.3);
      border: 1px solid #2a1a0a;
      border-radius: 3px;
      text-align: center;
    }
    
    .gr-d3-info-title {
      color: #c9a050;
      font-size: 12px;
      font-weight: bold;
      margin-bottom: 6px;
    }
    
    .gr-d3-info-text {
      color: #776655;
      font-size: 11px;
      line-height: 1.5;
    }
    
    /* Footer with Accept Button */
    .gr-d3-footer {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px 20px;
      background: linear-gradient(180deg, #1a1008 0%, #0d0804 100%);
      border-top: 2px solid #3a2818;
    }
    
    .gr-d3-accept {
      flex: 1;
      padding: 12px 24px;
      background: linear-gradient(180deg, #6a4020 0%, #4a2810 100%);
      border: 2px solid #8a5530;
      border-radius: 3px;
      color: #f4d4a4;
      font-size: 14px;
      font-weight: bold;
      letter-spacing: 3px;
      cursor: pointer;
      transition: all 0.15s;
      text-shadow: 0 2px 3px rgba(0,0,0,0.6);
    }
    
    .gr-d3-accept:hover {
      background: linear-gradient(180deg, #8a5530 0%, #6a3818 100%);
      border-color: #aa6840;
      box-shadow: 0 0 20px rgba(180,100,40,0.4);
    }
    
    .gr-d3-accept:active {
      transform: scale(0.98);
    }
    
    .gr-d3-cost {
      display: flex;
      align-items: center;
      gap: 6px;
      margin-left: 16px;
    }
    
    .gr-d3-cost-icon {
      font-size: 18px;
    }
    
    .gr-d3-cost-amount {
      color: #ffdd66;
      font-size: 16px;
      font-weight: bold;
      text-shadow: 0 1px 3px rgba(0,0,0,0.5);
    }
    
    .gr-modal-body {
      padding: 16px;
      display: flex;
      flex-direction: column;
      gap: 16px;
    }
    
    .gr-info {
      text-align: center;
      color: #aaa;
      font-size: 13px;
    }
    
    .gr-info p {
      margin: 4px 0;
    }
    
    .gr-level-select {
      text-align: center;
    }
    
    .gr-level-select label {
      display: block;
      margin-bottom: 8px;
      color: #ff8844;
      font-weight: bold;
    }
    
    .gr-level-controls {
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 8px;
    }
    
    .gr-level-controls button {
      padding: 6px 12px;
      background: #332211;
      border: 1px solid #553322;
      color: #ffaa66;
      border-radius: 4px;
      cursor: pointer;
      font-weight: bold;
    }
    
    .gr-level-controls button:hover {
      background: #443322;
      border-color: #ff6600;
    }
    
    .gr-level-controls input {
      width: 60px;
      text-align: center;
      padding: 6px;
      background: #1a0a05;
      border: 1px solid #553322;
      color: #ff8844;
      font-size: 16px;
      font-weight: bold;
      border-radius: 4px;
    }
    
    .gr-scaling-preview {
      background: #0a0502;
      border: 1px solid #332211;
      border-radius: 4px;
      padding: 12px;
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      justify-content: center;
    }
    
    .gr-scaling-stat {
      font-size: 12px;
      color: #888;
      padding: 4px 8px;
      background: #1a0a05;
      border-radius: 3px;
    }
    
    .gr-scaling-stat span {
      color: #ffaa44;
      font-weight: bold;
    }
    
    .gr-start-btn {
      padding: 12px 24px;
      background: linear-gradient(180deg, #ff6600 0%, #cc4400 100%);
      border: none;
      border-radius: 6px;
      color: #fff;
      font-size: 16px;
      font-weight: bold;
      cursor: pointer;
      text-shadow: 0 1px 2px rgba(0,0,0,0.5);
      transition: all 0.2s;
    }
    
    .gr-start-btn:hover {
      background: linear-gradient(180deg, #ff8833 0%, #dd5500 100%);
      transform: scale(1.02);
    }
    
    .gr-start-btn:disabled {
      background: #333;
      color: #666;
      cursor: not-allowed;
    }
    
    /* Greater Rift Tab Panel */
    .gr-tab-content {
      background: 
        linear-gradient(180deg, rgba(20,10,30,0.85) 0%, rgba(10,5,15,0.9) 100%),
        url('https://raw.githubusercontent.com/Graphic37/ARPG-/main/greater%20rift1.png');
      background-size: cover;
      background-position: center top;
      background-repeat: no-repeat;
    }
    
    .gr-intro {
      padding: 12px 20px;
      border-bottom: 1px solid #5a3080;
      background: linear-gradient(180deg, rgba(40,20,60,0.6) 0%, transparent 100%);
    }
    
    .gr-intro-title {
      color: #c080f0;
      font-size: 18px;
      font-weight: bold;
      margin-bottom: 6px;
      text-shadow: 0 0 10px rgba(160,80,220,0.5);
    }
    
    .gr-intro-text {
      color: #9988aa;
      font-size: 12px;
      line-height: 1.4;
    }
    
    .gr-main-panel {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 20px;
      padding: 20px;
    }
    
    .gr-gold-display {
      display: flex;
      align-items: center;
      gap: 10px;
      background: linear-gradient(135deg, rgba(40,20,60,0.8) 0%, rgba(20,10,30,0.9) 100%);
      border: 2px solid #6a4090;
      border-radius: 6px;
      padding: 12px 20px;
    }
    
    .gr-gold-icon {
      font-size: 24px;
    }
    
    .gr-gold-label {
      color: #d4a84b;
      font-weight: bold;
      font-size: 14px;
    }
    
    .gr-gold-info {
      color: #9988aa;
      font-size: 12px;
    }
    
    .gr-key-display {
      display: flex;
      align-items: center;
      gap: 12px;
      background: linear-gradient(135deg, rgba(40,20,60,0.8) 0%, rgba(20,10,30,0.9) 100%);
      border: 2px solid #a060d0;
      border-radius: 8px;
      padding: 16px 24px;
    }
    
    .gr-key-icon {
      font-size: 32px;
    }
    
    .gr-key-count {
      font-size: 28px;
      font-weight: bold;
      color: #c080f0;
    }
    
    .gr-key-label {
      color: #9988aa;
      font-size: 13px;
    }
    
    .gr-records {
      background: rgba(30,15,45,0.7);
      border: 1px solid #5a3080;
      border-radius: 6px;
      padding: 12px 20px;
      width: 100%;
      max-width: 350px;
    }
    
    .gr-record-title {
      text-align: center;
      color: #c080f0;
      font-weight: bold;
      margin-bottom: 10px;
    }
    
    .gr-record-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 8px;
    }
    
    .gr-record-item {
      font-size: 12px;
      color: #aaa;
      padding: 4px 8px;
      background: rgba(40,20,60,0.5);
      border-radius: 3px;
    }
    
    .gr-record-item span {
      color: #c080f0;
      font-weight: bold;
    }
    
    .gr-class-icon {
      margin-right: 4px;
    }
    
    .gr-open-btn {
      padding: 16px 40px;
      background: linear-gradient(180deg, #8040c0 0%, #5020a0 100%);
      border: 2px solid #a060e0;
      border-radius: 8px;
      color: #fff;
      font-size: 18px;
      font-weight: bold;
      cursor: pointer;
      text-shadow: 0 2px 4px rgba(0,0,0,0.5);
      box-shadow: 0 4px 15px rgba(128, 64, 192, 0.4);
      transition: all 0.2s;
    }
    
    .gr-open-btn:hover {
      background: linear-gradient(180deg, #9050d0 0%, #6030b0 100%);
      transform: scale(1.05);
      box-shadow: 0 6px 20px rgba(128, 64, 192, 0.6);
    }
    
    .gr-hint {
      color: #8866aa;
      font-size: 11px;
      font-style: italic;
    }

    /* Echo Domain 7x7 Grid Cells */
    .echo-cell {
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 20px;
      border: 2px solid;
      border-radius: 4px;
      transition: all 0.15s ease;
    }
    .echo-cell:hover {
      transform: scale(1.05);
      filter: brightness(1.2);
    }
    
    /* Vertical Shard Tier Cards */
    .shard-tiers-vertical {
      display: flex;
      flex-direction: column;
      gap: 6px;
      margin-top: auto;
      padding-top: 8px;
    }
    
    .shard-tier-card {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 8px 10px;
      border-radius: 5px;
      cursor: pointer;
      transition: all 0.2s;
      position: relative;
      overflow: hidden;
    }
    
    .shard-tier-card::before {
      content: '';
      position: absolute;
      inset: 0;
      opacity: 0;
      transition: opacity 0.2s;
    }
    
    .shard-tier-card:hover::before {
      opacity: 1;
    }
    
    .shard-tier-card:hover {
      transform: translateX(4px);
    }
    
    /* Tier 1: Stable - Blue (Low Risk) */
    .shard-tier-card.tier-stable {
      background: linear-gradient(90deg, rgba(60,80,120,0.3) 0%, rgba(30,40,60,0.2) 100%);
      border: 2px solid #4488cc;
      box-shadow: 0 0 10px rgba(68,136,204,0.2);
    }
    
    .shard-tier-card.tier-stable:hover {
      border-color: #66aaee;
      box-shadow: 0 0 20px rgba(68,136,204,0.4);
    }
    
    .shard-tier-card.tier-stable .shard-tier-badge {
      background: linear-gradient(180deg, #4488cc 0%, #336699 100%);
      color: #fff;
    }
    
    .shard-tier-card.tier-stable .shard-tier-cost {
      color: #6af;
    }
    
    /* Tier 2: Unstable - Purple (High Risk) */
    .shard-tier-card.tier-unstable {
      background: linear-gradient(90deg, rgba(100,60,120,0.3) 0%, rgba(50,30,60,0.2) 100%);
      border: 2px solid #9944cc;
      box-shadow: 0 0 10px rgba(153,68,204,0.2);
    }
    
    .shard-tier-card.tier-unstable:hover {
      border-color: #bb66ee;
      box-shadow: 0 0 20px rgba(153,68,204,0.4);
    }
    
    .shard-tier-card.tier-unstable .shard-tier-badge {
      background: linear-gradient(180deg, #9944cc 0%, #663399 100%);
      color: #fff;
    }
    
    .shard-tier-card.tier-unstable .shard-tier-cost {
      color: #c8f;
    }
    
    /* Tier 3: Fractured - Red (Extreme Risk) */
    .shard-tier-card.tier-fractured {
      background: linear-gradient(90deg, rgba(120,50,50,0.3) 0%, rgba(60,25,25,0.2) 100%);
      border: 2px solid #cc4444;
      box-shadow: 0 0 10px rgba(204,68,68,0.2);
    }
    
    .shard-tier-card.tier-fractured:hover {
      border-color: #ee6666;
      box-shadow: 0 0 20px rgba(204,68,68,0.4);
    }
    
    .shard-tier-card.tier-fractured .shard-tier-badge {
      background: linear-gradient(180deg, #cc4444 0%, #993333 100%);
      color: #fff;
    }
    
    .shard-tier-card.tier-fractured .shard-tier-cost {
      color: #f88;
    }
    
    .shard-tier-badge {
      width: 28px;
      height: 28px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 12px;
      font-weight: 700;
      flex-shrink: 0;
    }
    
    .shard-tier-info {
      flex: 1;
      min-width: 0;
    }
    
    .shard-tier-name {
      font-size: 12px;
      font-weight: 700;
      color: #ddd;
    }
    
    .shard-tier-cost-box {
      display: flex;
      flex-direction: column;
      align-items: flex-end;
      gap: 0;
    }
    
    .shard-tier-card .shard-tier-cost {
      font-size: 16px;
      font-weight: 700;
    }
    
    .shard-tier-cost-label {
      font-size: 8px;
      color: #666;
      text-transform: uppercase;
    }
    
    /* Toast Notification */
    .toast-notification {
      position: fixed;
      top: 80px;
      left: 50%;
      transform: translateX(-50%) translateY(-20px);
      background: linear-gradient(180deg, #2a1a10 0%, #1a0f08 100%);
      border: 2px solid #aa6030;
      border-radius: 6px;
      padding: 14px 24px;
      display: flex;
      align-items: center;
      gap: 12px;
      z-index: 15000;
      box-shadow: 0 4px 20px rgba(0,0,0,0.8), 0 0 30px rgba(170,96,48,0.3);
      opacity: 0;
      pointer-events: none;
      transition: all 0.3s ease-out;
    }
    
    .toast-notification.visible {
      opacity: 1;
      transform: translateX(-50%) translateY(0);
      pointer-events: auto;
    }
    
    .toast-notification.warning {
      border-color: #cc6600;
      box-shadow: 0 4px 20px rgba(0,0,0,0.8), 0 0 30px rgba(204,102,0,0.3);
    }
    
    .toast-notification.error {
      border-color: #aa3030;
      box-shadow: 0 4px 20px rgba(0,0,0,0.8), 0 0 30px rgba(170,48,48,0.3);
    }
    
    .toast-icon {
      font-size: 24px;
    }
    
    .toast-content {
      display: flex;
      flex-direction: column;
      gap: 2px;
    }
    
    .toast-title {
      font-size: 14px;
      font-weight: 600;
      color: #e0c090;
    }
    
    .toast-message {
      font-size: 12px;
      color: #999;
    }
    
    .confirm-modal-icon {
      font-size: 48px;
      margin-bottom: 12px;
      filter: drop-shadow(0 0 10px #ff0000);
    }
    
    .confirm-modal-title {
      font-size: 22px;
      font-weight: bold;
      color: #ff4444;
      margin-bottom: 8px;
      text-shadow: 0 0 10px rgba(255, 0, 0, 0.5);
    }
    
    .confirm-modal-warning {
      font-size: 14px;
      color: #ffaa00;
      margin-bottom: 12px;
      animation: pulse 1s infinite;
    }
    
    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.6; }
    }
    
    .confirm-modal-text {
      color: #ccc;
      font-size: 14px;
      margin-bottom: 16px;
      line-height: 1.5;
    }
    
    .confirm-modal-effects {
      color: #888;
      font-size: 12px;
      text-align: left;
      background: rgba(0, 0, 0, 0.3);
      padding: 12px;
      border-radius: 4px;
      margin-bottom: 20px;
    }
    
    .confirm-modal-effects ul {
      margin: 8px 0 0 20px;
      padding: 0;
    }
    
    .confirm-modal-effects li {
      margin: 4px 0;
    }
    
    .confirm-modal-buttons {
      display: flex;
      gap: 12px;
      justify-content: center;
    }
    
    .confirm-btn {
      padding: 10px 20px;
      border: none;
      border-radius: 4px;
      font-size: 14px;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.15s;
    }
    
    .confirm-btn.cancel {
      background: #333;
      color: #aaa;
      border: 1px solid #555;
    }
    
    .confirm-btn.cancel:hover {
      background: #444;
      color: #fff;
    }
    
    .confirm-btn.confirm {
      background: linear-gradient(180deg, #8b0000 0%, #5a0000 100%);
      color: #fff;
      border: 1px solid #aa2222;
    }
    
    .confirm-btn.confirm:hover {
      background: linear-gradient(180deg, #aa0000 0%, #6a0000 100%);
      box-shadow: 0 0 15px rgba(255, 0, 0, 0.4);
    }
    
    /* ════════════════════════════════════════════════════════════════════════════
       PASSIVE SKILL TREE (P key)
       ════════════════════════════════════════════════════════════════════════════ */
    
    #passiveTreePanel {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: rgba(5, 5, 8, 0.97);
      z-index: 3000;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.2s;
      display: flex;
      flex-direction: column;
    }
    
    #passiveTreePanel.visible {
      opacity: 1;
      pointer-events: auto;
    }
    
    .passive-tree-header {
      background: linear-gradient(90deg, #1a1510 0%, #2a2520 50%, #1a1510 100%);
      padding: 12px 20px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      border-bottom: 2px solid #3a3530;
      flex-shrink: 0;
    }
    
    .passive-tree-title {
      color: #d4af37;
      font-size: 20px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 2px;
      text-shadow: 0 2px 4px rgba(0,0,0,0.5);
    }
    
    .passive-tree-points {
      display: flex;
      gap: 20px;
      align-items: center;
    }
    
    .passive-tree-points span {
      color: #a09080;
      font-size: 14px;
    }
    
    .passive-tree-points .available {
      color: #88ff88;
      font-weight: 600;
    }
    
    .passive-tree-close {
      width: 32px;
      height: 32px;
      background: #8b0000;
      border: 1px solid #aa2020;
      border-radius: 4px;
      color: #fff;
      cursor: pointer;
      font-size: 16px;
      line-height: 28px;
      text-align: center;
    }
    
    .passive-tree-close:hover {
      background: #aa2020;
    }
    
    .passive-tree-container {
      flex: 1;
      position: relative;
      overflow: hidden;
    }
    
    #passiveTreeCanvas {
      position: absolute;
      top: 0;
      left: 0;
      cursor: grab;
    }
    
    #passiveTreeCanvas:active {
      cursor: grabbing;
    }
    
    .passive-tree-controls {
      position: absolute;
      bottom: 20px;
      right: 20px;
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
    
    .tree-control-btn {
      width: 40px;
      height: 40px;
      background: rgba(30, 28, 25, 0.9);
      border: 1px solid #4a4540;
      border-radius: 4px;
      color: #d4af37;
      font-size: 20px;
      cursor: pointer;
      transition: all 0.15s;
    }
    
    .tree-control-btn:hover {
      background: rgba(50, 45, 40, 0.9);
      border-color: #d4af37;
    }
    
    .passive-tree-legend {
      position: absolute;
      bottom: 20px;
      left: 20px;
      background: rgba(20, 18, 15, 0.95);
      border: 1px solid #3a3530;
      border-radius: 6px;
      padding: 12px 16px;
    }
    
    .legend-title {
      color: #d4af37;
      font-size: 12px;
      font-weight: 600;
      margin-bottom: 8px;
      text-transform: uppercase;
    }
    
    .legend-item {
      display: flex;
      align-items: center;
      gap: 10px;
      margin: 6px 0;
      font-size: 11px;
      color: #a09080;
    }
    
    .legend-node {
      width: 16px;
      height: 16px;
      border-radius: 50%;
      border: 2px solid;
    }
    
    .legend-node.small { 
      width: 12px; height: 12px;
      background: #2a2520;
      border-color: #5a5550;
    }
    
    .legend-node.notable { 
      width: 18px; height: 18px;
      background: radial-gradient(circle, #3a3530 0%, #2a2520 100%);
      border-color: #d4af37;
    }
    
    .legend-node.keystone { 
      width: 20px; height: 20px;
      background: radial-gradient(circle, #4a2020 0%, #2a1515 100%);
      border-color: #ff6644;
      transform: rotate(45deg);
      border-radius: 4px;
    }
    
    /* Node tooltip */
    #passiveNodeTooltip {
      position: fixed;
      background: linear-gradient(180deg, #1a1815 0%, #0d0c0a 100%);
      border: 2px solid #4a4540;
      border-radius: 6px;
      padding: 12px 16px;
      min-width: 200px;
      max-width: 320px;
      z-index: 4000;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.1s;
      box-shadow: 0 4px 20px rgba(0,0,0,0.6);
    }
    
    #passiveNodeTooltip.visible {
      opacity: 1;
    }
    
    .node-tooltip-name {
      font-size: 15px;
      font-weight: 600;
      margin-bottom: 6px;
    }
    
    .node-tooltip-name.small { color: #a09080; }
    .node-tooltip-name.notable { color: #d4af37; }
    .node-tooltip-name.keystone { color: #ff6644; }
    
    .node-tooltip-type {
      font-size: 10px;
      color: #666;
      text-transform: uppercase;
      letter-spacing: 1px;
      margin-bottom: 8px;
    }
    
    .node-tooltip-stats {
      border-top: 1px solid #3a3530;
      padding-top: 8px;
    }
    
    .node-tooltip-stat {
      font-size: 13px;
      color: #88ccff;
      margin: 4px 0;
    }
    
    .node-tooltip-stat.negative {
      color: #ff6666;
    }
    
    .node-tooltip-hint {
      font-size: 10px;
      color: #666;
      margin-top: 10px;
      font-style: italic;
    }
    
    .passive-tree-respec {
      position: absolute;
      top: 70px;
      right: 20px;
      background: rgba(60, 30, 30, 0.9);
      border: 1px solid #6a3030;
      border-radius: 4px;
      padding: 8px 16px;
      color: #ff8866;
      font-size: 12px;
      cursor: pointer;
      transition: all 0.15s;
    }
    
    .passive-tree-respec:hover {
      background: rgba(80, 40, 40, 0.9);
      border-color: #aa4040;
    }
    
    /* ============ LEADERBOARD PANEL ============ */
    #leaderboardPanel {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%) scale(0.9);
      width: 700px;
      height: 550px;
      background: linear-gradient(180deg, #1a1512 0%, #0d0b08 100%);
      border: 2px solid #4a3a28;
      border-radius: 8px;
      z-index: 3000;
      opacity: 0;
      pointer-events: none;
      transition: all 0.2s ease;
      display: flex;
      flex-direction: column;
      box-shadow: 0 10px 40px rgba(0,0,0,0.8);
    }
    
    #leaderboardPanel.visible {
      opacity: 1;
      pointer-events: auto;
      transform: translate(-50%, -50%) scale(1);
    }
    
    .leaderboard-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 16px 20px;
      background: linear-gradient(180deg, #2a2218 0%, #1a1512 100%);
      border-bottom: 1px solid #4a3a28;
      border-radius: 6px 6px 0 0;
    }
    
    .leaderboard-title {
      font-size: 22px;
      font-weight: 700;
      color: #d4af37;
      text-shadow: 0 2px 4px rgba(0,0,0,0.5);
      letter-spacing: 2px;
    }
    
    .leaderboard-close {
      width: 32px;
      height: 32px;
      background: rgba(60, 30, 30, 0.8);
      border: 1px solid #6a3030;
      border-radius: 4px;
      color: #ff8866;
      font-size: 18px;
      cursor: pointer;
      transition: all 0.15s;
    }
    
    .leaderboard-close:hover {
      background: #6a3030;
      border-color: #aa4040;
    }
    
    .leaderboard-filters {
      display: flex;
      gap: 8px;
      padding: 12px 20px;
      background: rgba(0,0,0,0.3);
      border-bottom: 1px solid #3a2a18;
    }
    
    .leaderboard-filter {
      padding: 8px 16px;
      background: rgba(40, 35, 30, 0.8);
      border: 1px solid #4a3a28;
      border-radius: 4px;
      color: #a09080;
      font-size: 12px;
      cursor: pointer;
      transition: all 0.15s;
    }
    
    .leaderboard-filter:hover {
      background: rgba(60, 50, 40, 0.8);
      border-color: #6a5a48;
      color: #c0b0a0;
    }
    
    .leaderboard-filter.active {
      background: linear-gradient(180deg, #3a3020 0%, #2a2015 100%);
      border-color: #8a7a58;
      color: #d4af37;
    }
    
    .leaderboard-content {
      flex: 1;
      overflow: hidden;
      display: flex;
      flex-direction: column;
    }
    
    .leaderboard-table-header {
      display: flex;
      padding: 12px 20px;
      background: rgba(40, 35, 30, 0.6);
      border-bottom: 1px solid #3a2a18;
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 1px;
      color: #8a7a6a;
    }
    
    .lb-col-rank { width: 60px; text-align: center; }
    .lb-col-name { flex: 1; }
    .lb-col-class { width: 100px; text-align: center; }
    .lb-col-level { width: 80px; text-align: center; }
    
    .leaderboard-table-body {
      flex: 1;
      overflow-y: auto;
      padding: 8px 0;
    }
    
    .leaderboard-row {
      display: flex;
      padding: 10px 20px;
      align-items: center;
      border-bottom: 1px solid rgba(60, 50, 40, 0.3);
      transition: background 0.1s;
    }
    
    .leaderboard-row:hover {
      background: rgba(60, 50, 40, 0.3);
    }
    
    .leaderboard-row.self {
      background: rgba(80, 70, 40, 0.3);
      border-left: 3px solid #d4af37;
    }
    
    .leaderboard-row.top-3 {
      background: linear-gradient(90deg, rgba(80, 60, 30, 0.4) 0%, transparent 50%);
    }
    
    .lb-rank {
      width: 60px;
      text-align: center;
      font-weight: 600;
      font-size: 14px;
    }
    
    .lb-rank.gold { color: #ffd700; }
    .lb-rank.silver { color: #c0c0c0; }
    .lb-rank.bronze { color: #cd7f32; }
    
    .lb-name {
      flex: 1;
      display: flex;
      align-items: center;
      gap: 10px;
    }
    
    .lb-avatar {
      width: 32px;
      height: 32px;
      background: rgba(40, 35, 30, 0.8);
      border: 1px solid #4a3a28;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 16px;
    }
    
    .lb-player-name {
      color: #d0c0b0;
      font-size: 13px;
    }
    
    .lb-class {
      width: 100px;
      text-align: center;
      font-size: 12px;
      color: #a09080;
    }
    
    .lb-level {
      width: 80px;
      text-align: center;
      font-size: 14px;
      font-weight: 600;
      color: #88ccff;
    }
    
    .leaderboard-footer {
      display: flex;
      justify-content: space-between;
      padding: 12px 20px;
      background: rgba(0,0,0,0.3);
      border-top: 1px solid #3a2a18;
      font-size: 11px;
      color: #6a5a4a;
    }
    
    #leaderboardStatus {
      color: #aa8844;
    }
    
  </style>
</head>
<body>
<div class="demo-badge">DEMO</div>
  <!-- ============ LOADING SCREEN ============ -->
  <div id="loadingScreen" style="
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: linear-gradient(135deg, #0a0a15 0%, #1a1a2e 50%, #0a0a15 100%);
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    z-index: 99999;
    font-family: 'Segoe UI', sans-serif;
  ">
    <h1 style="
      font-size: 64px;
      color: #d4af37;
      text-shadow: 0 0 30px rgba(212, 175, 55, 0.5);
      margin-bottom: 10px;
      letter-spacing: 8px;
    ">COREFALL</h1>
    <h2 style="
      font-size: 24px;
      color: #888;
      letter-spacing: 4px;
      margin-bottom: 60px;
    ">IDLE DUNGEON RPG</h2>
    <div style="
      width: 400px;
      height: 6px;
      background: rgba(255,255,255,0.1);
      border-radius: 3px;
      overflow: hidden;
    ">
      <div id="loadingBar" style="
        width: 0%;
        height: 100%;
        background: linear-gradient(90deg, #d4af37, #f4d03f);
        border-radius: 3px;
        transition: width 0.2s ease;
      "></div>
    </div>
    <p id="loadingText" style="
      color: #666;
      margin-top: 20px;
      font-size: 14px;
    ">Loading assets...</p>
  </div>

  <!-- ============ MENU SCREENS ============ -->
  
  <!-- Main Menu / Character Select -->
  <div class="menu-screen" id="mainMenu">
    <div class="menu-bg"></div>
    
    <div class="menu-left-panel">
      <div class="menu-logo">
        <h1>COREFALL</h1>
        <h2>Idle Dungeon RPG</h2>
      </div>
      
      <button class="menu-btn" onclick="showClassSelect()">CREATE NEW CHARACTER</button>
      
      <div class="slots-info">3/10 SLOTS USED</div>
      
      <div class="character-list" id="characterList">
        <!-- Characters populated by JS -->
      </div>
      
      <button class="start-game-btn" id="mainStartBtn" onclick="startGame()">START GAME</button>
    </div>
    
    <div class="menu-right-panel">
      <div class="menu-char-display" id="menuCharDisplay" style="display: none;">
        <div class="char-standing-portrait" id="charStandingPortrait"></div>
        <div class="character-name-display">
          <h2 id="menuCharName">NO CHARACTER</h2>
          <div class="mode" id="menuCharMode"></div>
          <div class="details" id="menuCharDetails">Create a new character to play</div>
        </div>
      </div>
    </div>
  </div>
  
  <!-- Class Selection Screen -->
  <div class="menu-screen hidden" id="classSelectMenu">
    <div class="menu-bg"></div>
    
    <div class="class-select-content">
      <div class="class-preview">
        <div class="class-preview-left">
          <h2 id="classTitle">MONK</h2>
          <p id="classDescription">A powerful warrior wielding brute strength. Masters of melee combat, few can match their raw damage output.</p>
        </div>
        
        <div class="class-icon-large" id="classIconLarge">🪓</div>
        
        <div class="class-preview-right">
          <h3>PLAYSTYLE</h3>
          <div class="playstyle-item">
            <span class="playstyle-icon">⚔️</span>
            <div>
              <h4>BRUTAL MELEE</h4>
              <p>Heavy hitting attacks that devastate enemies</p>
            </div>
          </div>
          <div class="playstyle-item">
            <span class="playstyle-icon">🛡️</span>
            <div>
              <h4>TANKY</h4>
              <p>High life and armor for survivability</p>
            </div>
          </div>
          <div class="playstyle-item">
            <span class="playstyle-icon">💪</span>
            <div>
              <h4>STRENGTH BASED</h4>
              <p>Scales with strength for massive damage</p>
            </div>
          </div>
        </div>
      </div>
      
      <div class="class-selector" id="classSelector">
        <!-- Classes populated by JS -->
      </div>
      
      <!-- Skill Preview Section -->
      <div class="skill-preview-section">
        <div class="skill-preview-header">
          <h3>AVAILABLE SKILLS</h3>
          <span class="skill-preview-hint">Hover for details</span>
        </div>
        <div class="skill-preview-grid" id="skillPreviewGrid">
          <!-- Skills populated by updateClassPreview() -->
        </div>
      </div>
      
      <div class="class-buttons">
        <button class="menu-btn" onclick="confirmClass()">CONFIRM CLASS</button>
        <button class="menu-btn secondary" onclick="showMainMenu()">BACK</button>
      </div>
    </div>
  </div>
  
  <!-- Character Creation Screen -->
  <div class="menu-screen hidden" id="characterCreateMenu">
    <div class="menu-bg"></div>
    
    <div class="create-left-panel">
      <div class="create-section">
        <h2 id="createClassTitle">CREATE RANGER</h2>
      </div>
      
      <div class="create-section">
        <h3>GAME MODE</h3>
        
        <div class="option-row demo-mode-btn selected" id="optionDemo">
          <div class="checkbox">✓</div>
          <span class="option-text">Demo</span>
        </div>
      </div>
      
      <div class="create-section">
        <h3>✦ NAME (REQUIRED)</h3>
        <input type="text" class="name-input" id="characterNameInput" placeholder="Enter character name" maxlength="12" oninput="updateCharacterName()">
      </div>
      
      <button class="menu-btn" id="startGameBtn" onclick="createAndStart()" disabled>START GAME</button>
      <button class="menu-btn secondary" onclick="showClassSelect()">◄ BACK</button>
    </div>
    
    <div class="menu-right-panel">
      <div class="create-character-preview" id="createCharPreview">🏹</div>
    </div>
  </div>
  
  <!-- Skill Preview Tooltip (for class select) -->
  <div class="skill-preview-tooltip" id="skillPreviewTooltip" style="display: none;"></div>
  
  <!-- Game Container (hidden until game starts) -->
  <div id="gameContainer" class="hidden">
  <canvas id="gameCanvas"></canvas>
  <div id="greaterRiftOverlay"></div>
  
  <!-- Top Stats -->
  <div id="topStats">
    <div class="top-stat">
      <span>⚔️</span>
      <span class="value damage" id="statDamage">15-25</span>
    </div>
    <div class="top-stat">
      <span>🛡️</span>
      <span class="value" id="statArmor">12</span>
    </div>
    <div class="top-stat">
      <span>💀</span>
      <span class="value" id="statKills">0</span>
    </div>
    <div class="top-stat">
      <span>💰</span>
      <span class="value gold" id="statGold">0</span>
    </div>
  </div>
  
  <!-- Zone Title (fades in/out on zone change) -->
  <div id="zoneTitle">
    <h1 id="zoneName">The Ossuary</h1>
    <p id="zoneLevel">Monster Level 1</p>
  </div>
  
  <!-- Dungeon Info (always visible, top right) -->
  <div id="dungeonInfo">
    <span class="dungeon-name" id="dungeonName">Crystal Caves</span>
    <span class="dungeon-details"><span id="dungeonDifficulty">Easy</span> (<span id="dungeonLevel">1</span>) <span class="timer" id="dungeonTimer">0:00</span></span>
  </div>
  
  <!-- Boss Bar -->
  <div id="bossBar">
    <div id="bossName">Goretusk, the Defiler</div>
    <div id="bossHealthContainer">
      <div id="bossHealthFill" style="width: 100%"></div>
      <div class="boss-ticks">
        <div class="boss-tick"></div>
        <div class="boss-tick"></div>
        <div class="boss-tick"></div>
        <div class="boss-tick"></div>
      </div>
      <div id="bossHealthText">100%</div>
    </div>
    <div id="bossDebuffs"></div>
  </div>
  
  <!-- Stats Dashboard Panel -->
  <div id="statsDashboard">
    <div class="stats-header">
      <h2>📊 Session Stats</h2>
      <div class="stats-header-buttons">
        <button class="stats-reset-btn" onclick="resetSessionStats()" title="Reset Stats">↺</button>
        <button class="stats-close-btn" onclick="toggleStatsDashboard()">✕</button>
      </div>
    </div>
    <div class="stats-duration">
      <span class="stats-label">Session Time</span>
      <span id="statDuration" class="stats-value duration">00:00:00</span>
    </div>
    <div class="stats-grid">
      <div class="stat-row">
        <span class="stat-icon">💀</span>
        <span class="stat-name">Kills</span>
        <span id="statKills" class="stat-total">0</span>
        <span id="statKillsHr" class="stat-rate">0/hr</span>
      </div>
      <div class="stat-row">
        <span class="stat-icon">👹</span>
        <span class="stat-name">Bosses</span>
        <span id="statBossKills" class="stat-total">0</span>
        <span class="stat-rate"></span>
      </div>
      <div class="stat-row gold">
        <span class="stat-icon">💰</span>
        <span class="stat-name">Gold</span>
        <span id="statGold" class="stat-total">0</span>
        <span id="statGoldHr" class="stat-rate">0/hr</span>
      </div>
      <div class="stat-row">
        <span class="stat-icon">🗡️</span>
        <span class="stat-name">Items</span>
        <span id="statItems" class="stat-total">0</span>
        <span id="statItemsHr" class="stat-rate">0/hr</span>
      </div>
      <div class="stat-row">
        <span class="stat-icon">♻️</span>
        <span class="stat-name">Salvaged</span>
        <span id="statSalvaged" class="stat-total">0</span>
        <span class="stat-rate"></span>
      </div>
      <div class="stat-row">
        <span class="stat-icon">🔵</span>
        <span class="stat-name">Cores</span>
        <span id="statCores" class="stat-total">0</span>
        <span class="stat-rate"></span>
      </div>
      <div class="stat-row">
        <span class="stat-icon">💎</span>
        <span class="stat-name">Prisms</span>
        <span id="statPrisms" class="stat-total">0</span>
        <span class="stat-rate"></span>
      </div>
      <div class="stat-row legendary">
        <span class="stat-icon">🔮</span>
        <span class="stat-name">Aspects</span>
        <span id="statAspects" class="stat-total">0</span>
        <span class="stat-rate"></span>
      </div>
      <div class="stat-row">
        <span class="stat-icon">⭐</span>
        <span class="stat-name">Best Drop</span>
        <span id="statBestDrop" class="stat-total stars">☆</span>
        <span class="stat-rate"></span>
      </div>
      <div class="stat-row deaths">
        <span class="stat-icon">💀</span>
        <span class="stat-name">Deaths</span>
        <span id="statDeaths" class="stat-total">0</span>
        <span class="stat-rate"></span>
      </div>
    </div>
  </div>
  
  <!-- Inventory Panel - Right Side -->
  <div id="inventoryPanel">
    <div class="inv-header">
      <h2>Inventory</h2>
    </div>
    
    <!-- Main: Equipment Only -->
    <div class="inv-main">
      <!-- Equipment Section -->
      <div class="inv-equipment-section">
        <div class="inv-paperdoll">
          <!-- Weapon - left, rows 1-2 -->
          <div class="equip-slot weapon" id="equip-weapon" data-placeholder="🗡️" onclick="clickEquipSlot('weapon')"></div>
          <!-- Helm - top center -->
          <div class="equip-slot helm" id="equip-helmet" data-placeholder="⛑️" onclick="clickEquipSlot('helmet')"></div>
          <!-- Amulet - right, row 1 (moved from center) -->
          <div class="equip-slot amulet" id="equip-amulet" data-placeholder="📿" onclick="clickEquipSlot('amulet')"></div>
          <!-- Body - rows 2-3 center (enlarged) -->
          <div class="equip-slot body" id="equip-body" data-placeholder="🎽" onclick="clickEquipSlot('body')"></div>
          <!-- Ring1 - row 3 left -->
          <div class="equip-slot ring1" id="equip-ring1" data-placeholder="💍" onclick="clickEquipSlot('ring1')"></div>
          <!-- Ring2 - row 3 right -->
          <div class="equip-slot ring2" id="equip-ring2" data-placeholder="💍" onclick="clickEquipSlot('ring2')"></div>
          <!-- Gloves - row 2 right -->
          <div class="equip-slot gloves" id="equip-gloves" data-placeholder="🧤" onclick="clickEquipSlot('gloves')"></div>
          <!-- Boots - row 4 center -->
          <div class="equip-slot boots" id="equip-boots" data-placeholder="👢" onclick="clickEquipSlot('boots')"></div>
        </div>
        
        <!-- Inline Stats Panel - Two Columns -->
        <div class="equip-stats-container">
          <div class="equip-stats-panel">
            <div class="equip-stats-row">
              <span class="stat-label">STR</span>
              <span class="stat-value" id="eqStr">10</span>
            </div>
            <div class="equip-stats-row">
              <span class="stat-label">DEX</span>
              <span class="stat-value" id="eqDex">10</span>
            </div>
            <div class="equip-stats-row">
              <span class="stat-label">INT</span>
              <span class="stat-value" id="eqInt">10</span>
            </div>
            <div class="equip-stats-divider"></div>
            <div class="equip-stats-row">
              <span class="stat-label">Damage</span>
              <span class="stat-value damage" id="eqDamage">1-2</span>
            </div>
            <div class="equip-stats-row">
              <span class="stat-label">Atk Spd</span>
              <span class="stat-value" id="eqAtkSpd">1.0</span>
            </div>
            <div class="equip-stats-row">
              <span class="stat-label">Crit %</span>
              <span class="stat-value crit" id="eqCritChance">5%</span>
            </div>
            <div class="equip-stats-row">
              <span class="stat-label">Crit Dmg</span>
              <span class="stat-value crit" id="eqCritDmg">150%</span>
            </div>
            <div class="equip-stats-divider"></div>
            <div class="equip-stats-row">
              <span class="stat-label">Armor</span>
              <span class="stat-value defense" id="eqArmor">0</span>
            </div>
            <div class="equip-stats-row">
              <span class="stat-label">Dodge</span>
              <span class="stat-value defense" id="eqDodge">0%</span>
            </div>
            <div class="equip-stats-row">
              <span class="stat-label">Shield</span>
              <span class="stat-value defense" id="eqShield">0</span>
            </div>
          </div>
          <div class="equip-stats-panel">
            <div class="equip-stats-row">
              <span class="stat-label">Life</span>
              <span class="stat-value life" id="eqLife">100</span>
            </div>
            <div class="equip-stats-row">
              <span class="stat-label">Mana</span>
              <span class="stat-value mana" id="eqMana">50</span>
            </div>
            <div class="equip-stats-row">
              <span class="stat-label">Life/Hit</span>
              <span class="stat-value life" id="eqLifeOnHit">1</span>
            </div>
            <div class="equip-stats-row">
              <span class="stat-label">Mana/Hit</span>
              <span class="stat-value mana" id="eqManaOnHit">2</span>
            </div>
            <div class="equip-stats-row">
              <span class="stat-label">Move %</span>
              <span class="stat-value" id="eqMoveSpd">100%</span>
            </div>
            <div class="equip-stats-divider"></div>
            <div class="equip-stats-row">
              <span class="stat-label">🔥 Fire</span>
              <span class="stat-value resist" id="eqFireRes">0%</span>
            </div>
            <div class="equip-stats-row">
              <span class="stat-label">❄️ Cold</span>
              <span class="stat-value resist" id="eqColdRes">0%</span>
            </div>
            <div class="equip-stats-row">
              <span class="stat-label">⚡ Light</span>
              <span class="stat-value resist" id="eqLightRes">0%</span>
            </div>
            <div class="equip-stats-row">
              <span class="stat-label">🌿 Nature</span>
              <span class="stat-value resist" id="eqNatureRes">0%</span>
            </div>
          </div>
        </div>
      </div>
    </div>
    
    <!-- Inventory Grid -->
    <div class="inv-grid-section">
      <div class="inv-grid" id="invGrid"></div>
    </div>
    
    <!-- Gold Bar -->
    <div class="inv-gold-bar">
      <div class="inv-gold-item">
        <span class="icon">💰</span>
        <span class="count" id="invGold">0</span>
      </div>
      <div class="inv-gold-item">
        <span class="icon">🩸</span>
        <span class="count blood">0</span>
      </div>
    </div>
    
    <div class="inv-hint">Press I to close</div>
  </div>
  
  <!-- Item Tooltip -->
  <div class="item-tooltip" id="itemTooltip">
    <div class="tooltip-header" id="tooltipHeader">
      <div class="tooltip-name" id="tooltipName">Item Name</div>
      <div class="tooltip-type" id="tooltipType">One Handed Sword</div>
    </div>
    <div class="tooltip-body" id="tooltipBody">
      <!-- Mods go here -->
    </div>
  </div>
  
  <!-- Equipped Item Comparison Tooltip (shown alongside main tooltip) -->
  <div class="item-tooltip equipped-tooltip" id="equippedTooltip">
    <div class="equipped-tooltip-label">EQUIPPED</div>
    <div class="tooltip-header" id="equippedTooltipHeader">
      <div class="tooltip-name" id="equippedTooltipName">Item Name</div>
      <div class="tooltip-type" id="equippedTooltipType">One Handed Sword</div>
    </div>
    <div class="tooltip-body" id="equippedTooltipBody">
      <!-- Mods go here -->
    </div>
  </div>
  
  <!-- Skill Tooltip -->
  <div class="skill-tooltip" id="skillTooltip">
    <div class="skill-tooltip-name" id="skillTooltipName">Skill Name</div>
    <div class="skill-tooltip-type" id="skillTooltipType">Attack Skill</div>
    <div class="skill-tooltip-desc" id="skillTooltipDesc">Skill description here.</div>
    <div class="skill-tooltip-stats" id="skillTooltipStats"></div>
    <div class="skill-tooltip-cost" id="skillTooltipCost">Mana Cost: 10</div>
  </div>
  
  <!-- Potion Tooltip -->
  <div class="potion-tooltip" id="potionTooltip">
    <div class="potion-tooltip-name" id="potionTooltipName">Potion Name</div>
    <div class="potion-tooltip-type" id="potionTooltipType">CONSUMABLE</div>
    <div class="potion-tooltip-desc" id="potionTooltipDesc">Description</div>
    <div class="potion-tooltip-stats" id="potionTooltipStats"></div>
    <div class="potion-tooltip-footer" id="potionTooltipFooter">Cooldown: 8s</div>
  </div>
  
  <!-- AI Priority Tooltip -->
  <div class="ai-priority-tooltip" id="aiPriorityTooltip">
    <div class="ai-tooltip-header">
      <span class="ai-tooltip-title">AI PRIORITY</span>
      <span class="ai-tooltip-level" id="aiTooltipLevel">Normal</span>
    </div>
    <div class="ai-tooltip-desc" id="aiTooltipDesc">Balanced intelligent usage</div>
    <div class="ai-tooltip-details" id="aiTooltipDetails"></div>
    <div class="ai-tooltip-hint">Click to cycle: Disabled → Conservative → Normal → Aggressive</div>
  </div>
  
  <!-- Buff/Debuff Tooltip -->
  <div class="buff-tooltip" id="buffTooltip">
    <div class="buff-tooltip-name" id="buffTooltipName">Buff Name</div>
    <div class="buff-tooltip-desc" id="buffTooltipDesc">Description</div>
    <div class="buff-tooltip-time" id="buffTooltipTime">5.0s remaining</div>
  </div>
  
  <!-- Currency/Gem Tooltip -->
  <div id="currencyTooltip">
    <div class="currency-tooltip-inner">
      <div class="currency-tooltip-header">
        <span class="currency-tooltip-name" id="currencyTooltipName">Gem Name</span>
        <span class="currency-tooltip-stack" id="currencyTooltipStack">Stack: 0</span>
      </div>
      <div class="currency-tooltip-body" id="currencyTooltipBody">
        <!-- Effects go here -->
      </div>
    </div>
  </div>
  
  <!-- Enemy Tooltip -->
  <div class="enemy-tooltip" id="enemyTooltip">
    <div class="enemy-tooltip-name" id="enemyTooltipName">Enemy Name</div>
    <div class="enemy-tooltip-type" id="enemyTooltipType">Monster</div>
    <div class="enemy-tooltip-hp" id="enemyTooltipHp">HP: 10/10</div>
    <div class="enemy-tooltip-hp-bar">
      <div class="enemy-tooltip-hp-fill" id="enemyTooltipHpFill" style="width: 100%"></div>
    </div>
    <div class="enemy-tooltip-stat">Damage: <span id="enemyTooltipDmg">2-4</span></div>
    <div class="enemy-tooltip-stat">Speed: <span id="enemyTooltipSpd">1.0</span></div>
  </div>
  
  <!-- Shop Panel (S key) -->
  <div id="shopPanel">
    <div class="shop-header">
      <div class="shop-header-left">
        <button class="shop-header-btn play" onclick="toggleShop()">PLAY</button>
        <button class="shop-header-btn shop-active">SHOP</button>
      </div>
      <div class="shop-gold-display" id="shopGold">0</div>
      <div class="shop-header-right">
        <button class="shop-tab active" data-tab="cosmetics">Cosmetics</button>
        <button class="shop-tab" data-tab="addons">Add Ons</button>
      </div>
      <button class="shop-close" onclick="toggleShop()">✕</button>
    </div>
    <div class="shop-content">
      <div class="shop-section-title" id="shopSectionTitle">Monk Appearances</div>
      <div class="shop-grid" id="shopGrid">
        <!-- Cards will be generated by JS -->
      </div>
    </div>
  </div>
  
  <!-- Character Stats Panel (C key) -->
  <div class="char-panel" id="charPanel">
    <div class="char-panel-header">
      <h2>Character</h2>
      <button class="char-panel-close" onclick="toggleCharPanel()">✕</button>
    </div>
    <div class="char-panel-content">
      <!-- Character Info -->
      <div class="char-info-row">
        <div class="char-info-left">
          <div class="char-name" id="charName">Exile</div>
          <div class="char-level-info">Level <span id="charLevelNum">1</span></div>
        </div>
        <div class="char-info-right">
          <div class="char-attr-row" onmouseenter="showStatTooltip('str', event)" onmouseleave="hideStatTooltip()">Strength <span style="color:#555;font-size:8px;">ⓘ</span> <span id="charStr">10</span></div>
          <div class="char-attr-row" onmouseenter="showStatTooltip('dex', event)" onmouseleave="hideStatTooltip()">Dexterity <span style="color:#555;font-size:8px;">ⓘ</span> <span id="charDex">10</span></div>
          <div class="char-attr-row" onmouseenter="showStatTooltip('int', event)" onmouseleave="hideStatTooltip()">Intelligence <span style="color:#555;font-size:8px;">ⓘ</span> <span id="charInt">10</span></div>
        </div>
      </div>
      
      <!-- Core Stats - Top Row -->
      <div class="char-stats-grid">
        <div class="char-stat-box life" onmouseenter="showStatTooltip('life', event)" onmouseleave="hideStatTooltip()">
          <div class="char-stat-icon">❤️</div>
          <div class="char-stat-label">Life</div>
          <div class="char-stat-value" id="charLife">80</div>
        </div>
        <div class="char-stat-box mana" onmouseenter="showStatTooltip('mana', event)" onmouseleave="hideStatTooltip()">
          <div class="char-stat-icon">💧</div>
          <div class="char-stat-label">Mana</div>
          <div class="char-stat-value" id="charMana">40</div>
        </div>
        <div class="char-stat-box damage" onmouseenter="showStatTooltip('damage', event)" onmouseleave="hideStatTooltip()">
          <div class="char-stat-icon">⚔️</div>
          <div class="char-stat-label">Damage</div>
          <div class="char-stat-value" id="charDamage">8-14</div>
        </div>
        <div class="char-stat-box atkspd" onmouseenter="showStatTooltip('atkspd', event)" onmouseleave="hideStatTooltip()">
          <div class="char-stat-icon">🗡️</div>
          <div class="char-stat-label">Attack Speed</div>
          <div class="char-stat-value" id="charAtkSpd">0.80</div>
        </div>
      </div>
      
      <!-- Defense Stats - Second Row -->
      <div class="char-defense-row">
        <div class="char-defense-box" onmouseenter="showStatTooltip('armor', event)" onmouseleave="hideStatTooltip()">
          <div class="char-defense-icon">🛡️</div>
          <div class="char-defense-label">Armor</div>
          <div class="char-defense-value" id="charArmor">5</div>
        </div>
        <div class="char-defense-box" onmouseenter="showStatTooltip('dodge', event)" onmouseleave="hideStatTooltip()">
          <div class="char-defense-icon">👁️</div>
          <div class="char-defense-label">Dodge</div>
          <div class="char-defense-value" id="charDodge">0%</div>
        </div>
        <div class="char-defense-box" onmouseenter="showStatTooltip('shield', event)" onmouseleave="hideStatTooltip()">
          <div class="char-defense-icon">🔷</div>
          <div class="char-defense-label">Shield</div>
          <div class="char-defense-value" id="charShield">0</div>
        </div>
      </div>
      
      <!-- Resistances -->
      <div class="char-res-header">Resistances</div>
      <div class="char-res-grid">
        <div class="char-res-box fire" onmouseenter="showResTooltip('fire', event)" onmouseleave="hideResTooltip()">
          <div class="char-res-icon">🔥</div>
          <div class="char-res-info">
            <div class="char-res-label">Fire</div>
            <div class="char-res-value"><span id="charFireRes">0%</span> <span class="char-res-uncapped" id="charFireResUncapped">(0%)</span></div>
          </div>
        </div>
        <div class="char-res-box cold" onmouseenter="showResTooltip('cold', event)" onmouseleave="hideResTooltip()">
          <div class="char-res-icon">❄️</div>
          <div class="char-res-info">
            <div class="char-res-label">Cold</div>
            <div class="char-res-value"><span id="charColdRes">0%</span> <span class="char-res-uncapped" id="charColdResUncapped">(0%)</span></div>
          </div>
        </div>
        <div class="char-res-box lightning" onmouseenter="showResTooltip('lightning', event)" onmouseleave="hideResTooltip()">
          <div class="char-res-icon">⚡</div>
          <div class="char-res-info">
            <div class="char-res-label">Lightning</div>
            <div class="char-res-value"><span id="charLightRes">0%</span> <span class="char-res-uncapped" id="charLightResUncapped">(0%)</span></div>
          </div>
        </div>
        <div class="char-res-box nature" onmouseenter="showResTooltip('nature', event)" onmouseleave="hideResTooltip()">
          <div class="char-res-icon">🌿</div>
          <div class="char-res-info">
            <div class="char-res-label">Nature</div>
            <div class="char-res-value"><span id="charNatureRes">0%</span> <span class="char-res-uncapped" id="charNatureResUncapped">(0%)</span></div>
          </div>
        </div>
      </div>
      
      <!-- On-Hit Stats -->
      <div class="char-onhit-row">
        <div class="char-onhit-box">
          <div class="char-onhit-icon">❤️</div>
          <div>
            <div class="char-onhit-label">Life on Hit</div>
            <div class="char-onhit-value" id="charLifeOnHit">+1</div>
          </div>
        </div>
        <div class="char-onhit-box">
          <div class="char-onhit-icon">💧</div>
          <div>
            <div class="char-onhit-label">Mana on Hit</div>
            <div class="char-onhit-value" id="charManaOnHit">+2</div>
          </div>
        </div>
      </div>
      
      <!-- Offense Stats -->
      <div class="char-res-header">Offense</div>
      <div class="char-stats-mini-grid">
        <div class="char-stat-mini">
          <span class="char-stat-mini-label">Crit Chance</span>
          <span class="char-stat-mini-value" id="charCritChance">5%</span>
        </div>
        <div class="char-stat-mini">
          <span class="char-stat-mini-label">Crit Damage</span>
          <span class="char-stat-mini-value" id="charCritDmg">150%</span>
        </div>
        <div class="char-stat-mini">
          <span class="char-stat-mini-label">Phys Damage %</span>
          <span class="char-stat-mini-value" id="charPhysDmgPct">0%</span>
        </div>
        <div class="char-stat-mini">
          <span class="char-stat-mini-label">Elemental Damage %</span>
          <span class="char-stat-mini-value" id="charEleDmgPct">0%</span>
        </div>
      </div>
      
      <!-- Utility Stats -->
      <div class="char-res-header">Utility</div>
      <div class="char-stats-mini-grid">
        <div class="char-stat-mini">
          <span class="char-stat-mini-label">Movement Speed</span>
          <span class="char-stat-mini-value" id="charMoveSpeed">100%</span>
        </div>
        <div class="char-stat-mini">
          <span class="char-stat-mini-label">Cast Speed</span>
          <span class="char-stat-mini-value" id="charCastSpeed">0%</span>
        </div>
        <div class="char-stat-mini">
          <span class="char-stat-mini-label">Cooldown Recovery</span>
          <span class="char-stat-mini-value" id="charCDR">0%</span>
        </div>
        <div class="char-stat-mini">
          <span class="char-stat-mini-label">Flask Charges</span>
          <span class="char-stat-mini-value" id="charFlaskCharges">0%</span>
        </div>
      </div>
      
      <!-- Level Badge -->
      <div class="char-level-badge" id="charLevelBadge">Level 1 Exile</div>
    </div>
  </div>
  
  <!-- Aspect Codex Panel (A key) -->
  <div class="aspect-panel" id="aspectPanel">
    <div class="aspect-panel-header">
      <div class="aspect-panel-title">Aspect Codex</div>
      <button class="aspect-panel-close" onclick="toggleAspectPanel()">✕</button>
    </div>
    
    <!-- Active Aspects Section -->
    <div class="active-aspects-section">
      <div class="active-aspects-header">
        <span class="active-aspects-title">Active Aspects</span>
        <span class="active-aspects-count" id="activeAspectsCount">0/3</span>
      </div>
      <div class="active-aspects-slots" id="activeAspectsSlots">
        <div class="active-aspect-slot empty" data-slot="0" onclick="clickActiveAspectSlot(0)"></div>
        <div class="active-aspect-slot empty" data-slot="1" onclick="clickActiveAspectSlot(1)"></div>
        <div class="active-aspect-slot empty" data-slot="2" onclick="clickActiveAspectSlot(2)"></div>
        <div class="active-aspect-slot locked" data-slot="3"></div>
        <div class="active-aspect-slot locked" data-slot="4"></div>
      </div>
    </div>
    
    <div class="aspect-tabs">
      <button class="aspect-tab active" data-filter="all" onclick="filterAspects('all')">All</button>
      <button class="aspect-tab" data-filter="warrior" onclick="filterAspects('warrior')">Warrior</button>
      <button class="aspect-tab" data-filter="monk" onclick="filterAspects('monk')">Monk</button>
      <button class="aspect-tab" data-filter="ranger" onclick="filterAspects('ranger')">Ranger</button>
      <button class="aspect-tab" data-filter="mage" onclick="filterAspects('mage')">Mage</button>
    </div>
    <div class="aspect-panel-body">
      <div class="aspect-sidebar">
        <div class="aspect-sidebar-section">
          <div class="aspect-sidebar-label">Collection</div>
          <div class="aspect-rarity-row" data-rarity="common" onclick="filterByRarity('common')">
            <span class="aspect-rarity-name common">Common</span>
            <span class="aspect-rarity-count" id="aspectCountCommon">0/0</span>
          </div>
          <div class="aspect-rarity-row" data-rarity="rare" onclick="filterByRarity('rare')">
            <span class="aspect-rarity-name rare">Rare</span>
            <span class="aspect-rarity-count" id="aspectCountRare">0/1</span>
          </div>
          <div class="aspect-rarity-row" data-rarity="legendary" onclick="filterByRarity('legendary')">
            <span class="aspect-rarity-name legendary">Legendary</span>
            <span class="aspect-rarity-count" id="aspectCountLegendary">0/0</span>
          </div>
        </div>
        <label class="aspect-myclass-toggle">
          <input type="checkbox" id="aspectMyClassOnly" onchange="renderAspectGrid()">
          Show my class only
        </label>
      </div>
      <div class="aspect-grid-container">
        <div class="aspect-grid-header">
          <span class="aspect-grid-title" id="aspectGridTitle">ALL</span>
          <span class="aspect-grid-count" id="aspectGridCount">(0/1)</span>
        </div>
        <div class="aspect-grid" id="aspectGrid">
          <!-- Aspect slots populated by JS -->
        </div>
      </div>
      <div class="aspect-detail" id="aspectDetail">
        <div class="aspect-detail-empty">Select an aspect to view details</div>
      </div>
    </div>
  </div>
  
  <!-- Aspect Discovery Popup -->
  <div class="aspect-discovery" id="aspectDiscovery">
    <div class="aspect-discovery-title">✨ New Aspect Discovered! ✨</div>
    <div class="aspect-discovery-icon" id="aspectDiscoveryIcon">🏹</div>
    <div class="aspect-discovery-name" id="aspectDiscoveryName">Sentry x2</div>
    <div class="aspect-discovery-desc" id="aspectDiscoveryDesc">Every Sentry summon now spawns 2 turrets instead of 1.</div>
    <div class="aspect-discovery-note">🌐 Active on ALL characters permanently!</div>
    <button class="aspect-discovery-close" onclick="closeAspectDiscovery()">Continue</button>
  </div>
  
  <!-- Passive Skill Tree Panel (P key) -->
  <div id="passiveTreePanel">
    <div class="passive-tree-header">
      <div class="passive-tree-title">⚡ Passive Skill Tree</div>
      <div class="passive-tree-points">
        <span>Points Available: <span class="available" id="passivePointsAvailable">0</span></span>
        <span>Points Allocated: <span id="passivePointsAllocated">0</span></span>
      </div>
      <button class="passive-tree-close" onclick="togglePassiveTree()">✕</button>
    </div>
    <div class="passive-tree-container">
      <canvas id="passiveTreeCanvas"></canvas>
      <div class="passive-tree-legend">
        <div class="legend-title">Node Types</div>
        <div class="legend-item"><div class="legend-node small"></div> Small Node</div>
        <div class="legend-item"><div class="legend-node notable"></div> Notable</div>
        <div class="legend-item"><div class="legend-node keystone"></div> Keystone</div>
      </div>
      <div class="passive-tree-controls">
        <button class="tree-control-btn" onclick="zoomPassiveTree(1.2)" title="Zoom In">+</button>
        <button class="tree-control-btn" onclick="zoomPassiveTree(0.8)" title="Zoom Out">−</button>
        <button class="tree-control-btn" onclick="centerPassiveTree()" title="Center">⌖</button>
      </div>
      <button class="passive-tree-respec" onclick="showRespecConfirm()">🔄 Respec All (500g)</button>
    </div>
  </div>
  
  <!-- Passive Node Tooltip -->
  <div id="passiveNodeTooltip">
    <div class="node-tooltip-name" id="nodeTooltipName">Node Name</div>
    <div class="node-tooltip-type" id="nodeTooltipType">Small Node</div>
    <div class="node-tooltip-stats" id="nodeTooltipStats"></div>
    <div class="node-tooltip-hint" id="nodeTooltipHint">Click to allocate</div>
  </div>
  
  <!-- Leaderboard Panel (L key) -->
  <div id="leaderboardPanel">
    <div class="leaderboard-header">
      <div class="leaderboard-title">🏆 LEADERBOARDS</div>
      <button class="leaderboard-close" onclick="toggleLeaderboard()">✕</button>
    </div>
    <div class="leaderboard-filters">
      <button class="leaderboard-filter active" data-filter="all" onclick="setLeaderboardFilter('all')">All Classes</button>
      <button class="leaderboard-filter" data-filter="warrior" onclick="setLeaderboardFilter('warrior')">⚔️ Warrior</button>
      <button class="leaderboard-filter" data-filter="monk" onclick="setLeaderboardFilter('monk')">🥋 Monk</button>
      <button class="leaderboard-filter" data-filter="ranger" onclick="setLeaderboardFilter('ranger')">🏹 Ranger</button>
      <button class="leaderboard-filter" data-filter="mage" onclick="setLeaderboardFilter('mage')">🔮 Mage</button>
    </div>
    <div class="leaderboard-content">
      <div class="leaderboard-table-header">
        <span class="lb-col-rank">Rank</span>
        <span class="lb-col-name">Name</span>
        <span class="lb-col-class">Class</span>
        <span class="lb-col-level">Level</span>
      </div>
      <div class="leaderboard-table-body" id="leaderboardTableBody">
        <!-- Populated by JS -->
      </div>
    </div>
    <div class="leaderboard-footer">
      <span id="leaderboardStatus">⚠️ Steam integration required for online leaderboards</span>
      <span id="leaderboardLastUpdate">Last Updated: --</span>
    </div>
  </div>
  
  <!-- Stash Panel - Left Side -->
  <div id="stashPanel">
    <div class="stash-header">
      <h2>Stash</h2>
    </div>
    
    <!-- Stash Tabs -->
    <div class="stash-tabs-container">
      <div class="stash-tabs" id="stashTabsRow">
        <!-- Tabs will be rendered dynamically -->
      </div>
      <button class="stash-add-tab" onclick="buyNewStashTab()" title="Open Store Add-ons">+</button>
    </div>
    
    <!-- Stash Content -->
    <div class="stash-content">
      <!-- Main Stash Tab - Large Grid -->
      <div class="stash-tab-content active" id="tab-stash">
        <div class="stash-large-grid" id="stashGrid"></div>
      </div>
      
      <!-- Crafting Tab - Organized Layout -->
      <div class="stash-tab-content" id="tab-currency">
        <!-- Crafting Area -->
        <div class="crafting-area">
          <div class="crafting-slot" id="craftingSlot" onclick="clearCraftingSlot()">
            <span class="placeholder">Click an item<br>in inventory<br>to craft</span>
          </div>
          <div class="crafting-info">
            <div class="crafting-info-title">Preview</div>
            <div class="crafting-mods" id="craftingMods">
              <div style="color: #504030; font-style: italic; text-align: center; padding: 20px;">No item selected</div>
            </div>
          </div>
        </div>
        
        <div class="currency-layout">
          <!-- Basic Cores -->
          <div class="currency-section">
            <div class="currency-section-title">Basic Cores</div>
            <div class="currency-grid">
              <div class="currency-item basic clickable" onclick="applyCraft('transmute')" onmouseenter="showCurrencyTooltip('transmute', event)" onmouseleave="hideCurrencyTooltip()">
                <span class="count" id="stash-transmute">0</span>
                <span class="icon">🔵</span>
              </div>
              <div class="currency-item basic clickable" onclick="applyCraft('augment')" onmouseenter="showCurrencyTooltip('augment', event)" onmouseleave="hideCurrencyTooltip()">
                <span class="count" id="stash-augment">0</span>
                <span class="icon">🟢</span>
              </div>
              <div class="currency-item rare clickable" onclick="applyCraft('upgrade')" onmouseenter="showCurrencyTooltip('upgrade', event)" onmouseleave="hideCurrencyTooltip()">
                <span class="count" id="stash-upgrade">0</span>
                <span class="icon">💠</span>
              </div>
              <div class="currency-item legendary clickable" onclick="applyCraft('rare')" onmouseenter="showCurrencyTooltip('rare', event)" onmouseleave="hideCurrencyTooltip()">
                <span class="count" id="stash-rare">0</span>
                <span class="icon">⭐</span>
              </div>
            </div>
          </div>
          
          <!-- Advanced Cores -->
          <div class="currency-section">
            <div class="currency-section-title">Advanced Cores</div>
            <div class="currency-grid">
              <div class="currency-item rare clickable" onclick="applyCraft('wild')" onmouseenter="showCurrencyTooltip('wild', event)" onmouseleave="hideCurrencyTooltip()">
                <span class="count" id="stash-wild">0</span>
                <span class="icon">🌀</span>
              </div>
              <div class="currency-item legendary clickable" onclick="applyCraft('echo')" onmouseenter="showCurrencyTooltip('echo', event)" onmouseleave="hideCurrencyTooltip()">
                <span class="count" id="stash-echo">0</span>
                <span class="icon">✨</span>
              </div>
              <div class="currency-item rare clickable" onclick="applyCraft('annul')" onmouseenter="showCurrencyTooltip('annul', event)" onmouseleave="hideCurrencyTooltip()">
                <span class="count" id="stash-annul">0</span>
                <span class="icon">⚪</span>
              </div>
              <div class="currency-item unique clickable" onclick="confirmUncontrolled()" onmouseenter="showCurrencyTooltip('vaal', event)" onmouseleave="hideCurrencyTooltip()">
                <span class="count" id="stash-vaal">0</span>
                <span class="icon">🔴</span>
              </div>
            </div>
          </div>
          
          <!-- Quality Items -->
          <div class="currency-section">
            <div class="currency-section-title">Quality</div>
            <div class="currency-grid">
              <div class="currency-item basic clickable" onclick="applyCraft('armorer')" onmouseenter="showCurrencyTooltip('armorer', event)" onmouseleave="hideCurrencyTooltip()">
                <span class="count" id="stash-armorer">0</span>
                <span class="icon">🛡️</span>
              </div>
              <div class="currency-item basic clickable" onclick="applyCraft('whetstone')" onmouseenter="showCurrencyTooltip('whetstone', event)" onmouseleave="hideCurrencyTooltip()">
                <span class="count" id="stash-whetstone">0</span>
                <span class="icon">⚔️</span>
              </div>
            </div>
          </div>
          
          <!-- Socket Currency -->
          <div class="currency-section">
            <div class="currency-section-title">Sockets</div>
            <div class="currency-grid">
              <div class="currency-item basic clickable" onclick="applyCraft('jeweller')" onmouseenter="showCurrencyTooltip('jeweller', event)" onmouseleave="hideCurrencyTooltip()">
                <span class="count" id="stash-jeweller">0</span>
                <span class="icon">💍</span>
              </div>
            </div>
          </div>
          
          <!-- Gems (socket into gear) -->
          <div class="currency-section full-width">
            <div class="currency-section-title">Gems (click to socket into selected item)</div>
            <div id="gemInventoryDisplay" class="currency-grid" style="max-height: 120px; overflow-y: auto;">
              <!-- Populated by updateGemInventoryDisplay() -->
            </div>
            <div style="margin-top: 8px; display: flex; gap: 8px; align-items: center;">
              <div class="currency-item magic" style="cursor: default;">
                <span class="count" id="stash-gemcuttersPrism">0</span>
                <span class="icon">💎</span>
              </div>
              <button onclick="openGemQualityModal()" style="padding: 4px 8px; font-size: 11px; background: #2a3a2a; border: 1px solid #4a6a4a; color: #8c8; cursor: pointer; border-radius: 3px;">
                Use Gemcutter's Prism
              </button>
            </div>
          </div>
        </div>
      </div>
      
      <!-- Loot Tab - AFK Loot Collection -->
      <div class="stash-tab-content" id="tab-overflow">
        <div class="overflow-container">
          <div class="overflow-header">
            <div class="overflow-info">
              <span class="overflow-capacity" id="overflowCapacity">0 / 20</span> items <span style="color:#666;font-size:10px;">(sorted by quality)</span>
              <span class="overflow-mode-indicator" id="overflowModeIndicator">Mode: Move to Stash</span>
            </div>
            <div class="overflow-actions">
              <button class="overflow-btn mode" id="overflowMoveMode" onclick="toggleOverflowMode('move')" title="MOVE MODE&#10;&#10;Click items to move them to inventory.&#10;Click again to exit mode.">📥 Move</button>
              <button class="overflow-btn mode" id="overflowSalvageMode" onclick="toggleOverflowMode('salvage')" title="SALVAGE MODE&#10;&#10;Click items to salvage them.&#10;Click again to exit mode.">♻️ Salvage</button>
              <button class="overflow-btn danger" onclick="salvageAllOverflow()" title="⚠️ SALVAGE ALL ITEMS&#10;&#10;DESTROYS all loot tab items!&#10;Most items yield nothing.&#10;Rare+ items have better odds.&#10;💎 All socketed gems will be returned.">🗑️ Salvage All</button>
            </div>
          </div>
          <div class="overflow-list" id="overflowList">
            <div class="overflow-empty">
              <div class="overflow-empty-icon">📦</div>
              <div>Loot tab is empty</div>
              <div style="margin-top: 8px; font-size: 11px; color: #555;">Items go here when inventory & stash are full</div>
              <div style="margin-top: 4px; font-size: 10px; color: #444;">Best items kept when full · Worst auto-salvaged</div>
            </div>
          </div>
        </div>
      </div>
    </div>
    
    <div class="stash-footer">Press TAB to close</div>
  </div>
  
  <!-- Store Modal for Add-ons -->
  <div id="storeModal" onclick="if(event.target === this) closeStoreModal()">
    <div class="store-content">
      <div class="store-header">
        <span class="store-title">🏪 STORE ADD-ONS</span>
        <button class="store-close" onclick="closeStoreModal()">✕</button>
      </div>
      <div class="store-body">
        <div class="store-section-title">STORAGE UPGRADES</div>
        
        <div class="store-item">
          <div class="store-item-icon">📦</div>
          <div class="store-item-info">
            <div class="store-item-name">Extra Stash Tab</div>
            <div class="store-item-desc">Add another 64-slot stash tab for storing items. Name and organize your collection!</div>
          </div>
          <div class="store-item-price">
            <span class="store-price-tag">1,000g</span>
            <button class="store-buy-btn" onclick="purchaseStashTab()">BUY</button>
          </div>
        </div>
        
        <div class="store-item">
          <div class="store-item-icon">📥</div>
          <div class="store-item-info">
            <div class="store-item-name">Loot Tab Capacity +25</div>
            <div class="store-item-desc">Increase your loot tab storage by 25 slots. Current: <span id="storeCurrentOverflow">20</span> slots</div>
          </div>
          <div class="store-item-price">
            <span class="store-price-tag">2,500g</span>
            <button class="store-buy-btn" onclick="purchaseOverflowUpgrade()">BUY</button>
          </div>
        </div>
        
        <div class="store-gold-display">
          <div class="store-gold-label">YOUR GOLD</div>
          <div class="store-gold-amount" id="storeGoldAmount">0</div>
        </div>
      </div>
    </div>
  </div>
  
  <!-- Toast Notification -->
  <div id="toastNotification" class="toast-notification">
    <span class="toast-icon" id="toastIcon">📦</span>
    <div class="toast-content">
      <div class="toast-title" id="toastTitle">Inventory Full</div>
      <div class="toast-message" id="toastMessage">Make room in your inventory first</div>
    </div>
  </div>
  
  <!-- Dungeon & Shards Modal -->
  <div id="dungeonModal" class="dungeon-modal" onclick="if(event.target === this) closeDungeonSelector()">
    <div class="dungeon-content">
      <div class="dungeon-header">
        <div class="dungeon-tabs">
          <button class="dungeon-tab active" id="tabDungeons" onclick="switchDungeonTab('dungeons')">Dungeons</button>
          <button class="dungeon-tab" id="tabShards" onclick="switchDungeonTab('shards')">Shards</button>
          <button class="dungeon-tab gr-tab" id="tabGreaterRifts" onclick="switchDungeonTab('greaterRifts')">Greater Rifts</button>
        </div>
        <button class="dungeon-close" onclick="closeDungeonSelector()">✕</button>
      </div>
      
      <!-- Dungeons Tab -->
      <div class="dungeon-tab-content active" id="dungeonTabContent">
        <div class="dungeon-current">
          Current: <span id="currentDiffName">Easy</span> (ilvl <span id="currentDiffIlvl">1-20</span>)
        </div>
        <div class="dungeon-grid" id="dungeonGrid">
          <!-- Populated by JavaScript -->
        </div>
        <div class="dungeon-footer">
          <div class="dungeon-hint">Lower tier number = better affix rolls (T1 is best, T8 is worst)</div>
          <div class="dungeon-hint">Difficulty sets the best POSSIBLE tier — not guaranteed, just unlocked</div>
        </div>
      </div>
      
      <!-- Shards Tab -->
      <div class="dungeon-tab-content" id="shardsTabContent">
        <div class="shards-intro">
          <div class="shards-intro-title">Shard Encounters</div>
          <div class="shards-intro-text">Shards are collected from enemies in all dungeons. Spend them to activate special encounters with increased risk and rewards.</div>
        </div>
        
        <div class="shard-mechanics-grid">
          <!-- Rift Surge - Active -->
          <div class="shard-mechanic rift-surge" id="riftSurgeMechanic">
            <div class="shard-mechanic-header">
              <span class="shard-icon">🌀</span>
              <span class="shard-mechanic-name">Rift Surge</span>
            </div>
            <div class="shard-mechanic-desc">Timed gauntlet. Kill enemies before time runs out. More kills = more loot.</div>
            
            <div class="shard-gate-visual">
              <div class="shard-gate-frame">
                <div class="shard-count-display">
                  <span class="shard-count" id="riftShardCount">0</span>
                  <span class="shard-label">Rift Shards</span>
                </div>
              </div>
            </div>
            
            <div class="shard-tiers-vertical">
              <!-- Tier 1: Stable Rift -->
              <div class="shard-tier-card tier-stable" onclick="activateRiftSurge(1)">
                <div class="shard-tier-badge">I</div>
                <div class="shard-tier-info">
                  <div class="shard-tier-name">Stable Rift</div>
                </div>
                <div class="shard-tier-cost-box">
                  <span class="shard-tier-cost">50</span>
                  <span class="shard-tier-cost-label">shards</span>
                </div>
              </div>
              
              <!-- Tier 2: Unstable Rift -->
              <div class="shard-tier-card tier-unstable" onclick="activateRiftSurge(2)">
                <div class="shard-tier-badge">II</div>
                <div class="shard-tier-info">
                  <div class="shard-tier-name">Unstable Rift</div>
                </div>
                <div class="shard-tier-cost-box">
                  <span class="shard-tier-cost">75</span>
                  <span class="shard-tier-cost-label">shards</span>
                </div>
              </div>
              
              <!-- Tier 3: Fractured Rift -->
              <div class="shard-tier-card tier-fractured" onclick="activateRiftSurge(3)">
                <div class="shard-tier-badge">III</div>
                <div class="shard-tier-info">
                  <div class="shard-tier-name">Fractured Rift</div>
                </div>
                <div class="shard-tier-cost-box">
                  <span class="shard-tier-cost">100</span>
                  <span class="shard-tier-cost-label">shards</span>
                </div>
              </div>
            </div>
          </div>
          
          <!-- Echo Domain - Active -->
          <div class="shard-mechanic echo-domain" id="echoDomainMechanic">
            <div class="shard-mechanic-header">
              <span class="shard-icon">🔮</span>
              <span class="shard-mechanic-name">Echo Domain</span>
            </div>
            <div class="shard-mechanic-desc">Explore rooms and defeat the Echo Overlord to escape.</div>
            
            <div class="shard-gate-visual">
              <div class="shard-gate-frame">
                <div class="shard-count-display">
                  <span class="shard-count" id="echoShardCount">0</span>
                  <span class="shard-label">Echo Shards</span>
                </div>
              </div>
            </div>
            
            <div class="shard-tiers-vertical">
              <!-- Tier 1: Fading Echo -->
              <div class="shard-tier-card tier-stable" onclick="activateEchoDomain(1)">
                <div class="shard-tier-badge">I</div>
                <div class="shard-tier-info">
                  <div class="shard-tier-name">Fading Echo</div>
                </div>
                <div class="shard-tier-cost-box">
                  <span class="shard-tier-cost">50</span>
                  <span class="shard-tier-cost-label">shards</span>
                </div>
              </div>
              
              <!-- Tier 2: Resonant Echo -->
              <div class="shard-tier-card tier-unstable" onclick="activateEchoDomain(2)">
                <div class="shard-tier-badge">II</div>
                <div class="shard-tier-info">
                  <div class="shard-tier-name">Resonant Echo</div>
                </div>
                <div class="shard-tier-cost-box">
                  <span class="shard-tier-cost">75</span>
                  <span class="shard-tier-cost-label">shards</span>
                </div>
              </div>
              
              <!-- Tier 3: Shattered Echo -->
              <div class="shard-tier-card tier-fractured" onclick="activateEchoDomain(3)">
                <div class="shard-tier-badge">III</div>
                <div class="shard-tier-info">
                  <div class="shard-tier-name">Shattered Echo</div>
                </div>
                <div class="shard-tier-cost-box">
                  <span class="shard-tier-cost">100</span>
                  <span class="shard-tier-cost-label">shards</span>
                </div>
              </div>
            </div>
          </div>
        </div>
        
        <div class="dungeon-footer">
          <div class="dungeon-hint">Higher shard cost = harder content = better rewards</div>
          <div class="dungeon-hint">Rift Surge: Speed & quantity | Echo Domain: Risk & crafting power</div>
        </div>
      </div>
      
      <!-- Greater Rifts Tab -->
      <div class="dungeon-tab-content gr-tab-content" id="greaterRiftsTabContent">
        <div class="gr-intro">
          <div class="gr-intro-title">Greater Rifts</div>
          <div class="gr-intro-text">Push your limits! Infinitely scaling dungeons with a 5-minute timer. Kill enemies to fill the progress bar, then defeat the Rift Guardian.</div>
        </div>
        
        <div class="gr-main-panel">
          <div class="gr-gold-display">
            <span class="gr-gold-icon">💰</span>
            <span class="gr-gold-label">Gold Cost:</span>
            <span class="gr-gold-info">Scales with level (500g base)</span>
          </div>
          
          <div class="gr-records">
            <div class="gr-record-title">🏆 Personal Bests</div>
            <div class="gr-record-grid" id="grRecordGrid">
              <div class="gr-record-item"><span class="gr-class-icon">🥋</span> Monk: <span id="grRecordMonk">-</span></div>
              <div class="gr-record-item"><span class="gr-class-icon">⚔️</span> Warrior: <span id="grRecordWarrior">-</span></div>
              <div class="gr-record-item"><span class="gr-class-icon">🏹</span> Ranger: <span id="grRecordRanger">-</span></div>
              <div class="gr-record-item"><span class="gr-class-icon">🔮</span> Mage: <span id="grRecordMage">-</span></div>
            </div>
          </div>
          
          <button class="gr-open-btn" onclick="openGreaterRiftModal()">
            ⚔️ Open Greater Rift
          </button>
          
          <div class="gr-hint">Higher levels cost more gold but give better rewards!</div>
        </div>
      </div>
    </div>
  </div>
  
    <canvas id="minimapCanvas" width="180" height="180"></canvas>
  </div>
  
  <!-- Hotkey Menu (press Escape) -->
  <div id="hotkeyMenu">
    <div class="hotkey-header">
      <h2>⚙️ Game Menu</h2>
      <button class="hotkey-close" onclick="toggleHotkeyMenu()">✕</button>
    </div>
    <div class="hotkey-content">
      <div class="hotkey-section">
        <div class="hotkey-section-title">Panels</div>
        <div class="hotkey-row"><span class="hotkey-action">Inventory</span><span class="hotkey-key">I</span></div>
        <div class="hotkey-row"><span class="hotkey-action">Character</span><span class="hotkey-key">C</span></div>
        <div class="hotkey-row"><span class="hotkey-action">Aspects</span><span class="hotkey-key">A</span></div>
        <div class="hotkey-row"><span class="hotkey-action">Stash</span><span class="hotkey-key">Tab</span></div>
        <div class="hotkey-row"><span class="hotkey-action">Shop</span><span class="hotkey-key">S</span></div>
        <div class="hotkey-row"><span class="hotkey-action">Dungeon Select</span><span class="hotkey-key">D</span></div>
        <div class="hotkey-row"><span class="hotkey-action">Disengage Rift</span><span class="hotkey-key">R</span></div>
      </div>
      <div class="hotkey-section">
        <div class="hotkey-section-title">Skills (Click icon to select)</div>
        <div class="hotkey-row"><span class="hotkey-action">Skill Slot 1</span><span class="hotkey-key">1</span></div>
        <div class="hotkey-row"><span class="hotkey-action">Skill Slot 2</span><span class="hotkey-key">2</span></div>
        <div class="hotkey-row"><span class="hotkey-action">Skill Slot 3</span><span class="hotkey-key">3</span></div>
        <div class="hotkey-row"><span class="hotkey-action">Skill Slot 4</span><span class="hotkey-key">4</span></div>
        <div class="hotkey-row"><span class="hotkey-action">Skill Slot 5</span><span class="hotkey-key">5</span></div>
      </div>
      <div class="hotkey-section">
        <div class="hotkey-section-title">Other</div>
        <div class="hotkey-row"><span class="hotkey-action">Debug Mode</span><span class="hotkey-key">D</span></div>
        <div class="hotkey-row"><span class="hotkey-action">Force Enter Portal</span><span class="hotkey-key">E</span></div>
        <div class="hotkey-row"><span class="hotkey-action">Compare Items</span><span class="hotkey-key">Alt</span></div>
      </div>
    </div>
    <div class="hotkey-footer">
      <button class="hotkey-mainmenu-btn" onclick="returnToMainMenu()">Main Menu</button>
      <button class="hotkey-resume-btn" onclick="toggleHotkeyMenu()">Resume Game</button>
    </div>
  </div>

  <!-- Skill Selector Panel -->
  <div id="skillSelector">
    <div class="skill-selector-header">
      <span class="skill-selector-title">Select Skill</span>
      <span class="skill-selector-close" onclick="closeSkillSelector()">✕</span>
    </div>
    <div class="skill-selector-content">
      <div class="skill-selector-grid" id="skillSelectorGrid">
        <!-- Populated by JS -->
      </div>
    </div>
    <div class="skill-selector-footer">
      Click a skill to equip it to this slot
    </div>
  </div>

  <!-- Hotkey Legend (bottom right) -->
  <div id="hotkeyLegend">
    <div class="hotkey-btn" onclick="togglePauseMenu()"><span class="btn-label">Pause Menu</span><span class="btn-key">Esc</span></div>
    <div class="hotkey-btn" style="pointer-events:none;opacity:0.6;"><span class="btn-label">Skills</span><span class="btn-key">1-5</span></div>
    <div class="hotkey-btn" onclick="pressKey('KeyS')"><span class="btn-label">Shop</span><span class="btn-key">S</span></div>
    <div class="hotkey-btn" onclick="pressKey('Tab')"><span class="btn-label">Stash</span><span class="btn-key">Tab</span></div>
    <div class="hotkey-btn" onclick="pressKey('KeyC')"><span class="btn-label">Character</span><span class="btn-key">C</span></div>
    <div class="hotkey-btn demo-locked" style="pointer-events:none;opacity:0.4;filter:grayscale(100%);"><span class="btn-label">Aspects</span><span class="btn-key coming-soon">Coming Soon!</span></div>
    <div class="hotkey-btn demo-locked" style="pointer-events:none;opacity:0.4;filter:grayscale(100%);"><span class="btn-label">Passives</span><span class="btn-key coming-soon">Coming Soon!</span></div>
    <div class="hotkey-btn" onclick="pressKey('KeyI')"><span class="btn-label">Inventory</span><span class="btn-key">I</span></div>
    <div class="hotkey-btn" onclick="toggleLeaderboard()"><span class="btn-label">Leaderboard</span><span class="btn-key">L</span></div>
    <div class="hotkey-btn" onclick="toggleStatsDashboard()"><span class="btn-label">Stats</span><span class="btn-key">F1</span></div>
  </div>

  <!-- Debug Panel (press D to toggle) -->
  <div id="debugPanel">
    <div class="debug-title">🔧 DEBUG (D to toggle)</div>
    <div class="debug-line" id="dbgTestMode" style="color:#0f0;display:none;font-weight:bold;">⚡ TEST MODE ACTIVE ⚡</div>
    <div class="debug-line">State: <span id="dbgState">idle</span></div>
    <div class="debug-line">Pos: <span id="dbgPos">0, 0</span></div>
    <div class="debug-line">Target: <span id="dbgTarget">none</span></div>
    <div class="debug-line">Path: <span id="dbgPath">0</span> waypoints</div>
    <div class="debug-line">Combat: <span id="dbgCombat">-</span></div>
    <div class="debug-line">Exit: <span id="dbgExit">none</span></div>
    <div class="debug-line">ExitDist: <span id="dbgExitDist">-</span></div>
    <div class="debug-line">Cleared: <span id="dbgCleared">0/0</span></div>
    <div class="debug-line">Enemies: <span id="dbgEnemies">0</span></div>
    <div class="debug-line">Stuck: <span id="dbgStuck">0</span></div>
    <div class="debug-line" style="color:#f80;">Entering: <span id="dbgEntering">false</span></div>
    <div class="debug-line" style="color:#0ff;">Timeout: <span id="dbgTimeout">0</span></div>
    <div class="debug-line debug-warn" id="dbgWarn"></div>
    <div style="margin-top:8px;font-size:10px;color:#888;">E = Force enter portal</div>
    <div style="font-size:10px;color:#0f0;">T = Toggle test mode</div>
    <div style="font-size:10px;color:#ff0;">K = Kill nearby enemies</div>
  </div>
  
  <!-- Combat Log -->
  <div id="combatLog"></div>
  
  <!-- Bottom HUD -->
  <div id="bottomHUD">
    <!-- Portrait -->
    <div class="portrait-container">
      <div class="portrait" id="playerPortrait">
        <img class="portrait-img" id="portraitImg" src="" alt="Character" draggable="false">
        <span class="portrait-icon" id="portraitIcon">🧘</span>
      </div>
      <div class="portrait-ring"></div>
      <div class="level-badge" id="levelBadge">1</div>
    </div>
    
    <!-- Stats -->
    <div class="stats-panel">
      <div class="stat-bar-container" id="healthBarContainer" onmouseenter="showHealthTooltip(event)" onmouseleave="hideBarTooltip()">
        <div class="stat-bar health" id="healthBar" style="width: 100%"></div>
        <div class="stat-bar shield-overlay" id="shieldBar" style="width: 0%"></div>
        <div class="stat-bar-text">
          <span id="healthText">688/848</span>
          <span class="regen" id="lifeOnHitText">+1/hit</span>
        </div>
      </div>
      <div class="stat-bar-container" id="manaBarContainer" onmouseenter="showManaTooltip(event)" onmouseleave="hideBarTooltip()">
        <div class="stat-bar mana" id="manaBar" style="width: 100%"></div>
        <div class="stat-bar-text">
          <span id="manaText">395/564</span>
          <span class="regen" id="manaOnHitText">+2/hit</span>
        </div>
      </div>
    </div>
    
    <!-- Potions -->
    <div class="potion-bar">
      <div class="potion-btn" id="lifePotionBtn" onclick="useLifePotion()" onmouseenter="showPotionTooltip('life', event)" onmouseleave="hidePotionTooltip()">
        <img class="potion-icon-img" id="lifePotionIcon" src="https://raw.githubusercontent.com/Graphic37/ARPG-/main/Ranger/hp%20potion.png" alt="HP">
        <div class="cooldown-ring" id="lifeCooldownRing"></div>
      </div>
      <div class="potion-btn" id="manaPotionBtn" onclick="useManaPotion()" onmouseenter="showPotionTooltip('mana', event)" onmouseleave="hidePotionTooltip()">
        <img class="potion-icon-img" id="manaPotionIcon" src="https://raw.githubusercontent.com/Graphic37/ARPG-/main/Ranger/mana%20full.png" alt="Mana">
        <div class="cooldown-ring" id="manaCooldownRing"></div>
      </div>
    </div>
    
    <!-- Active Buffs/Debuffs Display -->
    <div class="buff-bar" id="buffBar">
      <!-- Buffs will be dynamically added here -->
    </div>
    
    <!-- Skills -->
    <div class="skill-bar">
      <div class="skill-slot primary-slot" id="skill-slot-0" onclick="openSkillSelector(0, event)" onmouseenter="showSkillSlotTooltip(0, event)" onmouseleave="hideSkillTooltip(event)">
        <div class="ai-pips" data-slot="0" data-priority="2">
          <div class="ai-pip active"></div>
          <div class="ai-pip active"></div>
          <div class="ai-pip"></div>
        </div>
        <span class="skill-icon">🔄</span>
        <span class="skill-key">1</span>
        <span class="primary-label">PRIMARY</span>
        <div class="skill-cd"></div>
        <span class="skill-cd-text" id="skill-cd-text-0"></span>
      </div>
      <div class="skill-slot" id="skill-slot-1" onclick="openSkillSelector(1, event)" onmouseenter="showSkillSlotTooltip(1, event)" onmouseleave="hideSkillTooltip(event)">
        <div class="ai-pips" data-slot="1" data-priority="2" onclick="cycleAIPriority(1, event)">
          <div class="ai-pip active"></div>
          <div class="ai-pip active"></div>
          <div class="ai-pip"></div>
        </div>
        <span class="skill-icon">🖐️</span>
        <span class="skill-key">2</span>
        <div class="skill-cd"></div>
        <span class="skill-cd-text" id="skill-cd-text-1"></span>
      </div>
      <div class="skill-slot" id="skill-slot-2" onclick="openSkillSelector(2, event)" onmouseenter="showSkillSlotTooltip(2, event)" onmouseleave="hideSkillTooltip(event)">
        <div class="ai-pips" data-slot="2" data-priority="2" onclick="cycleAIPriority(2, event)">
          <div class="ai-pip active"></div>
          <div class="ai-pip active"></div>
          <div class="ai-pip"></div>
        </div>
        <span class="skill-icon">💨</span>
        <span class="skill-key">3</span>
        <div class="skill-cd"></div>
        <span class="skill-cd-text" id="skill-cd-text-2"></span>
      </div>
      <div class="skill-slot" id="skill-slot-3" onclick="openSkillSelector(3, event)" onmouseenter="showSkillSlotTooltip(3, event)" onmouseleave="hideSkillTooltip(event)">
        <div class="ai-pips" data-slot="3" data-priority="2" onclick="cycleAIPriority(3, event)">
          <div class="ai-pip active"></div>
          <div class="ai-pip active"></div>
          <div class="ai-pip"></div>
        </div>
        <span class="skill-icon">⚡</span>
        <span class="skill-key">4</span>
        <div class="skill-cd"></div>
        <span class="skill-cd-text" id="skill-cd-text-3"></span>
      </div>
      <div class="skill-slot passive-slot" id="skill-slot-4" onclick="openSkillSelector(4, event)" onmouseenter="showSkillSlotTooltip(4, event)" onmouseleave="hideSkillTooltip(event)">
        <span class="skill-icon">⚔️</span>
        <span class="skill-key">P</span>
        <span class="passive-label-top">PASSIVE</span>
      </div>
    </div>
  </div>
  
  <!-- Experience Bar -->
  <div id="expContainer" onmouseenter="showExpTooltip()" onmouseleave="hideExpTooltip()">
    <div id="expBar" style="width: 0%"></div>
    <div class="exp-segments">
      <div class="exp-segment"></div>
      <div class="exp-segment"></div>
      <div class="exp-segment"></div>
      <div class="exp-segment"></div>
      <div class="exp-segment"></div>
      <div class="exp-segment"></div>
      <div class="exp-segment"></div>
      <div class="exp-segment"></div>
      <div class="exp-segment"></div>
      <div class="exp-segment"></div>
    </div>
  </div>
  
  <!-- Experience Tooltip -->
  <div id="expTooltip">
    <div class="exp-tooltip-title">Level <span id="expTooltipLevel">1</span></div>
    <div class="exp-tooltip-progress">
      <div class="exp-tooltip-bar">
        <div class="exp-tooltip-bar-fill" id="expTooltipBarFill" style="width: 0%"></div>
        <div class="exp-tooltip-bar-segments">
          <div class="exp-tooltip-bar-segment"></div>
          <div class="exp-tooltip-bar-segment"></div>
          <div class="exp-tooltip-bar-segment"></div>
          <div class="exp-tooltip-bar-segment"></div>
          <div class="exp-tooltip-bar-segment"></div>
          <div class="exp-tooltip-bar-segment"></div>
          <div class="exp-tooltip-bar-segment"></div>
          <div class="exp-tooltip-bar-segment"></div>
          <div class="exp-tooltip-bar-segment"></div>
          <div class="exp-tooltip-bar-segment"></div>
        </div>
      </div>
      <span class="exp-tooltip-percent" id="expTooltipPercent">0%</span>
    </div>
    <div class="exp-tooltip-values">
      <span id="expTooltipCurrent">0</span> / <span id="expTooltipMax">100</span> XP to next level
    </div>
  </div>
  
  </div> <!-- End gameContainer -->
  
  <!-- Delete Character Confirmation Modal -->
  <div class="delete-confirm-modal" id="deleteConfirmModal">
    <div class="delete-confirm-box">
      <h3>⚠️ DELETE CHARACTER?</h3>
      <p>You are about to permanently delete:</p>
      <div class="char-name" id="deleteCharName">Character Name</div>
      <p style="color: #ff8888; font-size: 14px; font-weight: bold;">⚠️ THIS CANNOT BE UNDONE!</p>
      <div class="delete-confirm-buttons">
        <button class="delete-confirm-btn cancel" onclick="cancelDeleteCharacter()">CANCEL</button>
        <button class="delete-confirm-btn delete" onclick="confirmDeleteCharacter()">DELETE</button>
      </div>
    </div>
  </div>
  
  <!-- Skill Unlock Popup -->
  <div class="skill-unlock-modal" id="skillUnlockModal">
    <div class="skill-unlock-box">
      <h3>NEW SKILL UNLOCKED!</h3>
      <div class="unlock-subtitle">Level <span id="skillUnlockLevel">2</span> Reached</div>
      <div class="skill-unlock-icon" id="skillUnlockIcon">
        <span class="emoji">🏹</span>
      </div>
      <div class="skill-unlock-name" id="skillUnlockName">Multishot</div>
      <div class="skill-unlock-desc" id="skillUnlockDesc">Fire 5 arrows in a spread pattern.</div>
      <div class="skill-unlock-hint" id="skillUnlockHint">
        Click a <strong>skill slot</strong> at the bottom of the screen to equip this skill!
      </div>
      <button class="skill-unlock-btn" onclick="closeSkillUnlockPopup()">AWESOME!</button>
    </div>
  </div>

  <!-- Item Context Menu -->
  <div id="itemContextMenu" class="item-context-menu">
    <div class="context-menu-item equip" onclick="contextMenuEquip()">
      <span class="icon">⚔️</span>
      <span>Equip</span>
    </div>
    <div class="context-menu-item unequip" onclick="contextMenuUnequip()" style="display:none;">
      <span class="icon">📤</span>
      <span>Unequip</span>
    </div>
    <div class="context-menu-item move-to-stash" onclick="contextMenuMoveToStash()">
      <span class="icon">📦</span>
      <span>Move to Stash</span>
    </div>
    <div class="context-menu-item move-to-inv" onclick="contextMenuMoveToInventory()" style="display:none;">
      <span class="icon">🎒</span>
      <span>Move to Inventory</span>
    </div>
    <div class="context-menu-divider"></div>
    <div class="context-menu-item craft" onclick="contextMenuCraft()">
      <span class="icon">🔧</span>
      <span>Craft</span>
    </div>
    <div class="context-menu-item salvage" onclick="contextMenuSalvage()" id="salvageMenuItem">
      <span class="icon">♻️</span>
      <div style="display:flex;flex-direction:column;">
        <span>Salvage</span>
        <span id="salvageOddsText" style="font-size:9px;color:#666;margin-top:1px;"></span>
      </div>
    </div>
    <div class="context-menu-divider"></div>
    <div class="context-menu-item drop" onclick="contextMenuDrop()">
      <span class="icon">🗑️</span>
      <span>Drop</span>
    </div>
  </div>
  
  <!-- Tab Rename Modal -->
  <div id="tabRenameModal" style="display:none; position:fixed; top:0; left:0; right:0; bottom:0; background:rgba(0,0,0,0.8); z-index:10002; align-items:center; justify-content:center;">
    <div style="background:linear-gradient(180deg, #1a1510 0%, #0a0805 100%); border:2px solid #5a4020; border-radius:8px; padding:20px; min-width:250px;">
      <div style="color:#c9a050; font-size:16px; margin-bottom:12px;">Rename Tab</div>
      <input type="text" id="tabRenameInput" style="width:100%; padding:8px; background:#0a0805; border:1px solid #3a3020; color:#c9a050; border-radius:4px; margin-bottom:12px;" onkeydown="if(event.key==='Enter')confirmTabRename()">
      <div style="display:flex; gap:8px; justify-content:flex-end;">
        <button onclick="closeTabRename()" style="padding:6px 16px; background:#333; border:1px solid #555; color:#888; border-radius:4px; cursor:pointer;">Cancel</button>
        <button onclick="confirmTabRename()" style="padding:6px 16px; background:#4a8050; border:1px solid #6aaa70; color:#fff; border-radius:4px; cursor:pointer;">Save</button>
      </div>
    </div>
  </div>
  
  <!-- Shard Mechanic Tooltip -->
  <div id="shardTooltip"></div>
  
<script>
// ============ ASSET PRELOADER ============
const PRELOAD_IMAGES = [
  // Menu background
  'https://raw.githubusercontent.com/Graphic37/ARPG-/main/corefall%20grey%20without%20text.png',
  'https://raw.githubusercontent.com/Graphic37/ARPG-/main/greater%20rift1.png',
  // Weapons
  'https://raw.githubusercontent.com/Graphic37/ARPG-/main/Weapons/Elder%20Staff.png',
  'https://raw.githubusercontent.com/Graphic37/ARPG-/main/Weapons/Ironbark%20Quarterstaff.png',
  'https://raw.githubusercontent.com/Graphic37/ARPG-/main/Weapons/Ironwood%20Bow.png',
  'https://raw.githubusercontent.com/Graphic37/ARPG-/main/Weapons/Viper%20Blade.png',
  'https://raw.githubusercontent.com/Graphic37/ARPG-/main/Weapons/War%20Blade.png',
  'https://raw.githubusercontent.com/Graphic37/ARPG-/main/Weapons/Windrunner%20Bow.png',
  'https://raw.githubusercontent.com/Graphic37/ARPG-/main/Weapons/Windspire%20Quarterstaff.png',
  'https://raw.githubusercontent.com/Graphic37/ARPG-/main/Weapons/mystic%20staff.png',
  // Chest armor
  'https://raw.githubusercontent.com/Graphic37/ARPG-/main/Chest/Crusader%20Armor.png',
  'https://raw.githubusercontent.com/Graphic37/ARPG-/main/Chest/Scale%20Armor.png',
  'https://raw.githubusercontent.com/Graphic37/ARPG-/main/Chest/Silk%20Robe.png',
  'https://raw.githubusercontent.com/Graphic37/ARPG-/main/Chest/assassin%20garb.png',
  'https://raw.githubusercontent.com/Graphic37/ARPG-/main/Chest/leather%20tunic.png',
  'https://raw.githubusercontent.com/Graphic37/ARPG-/main/Chest/plate%20armor.png',
  // Helmets
  'https://raw.githubusercontent.com/Graphic37/ARPG-/main/Helmets/Bone%20Circlet.png',
  'https://raw.githubusercontent.com/Graphic37/ARPG-/main/Helmets/Crusader%20Helm.png',
  'https://raw.githubusercontent.com/Graphic37/ARPG-/main/Helmets/Iron%20helm.png',
  'https://raw.githubusercontent.com/Graphic37/ARPG-/main/Helmets/Leather%20cap.png',
  'https://raw.githubusercontent.com/Graphic37/ARPG-/main/Helmets/Mage%20Hat.png',
  'https://raw.githubusercontent.com/Graphic37/ARPG-/main/Helmets/Scale%20Helm.png',
  // Gloves
  'https://raw.githubusercontent.com/Graphic37/ARPG-/main/Gloves/Assassin%20Gloves.png',
  'https://raw.githubusercontent.com/Graphic37/ARPG-/main/Gloves/Crusader%20Gauntlets.png',
  'https://raw.githubusercontent.com/Graphic37/ARPG-/main/Gloves/Leather%20Gloves.png',
  'https://raw.githubusercontent.com/Graphic37/ARPG-/main/Gloves/Plate%20Gauntlets.png',
  'https://raw.githubusercontent.com/Graphic37/ARPG-/main/Gloves/Scale%20Gauntlets.png',
  'https://raw.githubusercontent.com/Graphic37/ARPG-/main/Gloves/Silk%20Gloves.png',
  // Boots
  'https://raw.githubusercontent.com/Graphic37/ARPG-/main/Boots/Assassin%20Boots.png',
  'https://raw.githubusercontent.com/Graphic37/ARPG-/main/Boots/Crusader%20Greaves.png',
  'https://raw.githubusercontent.com/Graphic37/ARPG-/main/Boots/Leather%20Boots.png',
  'https://raw.githubusercontent.com/Graphic37/ARPG-/main/Boots/Plate%20Greaves.png',
  'https://raw.githubusercontent.com/Graphic37/ARPG-/main/Boots/Scale%20Boots.png',
  'https://raw.githubusercontent.com/Graphic37/ARPG-/main/Boots/Silk%20Slippers.png',
  // Rings
  'https://raw.githubusercontent.com/Graphic37/ARPG-/main/Rings/Arcane%20Ring.png',
  'https://raw.githubusercontent.com/Graphic37/ARPG-/main/Rings/Flame%20Ring.png',
  'https://raw.githubusercontent.com/Graphic37/ARPG-/main/Rings/Frost%20Ring.png',
  'https://raw.githubusercontent.com/Graphic37/ARPG-/main/Rings/Nature%20Ring.png',
  'https://raw.githubusercontent.com/Graphic37/ARPG-/main/Rings/Prismatic.png',
  'https://raw.githubusercontent.com/Graphic37/ARPG-/main/Rings/Storm%20Ring.png',
  'https://raw.githubusercontent.com/Graphic37/ARPG-/main/Rings/Vitality.png',
  // Amulets
  'https://raw.githubusercontent.com/Graphic37/ARPG-/main/Amulets/Grace.png',
  'https://raw.githubusercontent.com/Graphic37/ARPG-/main/Amulets/Harmony.png',
  'https://raw.githubusercontent.com/Graphic37/ARPG-/main/Amulets/Might.png',
  'https://raw.githubusercontent.com/Graphic37/ARPG-/main/Amulets/Wisdom.png',
  // Ranger Skill Icons
  'https://raw.githubusercontent.com/Graphic37/ARPG-/main/Ranger/hungry%20arrow.png',
  'https://raw.githubusercontent.com/Graphic37/ARPG-/main/Ranger/chakram.png',
  'https://raw.githubusercontent.com/Graphic37/ARPG-/main/Ranger/caltrops.png',
  'https://raw.githubusercontent.com/Graphic37/ARPG-/main/Ranger/mark.png',
  'https://raw.githubusercontent.com/Graphic37/ARPG-/main/Ranger/multishot.png',
  'https://raw.githubusercontent.com/Graphic37/ARPG-/main/Ranger/sentry.png',
  'https://raw.githubusercontent.com/Graphic37/ARPG-/main/Ranger/rain%20of%20arrows.png',
  'https://raw.githubusercontent.com/Graphic37/ARPG-/main/Ranger/damage.png',
  'https://raw.githubusercontent.com/Graphic37/ARPG-/main/Ranger/life.png',
  'https://raw.githubusercontent.com/Graphic37/ARPG-/main/Ranger/elemental%20shield.png',
  // Ranger UI Icons
  'https://raw.githubusercontent.com/Graphic37/ARPG-/main/Ranger/hp%20potion.png',
  'https://raw.githubusercontent.com/Graphic37/ARPG-/main/Ranger/hp%20potion%20empty.png',
  'https://raw.githubusercontent.com/Graphic37/ARPG-/main/Ranger/mana%20full.png',
  'https://raw.githubusercontent.com/Graphic37/ARPG-/main/Ranger/mana%20empty.png',
  // Ranger Character
  'https://raw.githubusercontent.com/Graphic37/ARPG-/main/Ranger/ranger.png',
  'https://raw.githubusercontent.com/Graphic37/ARPG-/main/Ranger/ranger%20standing.png'
];

// Audio to preload
const PRELOAD_AUDIO = [
  'https://raw.githubusercontent.com/Graphic37/PokerTD/main/JDSherbert%20-%20Ultimate%20UI%20SFX%20Pack%20-%20Cancel%20-%209.mp3',
  'https://raw.githubusercontent.com/Graphic37/PokerTD/main/JDSherbert%20-%20Ultimate%20UI%20SFX%20Pack%20-%20Cursor%20-%208.mp3'
];

// Cache for preloaded images
window.preloadedImages = {};

// Preload all assets before showing game
async function preloadAssets() {
  const loadingBar = document.getElementById('loadingBar');
  const loadingText = document.getElementById('loadingText');
  const loadingScreen = document.getElementById('loadingScreen');
  
  const totalAssets = PRELOAD_IMAGES.length + PRELOAD_AUDIO.length;
  let loadedCount = 0;
  
  function updateProgress() {
    loadedCount++;
    const percent = Math.floor((loadedCount / totalAssets) * 100);
    if (loadingBar) loadingBar.style.width = percent + '%';
    if (loadingText) loadingText.textContent = `Loading assets... ${loadedCount}/${totalAssets}`;
  }
  
  // Preload images
  const imagePromises = PRELOAD_IMAGES.map(url => {
    return new Promise((resolve) => {
      const img = new Image();
      img.onload = () => {
        window.preloadedImages[url] = img;
        updateProgress();
        resolve();
      };
      img.onerror = () => {
        console.warn('Failed to preload:', url);
        updateProgress();
        resolve(); // Don't fail on missing images
      };
      img.src = url;
    });
  });
  
  // Preload audio
  const audioPromises = PRELOAD_AUDIO.map(url => {
    return new Promise((resolve) => {
      const audio = new Audio();
      audio.oncanplaythrough = () => {
        updateProgress();
        resolve();
      };
      audio.onerror = () => {
        console.warn('Failed to preload audio:', url);
        updateProgress();
        resolve();
      };
      audio.src = url;
      audio.load();
    });
  });
  
  // Wait for all assets
  await Promise.all([...imagePromises, ...audioPromises]);
  
  // Update text
  if (loadingText) loadingText.textContent = 'Ready!';
  
  // Short delay to show 100%
  await new Promise(r => setTimeout(r, 300));
  
  // Fade out loading screen
  if (loadingScreen) {
    loadingScreen.style.transition = 'opacity 0.5s ease';
    loadingScreen.style.opacity = '0';
    await new Promise(r => setTimeout(r, 500));
    loadingScreen.style.display = 'none';
  }
  
  console.log('✅ All assets preloaded');
}

// Start preloading when DOM is ready
document.addEventListener('DOMContentLoaded', () => {
  preloadAssets();
});

// ============ UI SOUND SYSTEM ============
const UI_SOUNDS = {
  hover: new Audio('https://raw.githubusercontent.com/Graphic37/PokerTD/main/JDSherbert%20-%20Ultimate%20UI%20SFX%20Pack%20-%20Cancel%20-%209.mp3'),
  click: new Audio('https://raw.githubusercontent.com/Graphic37/PokerTD/main/JDSherbert%20-%20Ultimate%20UI%20SFX%20Pack%20-%20Cursor%20-%208.mp3')
};

// Preload and set volume
UI_SOUNDS.hover.volume = 0.3;
UI_SOUNDS.click.volume = 0.4;

function playUISound(type) {
  const sound = UI_SOUNDS[type];
  if (sound) {
    sound.currentTime = 0;
    sound.play().catch(() => {}); // Ignore autoplay errors
  }
}

// Attach sound effects to all buttons on page load and dynamically
function attachButtonSounds() {
  document.querySelectorAll('button, .btn, .menu-btn, .class-card, .tab-btn, .tier-card, [onclick]').forEach(el => {
    if (el.dataset.soundsAttached) return;
    el.dataset.soundsAttached = 'true';
    
    el.addEventListener('mouseenter', () => playUISound('hover'));
    el.addEventListener('click', () => playUISound('click'));
  });
}

// Run on load and periodically for dynamic elements
document.addEventListener('DOMContentLoaded', () => {
  attachButtonSounds();
  setInterval(attachButtonSounds, 1000); // Check for new buttons every second
});

// Also attach when document changes (for modals, etc.)
const soundObserver = new MutationObserver(() => attachButtonSounds());
document.addEventListener('DOMContentLoaded', () => {
  soundObserver.observe(document.body, { childList: true, subtree: true });
});

// ============ MENU SYSTEM ============

// Menu state variables (declared early to avoid TDZ issues)
let gameState = 'menu';
let selectedCharacter = null;
let selectedClass = 'monk';
let newCharacterName = '';
let isSeasonalSelected = true;
let isHardcoreSelected = false;
let characters = [];

const CLASS_DATA = {
  warrior: { name: 'Warrior', icon: '⚔️', headshot: '⚔️', desc: 'A heavily armored fighter wielding powerful swords. Masters of physical combat and cleaving strikes.',
    playstyle: [
      { icon: '🛡️', title: 'HEAVY ARMOR', desc: 'Maximum physical protection' },
      { icon: '⚔️', title: 'MELEE COMBAT', desc: 'Devastating close-range attacks' },
      { icon: '💪', title: 'STRENGTH BASED', desc: 'Scales with strength for damage and armor' }
    ]
  },
  monk: { name: 'Monk', icon: '🥋', headshot: '🧘', desc: 'A disciplined warrior who combines martial arts with inner power. Masters of combat flow, striking with devastating precision.', 
    playstyle: [
      { icon: '⚔️', title: 'MARTIAL ARTS', desc: 'Swift combo attacks that flow together' },
      { icon: '💨', title: 'AGILE', desc: 'Quick movement and evasion' },
      { icon: '🏃', title: 'DEXTERITY BASED', desc: 'Scales with dexterity for speed and dodge' }
    ]
  },
  ranger: { 
    name: 'Ranger', 
    icon: '🏹', 
    headshot: '🏹',
    headshotImg: 'https://raw.githubusercontent.com/Graphic37/ARPG-/main/Ranger/ranger.png',
    portraitImg: 'https://raw.githubusercontent.com/Graphic37/ARPG-/main/Ranger/ranger%20standing.png',
    desc: 'Swift and deadly, Rangers strike from afar with precision. Masters of dodge and ranged combat.',
    playstyle: [
      { icon: '🎯', title: 'RANGED ATTACKS', desc: 'Strike enemies from a safe distance' },
      { icon: '💨', title: 'HIGH MOBILITY', desc: 'Fast movement and dodge' },
      { icon: '🏃', title: 'DEXTERITY BASED', desc: 'Scales with dexterity for speed and dodge' }
    ]
  },
  mage: { name: 'Mage', icon: '🔮', headshot: '🧙', desc: 'Masters of the arcane arts, wielding devastating elemental magic. Command fire, ice, lightning, and nature itself.',
    playstyle: [
      { icon: '✨', title: 'SPELL CASTING', desc: 'Devastating magical abilities' },
      { icon: '🔥', title: 'ELEMENTAL MASTERY', desc: 'Control the primal elements' },
      { icon: '🧠', title: 'INTELLIGENCE BASED', desc: 'Scales with intelligence for spell power' }
    ]
  }
};

function initMenu() {
  renderCharacterList();
  renderClassSelector();
  if (characters.length > 0) {
    selectCharacter(0);
  }
}

function renderCharacterList() {
  const list = document.getElementById('characterList');
  list.innerHTML = '';
  
  characters.forEach((char, i) => {
    const div = document.createElement('div');
    div.className = 'character-slot' + (selectedCharacter === i ? ' selected' : '');
    div.onclick = (e) => {
      // Don't select if clicking delete button
      if (e.target.classList.contains('char-delete-btn')) return;
      selectCharacter(i);
    };
    
    // Get headshot based on class and skin
    let charIcon;
    const charClass = char.class.toLowerCase();
    let charIconHtml;
    
    // Check for image-based headshot first
    const classData = CLASS_DATA[charClass];
    if (classData?.headshotImg) {
      charIconHtml = `<img class="char-portrait-img" src="${classData.headshotImg}" alt="${classData.name}" draggable="false">`;
    } else if (charClass === 'monk' && char.skin && MONK_SKINS[char.skin]) {
      charIcon = MONK_SKINS[char.skin].headshot || CLASS_DATA[charClass]?.headshot || '👤';
      charIconHtml = charIcon;
    } else if (charClass === 'ranger' && char.skin && RANGER_SKINS[char.skin]) {
      charIcon = RANGER_SKINS[char.skin].headshot || CLASS_DATA[charClass]?.headshot || '👤';
      charIconHtml = charIcon;
    } else if (charClass === 'mage' && char.skin && MAGE_SKINS[char.skin]) {
      charIcon = MAGE_SKINS[char.skin].headshot || CLASS_DATA[charClass]?.headshot || '👤';
      charIconHtml = charIcon;
    } else if (charClass === 'warrior' && char.skin && WARRIOR_SKINS[char.skin]) {
      charIcon = WARRIOR_SKINS[char.skin].headshot || CLASS_DATA[charClass]?.headshot || '👤';
      charIconHtml = charIcon;
    } else {
      charIcon = CLASS_DATA[charClass]?.headshot || '👤';
      charIconHtml = charIcon;
    }
    
    div.innerHTML = `
      <div class="char-portrait">
        ${charIconHtml}
        <div class="char-level">${char.level}</div>
      </div>
      <div class="char-info">
        <h3>${char.name}</h3>
        <p><span class="${char.mode === 'Demo' ? 'seasonal' : char.mode === 'Seasonal' ? 'seasonal' : ''}">${char.mode === 'Demo' ? '⬥ ' : char.mode === 'Seasonal' ? '✦ ' : ''}${char.mode}</span></p>
      </div>
      <button class="char-delete-btn" onclick="showDeleteConfirm(${i}, event)" title="Delete Character">🗑️</button>
    `;
    
    list.appendChild(div);
  });
  
  // Update slots info
  const slotsInfo = document.querySelector('.slots-info');
  if (slotsInfo) {
    slotsInfo.textContent = `${characters.length}/10 SLOTS USED`;
  }
  
  // Update start button state
  const startBtn = document.getElementById('mainStartBtn');
  if (startBtn) {
    startBtn.disabled = characters.length === 0;
  }
}

function selectCharacter(index) {
  selectedCharacter = index;
  const char = characters[index];
  
  // Show the character display panel
  const charDisplay = document.getElementById('menuCharDisplay');
  if (charDisplay) {
    charDisplay.style.display = 'block';
  }
  
  document.querySelectorAll('.character-slot').forEach((el, i) => {
    el.classList.toggle('selected', i === index);
  });
  
  // Get headshot based on class and skin
  let charIcon;
  const charClass = char.class.toLowerCase();
  const classData = CLASS_DATA[charClass];
  
  if (charClass === 'monk' && char.skin && MONK_SKINS[char.skin]) {
    charIcon = MONK_SKINS[char.skin].headshot || CLASS_DATA[charClass]?.headshot || '👤';
  } else if (charClass === 'ranger' && char.skin && RANGER_SKINS[char.skin]) {
    charIcon = RANGER_SKINS[char.skin].headshot || CLASS_DATA[charClass]?.headshot || '👤';
  } else if (charClass === 'mage' && char.skin && MAGE_SKINS[char.skin]) {
    charIcon = MAGE_SKINS[char.skin].headshot || CLASS_DATA[charClass]?.headshot || '👤';
  } else if (charClass === 'warrior' && char.skin && WARRIOR_SKINS[char.skin]) {
    charIcon = WARRIOR_SKINS[char.skin].headshot || CLASS_DATA[charClass]?.headshot || '👤';
  } else {
    charIcon = CLASS_DATA[charClass]?.headshot || '👤';
  }
  
  // Update standing portrait
  const standingPortrait = document.getElementById('charStandingPortrait');
  if (standingPortrait) {
    if (classData?.portraitImg) {
      standingPortrait.innerHTML = `<img src="${classData.portraitImg}" alt="${classData.name}" draggable="false">`;
    } else {
      standingPortrait.innerHTML = `<span class="portrait-emoji">${classData?.icon || '👤'}</span>`;
    }
  }
  
  document.getElementById('menuCharName').textContent = char.name.toUpperCase();
  document.getElementById('menuCharMode').textContent = char.mode === 'Demo' ? '⬥ Demo' : char.mode === 'Seasonal' ? '✦ Seasonal' : '◆ Standard';
  document.getElementById('menuCharMode').className = 'mode ' + (char.mode === 'Demo' ? 'seasonal' : char.mode === 'Seasonal' ? 'seasonal' : 'standard');
  document.getElementById('menuCharDetails').textContent = `${char.class} | Level ${char.level} | Normal`;
  
  // Also update player.skin and player.class if selecting this character
  if (char.skin) {
    player.skin = char.skin;
  }
  player.class = char.class.toLowerCase();
  
  // Set equipped skills based on class
  const defaultSkills = DEFAULT_EQUIPPED_SKILLS[player.class] || DEFAULT_EQUIPPED_SKILLS.monk;
  equippedSkills = [...defaultSkills];
  
  // Update skill bar UI
  for (let i = 0; i < 5; i++) {
    const slot = document.getElementById(`skill-slot-${i}`);
    if (slot) {
      const skillKey = equippedSkills[i];
      const skillData = SKILLS[skillKey];
      const gemData = SKILL_GEM_DATA[skillKey];
      updateSkillSlotIcon(slot, skillData, gemData);
    }
  }
}

// Character deletion
let pendingDeleteIndex = null;

function showDeleteConfirm(index, event) {
  event.stopPropagation();
  pendingDeleteIndex = index;
  const char = characters[index];
  
  document.getElementById('deleteCharName').textContent = `${char.name} (Level ${char.level} ${char.class})`;
  document.getElementById('deleteConfirmModal').classList.add('visible');
}

function cancelDeleteCharacter() {
  pendingDeleteIndex = null;
  document.getElementById('deleteConfirmModal').classList.remove('visible');
}

function confirmDeleteCharacter() {
  if (pendingDeleteIndex === null || pendingDeleteIndex >= characters.length) return;
  
  const char = characters[pendingDeleteIndex];
  if (!char) {
    cancelDeleteCharacter();
    return;
  }
  
  const charKey = `character_${char.name}_${char.class}`;
  
  // Remove character-specific save data from localStorage
  localStorage.removeItem(charKey);
  
  // Remove from characters array
  characters.splice(pendingDeleteIndex, 1);
  
  // Save updated account data (includes character list)
  saveCharacterList();
  
  // Reset selection if we deleted the selected character
  if (selectedCharacter === pendingDeleteIndex) {
    selectedCharacter = characters.length > 0 ? 0 : null;
  } else if (selectedCharacter > pendingDeleteIndex) {
    selectedCharacter--;
  }
  
  // Re-render character list
  renderCharacterList();
  
  // Update selection display
  if (characters.length > 0 && selectedCharacter !== null) {
    selectCharacter(selectedCharacter);
  } else {
    // No characters left - hide display panel
    const charDisplay = document.getElementById('menuCharDisplay');
    if (charDisplay) {
      charDisplay.style.display = 'none';
    }
    document.getElementById('menuCharName').textContent = 'NO CHARACTER';
    document.getElementById('menuCharMode').textContent = '';
    document.getElementById('menuCharDetails').textContent = 'Create a new character to play';
    const standingPortrait = document.getElementById('charStandingPortrait');
    if (standingPortrait) standingPortrait.innerHTML = '';
  }
  
  // Close modal
  cancelDeleteCharacter();
}

// Save just the character list to account data
function saveCharacterList() {
  try {
    const accountStr = localStorage.getItem('poe2idle_account');
    let accountData = accountStr ? JSON.parse(accountStr) : {};
    accountData.characterList = characters;
    localStorage.setItem('poe2idle_account', JSON.stringify(accountData));
  } catch (e) {
    console.error('Failed to save character list:', e);
  }
}

// Helper function to update skill slot icon (supports both emoji and images)
function updateSkillSlotIcon(slot, skillData, gemData) {
  // Remove existing icon elements
  const existingIcon = slot.querySelector('.skill-icon');
  const existingImg = slot.querySelector('.skill-icon-img');
  if (existingIcon) existingIcon.remove();
  if (existingImg) existingImg.remove();
  
  // Get icon from skillData (SKILLS) or gemData (SKILL_GEM_DATA)
  const imageUrl = skillData?.imageUrl;
  const icon = gemData?.icon || skillData?.icon || '❓';
  
  if (imageUrl) {
    // Use image
    const img = document.createElement('img');
    img.className = 'skill-icon-img';
    img.src = imageUrl;
    img.alt = skillData?.name || 'Skill';
    img.draggable = false;
    // Insert before cooldown overlay if it exists
    const cooldownOverlay = slot.querySelector('.cd-overlay');
    if (cooldownOverlay) {
      slot.insertBefore(img, cooldownOverlay);
    } else {
      slot.appendChild(img);
    }
  } else {
    // Use emoji
    const span = document.createElement('span');
    span.className = 'skill-icon';
    span.textContent = icon;
    const cooldownOverlay = slot.querySelector('.cd-overlay');
    if (cooldownOverlay) {
      slot.insertBefore(span, cooldownOverlay);
    } else {
      slot.appendChild(span);
    }
  }
}

function renderClassSelector() {
  const selector = document.getElementById('classSelector');
  selector.innerHTML = '';
  
  // DEMO MODE: Only Ranger is available, others are locked
  const DEMO_CLASS = 'ranger';
  
  Object.entries(CLASS_DATA).forEach(([key, data], i) => {
    const div = document.createElement('div');
    const isLocked = key !== DEMO_CLASS;
    div.className = 'class-option' + (key === DEMO_CLASS ? ' selected' : '') + (isLocked ? ' locked' : '');
    
    if (!isLocked) {
      div.onclick = () => selectClass(key);
    } else {
      // Show tooltip on hover for locked classes
      div.onmouseenter = (e) => showLockedTooltip(e, data.name);
      div.onmousemove = (e) => moveLockedTooltip(e);
      div.onmouseleave = () => hideLockedTooltip();
    }
    
    div.innerHTML = isLocked ? `<span style="filter: grayscale(100%); opacity: 0.5;">${data.icon}</span>` : data.icon;
    div.dataset.class = key;
    
    selector.appendChild(div);
  });
  
  selectedClass = DEMO_CLASS;
  updateClassPreview();
}

// Locked class tooltip functions
function showLockedTooltip(e, className) {
  let tooltip = document.getElementById('lockedClassTooltip');
  if (!tooltip) {
    tooltip = document.createElement('div');
    tooltip.id = 'lockedClassTooltip';
    tooltip.className = 'locked-tooltip';
    tooltip.innerHTML = `
      <div class="tooltip-title">${className}</div>
      <div class="tooltip-text">This class is not available in the demo.</div>
      <div class="wishlist-cta">⭐ Wishlist to see what's coming!</div>
    `;
    document.body.appendChild(tooltip);
  } else {
    tooltip.querySelector('.tooltip-title').textContent = className;
  }
  tooltip.style.display = 'block';
  moveLockedTooltip(e);
}

function moveLockedTooltip(e) {
  const tooltip = document.getElementById('lockedClassTooltip');
  if (tooltip) {
    tooltip.style.left = (e.clientX + 15) + 'px';
    tooltip.style.top = (e.clientY + 15) + 'px';
  }
}

function hideLockedTooltip() {
  const tooltip = document.getElementById('lockedClassTooltip');
  if (tooltip) {
    tooltip.style.display = 'none';
  }
}

function selectClass(classKey) {
  selectedClass = classKey;
  
  document.querySelectorAll('.class-option').forEach(el => {
    el.classList.toggle('selected', el.dataset.class === classKey);
  });
  
  updateClassPreview();
}

function updateClassPreview() {
  const data = CLASS_DATA[selectedClass];
  
  document.getElementById('classTitle').textContent = data.name.toUpperCase();
  document.getElementById('classDescription').textContent = data.desc;
  
  // Use portrait image if available
  const classIconLarge = document.getElementById('classIconLarge');
  if (data.portraitImg) {
    classIconLarge.innerHTML = `<img src="${data.portraitImg}" alt="${data.name}" draggable="false">`;
  } else {
    classIconLarge.textContent = data.icon;
  }
  
  // Update playstyle
  const container = document.querySelector('.class-preview-right');
  container.innerHTML = '<h3>PLAYSTYLE</h3>';
  
  data.playstyle.forEach(p => {
    container.innerHTML += `
      <div class="playstyle-item">
        <span class="playstyle-icon">${p.icon}</span>
        <div>
          <h4>${p.title}</h4>
          <p>${p.desc}</p>
        </div>
      </div>
    `;
  });
  
  // Update skill preview grid
  updateSkillPreviewGrid();
}

function updateSkillPreviewGrid() {
  const grid = document.getElementById('skillPreviewGrid');
  if (!grid) return;
  
  const skills = CLASS_SKILLS[selectedClass] || [];
  
  let html = '';
  skills.forEach(skillId => {
    const skillInfo = SKILL_TOOLTIPS[skillId];
    const skillDef = SKILLS[skillId];
    const gemData = SKILL_GEM_DATA[skillId];
    
    if (!skillInfo && !skillDef) return;
    
    const name = skillInfo?.name || skillDef?.name || skillId;
    const icon = gemData?.icon || skillDef?.icon || '❓';
    const imageUrl = skillDef?.imageUrl;
    const isPrimary = skillDef?.isPrimary || skillInfo?.cost === 0;
    const unlockLevel = skillDef?.unlockLevel || 1;
    
    // Use image if available, otherwise emoji
    const skillIcon = imageUrl 
      ? `<img class="skill-icon-img" src="${imageUrl}" alt="${name}" draggable="false">`
      : `<span class="skill-icon">${icon}</span>`;
    
    html += `
      <div class="skill-preview-item ${isPrimary ? 'primary' : ''}" 
           onmouseenter="showSkillPreviewTooltip('${skillId}', event)"
           onmouseleave="hideSkillPreviewTooltip()"
           onmousemove="moveSkillPreviewTooltip(event)">
        <span class="skill-unlock-level">Lv${unlockLevel}</span>
        ${skillIcon}
        <span class="skill-name">${name.split(' ')[0]}</span>
      </div>
    `;
  });
  
  grid.innerHTML = html;
}

function showSkillPreviewTooltip(skillId, event) {
  const tooltip = document.getElementById('skillPreviewTooltip');
  if (!tooltip) return;
  
  const skillInfo = SKILL_TOOLTIPS[skillId];
  const skillDef = SKILLS[skillId];
  const gemData = SKILL_GEM_DATA[skillId];
  
  if (!skillInfo && !skillDef) return;
  
  const name = skillInfo?.name || skillDef?.name || skillId;
  const type = skillInfo?.type || (skillDef?.isPrimary ? 'Primary Attack' : 'Active Skill');
  const desc = skillInfo?.desc || skillDef?.description || 'No description available.';
  const stats = skillInfo?.stats || [];
  const cost = skillInfo?.cost ?? skillDef?.manaCost ?? 0;
  const cooldown = skillInfo?.cooldown || (skillDef?.maxCooldown ? (skillDef.maxCooldown / 60).toFixed(1) + 's' : 'atkspd');
  const unlockLevel = skillDef?.unlockLevel || 1;
  
  let statsHtml = '';
  if (stats.length > 0) {
    statsHtml = '<div class="skill-stats">';
    stats.forEach(s => {
      statsHtml += `<div class="skill-stat">• ${s}</div>`;
    });
    statsHtml += '</div>';
  }
  
  const costText = cost === 0 ? 'Free' : `${cost} Mana`;
  const cdText = cooldown === 'atkspd' ? 'Attack Speed' : cooldown;
  
  tooltip.innerHTML = `
    <h4>${name}</h4>
    <div class="skill-type">${type} · <span style="color: #7cb;">Unlocks Lv${unlockLevel}</span></div>
    <div class="skill-desc">${desc}</div>
    ${statsHtml}
    <div class="skill-cost">Cost: ${costText} · Cooldown: ${cdText}</div>
  `;
  
  tooltip.style.display = 'block';
  moveSkillPreviewTooltip(event);
}

function moveSkillPreviewTooltip(event) {
  const tooltip = document.getElementById('skillPreviewTooltip');
  if (!tooltip || tooltip.style.display === 'none') return;
  
  const padding = 15;
  let x = event.clientX + padding;
  let y = event.clientY + padding;
  
  // Keep tooltip on screen
  const rect = tooltip.getBoundingClientRect();
  if (x + rect.width > window.innerWidth) {
    x = event.clientX - rect.width - padding;
  }
  if (y + rect.height > window.innerHeight) {
    y = event.clientY - rect.height - padding;
  }
  
  tooltip.style.left = x + 'px';
  tooltip.style.top = y + 'px';
}

function hideSkillPreviewTooltip() {
  const tooltip = document.getElementById('skillPreviewTooltip');
  if (tooltip) tooltip.style.display = 'none';
}

function showMainMenu() {
  const mainMenu = document.getElementById('mainMenu');
  const classSelectMenu = document.getElementById('classSelectMenu');
  const characterCreateMenu = document.getElementById('characterCreateMenu');
  
  if (mainMenu) {
    mainMenu.classList.remove('hidden');
    mainMenu.style.display = 'flex';
  }
  if (classSelectMenu) {
    classSelectMenu.classList.add('hidden');
    classSelectMenu.style.display = 'none';
  }
  if (characterCreateMenu) {
    characterCreateMenu.classList.add('hidden');
    characterCreateMenu.style.display = 'none';
  }
  
  // Re-render character list in case anything changed
  renderCharacterList();
  
  gameState = 'menu';
}

function returnToMainMenu() {
  // Save game before leaving
  saveGame();
  
  // CRITICAL: Set game state FIRST to stop update loop
  gameState = 'menu';
  
  // End any active rift surge
  if (riftSurgeActive) {
    riftSurgeActive = false;
    hideRiftSurgeUI();
    if (riftSavedState) {
      restoreFromRift();
    }
  }
  
  // Close the hotkey menu
  const hotkeyMenu = document.getElementById('hotkeyMenu');
  if (hotkeyMenu) hotkeyMenu.classList.remove('visible');
  
  // Hide game container
  const gameContainer = document.getElementById('gameContainer');
  if (gameContainer) {
    gameContainer.classList.add('hidden');
    gameContainer.style.display = 'none';
  }
  
  // Hide hotkey legend
  const hotkeyLegend = document.getElementById('hotkeyLegend');
  if (hotkeyLegend) hotkeyLegend.classList.remove('visible');
  
  // Close any open panels
  const panels = ['inventoryPanel', 'charPanel', 'stashPanel', 'shopPanel', 'passiveTreePanel', 'dungeonModal'];
  panels.forEach(id => {
    const panel = document.getElementById(id);
    if (panel) {
      panel.classList.remove('visible');
      panel.style.display = 'none';
    }
  });
  
  // Reset panel open state flags
  inventoryOpen = false;
  charPanelOpen = false;
  stashOpen = false;
  shopOpen = false;
  passiveTreeOpen = false;
  dungeonSelectorOpen = false;
  
  // Hide any modals
  const modals = document.querySelectorAll('.modal, .confirm-modal');
  modals.forEach(modal => {
    modal.style.display = 'none';
  });
  
  // Clear all combat state
  enemies = [];
  loot = [];
  particles = [];
  progressOrbs = [];
  skillProjectiles = [];
  damageNumbers = [];
  path = [];
  pathTarget = null;
  target = null;
  cycloneActive = false;
  cycloneTimer = 0;
  enteringPortal = false;
  
  // Reset player state
  if (player) {
    player.state = 'idle';
    player.attackCooldown = 0;
  }
  
  // Hide class select and character create menus
  const classSelectMenu = document.getElementById('classSelectMenu');
  const characterCreateMenu = document.getElementById('characterCreateMenu');
  if (classSelectMenu) {
    classSelectMenu.classList.add('hidden');
    classSelectMenu.style.display = 'none';
  }
  if (characterCreateMenu) {
    characterCreateMenu.classList.add('hidden');
    characterCreateMenu.style.display = 'none';
  }
  
  // Show main menu - MUST happen
  const mainMenu = document.getElementById('mainMenu');
  if (mainMenu) {
    mainMenu.classList.remove('hidden');
    mainMenu.style.display = 'flex';
  }
  
  // Re-render character list
  renderCharacterList();
  
  addLog('Returned to main menu', 'system');
}

function showClassSelect() {
  // Properly hide/show menus with both class and inline styles
  const mainMenu = document.getElementById('mainMenu');
  const classSelectMenu = document.getElementById('classSelectMenu');
  const characterCreateMenu = document.getElementById('characterCreateMenu');
  
  if (mainMenu) {
    mainMenu.classList.add('hidden');
    mainMenu.style.display = 'none';
  }
  if (classSelectMenu) {
    classSelectMenu.classList.remove('hidden');
    classSelectMenu.style.display = 'flex';
  }
  if (characterCreateMenu) {
    characterCreateMenu.classList.add('hidden');
    characterCreateMenu.style.display = 'none';
  }
  
  gameState = 'classSelect';
  
  // Ensure a class is selected and render the class selector
  renderClassSelector();
  if (!selectedClass) {
    selectedClass = 'monk';
  }
  updateClassPreview();
}

function confirmClass() {
  // Safety check
  if (!selectedClass || !CLASS_DATA[selectedClass]) {
    selectedClass = 'monk';
  }
  
  const classSelectMenu = document.getElementById('classSelectMenu');
  const characterCreateMenu = document.getElementById('characterCreateMenu');
  
  if (classSelectMenu) {
    classSelectMenu.classList.add('hidden');
    classSelectMenu.style.display = 'none';
  }
  if (characterCreateMenu) {
    characterCreateMenu.classList.remove('hidden');
    characterCreateMenu.style.display = 'flex';
  }
  
  const data = CLASS_DATA[selectedClass];
  document.getElementById('createClassTitle').textContent = `CREATE ${data.name.toUpperCase()}`;
  
  // Use portrait image if available
  const createCharPreview = document.getElementById('createCharPreview');
  if (data.portraitImg) {
    createCharPreview.innerHTML = `<img src="${data.portraitImg}" alt="${data.name}" style="max-height: 200px; object-fit: contain;" draggable="false">`;
  } else {
    createCharPreview.textContent = data.icon;
  }
  
  document.getElementById('characterNameInput').value = '';
  document.getElementById('startGameBtn').disabled = true;
  
  // Reset options to defaults
  isSeasonalSelected = true;
  isHardcoreSelected = false;
  document.getElementById('optionSeasonal').classList.add('selected');
  document.getElementById('optionSeasonal').querySelector('.checkbox').textContent = '✓';
  document.getElementById('optionHardcore').classList.remove('selected');
  document.getElementById('optionHardcore').querySelector('.checkbox').textContent = '';
  
  gameState = 'characterCreate';
}

function toggleOption(option) {
  if (option === 'seasonal') {
    isSeasonalSelected = !isSeasonalSelected;
    document.getElementById('optionSeasonal').classList.toggle('selected', isSeasonalSelected);
    document.getElementById('optionSeasonal').querySelector('.checkbox').textContent = isSeasonalSelected ? '✓' : '';
  } else {
    isHardcoreSelected = !isHardcoreSelected;
    document.getElementById('optionHardcore').classList.toggle('selected', isHardcoreSelected);
    document.getElementById('optionHardcore').querySelector('.checkbox').textContent = isHardcoreSelected ? '✓' : '';
  }
}

function updateCharacterName() {
  newCharacterName = document.getElementById('characterNameInput').value.trim();
  document.getElementById('startGameBtn').disabled = newCharacterName.length === 0;
}

function createAndStart() {
  if (!newCharacterName) return;
  
  const newChar = {
    name: newCharacterName,
    class: CLASS_DATA[selectedClass].name,
    level: 1,
    mode: 'Demo'
  };
  
  characters.unshift(newChar);
  selectedCharacter = 0;
  
  startGame();
}

function startGame() {
  // Hide all menu screens
  const mainMenu = document.getElementById('mainMenu');
  const classSelect = document.getElementById('classSelectMenu');
  const charCreate = document.getElementById('characterCreateMenu');
  const gameContainer = document.getElementById('gameContainer');
  
  if (mainMenu) {
    mainMenu.classList.add('hidden');
    mainMenu.style.display = 'none';
  }
  if (classSelect) {
    classSelect.classList.add('hidden');
    classSelect.style.display = 'none';
  }
  if (charCreate) {
    charCreate.classList.add('hidden');
    charCreate.style.display = 'none';
  }
  if (gameContainer) {
    gameContainer.classList.remove('hidden');
    gameContainer.style.display = 'block';
  }
  
  gameState = 'playing';
  
  // Show hotkey legend
  updateHotkeyLegend();
  
  // Update portrait with current skin
  updateCharacterPreview();
  
  // Initialize game
  initGame();
}

function initGame() {
  // Validate skill damage bands (development check)
  validateAllSkillBands();
  
  // Set player class/skin from selected character FIRST
  if (selectedCharacter !== null && characters[selectedCharacter]) {
    const char = characters[selectedCharacter];
    player.class = char.class.toLowerCase();
    player.skin = char.skin || 'default';
    player.level = char.level;
  }
  
  // Load character-specific save data (equipment, inventory, skills, etc.)
  const hasCharacterSave = loadCharacterData();
  
  // DEMO: No starting gems - players earn them through gameplay
  // Initialize gem inventory (empty for demo)
  if (gemInventory.length === 0) {
    // No starter gems in demo
  }
  
  // Initialize player currency if not exists (DEMO: Start with 0)
  player.currency = player.currency || {};
  player.currency.gemcuttersPrism = player.currency.gemcuttersPrism || 0;
  
  // Initialize passive tree for class (only if not loaded from save)
  if (!hasCharacterSave || allocatedPassives.size === 0) {
    initClassStartNode();
  }
  // Grant passive points for current level (1 per level, starting at level 2)
  if (passivePoints === 0 && passivePointsSpent === 0) {
    passivePoints = Math.max(0, player.level - 1);
  }
  
  // Recalculate all stats based on class and equipment
  recalculateStats();
  player.hp = player.maxHp;
  player.mana = player.maxMana;
  player.currentShield = player.shield;
  
  // Only set default skills if no saved skills (new character)
  if (!hasCharacterSave || equippedSkills.length === 0) {
    const defaultSkills = DEFAULT_EQUIPPED_SKILLS[player.class] || DEFAULT_EQUIPPED_SKILLS.monk;
    equippedSkills = [...defaultSkills];
  }
  
  // Update skill bar UI with current skills
  for (let i = 0; i < 5; i++) {
    const slot = document.getElementById(`skill-slot-${i}`);
    if (slot) {
      const skillKey = equippedSkills[i];
      const skillData = SKILLS[skillKey];
      const gemData = SKILL_GEM_DATA[skillKey];
      updateSkillSlotIcon(slot, skillData, gemData);
    }
  }
  
  // Update AI priority pip displays
  updateAllAIPipDisplays();
  
  // Rebuild inventory/stash grids
  gridNeedsRebuild = true;
  stashGridNeedsRebuild = true;
  
  generateDungeon();
  updateStats();
  updateUI();
  updateCharPanel(); // Update STR/DEX/INT/Damage display
  updateCharacterFace(); // Update character portrait in skill bar
}

// Update the character face/portrait in the skill bar
function updateCharacterFace() {
  const portraitImg = document.getElementById('portraitImg');
  const portraitIcon = document.getElementById('portraitIcon');
  const levelBadge = document.getElementById('levelBadge');
  
  if (levelBadge) {
    levelBadge.textContent = player.level;
  }
  
  const classData = CLASS_DATA[player.class];
  
  if (portraitImg && portraitIcon) {
    if (classData?.headshotImg) {
      // Use image
      portraitImg.src = classData.headshotImg;
      portraitImg.alt = classData.name;
      portraitImg.style.display = 'block';
      portraitIcon.style.display = 'none';
    } else {
      // Use emoji fallback
      portraitImg.style.display = 'none';
      portraitIcon.style.display = 'block';
      portraitIcon.textContent = classData?.icon || '👤';
    }
  }
}

// ============ CONFIG ============
const TILE = 36;
const PLAYER_RADIUS = 12;

const BIOMES = [
  { 
    name: 'The Ossuary', 
    floor: '#2a2520', floorAlt: '#302a25', 
    wall: '#3a352f', wallTop: '#4a453f',
    fog: '#151210',
    decorColor: '#1a1815', accentColor: '#4a4540',
    particles: { color: '#555', count: 8, speed: 0.1 },
    decorTypes: ['bones', 'cracks', 'debris']
  },
  { 
    name: 'Dried Lake', 
    floor: '#8a7a60', floorAlt: '#9a8a70', 
    wall: '#6a5a45', wallTop: '#7a6a55',
    fog: '#b8a888',
    decorColor: '#5a4a35', accentColor: '#7a6a50',
    particles: { color: '#c8b898', count: 10, speed: 0.15 },
    decorTypes: ['cracks', 'rocks', 'sand']
  },
  { 
    name: 'Verdant Wilds', 
    floor: '#283828', floorAlt: '#304030', 
    wall: '#1a2818', wallTop: '#253520',
    fog: '#2a3528',
    decorColor: '#1a2515', accentColor: '#4a6045',
    particles: { color: '#5a8050', count: 10, speed: 0.12 },
    decorTypes: ['moss', 'leaves']
  },
  { 
    name: 'Crystal Caves', 
    floor: '#1a1a28', floorAlt: '#202030', 
    wall: '#282840', wallTop: '#353550',
    fog: '#10101a',
    decorColor: '#25254a', accentColor: '#6666cc',
    particles: { color: '#8888ff', count: 12, speed: 0.08 },
    decorTypes: ['crystals', 'sparkles']
  },
  { 
    name: 'Volcanic Depths', 
    floor: '#281815', floorAlt: '#30201a', 
    wall: '#1a0c08', wallTop: '#281510',
    fog: '#140808',
    decorColor: '#200a05', accentColor: '#ff5522',
    particles: { color: '#ff6633', count: 10, speed: 0.2 },
    decorTypes: ['lava_cracks', 'embers']
  },
  { 
    name: 'Frozen Wastes', 
    floor: '#90a0b0', floorAlt: '#a0b0c0', 
    wall: '#6878a0', wallTop: '#7888b0',
    fog: '#c0d0e0',
    decorColor: '#708098', accentColor: '#d0e0f0',
    particles: { color: '#ffffff', count: 15, speed: 0.1 },
    decorTypes: ['ice', 'frost', 'snow']
  },
];

// ========== BALANCE REFERENCE (SANITY CHECK) ==========
// This section documents expected values for validation and debugging.
//
// HYBRID DAMAGE MODEL (PoE2-style):
// Enemies deal MIXED damage - Physical + Elemental portions
// Bosses shift +30% toward elemental (scarier without capped resists!)
//
// DEFENSE PRIORITY:
// 1. 🥇 Resistances - Mandatory baseline, boss slams are mostly elemental
// 2. 🥈 Dodge - Can fully negate big hits, RNG-based  
// 3. 🪨 Armor - Smooths trash damage, melts vs boss slams
//
// ARMOR FORMULA (PoE-style, scales with hit size):
//   reduction = armor / (armor + rawPhysDamage * 5)
//
// | Hit Size | 100 Armor | 200 Armor | 300 Armor |
// |----------|-----------|-----------|-----------|
// |       10 |       67% |       80% |       86% |
// |       25 |       44% |       62% |       71% |
// |       50 |       29% |       44% |       55% |
// |      100 |       17% |       29% |       38% |
//
// This means: Armor CRUSHES trash hits, MELTS vs boss slams
// You NEED capped resists for boss fights!
//
// ELEMENTAL RESISTANCES (75% cap each):
// Fire, Cold, Lightning, Nature
// Bosses deal 70-90% elemental (after +30% shift)
// Stack from gear suffixes + Resistance passive
//
// DIFFICULTY DEFENSE RECOMMENDATIONS:
// | Difficulty | Resists Rec | Notes                         |
// |------------|-------------|-------------------------------|
// | Easy       | Any         | No defense needed             |
// | Normal     | Any         | Light defense helps           |
// | Hard       | 30%+        | Resists start mattering       |
// | Elite      | 50%+        | Need layered defenses         |
// | Nightmare  | 70%+        | High resists recommended      |
// | Core       | 75%         | Capped resists recommended    |
//
// PLAYER HP BY LEVEL (base 80 + level * 8, before gear):
// Level 1: 88 HP | Level 10: 160 HP | Level 50: 480 HP | Level 70: 640 HP
//
// DEFENSE CAPS:
// - Elemental Resistances: 75% each (Fire, Cold, Lightning, Nature)
// - Dodge: 70% (capped)
// - Armor: No cap (but diminishing returns vs big hits)
//
// DEFENSE OPTIONS (pick what works for your build):
// - Armor: Reduces physical damage
// - Dodge: Chance to avoid all damage
// - Shield: Energy shield buffer before HP
// - Resistances: Reduces elemental damage
// ========================================================

const ENEMIES = [
  // Enemies deal HYBRID damage - physical base + elemental portion
  // Format: damage: { physical: 0.X, element: 'type', elemental: 0.X }
  // This ensures BOTH armor AND resistances are always useful
  // Accuracy: Base accuracy for dodge calculation. Bosses get +50%, Elites get +25%
  
  // Undead - Physical + Cold (deathly chill)
  { name: 'Skeleton', hp: 3, dmg: [2, 4], spd: 1.8, color: '#c8c0a8', size: 14, exp: 15, gold: [2, 6], canLeap: true, leapChance: 0.02, type: 'skeleton', accuracy: 100, damage: { physical: 0.7, element: 'cold', elemental: 0.3 } },
  { name: 'Skeleton Warrior', hp: 5, dmg: [3, 5], spd: 1.5, color: '#b8b098', size: 16, exp: 22, gold: [3, 8], type: 'skeleton_warrior', accuracy: 110, damage: { physical: 0.8, element: 'cold', elemental: 0.2 } },
  { name: 'Zombie', hp: 6, dmg: [3, 5], spd: 1.0, color: '#506050', size: 18, exp: 20, gold: [3, 10], type: 'zombie', accuracy: 80, damage: { physical: 0.6, element: 'nature', elemental: 0.4 } },
  { name: 'Bloated Corpse', hp: 10, dmg: [4, 7], spd: 0.7, color: '#405840', size: 24, exp: 35, gold: [5, 15], type: 'bloated', accuracy: 70, damage: { physical: 0.4, element: 'nature', elemental: 0.6 } },
  { name: 'Specter', hp: 2, dmg: [4, 6], spd: 2.5, color: '#8090c0', size: 14, exp: 25, gold: [4, 12], canLeap: true, leapChance: 0.04, type: 'specter', accuracy: 90, damage: { physical: 0.2, element: 'cold', elemental: 0.8 } },
  { name: 'Wraith', hp: 3, dmg: [5, 8], spd: 2.8, color: '#5060a0', size: 16, exp: 35, gold: [5, 15], canLeap: true, leapChance: 0.05, type: 'wraith', accuracy: 95, damage: { physical: 0.1, element: 'cold', elemental: 0.9 } },
  // Beasts - Physical + Nature (venom/disease)
  { name: 'Spider', hp: 2, dmg: [2, 4], spd: 2.2, color: '#403030', size: 12, exp: 12, gold: [1, 4], type: 'spider', accuracy: 85, damage: { physical: 0.5, element: 'nature', elemental: 0.5 } },
  { name: 'Giant Spider', hp: 5, dmg: [3, 6], spd: 1.8, color: '#302020', size: 20, exp: 28, gold: [3, 10], canLeap: true, leapChance: 0.03, type: 'spider_giant', accuracy: 100, damage: { physical: 0.4, element: 'nature', elemental: 0.6 } },
  { name: 'Bat', hp: 2, dmg: [2, 3], spd: 3.0, color: '#352530', size: 10, exp: 10, gold: [1, 3], type: 'bat', accuracy: 120, damage: { physical: 0.9, element: 'nature', elemental: 0.1 } },
  { name: 'Wolf', hp: 4, dmg: [3, 5], spd: 2.4, color: '#505050', size: 16, exp: 20, gold: [2, 7], canLeap: true, leapChance: 0.04, type: 'wolf', accuracy: 110, damage: { physical: 0.85, element: 'cold', elemental: 0.15 } },
  // Humanoid - Physical + Elemental magic
  { name: 'Cultist', hp: 4, dmg: [3, 5], spd: 1.6, color: '#704848', size: 15, exp: 18, gold: [3, 8], canLeap: true, leapChance: 0.03, type: 'cultist', accuracy: 100, damage: { physical: 0.3, element: 'fire', elemental: 0.7 } },
  { name: 'Dark Mage', hp: 3, dmg: [5, 8], spd: 1.4, color: '#483058', size: 15, exp: 30, gold: [5, 12], type: 'mage', accuracy: 90, damage: { physical: 0.1, element: 'lightning', elemental: 0.9 } },
  { name: 'Bandit', hp: 5, dmg: [3, 5], spd: 1.7, color: '#5a4030', size: 16, exp: 20, gold: [4, 12], type: 'bandit', accuracy: 105, damage: { physical: 0.7, element: 'fire', elemental: 0.3 } },
  // Heavy - Mixed damage
  { name: 'Golem', hp: 12, dmg: [5, 8], spd: 0.6, color: '#606068', size: 26, exp: 50, gold: [8, 20], type: 'golem', accuracy: 75, damage: { physical: 0.8, element: 'lightning', elemental: 0.2 } },
  { name: 'Demon', hp: 8, dmg: [6, 10], spd: 1.2, color: '#8a3030', size: 22, exp: 45, gold: [7, 18], canLeap: true, leapChance: 0.03, type: 'demon', accuracy: 115, damage: { physical: 0.4, element: 'fire', elemental: 0.6 } },
  { name: 'Slime', hp: 4, dmg: [2, 4], spd: 1.0, color: '#40a060', size: 16, exp: 15, gold: [2, 6], type: 'slime', accuracy: 60, damage: { physical: 0.3, element: 'nature', elemental: 0.7 } },
];

// ========== ENEMY DRAWING FUNCTIONS ==========
// Each enemy type has a unique silhouette for visual clarity
// Performance: Simple shapes, no shadows, minimal operations

function drawEnemySprite(ctx, e, x, y, frame) {
  const s = e.size;
  const color = e.flash > 0 ? '#fff' : e.color;
  const walkCycle = Math.sin(frame * 0.15 + e.id * 10) * 0.15; // Subtle bob
  const type = e.type || 'default';
  
  ctx.save();
  ctx.translate(x, y);
  
  // Attack animation - lunge forward and scale up
  let attackLunge = 0;
  let attackScale = 1;
  let attackRotation = 0;
  if (e.atkAnim > 0) {
    const animProgress = e.atkAnim / 20;
    // Quick lunge forward then back
    const lungeCurve = Math.sin(animProgress * Math.PI);
    attackLunge = lungeCurve * (e.isBoss ? 25 : 15);
    // Slight scale up on attack
    attackScale = 1 + lungeCurve * (e.isBoss ? 0.25 : 0.15);
    // Slight rotation for menacing effect
    attackRotation = Math.sin(animProgress * Math.PI * 2) * 0.15;
    
    // Attack glow effect for bosses
    if (e.isBoss && lungeCurve > 0.3) {
      ctx.shadowColor = '#ff4444';
      ctx.shadowBlur = 20 * lungeCurve;
    }
  }
  
  // Apply attack transformations
  // Calculate lunge direction toward player
  const angleToPlayer = Math.atan2(player.y - e.y, player.x - e.x);
  ctx.translate(Math.cos(angleToPlayer) * attackLunge, Math.sin(angleToPlayer) * attackLunge);
  ctx.rotate(attackRotation);
  ctx.scale(attackScale, attackScale);
  
  switch(type) {
    case 'skeleton':
    case 'skeleton_warrior':
      drawSkeleton(ctx, s, color, walkCycle, type === 'skeleton_warrior');
      break;
    case 'zombie':
    case 'bloated':
      drawZombie(ctx, s, color, walkCycle, type === 'bloated');
      break;
    case 'specter':
    case 'wraith':
      drawSpecter(ctx, s, color, frame, type === 'wraith');
      break;
    case 'spider':
    case 'spider_giant':
      drawSpider(ctx, s, color, walkCycle, type === 'spider_giant');
      break;
    case 'bat':
      drawBat(ctx, s, color, frame);
      break;
    case 'wolf':
      drawWolf(ctx, s, color, walkCycle);
      break;
    case 'cultist':
      drawCultist(ctx, s, color, walkCycle);
      break;
    case 'mage':
      drawDarkMage(ctx, s, color, frame);
      break;
    case 'bandit':
      drawBandit(ctx, s, color, walkCycle);
      break;
    case 'golem':
      drawGolem(ctx, s, color, walkCycle);
      break;
    case 'demon':
      drawDemon(ctx, s, color, walkCycle, frame);
      break;
    case 'slime':
      drawSlime(ctx, s, color, frame);
      break;
    default:
      // Fallback: simple circle
      ctx.beginPath();
      ctx.arc(0, 0, s, 0, Math.PI * 2);
      ctx.fillStyle = color;
      ctx.fill();
  }
  
  ctx.restore();
}

function drawSkeleton(ctx, s, color, bob, hasWeapon) {
  const y = bob * 3;
  // Skull
  ctx.fillStyle = color;
  ctx.beginPath();
  ctx.ellipse(0, -s * 0.5 + y, s * 0.5, s * 0.6, 0, 0, Math.PI * 2);
  ctx.fill();
  // Eye sockets
  ctx.fillStyle = '#200';
  ctx.beginPath();
  ctx.ellipse(-s * 0.2, -s * 0.5 + y, s * 0.12, s * 0.15, 0, 0, Math.PI * 2);
  ctx.ellipse(s * 0.2, -s * 0.5 + y, s * 0.12, s * 0.15, 0, 0, Math.PI * 2);
  ctx.fill();
  // Eye glow
  ctx.fillStyle = '#f44';
  ctx.beginPath();
  ctx.arc(-s * 0.2, -s * 0.5 + y, s * 0.06, 0, Math.PI * 2);
  ctx.arc(s * 0.2, -s * 0.5 + y, s * 0.06, 0, Math.PI * 2);
  ctx.fill();
  // Ribs/body
  ctx.fillStyle = color;
  ctx.fillRect(-s * 0.3, -s * 0.1 + y, s * 0.6, s * 0.6);
  ctx.fillStyle = '#1a1a1a';
  for (let i = 0; i < 3; i++) {
    ctx.fillRect(-s * 0.2, s * 0.05 + i * s * 0.15 + y, s * 0.4, 2);
  }
  // Arms
  ctx.fillStyle = color;
  ctx.fillRect(-s * 0.5, -s * 0.05 + y, s * 0.15, s * 0.4);
  ctx.fillRect(s * 0.35, -s * 0.05 + y, s * 0.15, s * 0.4);
  // Legs
  ctx.fillRect(-s * 0.25, s * 0.5 + y, s * 0.12, s * 0.4);
  ctx.fillRect(s * 0.13, s * 0.5 + y, s * 0.12, s * 0.4);
  // Weapon for warrior variant
  if (hasWeapon) {
    ctx.fillStyle = '#666';
    ctx.fillRect(s * 0.45, -s * 0.3 + y, 3, s * 0.9);
    ctx.fillStyle = '#888';
    ctx.fillRect(s * 0.43, -s * 0.5 + y, 7, 4);
  }
}

function drawZombie(ctx, s, color, bob, bloated) {
  const y = bob * 4;
  const width = bloated ? 1.4 : 1;
  // Body (hunched)
  ctx.fillStyle = color;
  ctx.beginPath();
  ctx.ellipse(0, s * 0.1 + y, s * 0.5 * width, s * 0.7, 0, 0, Math.PI * 2);
  ctx.fill();
  // Head (drooping)
  ctx.beginPath();
  ctx.ellipse(s * 0.15, -s * 0.5 + y, s * 0.35, s * 0.4, 0.3, 0, Math.PI * 2);
  ctx.fill();
  // Torn clothing
  ctx.fillStyle = '#333';
  ctx.fillRect(-s * 0.4, s * 0.2 + y, s * 0.8, s * 0.3);
  // Eyes (one droopy)
  ctx.fillStyle = '#8a8';
  ctx.beginPath();
  ctx.arc(-s * 0.05 + s * 0.15, -s * 0.55 + y, s * 0.1, 0, Math.PI * 2);
  ctx.fill();
  ctx.fillStyle = '#600';
  ctx.beginPath();
  ctx.arc(s * 0.25 + s * 0.15, -s * 0.45 + y, s * 0.08, 0, Math.PI * 2);
  ctx.fill();
  // Arms (one hanging low)
  ctx.fillStyle = color;
  ctx.fillRect(-s * 0.6, 0 + y, s * 0.15, s * 0.7);
  ctx.fillRect(s * 0.4, s * 0.1 + y, s * 0.15, s * 0.5);
  // Legs
  ctx.fillRect(-s * 0.3, s * 0.7 + y, s * 0.18, s * 0.35);
  ctx.fillRect(s * 0.12, s * 0.7 + y, s * 0.18, s * 0.35);
}

function drawSpecter(ctx, s, color, frame, isWraith) {
  const float = Math.sin(frame * 0.08) * 4;
  const sway = Math.sin(frame * 0.05) * 3;
  // Ghostly glow
  ctx.globalAlpha = 0.3;
  ctx.fillStyle = isWraith ? '#6060ff' : '#8090c0';
  ctx.beginPath();
  ctx.ellipse(sway, float, s * 1.2, s * 1.2, 0, 0, Math.PI * 2);
  ctx.fill();
  ctx.globalAlpha = 0.7;
  // Main body (wispy)
  ctx.fillStyle = color;
  ctx.beginPath();
  ctx.moveTo(-s * 0.5 + sway, -s * 0.3 + float);
  ctx.quadraticCurveTo(-s * 0.6 + sway, s * 0.5 + float, 0 + sway, s * 0.8 + float);
  ctx.quadraticCurveTo(s * 0.6 + sway, s * 0.5 + float, s * 0.5 + sway, -s * 0.3 + float);
  ctx.quadraticCurveTo(0 + sway, -s * 0.8 + float, -s * 0.5 + sway, -s * 0.3 + float);
  ctx.fill();
  // Hood/head
  ctx.beginPath();
  ctx.ellipse(sway, -s * 0.2 + float, s * 0.4, s * 0.5, 0, 0, Math.PI * 2);
  ctx.fill();
  // Hollow eyes
  ctx.fillStyle = isWraith ? '#4040ff' : '#fff';
  ctx.beginPath();
  ctx.ellipse(-s * 0.15 + sway, -s * 0.2 + float, s * 0.12, s * 0.08, 0, 0, Math.PI * 2);
  ctx.ellipse(s * 0.15 + sway, -s * 0.2 + float, s * 0.12, s * 0.08, 0, 0, Math.PI * 2);
  ctx.fill();
  ctx.globalAlpha = 1;
}

function drawSpider(ctx, s, color, bob, giant) {
  const legMove = bob * 8;
  // Body segments
  ctx.fillStyle = color;
  ctx.beginPath();
  ctx.ellipse(0, s * 0.2, s * 0.6, s * 0.4, 0, 0, Math.PI * 2);
  ctx.fill();
  ctx.beginPath();
  ctx.ellipse(0, -s * 0.3, s * 0.35, s * 0.3, 0, 0, Math.PI * 2);
  ctx.fill();
  // Legs (8 total, 4 per side)
  ctx.strokeStyle = color;
  ctx.lineWidth = giant ? 3 : 2;
  for (let i = 0; i < 4; i++) {
    const angle = -0.8 + i * 0.4;
    const legLen = s * 0.9;
    const move = (i % 2 === 0 ? legMove : -legMove);
    // Left legs
    ctx.beginPath();
    ctx.moveTo(-s * 0.3, s * 0.1);
    ctx.lineTo(-s * 0.3 - Math.cos(angle) * legLen, s * 0.1 + Math.sin(angle) * legLen + move);
    ctx.stroke();
    // Right legs
    ctx.beginPath();
    ctx.moveTo(s * 0.3, s * 0.1);
    ctx.lineTo(s * 0.3 + Math.cos(angle) * legLen, s * 0.1 + Math.sin(angle) * legLen - move);
    ctx.stroke();
  }
  // Eyes (multiple)
  ctx.fillStyle = giant ? '#f00' : '#800';
  for (let i = 0; i < 4; i++) {
    ctx.beginPath();
    ctx.arc(-s * 0.15 + i * s * 0.1, -s * 0.35, s * 0.06, 0, Math.PI * 2);
    ctx.fill();
  }
  // Fangs
  ctx.fillStyle = '#eee';
  ctx.beginPath();
  ctx.moveTo(-s * 0.1, -s * 0.1);
  ctx.lineTo(-s * 0.05, s * 0.15);
  ctx.lineTo(0, -s * 0.1);
  ctx.fill();
  ctx.beginPath();
  ctx.moveTo(0, -s * 0.1);
  ctx.lineTo(s * 0.05, s * 0.15);
  ctx.lineTo(s * 0.1, -s * 0.1);
  ctx.fill();
}

function drawBat(ctx, s, color, frame) {
  const wingFlap = Math.sin(frame * 0.3) * 0.5;
  const float = Math.sin(frame * 0.1) * 3;
  ctx.translate(0, float);
  // Body
  ctx.fillStyle = color;
  ctx.beginPath();
  ctx.ellipse(0, 0, s * 0.4, s * 0.5, 0, 0, Math.PI * 2);
  ctx.fill();
  // Wings
  ctx.save();
  ctx.rotate(wingFlap);
  ctx.beginPath();
  ctx.moveTo(-s * 0.3, 0);
  ctx.quadraticCurveTo(-s * 1.2, -s * 0.3, -s * 0.8, s * 0.4);
  ctx.lineTo(-s * 0.3, s * 0.2);
  ctx.fill();
  ctx.restore();
  ctx.save();
  ctx.rotate(-wingFlap);
  ctx.beginPath();
  ctx.moveTo(s * 0.3, 0);
  ctx.quadraticCurveTo(s * 1.2, -s * 0.3, s * 0.8, s * 0.4);
  ctx.lineTo(s * 0.3, s * 0.2);
  ctx.fill();
  ctx.restore();
  // Ears
  ctx.beginPath();
  ctx.moveTo(-s * 0.2, -s * 0.3);
  ctx.lineTo(-s * 0.3, -s * 0.7);
  ctx.lineTo(-s * 0.05, -s * 0.4);
  ctx.fill();
  ctx.beginPath();
  ctx.moveTo(s * 0.2, -s * 0.3);
  ctx.lineTo(s * 0.3, -s * 0.7);
  ctx.lineTo(s * 0.05, -s * 0.4);
  ctx.fill();
  // Eyes
  ctx.fillStyle = '#f44';
  ctx.beginPath();
  ctx.arc(-s * 0.12, -s * 0.1, s * 0.08, 0, Math.PI * 2);
  ctx.arc(s * 0.12, -s * 0.1, s * 0.08, 0, Math.PI * 2);
  ctx.fill();
}

function drawWolf(ctx, s, color, bob) {
  const y = bob * 3;
  // Body
  ctx.fillStyle = color;
  ctx.beginPath();
  ctx.ellipse(0, s * 0.2 + y, s * 0.7, s * 0.4, 0, 0, Math.PI * 2);
  ctx.fill();
  // Head
  ctx.beginPath();
  ctx.ellipse(s * 0.5, -s * 0.1 + y, s * 0.4, s * 0.35, 0.3, 0, Math.PI * 2);
  ctx.fill();
  // Snout
  ctx.beginPath();
  ctx.ellipse(s * 0.85, 0 + y, s * 0.2, s * 0.15, 0, 0, Math.PI * 2);
  ctx.fill();
  // Ears
  ctx.beginPath();
  ctx.moveTo(s * 0.3, -s * 0.35 + y);
  ctx.lineTo(s * 0.2, -s * 0.7 + y);
  ctx.lineTo(s * 0.5, -s * 0.4 + y);
  ctx.fill();
  ctx.beginPath();
  ctx.moveTo(s * 0.5, -s * 0.35 + y);
  ctx.lineTo(s * 0.55, -s * 0.7 + y);
  ctx.lineTo(s * 0.7, -s * 0.35 + y);
  ctx.fill();
  // Legs
  ctx.fillRect(-s * 0.5, s * 0.5 + y, s * 0.15, s * 0.4);
  ctx.fillRect(-s * 0.2, s * 0.5 + y, s * 0.15, s * 0.4);
  ctx.fillRect(s * 0.1, s * 0.5 + y, s * 0.15, s * 0.4);
  ctx.fillRect(s * 0.35, s * 0.5 + y, s * 0.15, s * 0.4);
  // Tail
  ctx.beginPath();
  ctx.moveTo(-s * 0.6, s * 0.1 + y);
  ctx.quadraticCurveTo(-s * 1.1, -s * 0.2 + y, -s * 0.9, -s * 0.5 + y);
  ctx.quadraticCurveTo(-s * 0.8, -s * 0.2 + y, -s * 0.5, s * 0.2 + y);
  ctx.fill();
  // Eyes
  ctx.fillStyle = '#ff0';
  ctx.beginPath();
  ctx.arc(s * 0.4, -s * 0.2 + y, s * 0.08, 0, Math.PI * 2);
  ctx.arc(s * 0.6, -s * 0.15 + y, s * 0.08, 0, Math.PI * 2);
  ctx.fill();
  // Nose
  ctx.fillStyle = '#222';
  ctx.beginPath();
  ctx.arc(s * 0.95, 0 + y, s * 0.08, 0, Math.PI * 2);
  ctx.fill();
}

function drawCultist(ctx, s, color, bob) {
  const y = bob * 3;
  // Robe
  ctx.fillStyle = color;
  ctx.beginPath();
  ctx.moveTo(-s * 0.5, -s * 0.2 + y);
  ctx.lineTo(-s * 0.6, s * 0.9 + y);
  ctx.lineTo(s * 0.6, s * 0.9 + y);
  ctx.lineTo(s * 0.5, -s * 0.2 + y);
  ctx.closePath();
  ctx.fill();
  // Hood
  ctx.beginPath();
  ctx.ellipse(0, -s * 0.4 + y, s * 0.45, s * 0.5, 0, 0, Math.PI * 2);
  ctx.fill();
  // Hood shadow (face hidden)
  ctx.fillStyle = '#1a0a0a';
  ctx.beginPath();
  ctx.ellipse(0, -s * 0.25 + y, s * 0.3, s * 0.35, 0, 0, Math.PI * 2);
  ctx.fill();
  // Glowing eyes in shadow
  ctx.fillStyle = '#f44';
  ctx.beginPath();
  ctx.arc(-s * 0.12, -s * 0.3 + y, s * 0.06, 0, Math.PI * 2);
  ctx.arc(s * 0.12, -s * 0.3 + y, s * 0.06, 0, Math.PI * 2);
  ctx.fill();
  // Hands
  ctx.fillStyle = '#886';
  ctx.beginPath();
  ctx.arc(-s * 0.55, s * 0.3 + y, s * 0.12, 0, Math.PI * 2);
  ctx.arc(s * 0.55, s * 0.3 + y, s * 0.12, 0, Math.PI * 2);
  ctx.fill();
}

function drawDarkMage(ctx, s, color, frame) {
  const float = Math.sin(frame * 0.06) * 2;
  const y = float;
  // Robe
  ctx.fillStyle = color;
  ctx.beginPath();
  ctx.moveTo(-s * 0.4, -s * 0.1 + y);
  ctx.lineTo(-s * 0.5, s * 0.85 + y);
  ctx.lineTo(s * 0.5, s * 0.85 + y);
  ctx.lineTo(s * 0.4, -s * 0.1 + y);
  ctx.closePath();
  ctx.fill();
  // Hood
  ctx.beginPath();
  ctx.ellipse(0, -s * 0.35 + y, s * 0.4, s * 0.45, 0, 0, Math.PI * 2);
  ctx.fill();
  // Face shadow
  ctx.fillStyle = '#100818';
  ctx.beginPath();
  ctx.ellipse(0, -s * 0.2 + y, s * 0.25, s * 0.3, 0, 0, Math.PI * 2);
  ctx.fill();
  // Magic glow eyes
  ctx.fillStyle = '#a0f';
  ctx.beginPath();
  ctx.arc(-s * 0.1, -s * 0.25 + y, s * 0.08, 0, Math.PI * 2);
  ctx.arc(s * 0.1, -s * 0.25 + y, s * 0.08, 0, Math.PI * 2);
  ctx.fill();
  // Staff
  ctx.fillStyle = '#442';
  ctx.fillRect(s * 0.45, -s * 0.6 + y, 4, s * 1.4);
  // Staff orb
  ctx.fillStyle = '#80f';
  ctx.globalAlpha = 0.5 + Math.sin(frame * 0.1) * 0.3;
  ctx.beginPath();
  ctx.arc(s * 0.47, -s * 0.7 + y, s * 0.15, 0, Math.PI * 2);
  ctx.fill();
  ctx.globalAlpha = 1;
}

function drawBandit(ctx, s, color, bob) {
  const y = bob * 3;
  // Body
  ctx.fillStyle = color;
  ctx.beginPath();
  ctx.ellipse(0, s * 0.15 + y, s * 0.45, s * 0.55, 0, 0, Math.PI * 2);
  ctx.fill();
  // Head
  ctx.fillStyle = '#a08070';
  ctx.beginPath();
  ctx.arc(0, -s * 0.5 + y, s * 0.35, 0, Math.PI * 2);
  ctx.fill();
  // Bandana/mask
  ctx.fillStyle = '#433';
  ctx.fillRect(-s * 0.35, -s * 0.4 + y, s * 0.7, s * 0.2);
  // Eyes above mask
  ctx.fillStyle = '#222';
  ctx.beginPath();
  ctx.arc(-s * 0.12, -s * 0.55 + y, s * 0.07, 0, Math.PI * 2);
  ctx.arc(s * 0.12, -s * 0.55 + y, s * 0.07, 0, Math.PI * 2);
  ctx.fill();
  // Arms
  ctx.fillStyle = color;
  ctx.fillRect(-s * 0.6, 0 + y, s * 0.18, s * 0.45);
  ctx.fillRect(s * 0.42, 0 + y, s * 0.18, s * 0.45);
  // Legs
  ctx.fillStyle = '#332';
  ctx.fillRect(-s * 0.25, s * 0.6 + y, s * 0.18, s * 0.35);
  ctx.fillRect(s * 0.07, s * 0.6 + y, s * 0.18, s * 0.35);
  // Dagger
  ctx.fillStyle = '#999';
  ctx.fillRect(s * 0.5, s * 0.2 + y, 3, s * 0.4);
}

function drawGolem(ctx, s, color, bob) {
  const y = bob * 2;
  // Large rocky body
  ctx.fillStyle = color;
  ctx.beginPath();
  ctx.moveTo(-s * 0.5, -s * 0.3 + y);
  ctx.lineTo(-s * 0.6, s * 0.5 + y);
  ctx.lineTo(-s * 0.4, s * 0.8 + y);
  ctx.lineTo(s * 0.4, s * 0.8 + y);
  ctx.lineTo(s * 0.6, s * 0.5 + y);
  ctx.lineTo(s * 0.5, -s * 0.3 + y);
  ctx.closePath();
  ctx.fill();
  // Head
  ctx.beginPath();
  ctx.moveTo(-s * 0.35, -s * 0.3 + y);
  ctx.lineTo(-s * 0.25, -s * 0.7 + y);
  ctx.lineTo(s * 0.25, -s * 0.7 + y);
  ctx.lineTo(s * 0.35, -s * 0.3 + y);
  ctx.closePath();
  ctx.fill();
  // Rock texture lines
  ctx.strokeStyle = '#444';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(-s * 0.3, 0 + y);
  ctx.lineTo(s * 0.1, s * 0.2 + y);
  ctx.moveTo(s * 0.2, -s * 0.1 + y);
  ctx.lineTo(s * 0.4, s * 0.4 + y);
  ctx.stroke();
  // Glowing core/eyes
  ctx.fillStyle = '#fa0';
  ctx.beginPath();
  ctx.arc(-s * 0.12, -s * 0.5 + y, s * 0.1, 0, Math.PI * 2);
  ctx.arc(s * 0.12, -s * 0.5 + y, s * 0.1, 0, Math.PI * 2);
  ctx.fill();
  // Massive arms
  ctx.fillStyle = color;
  ctx.beginPath();
  ctx.ellipse(-s * 0.7, s * 0.2 + y, s * 0.25, s * 0.4, 0.3, 0, Math.PI * 2);
  ctx.fill();
  ctx.beginPath();
  ctx.ellipse(s * 0.7, s * 0.2 + y, s * 0.25, s * 0.4, -0.3, 0, Math.PI * 2);
  ctx.fill();
  // Fists
  ctx.beginPath();
  ctx.arc(-s * 0.8, s * 0.55 + y, s * 0.2, 0, Math.PI * 2);
  ctx.arc(s * 0.8, s * 0.55 + y, s * 0.2, 0, Math.PI * 2);
  ctx.fill();
}

function drawDemon(ctx, s, color, bob, frame) {
  const y = bob * 3;
  // Body
  ctx.fillStyle = color;
  ctx.beginPath();
  ctx.ellipse(0, s * 0.1 + y, s * 0.5, s * 0.6, 0, 0, Math.PI * 2);
  ctx.fill();
  // Head
  ctx.beginPath();
  ctx.arc(0, -s * 0.5 + y, s * 0.4, 0, Math.PI * 2);
  ctx.fill();
  // Horns
  ctx.beginPath();
  ctx.moveTo(-s * 0.25, -s * 0.7 + y);
  ctx.quadraticCurveTo(-s * 0.5, -s * 1.2 + y, -s * 0.3, -s * 1.1 + y);
  ctx.lineTo(-s * 0.2, -s * 0.8 + y);
  ctx.fill();
  ctx.beginPath();
  ctx.moveTo(s * 0.25, -s * 0.7 + y);
  ctx.quadraticCurveTo(s * 0.5, -s * 1.2 + y, s * 0.3, -s * 1.1 + y);
  ctx.lineTo(s * 0.2, -s * 0.8 + y);
  ctx.fill();
  // Glowing eyes
  ctx.fillStyle = '#ff0';
  ctx.beginPath();
  ctx.arc(-s * 0.15, -s * 0.5 + y, s * 0.1, 0, Math.PI * 2);
  ctx.arc(s * 0.15, -s * 0.5 + y, s * 0.1, 0, Math.PI * 2);
  ctx.fill();
  // Mouth
  ctx.fillStyle = '#400';
  ctx.beginPath();
  ctx.ellipse(0, -s * 0.3 + y, s * 0.15, s * 0.08, 0, 0, Math.PI * 2);
  ctx.fill();
  // Wings (small)
  ctx.fillStyle = '#600';
  ctx.beginPath();
  ctx.moveTo(-s * 0.4, -s * 0.1 + y);
  ctx.quadraticCurveTo(-s * 1, -s * 0.5 + y, -s * 0.7, s * 0.3 + y);
  ctx.lineTo(-s * 0.4, s * 0.2 + y);
  ctx.fill();
  ctx.beginPath();
  ctx.moveTo(s * 0.4, -s * 0.1 + y);
  ctx.quadraticCurveTo(s * 1, -s * 0.5 + y, s * 0.7, s * 0.3 + y);
  ctx.lineTo(s * 0.4, s * 0.2 + y);
  ctx.fill();
  // Legs
  ctx.fillStyle = color;
  ctx.fillRect(-s * 0.3, s * 0.6 + y, s * 0.18, s * 0.35);
  ctx.fillRect(s * 0.12, s * 0.6 + y, s * 0.18, s * 0.35);
  // Hooves
  ctx.fillStyle = '#333';
  ctx.fillRect(-s * 0.32, s * 0.9 + y, s * 0.22, s * 0.1);
  ctx.fillRect(s * 0.1, s * 0.9 + y, s * 0.22, s * 0.1);
}

function drawSlime(ctx, s, color, frame) {
  const squish = 1 + Math.sin(frame * 0.1) * 0.15;
  const squishY = 1 / squish;
  // Body (blobby)
  ctx.fillStyle = color;
  ctx.globalAlpha = 0.8;
  ctx.beginPath();
  ctx.ellipse(0, s * 0.2, s * 0.7 * squish, s * 0.5 * squishY, 0, 0, Math.PI * 2);
  ctx.fill();
  // Highlight
  ctx.fillStyle = '#8f8';
  ctx.globalAlpha = 0.4;
  ctx.beginPath();
  ctx.ellipse(-s * 0.2, -s * 0.1, s * 0.25, s * 0.2, -0.3, 0, Math.PI * 2);
  ctx.fill();
  ctx.globalAlpha = 1;
  // Eyes
  ctx.fillStyle = '#fff';
  ctx.beginPath();
  ctx.arc(-s * 0.2, 0, s * 0.15, 0, Math.PI * 2);
  ctx.arc(s * 0.2, 0, s * 0.15, 0, Math.PI * 2);
  ctx.fill();
  ctx.fillStyle = '#222';
  ctx.beginPath();
  ctx.arc(-s * 0.2, s * 0.02, s * 0.08, 0, Math.PI * 2);
  ctx.arc(s * 0.2, s * 0.02, s * 0.08, 0, Math.PI * 2);
  ctx.fill();
}

// ╔════════════════════════════════════════════════════════════════════════════╗
// ║                    ARMOR BASE SYSTEM - FINAL SPECIFICATION                  ║
// ║                         DO NOT MODIFY WITHOUT REVIEW                        ║
// ╚════════════════════════════════════════════════════════════════════════════╝
//
// ┌─────────────────────────────────────────────────────────────────────────────┐
// │ RULE 1: BASE IDENTITY                                                       │
// │ One base name per defense COMBINATION. This is FINAL.                       │
// │ • Pure bases: exactly ONE per attribute (STR, DEX, INT)                     │
// │ • Hybrid bases: exactly ONE per attribute pair (STR/DEX, STR/INT, DEX/INT)  │
// │ • Hybrid bases must NOT be removed during consolidation                     │
// └─────────────────────────────────────────────────────────────────────────────┘
//
// ┌─────────────────────────────────────────────────────────────────────────────┐
// │ RULE 2: INT HELMET CONFIRMATION                                             │
// │ Silk Hood is the ONLY pure INT helmet base in the game.                     │
// │ All INT helmet progression uses Silk Hood.                                  │
// │ Silk Hood may use multiple images for cosmetic variety.                     │
// │ This NEVER creates new bases or mechanics.                                  │
// └─────────────────────────────────────────────────────────────────────────────┘
//
// ┌─────────────────────────────────────────────────────────────────────────────┐
// │ RULE 3: HYBRID DEFENSE VALUES                                               │
// │ Hybrid bases provide BOTH defense types with reduced base values.           │
// │ Implementation: 55% of each pure base's value (split hybrid defenses).      │
// │ Example: Scale Helm gives 55% Armor AND 55% Dodge vs pure bases.            │
// │ This makes hybrids slightly stronger in coverage without overshadowing pure.│
// └─────────────────────────────────────────────────────────────────────────────┘
//
// ┌─────────────────────────────────────────────────────────────────────────────┐
// │ RULE 4: HYBRID RARITY AVAILABILITY                                          │
// │ Hybrid bases do NOT drop as Normal rarity.                                  │
// │ This is INTENTIONAL to preserve early-game readability.                     │
// │ Hybrids appear at Magic+ rarity only.                                       │
// └─────────────────────────────────────────────────────────────────────────────┘
//
// ┌─────────────────────────────────────────────────────────────────────────────┐
// │ RULE 5: STAT SCALING                                                        │
// │ Base defensive stats scale ONLY with item level (ilvl).                     │
// │ Rarity adds AFFIXES — never base stats.                                     │
// │ There are NO upgraded base names (no Steel Helm / Royal Helm progression).  │
// └─────────────────────────────────────────────────────────────────────────────┘
//
// ┌─────────────────────────────────────────────────────────────────────────────┐
// │ RULE 6: UNIVERSAL APPLICATION                                               │
// │ These rules apply to ALL armor slots:                                       │
// │ • Helmets, Body Armor, Gloves, Boots                                        │
// │ One base per defense combination, cosmetic variation only via images.       │
// └─────────────────────────────────────────────────────────────────────────────┘
//
// ════════════════════════════════════════════════════════════════════════════════
// COMPLETE BASE REGISTRY (24 armor bases total)
// ════════════════════════════════════════════════════════════════════════════════
//
// HELMETS (6 bases):
// │ Defense      │ Base Name      │ Rarity      │
// │ Pure STR     │ Plate Helm     │ Normal+     │
// │ Pure DEX     │ Leather Cap    │ Normal+     │
// │ Pure INT     │ Silk Hood      │ Normal+     │
// │ STR/DEX      │ Scale Helm     │ Magic+      │
// │ STR/INT      │ Crusader Helm  │ Magic+      │
// │ DEX/INT      │ Assassin Hood  │ Magic+      │
//
// BODY ARMOR (6 bases):
// │ Defense      │ Base Name      │ Rarity      │
// │ Pure STR     │ Plate Armor    │ Normal+     │
// │ Pure DEX     │ Leather Tunic  │ Normal+     │
// │ Pure INT     │ Silk Robe      │ Normal+     │
// │ STR/DEX      │ Scale Armor    │ Magic+      │
// │ STR/INT      │ Crusader Armor │ Magic+      │
// │ DEX/INT      │ Assassin Garb  │ Magic+      │
//
// GLOVES (6 bases):
// │ Defense      │ Base Name         │ Rarity      │
// │ Pure STR     │ Plate Gauntlets   │ Normal+     │
// │ Pure DEX     │ Leather Gloves    │ Normal+     │
// │ Pure INT     │ Silk Gloves       │ Normal+     │
// │ STR/DEX      │ Scale Gauntlets   │ Magic+      │
// │ STR/INT      │ Crusader Gauntlets│ Magic+      │
// │ DEX/INT      │ Assassin Gloves   │ Magic+      │
//
// BOOTS (6 bases):
// │ Defense      │ Base Name         │ Rarity      │
// │ Pure STR     │ Plate Greaves     │ Normal+     │
// │ Pure DEX     │ Leather Boots     │ Normal+     │
// │ Pure INT     │ Silk Slippers     │ Normal+     │
// │ STR/DEX      │ Scale Boots       │ Magic+      │
// │ STR/INT      │ Crusader Greaves  │ Magic+      │
// │ DEX/INT      │ Assassin Boots    │ Magic+      │
//
// ════════════════════════════════════════════════════════════════════════════════
// THIS SYSTEM IS FINAL. DO NOT ADD NEW BASES UNLESS A NEW DEFENSE TYPE IS ADDED.
// ════════════════════════════════════════════════════════════════════════════════

const LOOT = {
  normal: [
    // Weapons (8 types - 2 per class)
    'Viper Blade', 'War Blade', 'Windspire Quarterstaff', 'Ironbark Quarterstaff',
    'Windrunner Bow', 'Ironwood Bow', 'Mystic Staff', 'Elder Staff',
    // Body - pure bases only (no hybrids at Normal)
    'Silk Robe', 'Leather Tunic', 'Plate Armor',
    // Helmets - pure bases only (no hybrids at Normal)
    'Mage Hat', 'Leather Cap', 'Iron Helm',
    // Gloves - pure bases only (no hybrids at Normal)
    'Silk Gloves', 'Leather Gloves', 'Plate Gauntlets',
    // Boots - pure bases only (no hybrids at Normal)
    'Silk Slippers', 'Leather Boots', 'Plate Greaves',
    // Jewelry - renamed to match implicits
    'Nature Ring', 'Vitality Ring', 'Might Amulet', 'Grace Amulet'
  ],
  magic: [
    // Weapons
    'Viper Blade', 'War Blade', 'Windspire Quarterstaff', 'Ironbark Quarterstaff',
    'Windrunner Bow', 'Ironwood Bow', 'Mystic Staff', 'Elder Staff',
    // Body - pure and hybrid bases
    'Silk Robe', 'Leather Tunic', 'Plate Armor',
    'Scale Armor', 'Crusader Armor', 'Assassin Garb',
    // Helmets - pure and hybrid bases
    'Mage Hat', 'Leather Cap', 'Iron Helm',
    'Scale Helm', 'Crusader Helm', 'Bone Circlet',
    // Gloves - pure and hybrid bases
    'Silk Gloves', 'Leather Gloves', 'Plate Gauntlets',
    'Scale Gauntlets', 'Crusader Gauntlets', 'Assassin Gloves',
    // Boots - pure and hybrid bases
    'Silk Slippers', 'Leather Boots', 'Plate Greaves',
    'Scale Boots', 'Crusader Greaves', 'Assassin Boots',
    // Jewelry - renamed to match implicits
    'Arcane Ring', 'Flame Ring', 'Frost Ring', 'Wisdom Amulet', 'Harmony Amulet'
  ],
  rare: [
    // Weapons
    'Viper Blade', 'War Blade', 'Windspire Quarterstaff', 'Ironbark Quarterstaff',
    'Windrunner Bow', 'Ironwood Bow', 'Mystic Staff', 'Elder Staff',
    // Body - pure and hybrid bases
    'Silk Robe', 'Leather Tunic', 'Plate Armor',
    'Scale Armor', 'Crusader Armor', 'Assassin Garb',
    // Helmets - pure and hybrid bases
    'Mage Hat', 'Leather Cap', 'Iron Helm',
    'Scale Helm', 'Crusader Helm', 'Bone Circlet',
    // Gloves - pure and hybrid bases
    'Silk Gloves', 'Leather Gloves', 'Plate Gauntlets',
    'Scale Gauntlets', 'Crusader Gauntlets', 'Assassin Gloves',
    // Boots - pure and hybrid bases
    'Silk Slippers', 'Leather Boots', 'Plate Greaves',
    'Scale Boots', 'Crusader Greaves', 'Assassin Boots',
    // Jewelry - renamed to match implicits
    'Storm Ring', 'Prismatic Ring', 'Nature Ring', 'Might Amulet', 'Harmony Amulet'
  ],
  unique: [
    // Unique items are generated from UNIQUE_ITEMS registry below
  ],
};

// ════════════════════════════════════════════════════════════════════════════════
// ASPECTS REGISTRY
// Account-wide permanent bonuses unlocked through gameplay discoveries
// Aspects are NOT items - they unlock instantly and persist forever
// ════════════════════════════════════════════════════════════════════════════════
const ASPECTS = {
  // ═══════════════════════════════════════════════════════════════════════
  // CLASS-SPECIFIC PASSIVE ASPECTS (Common - doubles passive bonuses)
  // 12 total: 3 per class (Power, Vitality, Resistance)
  // ═══════════════════════════════════════════════════════════════════════
  
  // MONK PASSIVE ASPECTS
  aspect_monk_power: {
    id: 'aspect_monk_power',
    name: 'Aspect of Monk Power',
    skillRef: 'monkPower',
    fallbackIcon: '⚔️',
    rarity: 'common',
    class: 'monk',
    category: 'offensive',
    description: 'Doubles the effect of Monk Power. (+5% Damage becomes +10% Damage)',
    tooltip: 'Inner strength amplified.'
  },
  aspect_monk_vitality: {
    id: 'aspect_monk_vitality',
    name: 'Aspect of Monk Vitality',
    skillRef: 'monkVitality',
    fallbackIcon: '❤️',
    rarity: 'common',
    class: 'monk',
    category: 'defensive',
    description: 'Doubles the effect of Monk Vitality. (+5% HP becomes +10% HP)',
    tooltip: 'Body hardened through meditation.'
  },
  aspect_monk_resistance: {
    id: 'aspect_monk_resistance',
    name: 'Aspect of Monk Resistance',
    skillRef: 'monkResistance',
    fallbackIcon: '🛡️',
    rarity: 'common',
    class: 'monk',
    category: 'utility',
    description: 'Doubles the effect of Monk Resistance. (+5% All Resist becomes +10% All Resist)',
    tooltip: 'Spiritual wards strengthened.'
  },
  
  // WARRIOR PASSIVE ASPECTS
  aspect_warrior_power: {
    id: 'aspect_warrior_power',
    name: 'Aspect of Warrior Power',
    skillRef: 'warriorPower',
    fallbackIcon: '⚔️',
    rarity: 'common',
    class: 'warrior',
    category: 'offensive',
    description: 'Doubles the effect of Warrior Power. (+5% Damage becomes +10% Damage)',
    tooltip: 'Raw might unleashed.'
  },
  aspect_warrior_vitality: {
    id: 'aspect_warrior_vitality',
    name: 'Aspect of Warrior Vitality',
    skillRef: 'warriorVitality',
    fallbackIcon: '❤️',
    rarity: 'common',
    class: 'warrior',
    category: 'defensive',
    description: 'Doubles the effect of Warrior Vitality. (+5% HP becomes +10% HP)',
    tooltip: 'Battle-hardened constitution.'
  },
  aspect_warrior_resistance: {
    id: 'aspect_warrior_resistance',
    name: 'Aspect of Warrior Resistance',
    skillRef: 'warriorResistance',
    fallbackIcon: '🛡️',
    rarity: 'common',
    class: 'warrior',
    category: 'utility',
    description: 'Doubles the effect of Warrior Resistance. (+5% All Resist becomes +10% All Resist)',
    tooltip: 'Endurance against the elements.'
  },
  
  // RANGER PASSIVE ASPECTS
  aspect_ranger_power: {
    id: 'aspect_ranger_power',
    name: 'Aspect of Ranger Power',
    skillRef: 'rangerPower',
    fallbackIcon: '⚔️',
    rarity: 'common',
    class: 'ranger',
    category: 'offensive',
    description: 'Doubles the effect of Ranger Power. (+5% Damage becomes +10% Damage)',
    tooltip: 'Deadly precision enhanced.'
  },
  aspect_ranger_vitality: {
    id: 'aspect_ranger_vitality',
    name: 'Aspect of Ranger Vitality',
    skillRef: 'rangerVitality',
    fallbackIcon: '❤️',
    rarity: 'common',
    class: 'ranger',
    category: 'defensive',
    description: 'Doubles the effect of Ranger Vitality. (+5% HP becomes +10% HP)',
    tooltip: 'Survival instincts sharpened.'
  },
  aspect_ranger_resistance: {
    id: 'aspect_ranger_resistance',
    name: 'Aspect of Ranger Resistance',
    skillRef: 'rangerResistance',
    fallbackIcon: '🛡️',
    rarity: 'common',
    class: 'ranger',
    category: 'utility',
    description: 'Doubles the effect of Ranger Resistance. (+5% All Resist becomes +10% All Resist)',
    tooltip: 'Natural resilience fortified.'
  },
  
  // MAGE PASSIVE ASPECTS
  aspect_mage_power: {
    id: 'aspect_mage_power',
    name: 'Aspect of Mage Power',
    skillRef: 'magePower',
    fallbackIcon: '⚔️',
    rarity: 'common',
    class: 'mage',
    category: 'offensive',
    description: 'Doubles the effect of Mage Power. (+5% Damage becomes +10% Damage)',
    tooltip: 'Arcane potency magnified.'
  },
  aspect_mage_vitality: {
    id: 'aspect_mage_vitality',
    name: 'Aspect of Mage Vitality',
    skillRef: 'mageVitality',
    fallbackIcon: '❤️',
    rarity: 'common',
    class: 'mage',
    category: 'defensive',
    description: 'Doubles the effect of Mage Vitality. (+5% HP becomes +10% HP)',
    tooltip: 'Life force infused with magic.'
  },
  aspect_mage_resistance: {
    id: 'aspect_mage_resistance',
    name: 'Aspect of Mage Resistance',
    skillRef: 'mageResistance',
    fallbackIcon: '🛡️',
    rarity: 'common',
    class: 'mage',
    category: 'utility',
    description: 'Doubles the effect of Mage Resistance. (+5% All Resist becomes +10% All Resist)',
    tooltip: 'Magical wards reinforced.'
  },
  
  // ═══════════════════════════════════════════════════════════════════════
  // RANGER ASPECTS
  // ═══════════════════════════════════════════════════════════════════════
  sentry_x2: {
    id: 'sentry_x2',
    name: 'Aspect of Twin Sentries',
    skillRef: 'sentry',
    fallbackIcon: '🗼',
    rarity: 'legendary',
    class: 'ranger',
    category: 'offensive',
    description: 'Your Sentry skill now deploys two turrets simultaneously instead of one.',
    tooltip: 'Double the turrets, double the destruction.'
  },
  
  // ═══════════════════════════════════════════════════════════════════════
  // MONK ASPECTS
  // ═══════════════════════════════════════════════════════════════════════
  cyclone_pull: {
    id: 'cyclone_pull',
    name: 'Aspect of the Vortex',
    skillRef: 'cycloneStrike',
    fallbackIcon: '🌪️',
    rarity: 'rare',
    class: 'monk',
    category: 'offensive',
    description: 'Cyclone Strike pulls enemies from twice the distance and deals 20% more damage.',
    tooltip: 'Your vortex reaches further and strikes harder.'
  },
  exploding_palm_power: {
    id: 'exploding_palm_power',
    name: 'Aspect of Detonation',
    skillRef: 'explodingPalm',
    fallbackIcon: '💥',
    rarity: 'legendary',
    class: 'monk',
    category: 'offensive',
    description: 'Exploding Palm has a 50% larger explosion radius and deals 100% more damage.',
    tooltip: 'Explosions deal double damage in a wider area.'
  },
  breath_of_heaven_power: {
    id: 'breath_of_heaven_power',
    name: 'Aspect of Heavenly Grace',
    skillRef: 'breathOfHeaven',
    fallbackIcon: '✨',
    rarity: 'rare',
    class: 'monk',
    category: 'utility',
    description: 'Breath of Heaven grants 30% attack speed (up from 15%) and lasts 4 seconds (up from 2s).',
    tooltip: 'Extended blessing with amplified fervor.'
  },
  wave_of_light_speed: {
    id: 'wave_of_light_speed',
    name: 'Aspect of Radiant Speed',
    skillRef: 'waveOfLight',
    fallbackIcon: '🔔',
    rarity: 'rare',
    class: 'monk',
    category: 'utility',
    description: 'Wave of Light cooldown is reduced by 50%.',
    tooltip: 'Halve the time between divine strikes.'
  },
  wave_of_light_cold: {
    id: 'wave_of_light_cold',
    name: 'Aspect of Frozen Light',
    skillRef: 'waveOfLight',
    fallbackIcon: '❄️',
    rarity: 'rare',
    class: 'monk',
    category: 'offensive',
    description: 'Wave of Light now also scales with Cold Damage in addition to Fire Damage.',
    tooltip: 'Divine flame meets glacial fury.'
  }
};

// Get aspect icon (dynamically from skill if available)
// Returns HTML string (could be emoji or img tag)
function getAspectIcon(aspect) {
  if (aspect.skillRef && typeof SKILL_GEM_DATA !== 'undefined' && SKILL_GEM_DATA[aspect.skillRef]) {
    return SKILL_GEM_DATA[aspect.skillRef].icon;
  }
  return aspect.fallbackIcon || aspect.icon || '❓';
}

// Set aspect icon element (handles both text and HTML)
function setAspectIconElement(element, aspect) {
  const icon = getAspectIcon(aspect);
  // Check if it's an img tag or just text/emoji
  if (icon.startsWith('<img') || icon.startsWith('<')) {
    element.innerHTML = icon;
  } else {
    element.textContent = icon;
  }
}

// Account-wide aspect storage (separate from character saves)
let unlockedAspects = new Set();

// Active aspects (5 slots, 3 unlocked by default)
let activeAspects = [null, null, null, null, null]; // aspectId or null
let activeAspectSlotsUnlocked = 3; // Start with 3 slots unlocked
let selectedAspectForSlot = null; // Track which aspect is being placed

// Load unlocked aspects from localStorage
function loadUnlockedAspects() {
  try {
    const stored = localStorage.getItem('poe2idle_aspects');
    if (stored) {
      const parsed = JSON.parse(stored);
      unlockedAspects = new Set(parsed);
    }
    // Load active aspects
    const activeStored = localStorage.getItem('poe2idle_active_aspects');
    if (activeStored) {
      const activeParsed = JSON.parse(activeStored);
      activeAspects = activeParsed.slots || [null, null, null, null, null];
      activeAspectSlotsUnlocked = activeParsed.slotsUnlocked || 3;
    }
  } catch (e) {
    console.error('Failed to load aspects:', e);
  }
}

// Save unlocked aspects to localStorage
function saveUnlockedAspects() {
  try {
    localStorage.setItem('poe2idle_aspects', JSON.stringify(Array.from(unlockedAspects)));
    localStorage.setItem('poe2idle_active_aspects', JSON.stringify({
      slots: activeAspects,
      slotsUnlocked: activeAspectSlotsUnlocked
    }));
  } catch (e) {
    console.error('Failed to save aspects:', e);
  }
}

// Check if an aspect is currently active (equipped in a slot)
function isAspectActive(aspectId) {
  return activeAspects.includes(aspectId);
}

// Click handler for active aspect slots
function clickActiveAspectSlot(slotIndex) {
  if (slotIndex >= activeAspectSlotsUnlocked) return; // Slot is locked
  
  const currentAspect = activeAspects[slotIndex];
  if (currentAspect) {
    // Unequip aspect from slot
    activeAspects[slotIndex] = null;
    saveUnlockedAspects();
    updateActiveAspectsUI();
    renderAspectGrid();
    showToast('🔮', 'Aspect Removed', `${ASPECTS[currentAspect]?.name || 'Aspect'} unequipped`, 'info');
  } else if (selectedAspectForSlot) {
    // Equip the selected aspect
    // First check if it's already equipped somewhere else
    const existingSlot = activeAspects.indexOf(selectedAspectForSlot);
    if (existingSlot !== -1) {
      activeAspects[existingSlot] = null; // Remove from old slot
    }
    activeAspects[slotIndex] = selectedAspectForSlot;
    selectedAspectForSlot = null;
    saveUnlockedAspects();
    updateActiveAspectsUI();
    renderAspectGrid();
    const aspect = ASPECTS[activeAspects[slotIndex]];
    showToast('✨', 'Aspect Equipped', `${aspect?.name || 'Aspect'} is now active!`, 'skill');
  }
}

// Select an aspect from the grid to equip
function selectAspectForEquip(aspectId) {
  if (!unlockedAspects.has(aspectId)) return; // Not unlocked
  
  const aspect = ASPECTS[aspectId];
  if (!aspect) return;
  
  // Check class restriction
  if (aspect.class && aspect.class !== player.class) {
    showToast('⚠️', 'Wrong Class', `This aspect is for ${aspect.class.charAt(0).toUpperCase() + aspect.class.slice(1)} only`, 'warning');
    return;
  }
  
  // Check if already active
  if (isAspectActive(aspectId)) {
    // Find and remove from slot
    const slotIndex = activeAspects.indexOf(aspectId);
    if (slotIndex !== -1) {
      activeAspects[slotIndex] = null;
      saveUnlockedAspects();
      updateActiveAspectsUI();
      renderAspectGrid();
      showToast('🔮', 'Aspect Removed', `${aspect.name || 'Aspect'} unequipped`, 'info');
    }
    return;
  }
  
  // Find first empty unlocked slot
  for (let i = 0; i < activeAspectSlotsUnlocked; i++) {
    if (activeAspects[i] === null) {
      activeAspects[i] = aspectId;
      saveUnlockedAspects();
      updateActiveAspectsUI();
      renderAspectGrid();
      showToast('✨', 'Aspect Equipped', `${aspect.name || 'Aspect'} is now active!`, 'skill');
      return;
    }
  }
  
  // No empty slots - show message
  showToast('⚠️', 'No Empty Slots', 'Remove an active aspect first', 'warning');
}

// Update active aspects UI
function updateActiveAspectsUI() {
  const slotsContainer = document.getElementById('activeAspectsSlots');
  const countDisplay = document.getElementById('activeAspectsCount');
  if (!slotsContainer) return;
  
  let activeCount = 0;
  
  for (let i = 0; i < 5; i++) {
    const slot = slotsContainer.children[i];
    if (!slot) continue;
    
    const aspectId = activeAspects[i];
    const isLocked = i >= activeAspectSlotsUnlocked;
    
    slot.className = 'active-aspect-slot';
    slot.innerHTML = '';
    
    if (isLocked) {
      slot.classList.add('locked');
    } else if (aspectId && ASPECTS[aspectId]) {
      slot.classList.add('filled');
      const aspect = ASPECTS[aspectId];
      slot.innerHTML = `<span class="slot-icon">${getAspectIcon(aspect)}</span>`;
      slot.title = aspect.name;
      activeCount++;
    } else {
      slot.classList.add('empty');
    }
  }
  
  if (countDisplay) {
    countDisplay.textContent = `${activeCount}/${activeAspectSlotsUnlocked}`;
  }
}

// Check if player has an aspect unlocked AND active
function hasAspect(aspectId) {
  return unlockedAspects.has(aspectId) && isAspectActive(aspectId);
}

// Check if player has unlocked an aspect (regardless of active status)
function hasUnlockedAspect(aspectId) {
  return unlockedAspects.has(aspectId);
}

// Check if aspect applies to current character
function aspectAppliesToCharacter(aspect) {
  if (!aspect.class) return true;  // Universal aspect
  return player.class === aspect.class;
}

// Unlock a new aspect
function unlockAspect(aspectId) {
  if (unlockedAspects.has(aspectId)) return false;  // Already unlocked
  
  const aspect = ASPECTS[aspectId];
  if (!aspect) return false;
  
  unlockedAspects.add(aspectId);
  saveUnlockedAspects();
  showAspectDiscovery(aspect);
  sessionStats.aspectsFound++;
  return true;
}

// ════════════════════════════════════════════════════════════════════════════════
// NEW ASPECT DROP SYSTEM
// ════════════════════════════════════════════════════════════════════════════════

// TEST MODE: Set to true to guarantee first aspect drop
let aspectTestMode = false;

// Get all available (not yet unlocked) aspects of a specific rarity
function getAvailableAspectsByRarity(rarity) {
  return Object.values(ASPECTS).filter(a => a.rarity === rarity && !unlockedAspects.has(a.id));
}

// Get a random aspect of a given rarity, with duplicate protection
// If no aspects of that rarity available, returns null
function getRandomAspectOfRarity(rarity) {
  const available = getAvailableAspectsByRarity(rarity);
  if (available.length === 0) return null;
  return available[Math.floor(Math.random() * available.length)];
}

// Roll rarity based on weights, then try to award aspect
// Returns the aspect if awarded, null if not
function tryAwardAspect(commonChance, rareChance, legendaryChance) {
  const roll = Math.random() * 100;
  
  let targetRarity = null;
  if (roll < legendaryChance) {
    targetRarity = 'legendary';
  } else if (roll < legendaryChance + rareChance) {
    targetRarity = 'rare';
  } else if (roll < legendaryChance + rareChance + commonChance) {
    targetRarity = 'common';
  }
  
  if (!targetRarity) return null;  // No drop
  
  // Try to get aspect of target rarity
  let aspect = getRandomAspectOfRarity(targetRarity);
  
  // Duplicate protection: if we rolled a rarity but all are unlocked,
  // try to give one of the same rarity (already handled above)
  // If truly none available, no aspect given
  if (!aspect) return null;
  
  unlockAspect(aspect.id);
  return aspect;
}

// ════════════════════════════════════════════════════════════════════════════════
// BOSS ASPECT DROPS (0.1% from dungeon bosses only)
// ════════════════════════════════════════════════════════════════════════════════
function rollAspectFromBoss() {
  // TEST MODE: Guarantee first drop
  if (aspectTestMode) {
    aspectTestMode = false;
    const anyAvailable = Object.values(ASPECTS).find(a => !unlockedAspects.has(a.id));
    if (anyAvailable) {
      unlockAspect(anyAvailable.id);
      return;
    }
  }
  
  // 0.1% base chance from boss
  if (Math.random() > 0.001) return;  // 99.9% of the time, no drop
  
  // Rarity weights based on difficulty
  // Easy/Normal/Hard: 100% Common
  // Elite/Nightmare: 80% Common, 20% Rare
  // Core: 55% Common, 40% Rare, 5% Legendary
  
  let commonWeight, rareWeight, legendaryWeight;
  
  if (currentDifficulty === 'core') {
    commonWeight = 55;
    rareWeight = 40;
    legendaryWeight = 5;
  } else if (currentDifficulty === 'elite' || currentDifficulty === 'nightmare') {
    commonWeight = 80;
    rareWeight = 20;
    legendaryWeight = 0;
  } else {
    // easy, normal, hard
    commonWeight = 100;
    rareWeight = 0;
    legendaryWeight = 0;
  }
  
  // Roll rarity
  const roll = Math.random() * 100;
  let targetRarity;
  if (roll < legendaryWeight) {
    targetRarity = 'legendary';
  } else if (roll < legendaryWeight + rareWeight) {
    targetRarity = 'rare';
  } else {
    targetRarity = 'common';
  }
  
  const aspect = getRandomAspectOfRarity(targetRarity);
  if (aspect) {
    unlockAspect(aspect.id);
  }
}

// ════════════════════════════════════════════════════════════════════════════════
// RIFT SURGE ASPECT DROPS (requires 60+ kills)
// Stable: 10% common, 2% rare, 0.01% legendary
// Unstable: 20% common, 5% rare, 0.5% legendary
// Fractured: 40% common, 10% rare, 2% legendary
// ════════════════════════════════════════════════════════════════════════════════
function rollAspectFromRift(tier, killCount) {
  if (killCount < 60) return;  // Must have 60+ kills
  
  let commonChance, rareChance, legendaryChance;
  
  if (tier === 1) {
    // Stable Rift
    commonChance = 10;
    rareChance = 2;
    legendaryChance = 0.01;
  } else if (tier === 2) {
    // Unstable Rift
    commonChance = 20;
    rareChance = 5;
    legendaryChance = 0.5;
  } else {
    // Fractured Rift (tier 3)
    commonChance = 40;
    rareChance = 10;
    legendaryChance = 2;
  }
  
  tryAwardAspect(commonChance, rareChance, legendaryChance);
}

// ════════════════════════════════════════════════════════════════════════════════
// ECHO DOMAIN ASPECT DROPS (requires killing Echo Overlord)
// Fading: 10% common, 2% rare, 0.01% legendary
// Resonant: 20% common, 5% rare, 0.5% legendary
// Shattered: 40% common, 10% rare, 2% legendary
// ════════════════════════════════════════════════════════════════════════════════
function rollAspectFromEchoDomain(tier) {
  // Only called when Echo Overlord is killed - no kill count needed
  
  let commonChance, rareChance, legendaryChance;
  
  if (tier === 1) {
    // Fading Echo
    commonChance = 10;
    rareChance = 2;
    legendaryChance = 0.01;
  } else if (tier === 2) {
    // Resonant Echo
    commonChance = 20;
    rareChance = 5;
    legendaryChance = 0.5;
  } else {
    // Shattered Echo (tier 3)
    commonChance = 40;
    rareChance = 10;
    legendaryChance = 2;
  }
  
  tryAwardAspect(commonChance, rareChance, legendaryChance);
}

// Helper to get aspect drop info for UI
function getAspectDropInfo() {
  return {
    boss: {
      chance: '0.1%',
      rarityByDifficulty: {
        'easy/normal/hard': '100% Common',
        'elite/nightmare': '80% Common, 20% Rare',
        'core': '55% Common, 40% Rare, 5% Legendary'
      }
    },
    rift: {
      requirement: '60+ kills',
      tiers: {
        stable: '10% Common, 2% Rare, 0.01% Legendary',
        unstable: '20% Common, 5% Rare, 0.5% Legendary',
        fractured: '40% Common, 10% Rare, 2% Legendary'
      }
    },
    echo: {
      requirement: 'Kill Echo Overlord',
      tiers: {
        fading: '10% Common, 2% Rare, 0.01% Legendary',
        resonant: '20% Common, 5% Rare, 0.5% Legendary',
        shattered: '40% Common, 10% Rare, 2% Legendary'
      }
    }
  };
}

// Get drop hint text based on aspect rarity
function getAspectDropHint(rarity) {
  switch(rarity) {
    case 'legendary':
      return 'Dungeon Bosses (Core), High Rifts, or Shattered Echo';
    case 'rare':
      return 'Dungeon Bosses (Elite+), Rifts, or Echo Domain';
    case 'common':
    default:
      return 'Dungeon Bosses, Rifts, or Echo Domain';
  }
}

// ════════════════════════════════════════════════════════════════════════════════
// SHARD TOOLTIP SYSTEM (Rift/Echo mechanic info)
// ════════════════════════════════════════════════════════════════════════════════

const SHARD_TOOLTIP_DATA = {
  rift: {
    1: {
      name: 'Stable Rift',
      description: 'A timed gauntlet at Nightmare difficulty.',
      stats: [
        '60 second time limit',
        '8 enemy packs (4-6 each)',
        '15% elite chance, 1 boss',
        '⚔️ Nightmare (3.5x HP, 6x Dmg)',
        '4x XP & Gold'
      ],
      aspect: '10% Common, 2% Rare, 0.01% Legendary',
      aspectReq: '60+ kills'
    },
    2: {
      name: 'Unstable Rift',
      description: 'A timed gauntlet at Core difficulty.',
      stats: [
        '60 second time limit',
        '10 enemy packs (5-7 each)',
        '25% elite chance, 2 bosses',
        '⚔️ Core (5x HP, 8x Dmg)',
        '5x XP & Gold'
      ],
      aspect: '20% Common, 5% Rare, 0.5% Legendary',
      aspectReq: '60+ kills'
    },
    3: {
      name: 'Fractured Rift',
      description: 'A chaotic gauntlet beyond Core difficulty.',
      stats: [
        '60 second time limit',
        '12 enemy packs (6-8 each)',
        '35% elite chance, 3 bosses',
        '💀 2x Nightmare (7x HP, 12x Dmg)',
        '6x XP & Gold'
      ],
      aspect: '40% Common, 10% Rare, 2% Legendary',
      aspectReq: '60+ kills'
    }
  },
  echo: {
    1: {
      name: 'Fading Echo',
      description: 'An echo domain at Nightmare difficulty.',
      stats: [
        '7x7 room grid to explore',
        '3-5 enemies per room',
        '10% elite chance',
        '⚔️ Nightmare (3.5x HP, 6x Dmg)',
        '1% Echo Ring drop'
      ],
      aspect: '10% Common, 2% Rare, 0.01% Legendary',
      aspectReq: 'Kill Echo Overlord'
    },
    2: {
      name: 'Resonant Echo',
      description: 'An echo domain at Core difficulty.',
      stats: [
        '7x7 room grid to explore',
        '4-7 enemies per room',
        '20% elite chance',
        '⚔️ Core (5x HP, 8x Dmg)',
        '3% Echo Ring drop'
      ],
      aspect: '20% Common, 5% Rare, 0.5% Legendary',
      aspectReq: 'Kill Echo Overlord'
    },
    3: {
      name: 'Shattered Echo',
      description: 'An echo domain beyond Core difficulty.',
      stats: [
        '7x7 room grid to explore',
        '5-9 enemies per room',
        '30% elite chance',
        '💀 2x Nightmare (7x HP, 12x Dmg)',
        '5% Echo Ring drop'
      ],
      aspect: '40% Common, 10% Rare, 2% Legendary',
      aspectReq: 'Kill Echo Overlord'
    }
  }
};

function showShardTooltip(event, type, tier) {
  event.stopPropagation();
  const tooltip = document.getElementById('shardTooltip');
  if (!tooltip) {
    console.error('Shard tooltip element not found');
    return;
  }
  
  const data = SHARD_TOOLTIP_DATA[type]?.[tier];
  if (!data) {
    console.error('No data for', type, tier);
    return;
  }
  
  const typeClass = type === 'rift' ? 'rift' : 'echo';
  const typeIcon = type === 'rift' ? '🌀' : '🔮';
  
  tooltip.innerHTML = `
    <div class="shard-tooltip-title ${typeClass}">${typeIcon} ${data.name}</div>
    <div class="shard-tooltip-section">
      <div class="shard-tooltip-text">${data.description}</div>
    </div>
    <div class="shard-tooltip-section">
      <div class="shard-tooltip-label">Stats</div>
      <div class="shard-tooltip-text">
        ${data.stats.map(s => `• ${s}`).join('<br>')}
      </div>
    </div>
    <div class="shard-tooltip-aspect">
      <div class="shard-tooltip-aspect-title">⚡ Aspect Drop</div>
      <div class="shard-tooltip-aspect-text">${data.aspect}</div>
      <div class="shard-tooltip-req">Requires: ${data.aspectReq}</div>
    </div>
  `;
  
  // Position near mouse cursor
  const mouseX = event.clientX || event.pageX;
  const mouseY = event.clientY || event.pageY;
  
  // Show first to get dimensions
  tooltip.style.display = 'block';
  
  const tooltipRect = tooltip.getBoundingClientRect();
  
  // Position to the right of cursor
  let left = mouseX + 15;
  let top = mouseY - 10;
  
  // Keep on screen horizontally
  if (left + tooltipRect.width > window.innerWidth - 10) {
    left = mouseX - tooltipRect.width - 15;
  }
  
  // Keep on screen vertically
  if (top + tooltipRect.height > window.innerHeight - 10) {
    top = window.innerHeight - tooltipRect.height - 10;
  }
  if (top < 10) top = 10;
  
  tooltip.style.left = left + 'px';
  tooltip.style.top = top + 'px';
}

function hideShardTooltip() {
  const tooltip = document.getElementById('shardTooltip');
  if (tooltip) tooltip.style.display = 'none';
}

// Setup shard tooltip event listeners (called on page load)
let shardTooltipsInitialized = false;
function setupShardTooltips() {
  if (shardTooltipsInitialized) return;
  shardTooltipsInitialized = true;
  
  // Rift and Echo tiers
  document.querySelectorAll('.shard-tier-card').forEach(card => {
    const onclick = card.getAttribute('onclick');
    if (!onclick) return;
    
    let type, tier;
    if (onclick.includes('activateRiftSurge(1)')) { type = 'rift'; tier = 1; }
    else if (onclick.includes('activateRiftSurge(2)')) { type = 'rift'; tier = 2; }
    else if (onclick.includes('activateRiftSurge(3)')) { type = 'rift'; tier = 3; }
    else if (onclick.includes('activateEchoDomain(1)')) { type = 'echo'; tier = 1; }
    else if (onclick.includes('activateEchoDomain(2)')) { type = 'echo'; tier = 2; }
    else if (onclick.includes('activateEchoDomain(3)')) { type = 'echo'; tier = 3; }
    
    if (type && tier) {
      card.addEventListener('mouseenter', (e) => showShardTooltip(e, type, tier));
      card.addEventListener('mouseleave', hideShardTooltip);
    }
  });
}

// Show aspect discovery celebration popup
function showAspectDiscovery(aspect) {
  const popup = document.getElementById('aspectDiscovery');
  const icon = document.getElementById('aspectDiscoveryIcon');
  const name = document.getElementById('aspectDiscoveryName');
  const desc = document.getElementById('aspectDiscoveryDesc');
  
  setAspectIconElement(icon, aspect);  // Handles both emoji and img tags
  name.textContent = aspect.name;
  name.className = 'aspect-discovery-name ' + aspect.rarity;
  desc.textContent = aspect.description;
  
  popup.classList.add('visible');
  
  // Play discovery sound effect if available
  addLog(`🌟 ASPECT DISCOVERED: ${aspect.name}! (Account-wide, applies to all characters)`, 'skill');
  
  // Auto-close after 4 seconds so it doesn't block gameplay
  clearTimeout(window.aspectDiscoveryTimer);
  window.aspectDiscoveryTimer = setTimeout(() => {
    closeAspectDiscovery();
  }, 4000);
}

// Close discovery popup
function closeAspectDiscovery() {
  document.getElementById('aspectDiscovery').classList.remove('visible');
}

// Toggle aspect panel (A key)
function toggleAspectPanel() {
  const panel = document.getElementById('aspectPanel');
  if (!panel) {
    console.error('Aspect panel not found');
    return;
  }
  
  const isVisible = panel.classList.contains('visible');
  
  // Close other panels
  const inv = document.getElementById('inventoryPanel');
  const charP = document.getElementById('charPanel');
  const passiveP = document.getElementById('passiveTreePanel');
  const skillSel = document.getElementById('skillSelector');
  
  if (inv) inv.classList.remove('visible');
  if (charP) charP.classList.remove('visible');
  if (passiveP) passiveP.classList.remove('visible');
  if (skillSel) skillSel.classList.remove('visible');
  
  if (isVisible) {
    panel.classList.remove('visible');
  } else {
    panel.classList.add('visible');
    renderAspectGrid();
    updateActiveAspectsUI();
  }
}

// Current aspect filter state
let currentAspectFilter = 'all';
let currentRarityFilter = null;

// Filter aspects by class
function filterAspects(filter) {
  currentAspectFilter = filter;
  currentRarityFilter = null;  // Clear rarity filter when using class filter
  
  // Update active tabs
  document.querySelectorAll('.aspect-tab').forEach(btn => {
    btn.classList.toggle('active', btn.dataset.filter === filter);
  });
  
  // Clear rarity row selection
  document.querySelectorAll('.aspect-rarity-row').forEach(row => {
    row.classList.remove('active');
  });
  
  renderAspectGrid();
}

// Filter by rarity
function filterByRarity(rarity) {
  currentRarityFilter = currentRarityFilter === rarity ? null : rarity;
  
  // Update rarity row selection
  document.querySelectorAll('.aspect-rarity-row').forEach(row => {
    row.classList.toggle('active', row.dataset.rarity === currentRarityFilter);
  });
  
  renderAspectGrid();
}

// Render aspect grid
function renderAspectGrid() {
  const grid = document.getElementById('aspectGrid');
  if (!grid) return;
  
  grid.innerHTML = '';
  
  const myClassOnly = document.getElementById('aspectMyClassOnly')?.checked || false;
  
  // Count aspects by rarity
  const rarityCounts = { common: { total: 0, unlocked: 0 }, rare: { total: 0, unlocked: 0 }, legendary: { total: 0, unlocked: 0 } };
  let totalCount = 0;
  let totalUnlocked = 0;
  let displayedCount = 0;
  let displayedUnlocked = 0;
  
  for (const aspect of Object.values(ASPECTS)) {
    // Count by rarity
    if (rarityCounts[aspect.rarity]) {
      rarityCounts[aspect.rarity].total++;
      if (unlockedAspects.has(aspect.id)) {
        rarityCounts[aspect.rarity].unlocked++;
      }
    }
    totalCount++;
    if (unlockedAspects.has(aspect.id)) totalUnlocked++;
  }
  
  // Update rarity counts in sidebar
  const countCommon = document.getElementById('aspectCountCommon');
  const countRare = document.getElementById('aspectCountRare');
  const countLegendary = document.getElementById('aspectCountLegendary');
  
  if (countCommon) countCommon.textContent = `${rarityCounts.common.unlocked}/${rarityCounts.common.total}`;
  if (countRare) countRare.textContent = `${rarityCounts.rare.unlocked}/${rarityCounts.rare.total}`;
  if (countLegendary) countLegendary.textContent = `${rarityCounts.legendary.unlocked}/${rarityCounts.legendary.total}`;
  
  // Sort aspects: by class (current player's class first), then by rarity (legendary > rare > common), then by name
  const rarityOrder = { legendary: 0, rare: 1, common: 2 };
  const classOrder = ['monk', 'warrior', 'ranger', 'mage'];
  
  const sortedAspects = Object.values(ASPECTS).sort((a, b) => {
    // Player's class first
    const aIsPlayerClass = a.class === player.class ? 0 : 1;
    const bIsPlayerClass = b.class === player.class ? 0 : 1;
    if (aIsPlayerClass !== bIsPlayerClass) return aIsPlayerClass - bIsPlayerClass;
    
    // Then by class order
    const aClassOrder = classOrder.indexOf(a.class) >= 0 ? classOrder.indexOf(a.class) : 99;
    const bClassOrder = classOrder.indexOf(b.class) >= 0 ? classOrder.indexOf(b.class) : 99;
    if (aClassOrder !== bClassOrder) return aClassOrder - bClassOrder;
    
    // Then by rarity (legendary first)
    const aRarity = rarityOrder[a.rarity] ?? 99;
    const bRarity = rarityOrder[b.rarity] ?? 99;
    if (aRarity !== bRarity) return aRarity - bRarity;
    
    // Then by name
    return a.name.localeCompare(b.name);
  });
  
  // Filter and render aspects
  for (const aspect of sortedAspects) {
    // Apply class filter
    if (currentAspectFilter !== 'all' && aspect.class !== currentAspectFilter) continue;
    
    // Apply rarity filter
    if (currentRarityFilter && aspect.rarity !== currentRarityFilter) continue;
    
    // Apply "my class only" filter (redundant if class tab selected, but kept for checkbox)
    if (myClassOnly && aspect.class && aspect.class !== player.class) continue;
    
    displayedCount++;
    const isUnlocked = unlockedAspects.has(aspect.id);
    const isActive = isAspectActive(aspect.id);
    if (isUnlocked) displayedUnlocked++;
    
    // Check if aspect can be equipped by current class
    const canEquip = !aspect.class || aspect.class === player.class;
    
    const slot = document.createElement('div');
    slot.className = `aspect-slot ${aspect.rarity} ${isUnlocked ? 'unlocked' : 'locked'} ${isActive ? 'active' : ''} ${!canEquip ? 'wrong-class' : ''}`;
    slot.innerHTML = `<span class="aspect-icon">${getAspectIcon(aspect)}</span>${isActive ? '<span class="aspect-active-badge">✓</span>' : ''}`;
    slot.onclick = function() { selectAspect(aspect.id, this); };
    
    grid.appendChild(slot);
  }
  
  // Update grid header
  const gridTitle = document.getElementById('aspectGridTitle');
  const gridCount = document.getElementById('aspectGridCount');
  
  if (gridTitle) {
    let title = currentAspectFilter.toUpperCase();
    if (currentRarityFilter) title = currentRarityFilter.toUpperCase();
    gridTitle.textContent = title;
  }
  if (gridCount) gridCount.textContent = `(${displayedUnlocked}/${displayedCount})`;
  
  // Clear detail panel
  const detailPanel = document.getElementById('aspectDetail');
  if (detailPanel) {
    detailPanel.innerHTML = '<div class="aspect-detail-empty">Select an aspect to view details</div>';
  }
}

// Select aspect to view details
function selectAspect(aspectId, clickedElement) {
  const aspect = ASPECTS[aspectId];
  if (!aspect) return;
  
  // Update selection visuals
  document.querySelectorAll('.aspect-slot').forEach(slot => slot.classList.remove('selected'));
  if (clickedElement) clickedElement.classList.add('selected');
  
  const isUnlocked = unlockedAspects.has(aspectId);
  const isActive = isAspectActive(aspectId);
  const detail = document.getElementById('aspectDetail');
  if (!detail) return;
  
  const className = aspect.class ? aspect.class.charAt(0).toUpperCase() + aspect.class.slice(1) : 'All Classes';
  
  // Build equip button if unlocked
  let equipButton = '';
  if (isUnlocked) {
    if (isActive) {
      equipButton = `<button class="aspect-equip-btn unequip" onclick="selectAspectForEquip('${aspectId}')">✗ Unequip</button>`;
    } else {
      equipButton = `<button class="aspect-equip-btn equip" onclick="selectAspectForEquip('${aspectId}')">✓ Equip</button>`;
    }
  }
  
  detail.innerHTML = `
    <div class="aspect-detail-content">
      <div class="aspect-detail-icon">${getAspectIcon(aspect)}</div>
      <div class="aspect-detail-name ${aspect.rarity}">${aspect.name}</div>
      ${aspect.tooltip ? `<div class="aspect-detail-tooltip">"${aspect.tooltip}"</div>` : ''}
      <div class="aspect-detail-divider"></div>
      <div class="aspect-detail-desc">${aspect.description}</div>
      <div class="aspect-detail-unlock">
        <div class="aspect-detail-unlock-label">${isUnlocked ? 'Status' : 'How to Unlock'}</div>
        <div class="aspect-detail-unlock-text ${isUnlocked ? 'unlocked' : ''}">
          ${isUnlocked ? (isActive ? '✓ Active' : '○ Unlocked - Not Active') : getAspectDropHint(aspect.rarity)}
        </div>
      </div>
      ${equipButton}
      <div class="aspect-detail-class-badge">${className}</div>
    </div>
  `;
}

// Apply active aspects to character (called on load)
function applyActiveAspects() {
  // This function checks which aspects should be active for current character
  // Effects are applied dynamically in relevant game systems
  console.log('Active aspects:', Array.from(unlockedAspects).filter(id => {
    const aspect = ASPECTS[id];
    return aspect && aspectAppliesToCharacter(aspect);
  }));
}

// Check if Sentry x2 aspect is active for current character
function hasSentryX2Aspect() {
  return hasAspect('sentry_x2') && player.class === 'ranger';
}

// ════════════════════════════════════════════════════════════════════════════════
// UNIQUE ITEMS REGISTRY
// Each unique defines its own drop source - uniques do NOT drop from regular loot
// Normal enemies CANNOT drop uniques (0% chance always)
// Only bosses can drop uniques, and only if enemy.sourceType matches unique.sourceType
// NOTE: Echo Ring uses a separate system (generateEchoRing) for stat mirroring
// ════════════════════════════════════════════════════════════════════════════════
const UNIQUE_ITEMS = {
  // Future uniques can be added here
  // Echo Ring is handled separately via generateEchoRing() and ECHO_RING_BASE
};

// Roll for a unique drop from a boss kill
// Returns unique definition if one drops, or null
// Rules:
// 1. Normal enemies CANNOT drop uniques (must be boss)
// 2. enemy.sourceType must match unique.sourceType
// 3. player.level must be >= unique.minLevel
// 4. dropWeight used for weighted selection among matching uniques
function rollUnique(enemy, playerLevel) {
  if (!enemy.isBoss) return null;
  
  // Build pool of eligible uniques
  let pool = [];
  for (let id in UNIQUE_ITEMS) {
    let U = UNIQUE_ITEMS[id];
    if (U.sourceType === enemy.sourceType && playerLevel >= U.minLevel) {
      pool.push(U);
    }
  }
  
  if (pool.length === 0) return null;
  
  // Weighted random selection
  return weightedRandom(pool, 'dropWeight');
}

// Weighted random selection helper
function weightedRandom(pool, weightKey) {
  const totalWeight = pool.reduce((sum, item) => sum + (item[weightKey] || 1), 0);
  let roll = Math.random() * totalWeight;
  
  for (const item of pool) {
    roll -= (item[weightKey] || 1);
    if (roll <= 0) return item;
  }
  
  return pool[pool.length - 1];
}

function generateUniqueItem(uniqueDef, baseLevel) {
  const size = getItemSize(uniqueDef.baseName);
  return {
    id: Math.random(),
    uniqueId: uniqueDef.id,
    name: uniqueDef.name,
    baseName: uniqueDef.baseName,
    slot: uniqueDef.slot,
    rarity: 'unique',
    isUnique: true,
    width: size[0],
    height: size[1],
    baseLevel: baseLevel,
    levelReq: uniqueDef.minLevel,
    mods: JSON.parse(JSON.stringify(uniqueDef.fixedMods)),
    sockets: [],
    quality: 0,
    tooltipLines: uniqueDef.tooltipLines,
    image: getItemImage(uniqueDef.baseName)
  };
}

function updateUniqueEffects(dt) {
  if (!player.uniqueEffects) return;
  for (const slot of ['ring1', 'ring2', 'weapon', 'helmet', 'amulet', 'body', 'gloves', 'boots']) {
    const item = equipment[slot];
    if (item && item.isUnique && item.uniqueId && UNIQUE_ITEMS[item.uniqueId]) {
      const uniqueDef = UNIQUE_ITEMS[item.uniqueId];
      if (uniqueDef.onUpdate) uniqueDef.onUpdate(player, dt);
    }
  }
}

function reregisterUniqueEffects() {
  player.uniqueEffects = {};
  for (const slot of ['ring1', 'ring2', 'weapon', 'helmet', 'amulet', 'body', 'gloves', 'boots']) {
    const item = equipment[slot];
    if (item && item.isUnique && item.uniqueId && UNIQUE_ITEMS[item.uniqueId]) {
      const uniqueDef = UNIQUE_ITEMS[item.uniqueId];
      if (uniqueDef.onEquip) uniqueDef.onEquip(player);
    }
  }
}

const BOSS_NAMES = [
  ['Goretusk', 'Blight', 'Vexis', 'Drakul', 'Morgath', 'Xul', 'Ignagduk', 'Vorn', 'Skarn', 'Razeth'],
  ['the Defiler', 'the Cursed', 'the Undying', 'Bonecrusher', 'Soulreaver', 'the Wretched', 'Plaguebearer', 'the Bog Witch', 'Fleshweaver', 'Doomcaller']
];

const DEBUFFS = [
  // Only non-DoT status effects (per spec: no DoT, no ailments)
  { icon: '❄️', name: 'Chilled', color: '#8cf', desc: 'Slows enemy movement and attack speed by 30%' },
  { icon: '⚡', name: 'Shocked', color: '#ff8', desc: 'Shocked enemies take 20% increased damage' },
  { icon: '💀', name: 'Weakened', color: '#a88', desc: 'Reduces enemy damage dealt by 25%' },
];

// Item images from GitHub - maps item names to image URLs
const ITEM_IMAGES = {
  // ═══════════════════════════════════════════════════════════════════════
  // HELMETS (6 bases)
  // ═══════════════════════════════════════════════════════════════════════
  'Iron Helm': 'https://raw.githubusercontent.com/Graphic37/ARPG-/main/Helmets/Iron%20helm.png',
  'Leather Cap': 'https://raw.githubusercontent.com/Graphic37/ARPG-/main/Helmets/Leather%20cap.png',
  'Mage Hat': 'https://raw.githubusercontent.com/Graphic37/ARPG-/main/Helmets/Mage%20Hat.png',
  'Scale Helm': 'https://raw.githubusercontent.com/Graphic37/ARPG-/main/Helmets/Scale%20Helm.png',
  'Crusader Helm': 'https://raw.githubusercontent.com/Graphic37/ARPG-/main/Helmets/Crusader%20Helm.png',
  'Bone Circlet': 'https://raw.githubusercontent.com/Graphic37/ARPG-/main/Helmets/Bone%20Circlet.png',
  
  // ═══════════════════════════════════════════════════════════════════════
  // BODY ARMOR (6 bases)
  // ═══════════════════════════════════════════════════════════════════════
  'Plate Armor': 'https://raw.githubusercontent.com/Graphic37/ARPG-/main/Chest/plate%20armor.png',
  'Leather Tunic': 'https://raw.githubusercontent.com/Graphic37/ARPG-/main/Chest/leather%20tunic.png',
  'Silk Robe': 'https://raw.githubusercontent.com/Graphic37/ARPG-/main/Chest/Silk%20Robe.png',
  'Scale Armor': 'https://raw.githubusercontent.com/Graphic37/ARPG-/main/Chest/Scale%20Armor.png',
  'Crusader Armor': 'https://raw.githubusercontent.com/Graphic37/ARPG-/main/Chest/Crusader%20Armor.png',
  'Assassin Garb': 'https://raw.githubusercontent.com/Graphic37/ARPG-/main/Chest/assassin%20garb.png',
  
  // ═══════════════════════════════════════════════════════════════════════
  // GLOVES (6 bases)
  // ═══════════════════════════════════════════════════════════════════════
  'Plate Gauntlets': 'https://raw.githubusercontent.com/Graphic37/ARPG-/main/Gloves/Plate%20Gauntlets.png',
  'Leather Gloves': 'https://raw.githubusercontent.com/Graphic37/ARPG-/main/Gloves/Leather%20Gloves.png',
  'Silk Gloves': 'https://raw.githubusercontent.com/Graphic37/ARPG-/main/Gloves/Silk%20Gloves.png',
  'Scale Gauntlets': 'https://raw.githubusercontent.com/Graphic37/ARPG-/main/Gloves/Scale%20Gauntlets.png',
  'Crusader Gauntlets': 'https://raw.githubusercontent.com/Graphic37/ARPG-/main/Gloves/Crusader%20Gauntlets.png',
  'Assassin Gloves': 'https://raw.githubusercontent.com/Graphic37/ARPG-/main/Gloves/Assassin%20Gloves.png',
  
  // ═══════════════════════════════════════════════════════════════════════
  // BOOTS (6 bases)
  // ═══════════════════════════════════════════════════════════════════════
  'Plate Greaves': 'https://raw.githubusercontent.com/Graphic37/ARPG-/main/Boots/Plate%20Greaves.png',
  'Leather Boots': 'https://raw.githubusercontent.com/Graphic37/ARPG-/main/Boots/Leather%20Boots.png',
  'Silk Slippers': 'https://raw.githubusercontent.com/Graphic37/ARPG-/main/Boots/Silk%20Slippers.png',
  'Scale Boots': 'https://raw.githubusercontent.com/Graphic37/ARPG-/main/Boots/Scale%20Boots.png',
  'Crusader Greaves': 'https://raw.githubusercontent.com/Graphic37/ARPG-/main/Boots/Crusader%20Greaves.png',
  'Assassin Boots': 'https://raw.githubusercontent.com/Graphic37/ARPG-/main/Boots/Assassin%20Boots.png',
  
  // ═══════════════════════════════════════════════════════════════════════
  // WEAPONS (8 types - 2 per class)
  // ═══════════════════════════════════════════════════════════════════════
  // Sword type (STR)
  'Viper Blade': 'https://raw.githubusercontent.com/Graphic37/ARPG-/main/Weapons/Viper%20Blade.png',
  'War Blade': 'https://raw.githubusercontent.com/Graphic37/ARPG-/main/Weapons/War%20Blade.png',
  // Quarterstaff type (STR/DEX)
  'Windspire Quarterstaff': 'https://raw.githubusercontent.com/Graphic37/ARPG-/main/Weapons/Windspire%20Quarterstaff.png',
  'Ironbark Quarterstaff': 'https://raw.githubusercontent.com/Graphic37/ARPG-/main/Weapons/Ironbark%20Quarterstaff.png',
  // Bow type (DEX)
  'Windrunner Bow': 'https://raw.githubusercontent.com/Graphic37/ARPG-/main/Weapons/Windrunner%20Bow.png',
  'Ironwood Bow': 'https://raw.githubusercontent.com/Graphic37/ARPG-/main/Weapons/Ironwood%20Bow.png',
  // Staff type (INT)
  'Mystic Staff': 'https://raw.githubusercontent.com/Graphic37/ARPG-/main/Weapons/mystic%20staff.png',
  'Elder Staff': 'https://raw.githubusercontent.com/Graphic37/ARPG-/main/Weapons/Elder%20Staff.png',
  
  // ═══════════════════════════════════════════════════════════════════════
  // RINGS (7 unique)
  // ═══════════════════════════════════════════════════════════════════════
  'Nature Ring': 'https://raw.githubusercontent.com/Graphic37/ARPG-/main/Rings/Nature%20Ring.png',
  'Vitality Ring': 'https://raw.githubusercontent.com/Graphic37/ARPG-/main/Rings/Vitality.png',
  'Arcane Ring': 'https://raw.githubusercontent.com/Graphic37/ARPG-/main/Rings/Arcane%20Ring.png',
  'Flame Ring': 'https://raw.githubusercontent.com/Graphic37/ARPG-/main/Rings/Flame%20Ring.png',
  'Frost Ring': 'https://raw.githubusercontent.com/Graphic37/ARPG-/main/Rings/Frost%20Ring.png',
  'Storm Ring': 'https://raw.githubusercontent.com/Graphic37/ARPG-/main/Rings/Storm%20Ring.png',
  'Prismatic Ring': 'https://raw.githubusercontent.com/Graphic37/ARPG-/main/Rings/Prismatic.png',
  
  // ═══════════════════════════════════════════════════════════════════════
  // AMULETS (4 unique)
  // ═══════════════════════════════════════════════════════════════════════
  'Might Amulet': 'https://raw.githubusercontent.com/Graphic37/ARPG-/main/Amulets/Might.png',
  'Grace Amulet': 'https://raw.githubusercontent.com/Graphic37/ARPG-/main/Amulets/Grace.png',
  'Wisdom Amulet': 'https://raw.githubusercontent.com/Graphic37/ARPG-/main/Amulets/Wisdom.png',
  'Harmony Amulet': 'https://raw.githubusercontent.com/Graphic37/ARPG-/main/Amulets/Harmony.png',
};

// Get a random image URL for an item (or null if no images)
// Tries: 1) exact name match, 2) slot+baseType lookup, 3) logs and returns null
function getItemImage(itemName) {
  // Helper to get image from value (handles string or array)
  const getImage = (value) => {
    if (typeof value === 'string') return value;
    if (Array.isArray(value) && value.length > 0) {
      return value[Math.floor(Math.random() * value.length)];
    }
    return null;
  };
  
  // Try exact name match first
  let imageValue = ITEM_IMAGES[itemName];
  if (imageValue) {
    const selectedImage = getImage(imageValue);
    if (selectedImage) {
      return selectedImage;
    }
  }
  
  // Try slot + baseType lookup
  const slot = getItemSlot(itemName);
  if (slot === 'helmet' || slot === 'body' || slot === 'gloves' || slot === 'boots') {
    const baseType = getArmorBaseType(itemName);
    const slotTypeKey = `${slot}_${baseType}`;
    imageValue = ITEM_IMAGES[slotTypeKey];
    if (imageValue) {
      const selectedImage = getImage(imageValue);
      if (selectedImage) {
        return selectedImage;
      }
    }
  }
  
  return null;
}

function generateBossName() {
  const first = BOSS_NAMES[0][Math.floor(Math.random() * BOSS_NAMES[0].length)];
  const second = BOSS_NAMES[1][Math.floor(Math.random() * BOSS_NAMES[1].length)];
  return `${first}, ${second}`;
}

// Image load error handler with logging
function handleImageError(imgEl, itemName, fallbackIcon) {
  console.warn(`Image load failed for "${itemName}": ${imgEl.src}`);
  if (imgEl.parentElement) {
    imgEl.parentElement.textContent = fallbackIcon;
  }
}

// ============ CANVAS ============
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const mmCanvas = document.getElementById('minimapCanvas');
const mmCtx = mmCanvas.getContext('2d');

// ============ DOM CACHE (Performance Optimization) ============
// Caching frequently accessed DOM elements to avoid repeated lookups
const DOM = {
  healthBar: null,
  shieldBar: null,
  manaBar: null,
  healthText: null,
  manaText: null,
  lifeOnHitText: null,
  manaOnHitText: null,
  expBar: null,
  levelBadge: null,
  portraitRing: null,
  debugPanel: null,
  dungeonTimer: null,
  dungeonName: null,
  dungeonLevel: null,
  log: null
};

// Initialize DOM cache after page loads
function initDOMCache() {
  // Core UI elements (updated every frame)
  DOM.healthBar = document.getElementById('healthBar');
  DOM.shieldBar = document.getElementById('shieldBar');
  DOM.manaBar = document.getElementById('manaBar');
  DOM.healthText = document.getElementById('healthText');
  DOM.manaText = document.getElementById('manaText');
  DOM.lifeOnHitText = document.getElementById('lifeOnHitText');
  DOM.manaOnHitText = document.getElementById('manaOnHitText');
  DOM.expBar = document.getElementById('expBar');
  DOM.levelBadge = document.getElementById('levelBadge');
  DOM.portraitRing = document.querySelector('.portrait-ring');
  DOM.debugPanel = document.getElementById('debugPanel');
  DOM.dungeonTimer = document.getElementById('dungeonTimer');
  DOM.dungeonName = document.getElementById('dungeonName');
  DOM.dungeonLevel = document.getElementById('dungeonLevel');
  DOM.log = document.getElementById('combatLog');
  
  // Buff bar elements (accessed frequently)
  DOM.buffBar = document.getElementById('buffBar');
  DOM.buffTooltip = document.getElementById('buffTooltip');
  DOM.buffTooltipName = document.getElementById('buffTooltipName');
  DOM.buffTooltipDesc = document.getElementById('buffTooltipDesc');
  DOM.buffTooltipTime = document.getElementById('buffTooltipTime');
  
  // Death screen elements
  DOM.deathScreen = document.getElementById('deathScreen');
  DOM.deathTimer = document.getElementById('deathTimer');
  
  // Debug elements
  DOM.dbgState = document.getElementById('dbgState');
  DOM.dbgPos = document.getElementById('dbgPos');
  DOM.dbgTestMode = document.getElementById('dbgTestMode');
}

let W, H;
function resize() {
  // Calculate 16:9 aspect ratio that fits in window
  const windowW = window.innerWidth;
  const windowH = window.innerHeight;
  const targetRatio = 16 / 9;
  const windowRatio = windowW / windowH;
  
  if (windowRatio > targetRatio) {
    // Window is wider than 16:9, fit to height
    H = windowH;
    W = Math.floor(H * targetRatio);
  } else {
    // Window is taller than 16:9, fit to width
    W = windowW;
    H = Math.floor(W / targetRatio);
  }
  
  canvas.width = W;
  canvas.height = H;
  canvas.style.width = W + 'px';
  canvas.style.height = H + 'px';
  
  // Always render after resize to prevent black screen
  if (gameState === 'playing') {
    render();
  }
}
resize();
window.addEventListener('resize', resize);

// ============ GAME STATE ============
let map = { tiles: [], width: 0, height: 0, rooms: [], explored: [] };
let biome = BIOMES[0];

let player = {
  x: 0, y: 0,
  hp: 80, maxHp: 80,
  mana: 40, maxMana: 40,
  minDmg: 1, maxDmg: 2,
  baseDmgMin: 1, baseDmgMax: 2, // Unarmed base damage (weapon provides real damage)
  atkSpd: 0.8,
  castSpd: 1.0,    // Cast speed for spells (modified by cast speed bonuses)
  castCD: 0,       // Cast cooldown (for spell primaries)
  spellDmg: 0,     // Base spell damage (scales with INT, set in updateStats)
  armor: 5,
  shield: 0, // Max Shield from gear and INT
  currentShield: 0, // Current Shield
  shieldRechargeDelay: 0, // Frames until shield starts recharging (resets on damage)
  shieldRechargeRate: 0.1, // Shield recovered per frame when recharging
  dodge: 0, // Dodge chance percentage
  lifeOnHit: 1,
  manaOnHit: 2,
  speed: 4.0,
  level: 1,
  exp: 0,
  expToLevel: 100,
  gold: 0,
  kills: 0,
  totalCrafts: 0, // Lifetime crafting orbs used (for achievements)
  atkCD: 0,
  escapeDashCD: 0, // Cooldown for defensive escape dash (monk)
  fistsDashCD: 0,  // Internal cooldown for Fists of Thunder dash (prevents micro-dashes)
  atkAnim: 0, // Attack animation timer
  skillAnimType: null, // Current skill animation type (e.g., 'punch', 'kick', 'spin', 'cast', 'shoot')
  skillAnimProgress: 0, // Animation progress (0-1)
  state: 'idle',
  facing: 1,
  class: 'monk', // Current class
  skin: 'default', // Current equipped skin
  // Base attributes
  str: 10,
  dex: 10,
  int: 10,
  // Domain currency
  echoCores: 0
};

// Class primary stat definitions
// Primary stat gives DAMAGE bonus, secondary effects apply to all
const CLASS_PRIMARY_STAT = {
  monk: 'dex',
  ranger: 'dex',
  mage: 'int',
  warrior: 'str'
};

// Base stats per level by class (growth per level)
const CLASS_BASE_STATS = {
  monk:    { str: 2, dex: 3, int: 1 },   // DEX primary
  ranger:  { str: 1, dex: 3, int: 2 },   // DEX primary
  mage:    { str: 1, dex: 2, int: 3 },   // INT primary
  warrior: { str: 3, dex: 2, int: 1 }    // STR primary
};

// Starting stats by class (level 1)
const CLASS_START_STATS = {
  monk:    { str: 12, dex: 16, int: 10 },
  ranger:  { str: 10, dex: 18, int: 10 },
  mage:    { str: 8,  dex: 10, int: 18 },
  warrior: { str: 18, dex: 10, int: 8  }
};

// Which weapon types each class can equip
const CLASS_WEAPONS = {
  monk:    ['quarterstaff'],            // Quarterstaff only
  warrior: ['sword'],                   // Swords only
  ranger:  ['bow'],                     // Bows only
  mage:    ['staff']                    // Staves only
};

// ============ SHOP / COSMETICS SYSTEM ============
let shopOpen = false;

const MONK_SKINS = {
  default: {
    id: 'default',
    name: 'Wandering Monk',
    type: 'EQUIPMENT',
    price: 0,
    owned: true,
    description: 'The default appearance of a humble monk on their journey.',
    badge: null,
    headshot: '🧘'
  },
  nature: {
    id: 'nature',
    name: 'Verdant Guardian',
    type: 'EQUIPMENT',
    price: 5000,
    owned: false,
    description: 'A monk attuned to the primal forces of nature and poison.',
    badge: 'new',
    headshot: '🧝‍♂️'
  },
  lightning: {
    id: 'lightning',
    name: 'Storm Caller',
    type: 'ARMOR',
    price: 15000,
    owned: false,
    description: 'Channels the fury of thunderstorms through martial mastery.',
    badge: 'new',
    headshot: '🧙‍♂️'
  },
  fire: {
    id: 'fire',
    name: 'Ember Fist',
    type: 'EQUIPMENT',
    price: 10000,
    owned: false,
    description: 'A warrior monk who channels blazing fury through devastating strikes.',
    badge: 'new',
    headshot: '👹'
  },
  frost: {
    id: 'frost',
    name: 'Frozen Ascetic',
    type: 'ACCESSORIES',
    price: 8000,
    owned: false,
    description: 'A hermit monk who has mastered the cold winds of the northern mountains.',
    badge: null,
    headshot: '🥶'
  }
};

const RANGER_SKINS = {
  default: {
    id: 'default',
    name: 'Forest Ranger',
    type: 'EQUIPMENT',
    price: 0,
    owned: true,
    description: 'A skilled hunter and tracker, at home in the wilderness.',
    badge: null,
    headshot: '🏹'
  },
  nature: {
    id: 'nature',
    name: 'Verdant Archer',
    type: 'EQUIPMENT',
    price: 5000,
    owned: false,
    description: 'One with nature, commanding living wood and vine.',
    badge: 'new',
    headshot: '🧝'
  },
  lightning: {
    id: 'lightning',
    name: 'Storm Archer',
    type: 'ARMOR',
    price: 15000,
    owned: false,
    description: 'Arrows charged with the fury of lightning strikes.',
    badge: 'new',
    headshot: '⚡'
  },
  fire: {
    id: 'fire',
    name: 'Flame Hunter',
    type: 'EQUIPMENT',
    price: 10000,
    owned: false,
    description: 'Burns enemies down with searing arrows and explosive shots.',
    badge: 'new',
    headshot: '🔥'
  },
  frost: {
    id: 'frost',
    name: 'Frost Stalker',
    type: 'ACCESSORIES',
    price: 8000,
    owned: false,
    description: 'A hunter from the frozen north, wielding icy precision.',
    badge: null,
    headshot: '❄️'
  }
};

const MAGE_SKINS = {
  default: {
    id: 'default',
    name: 'Arcane Scholar',
    type: 'EQUIPMENT',
    price: 0,
    owned: true,
    description: 'A student of the arcane arts, seeking forbidden knowledge.',
    badge: null,
    headshot: '🧙'
  },
  nature: {
    id: 'nature',
    name: 'Nature Mage',
    type: 'EQUIPMENT',
    price: 5000,
    owned: false,
    description: 'Channels the living essence of nature itself.',
    badge: 'new',
    headshot: '🌿'
  },
  lightning: {
    id: 'lightning',
    name: 'Storm Mage',
    type: 'ARMOR',
    price: 15000,
    owned: false,
    description: 'Commands the power of thunder and lightning.',
    badge: 'new',
    headshot: '🌩️'
  },
  fire: {
    id: 'fire',
    name: 'Pyromancer',
    type: 'EQUIPMENT',
    price: 10000,
    owned: false,
    description: 'Master of destructive fire magic and burning devastation.',
    badge: 'new',
    headshot: '🔥'
  },
  frost: {
    id: 'frost',
    name: 'Cryomancer',
    type: 'ACCESSORIES',
    price: 8000,
    owned: false,
    description: 'Freezes enemies solid with devastating ice magic.',
    badge: null,
    headshot: '🧊'
  }
};

const WARRIOR_SKINS = {
  default: {
    id: 'default',
    name: 'Iron Guardian',
    type: 'EQUIPMENT',
    price: 0,
    owned: true,
    description: 'A stalwart defender clad in sturdy iron armor.',
    badge: null,
    headshot: '🛡️'
  },
  nature: {
    id: 'nature',
    name: 'Verdant Knight',
    type: 'EQUIPMENT',
    price: 5000,
    owned: false,
    description: 'A warrior blessed by the forest spirits.',
    badge: 'new',
    headshot: '🌿'
  },
  lightning: {
    id: 'lightning',
    name: 'Storm Knight',
    type: 'ARMOR',
    price: 15000,
    owned: false,
    description: 'Armor crackling with the power of storms.',
    badge: 'new',
    headshot: '⚡'
  },
  fire: {
    id: 'fire',
    name: 'Inferno Knight',
    type: 'EQUIPMENT',
    price: 10000,
    owned: false,
    description: 'Forged in volcanic fire, burns all who oppose.',
    badge: 'new',
    headshot: '🔥'
  },
  frost: {
    id: 'frost',
    name: 'Frost Knight',
    type: 'ACCESSORIES',
    price: 8000,
    owned: false,
    description: 'Armor enchanted with eternal ice.',
    badge: null,
    headshot: '🧊'
  }
};

// Get player headshot based on equipped skin and class
function getPlayerHeadshot() {
  let skinData;
  if (player.class === 'ranger') {
    skinData = RANGER_SKINS[player.skin] || RANGER_SKINS.default;
  } else if (player.class === 'mage') {
    skinData = MAGE_SKINS[player.skin] || MAGE_SKINS.default;
  } else if (player.class === 'warrior') {
    skinData = WARRIOR_SKINS[player.skin] || WARRIOR_SKINS.default;
  } else {
    skinData = MONK_SKINS[player.skin] || MONK_SKINS.default;
  }
  return skinData.headshot || '👤';
}

// Get skins for current player class
function getClassSkins() {
  if (player.class === 'ranger') return RANGER_SKINS;
  if (player.class === 'mage') return MAGE_SKINS;
  if (player.class === 'warrior') return WARRIOR_SKINS;
  return MONK_SKINS;
}

// Update character preview with current skin headshot
function updateCharacterPreview() {
  const preview = document.getElementById('menuCharPreview');
  if (preview) {
    preview.textContent = getPlayerHeadshot();
  }
  // Also update portrait if exists
  const portrait = document.querySelector('.portrait-icon');
  if (portrait) {
    portrait.textContent = getPlayerHeadshot();
  }
}

function toggleHotkeyMenu() {
  hotkeyMenuOpen = !hotkeyMenuOpen;
  const menu = document.getElementById('hotkeyMenu');
  
  if (hotkeyMenuOpen) {
    menu.classList.add('visible');
  } else {
    menu.classList.remove('visible');
  }
  updateHotkeyLegend();
}

function toggleShop() {
  shopOpen = !shopOpen;
  const panel = document.getElementById('shopPanel');
  
  if (shopOpen) {
    panel.style.display = '';  // Clear any inline display:none from returnToMainMenu
    panel.classList.add('visible');
    // Set up tab click handlers
    setupShopTabs();
    // Default to cosmetics tab
    switchShopTab('cosmetics');
    document.getElementById('shopGold').textContent = player.gold.toLocaleString();
  } else {
    panel.classList.remove('visible');
  }
  updateHotkeyLegend();
}

let currentShopTab = 'cosmetics';

function setupShopTabs() {
  const tabs = document.querySelectorAll('.shop-tab');
  tabs.forEach(tab => {
    tab.onclick = () => switchShopTab(tab.dataset.tab);
  });
}

function switchShopTab(tabName) {
  currentShopTab = tabName;
  
  // Update tab active state
  const tabs = document.querySelectorAll('.shop-tab');
  tabs.forEach(tab => {
    tab.classList.toggle('active', tab.dataset.tab === tabName);
  });
  
  // Render appropriate content
  if (tabName === 'cosmetics') {
    renderShopCards();
  } else if (tabName === 'addons') {
    renderAddOnsTab();
  }
}

function renderAddOnsTab() {
  const grid = document.getElementById('shopGrid');
  const titleEl = document.getElementById('shopSectionTitle');
  
  if (titleEl) titleEl.textContent = 'Upgrades & Add-Ons';
  
  grid.innerHTML = '';
  
  // Loot Tab Capacity Upgrade
  const maxOverflow = 100;
  const currentCap = overflowCapacity;
  const nextCap = Math.min(currentCap + 10, maxOverflow);
  const isMaxed = currentCap >= maxOverflow;
  const upgradeCost = Math.floor(500 * Math.pow(1.5, (currentCap - 20) / 10));
  
  const card = document.createElement('div');
  card.className = `addon-card ${isMaxed ? 'maxed' : ''}`;
  card.innerHTML = `
    <div class="addon-icon">📦</div>
    <div class="addon-info">
      <div class="addon-name">Loot Tab Capacity</div>
      <div class="addon-desc">Increase loot tab capacity by +10 slots</div>
      <div class="addon-progress">
        <div class="addon-progress-bar" style="width: ${(currentCap / maxOverflow) * 100}%"></div>
      </div>
      <div class="addon-stats">${currentCap} / ${maxOverflow} slots</div>
    </div>
    <div class="addon-action">
      ${isMaxed ? 
        `<span class="addon-maxed">MAXED</span>` :
        `<button class="addon-buy-btn" onclick="buyOverflowUpgrade()" ${player.gold < upgradeCost ? 'disabled' : ''}>
          <span class="addon-cost">💰 ${upgradeCost.toLocaleString()}</span>
          <span class="addon-gain">+10 slots</span>
        </button>`
      }
    </div>
  `;
  grid.appendChild(card);
  
  // Placeholder for future add-ons
  const placeholder = document.createElement('div');
  placeholder.className = 'addon-card coming-soon';
  placeholder.innerHTML = `
    <div class="addon-icon" style="opacity:0.4">🎒</div>
    <div class="addon-info">
      <div class="addon-name" style="opacity:0.5">More Upgrades</div>
      <div class="addon-desc" style="opacity:0.4">Coming soon...</div>
    </div>
  `;
  grid.appendChild(placeholder);
}

function buyOverflowUpgrade() {
  const maxOverflow = 100;
  if (overflowCapacity >= maxOverflow) {
    addLog('Loot tab capacity already maxed!', 'warning');
    return;
  }
  
  const cost = Math.floor(500 * Math.pow(1.5, (overflowCapacity - 20) / 10));
  
  if (player.gold < cost) {
    addLog('Not enough gold!', 'warning');
    return;
  }
  
  player.gold -= cost;
  overflowCapacity += 10;
  
  addLog(`Loot tab capacity increased to ${overflowCapacity}!`, 'skill');
  
  // Update displays
  document.getElementById('shopGold').textContent = player.gold.toLocaleString();
  renderAddOnsTab();
  updateOverflowDisplay();
  saveGame();
}

function updateHotkeyLegend() {
  const legend = document.getElementById('hotkeyLegend');
  if (!legend) return;
  
  // Hide legend when full hotkey menu is open or in menu state
  if (hotkeyMenuOpen || gameState !== 'playing') {
    legend.classList.remove('visible');
  } else {
    legend.classList.add('visible');
  }
}

function renderShopCards() {
  const grid = document.getElementById('shopGrid');
  grid.innerHTML = '';
  
  // Update shop title
  const titleEl = document.getElementById('shopSectionTitle');
  if (titleEl) {
    titleEl.textContent = 'All Appearances';
  }
  
  // Show all classes in order
  const allClasses = [
    { id: 'monk', name: 'Monk', skins: MONK_SKINS },
    { id: 'ranger', name: 'Ranger', skins: RANGER_SKINS },
    { id: 'mage', name: 'Mage', skins: MAGE_SKINS },
    { id: 'warrior', name: 'Warrior', skins: WARRIOR_SKINS }
  ];
  
  for (const classData of allClasses) {
    // Add class header
    const header = document.createElement('div');
    header.className = 'shop-class-header';
    header.innerHTML = `<span class="shop-class-icon">${CLASS_DATA[classData.id]?.icon || '👤'}</span> ${classData.name} Appearances`;
    if (player.class === classData.id) {
      header.innerHTML += ' <span class="current-class-badge">YOUR CLASS</span>';
    }
    grid.appendChild(header);
    
    // Add skins for this class
    for (const [skinId, skin] of Object.entries(classData.skins)) {
      const isCurrentClass = player.class === classData.id;
      const isEquipped = player.skin === skinId && isCurrentClass;
      const card = document.createElement('div');
      card.className = `shop-card ${skin.owned ? 'owned' : ''} ${isEquipped ? 'equipped' : ''} ${!isCurrentClass ? 'other-class' : ''}`;
      card.innerHTML = `
        <div class="shop-card-image">
          <canvas class="shop-card-preview" id="preview-${classData.id}-${skinId}" width="180" height="240"></canvas>
          ${skin.badge ? `<span class="shop-card-badge ${skin.badge}">${skin.badge}</span>` : ''}
          ${skin.owned ? `<span class="shop-card-badge ${isEquipped ? 'equipped' : 'owned'}">${isEquipped ? 'EQUIPPED' : 'OWNED'}</span>` : ''}
          ${!isCurrentClass ? `<span class="shop-card-class-lock">${classData.name} Only</span>` : ''}
        </div>
        <div class="shop-card-info">
          <div class="shop-card-name">${skin.name}</div>
          <div class="shop-card-type">${skin.type}</div>
          ${!skin.owned ? `<div class="shop-card-price">💰 ${skin.price.toLocaleString()}</div>` : ''}
        </div>
        <div class="shop-card-actions">
          ${!skin.owned ? 
            `<button class="shop-btn buy" onclick="buySkin('${skinId}', '${classData.id}')" ${player.gold < skin.price ? 'disabled' : ''}>Buy</button>` :
            (isCurrentClass ?
              (isEquipped ? 
                `<button class="shop-btn unequip" onclick="unequipSkin()">Unequip</button>` :
                `<button class="shop-btn equip" onclick="equipSkin('${skinId}', '${classData.id}')">Equip</button>`
              ) :
              `<button class="shop-btn equip" disabled title="Switch to ${classData.name} to equip">Wrong Class</button>`
            )
          }
        </div>
      `;
      grid.appendChild(card);
      
      // Render preview after card is in DOM
      setTimeout(() => renderSkinPreviewForClass(skinId, classData.id), 10);
    }
  }
}

function renderSkinPreviewForClass(skinId, classId) {
  const canvas = document.getElementById(`preview-${classId}-${skinId}`);
  if (!canvas) return;
  const ctx = canvas.getContext('2d');
  ctx.clearRect(0, 0, 180, 240);
  
  ctx.save();
  ctx.translate(90, 140);
  ctx.scale(2.5, 2.5); // Scale up for preview
  
  // Draw the skin based on class
  if (classId === 'ranger') {
    drawRangerSkin(ctx, skinId, 0, false);
  } else if (classId === 'mage') {
    drawMageSkin(ctx, skinId, 0, false);
  } else if (classId === 'warrior') {
    drawWarriorSkin(ctx, skinId, 0, false);
  } else {
    drawMonkSkin(ctx, skinId, 0, false);
  }
  
  ctx.restore();
}

function renderSkinPreview(skinId) {
  const canvas = document.getElementById(`preview-${skinId}`);
  if (!canvas) return;
  const ctx = canvas.getContext('2d');
  ctx.clearRect(0, 0, 180, 240);
  
  ctx.save();
  ctx.translate(90, 140);
  ctx.scale(2.5, 2.5); // Scale up for preview
  
  // Draw the skin based on class
  if (player.class === 'ranger') {
    drawRangerSkin(ctx, skinId, 0, false);
  } else if (player.class === 'mage') {
    drawMageSkin(ctx, skinId, 0, false);
  } else if (player.class === 'warrior') {
    drawWarriorSkin(ctx, skinId, 0, false);
  } else {
    drawMonkSkin(ctx, skinId, 0, false);
  }
  
  ctx.restore();
}

function getSkinsForClass(classId) {
  switch(classId) {
    case 'ranger': return RANGER_SKINS;
    case 'mage': return MAGE_SKINS;
    case 'warrior': return WARRIOR_SKINS;
    default: return MONK_SKINS;
  }
}

function buySkin(skinId, classId) {
  const skins = getSkinsForClass(classId);
  const skin = skins[skinId];
  if (!skin || skin.owned || player.gold < skin.price) return;
  
  player.gold -= skin.price;
  skin.owned = true;
  skin.badge = null;
  
  addLog(`Purchased ${skin.name}!`, 'unique');
  renderShopCards();
  document.getElementById('shopGold').textContent = player.gold.toLocaleString();
}

function equipSkin(skinId, classId) {
  // Only equip if it's for the current class
  if (classId && classId !== player.class) {
    addLog(`Switch to ${classId} to equip this skin!`, 'warning');
    return;
  }
  
  const skins = getClassSkins();
  const skin = skins[skinId];
  if (!skin || !skin.owned) return;
  
  player.skin = skinId;
  // Also save to current character
  if (selectedCharacter !== null && characters[selectedCharacter]) {
    characters[selectedCharacter].skin = skinId;
  }
  addLog(`Equipped ${skin.name}`, 'skill');
  renderShopCards();
  updateCharacterPreview();
}

function unequipSkin() {
  player.skin = 'default';
  // Also save to current character
  if (selectedCharacter !== null && characters[selectedCharacter]) {
    characters[selectedCharacter].skin = 'default';
  }
  addLog('Reverted to default appearance', 'info');
  renderShopCards();
  updateCharacterPreview();
}

// Draw monk with specific skin (used for both game and previews)
function drawMonkSkin(ctx, skinId, wAng, showGlow) {
  switch(skinId) {
    case 'nature': drawNatureMonk(ctx, wAng, showGlow); break;
    case 'lightning': drawLightningMonk(ctx, wAng, showGlow); break;
    case 'fire': drawFireMonk(ctx, wAng, showGlow); break;
    case 'frost': drawFrostMonk(ctx, wAng, showGlow); break;
    default: drawDefaultMonk(ctx, wAng, showGlow);
  }
}

// ============ MONK SKIN DRAWING FUNCTIONS ============

function drawDefaultMonk(ctx, wAng, showGlow) {
  const breathe = Math.sin(frame * 0.05) * 0.5;
  const legMove = player.state === 'moving' ? Math.sin(frame * 0.15) * 2.5 : 0;
  
  // Shadow
  ctx.fillStyle = 'rgba(0,0,0,0.4)';
  ctx.beginPath();
  ctx.ellipse(0, 18, 14, 5, 0, 0, Math.PI * 2);
  ctx.fill();
  
  // Legs - muscular martial artist with orange gi pants
  ctx.fillStyle = '#8B6914';
  ctx.fillRect(-8, 4, 6, 12 + legMove);
  ctx.fillRect(2, 4, 6, 12 - legMove);
  // Leg wraps
  ctx.strokeStyle = '#F5DEB3';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(-7, 10); ctx.lineTo(-4, 14);
  ctx.moveTo(3, 10); ctx.lineTo(6, 14);
  ctx.stroke();
  
  // Bare feet
  ctx.fillStyle = '#C4A35A';
  ctx.fillRect(-9, 15 + legMove, 7, 3);
  ctx.fillRect(2, 15 - legMove, 7, 3);
  
  // Muscular body - sleeveless bright orange gi
  ctx.fillStyle = '#FF8C00';
  ctx.beginPath();
  ctx.moveTo(-12, 4); ctx.lineTo(-12, -6); ctx.lineTo(-6, -12);
  ctx.lineTo(6, -12); ctx.lineTo(12, -6); ctx.lineTo(12, 4);
  ctx.lineTo(8, 6); ctx.lineTo(-8, 6);
  ctx.closePath();
  ctx.fill();
  
  // Black belt
  ctx.fillStyle = '#222';
  ctx.fillRect(-10, 2, 20, 4);
  ctx.fillStyle = '#333';
  ctx.fillRect(-3, 2, 6, 4);
  ctx.fillRect(-4, 4, 2, 6);
  ctx.fillRect(2, 4, 2, 6);
  
  // Bare muscular arms
  ctx.fillStyle = '#C4A35A';
  ctx.beginPath(); ctx.ellipse(-14, -4, 5, 6, 0.2, 0, Math.PI * 2); ctx.fill();
  ctx.beginPath(); ctx.ellipse(14, -4, 5, 6, -0.2, 0, Math.PI * 2); ctx.fill();
  ctx.fillRect(-16, -2, 5, 10);
  ctx.fillRect(11, -2, 5, 10);
  
  // Fists with hand wraps
  ctx.fillStyle = '#C4A35A';
  ctx.beginPath(); ctx.arc(-14, 9, 4, 0, Math.PI * 2); ctx.fill();
  ctx.beginPath(); ctx.arc(14, 9, 4, 0, Math.PI * 2); ctx.fill();
  ctx.strokeStyle = '#fff';
  ctx.lineWidth = 1.5;
  ctx.beginPath(); ctx.arc(-14, 9, 4, 0, Math.PI * 2); ctx.stroke();
  ctx.beginPath(); ctx.arc(14, 9, 4, 0, Math.PI * 2); ctx.stroke();
  
  // Head - bald with topknot
  ctx.fillStyle = '#C4A35A';
  ctx.beginPath(); ctx.arc(0, -18, 10, 0, Math.PI * 2); ctx.fill();
  
  // Topknot
  ctx.fillStyle = '#222';
  ctx.beginPath();
  ctx.moveTo(-3, -28); ctx.quadraticCurveTo(0, -32, 3, -28);
  ctx.quadraticCurveTo(0, -26, -3, -28);
  ctx.fill();
  
  // Red headband
  ctx.fillStyle = '#CC0000';
  ctx.fillRect(-10, -22, 20, 3);
  ctx.beginPath();
  ctx.moveTo(10, -22); ctx.lineTo(16, -20 + Math.sin(frame * 0.1) * 2);
  ctx.lineTo(14, -18); ctx.lineTo(10, -19);
  ctx.fill();
  
  // Face - determined expression
  ctx.fillStyle = '#222';
  ctx.beginPath(); ctx.ellipse(-4, -18, 1.5, 1.2, 0, 0, Math.PI * 2); ctx.fill();
  ctx.beginPath(); ctx.ellipse(4, -18, 1.5, 1.2, 0, 0, Math.PI * 2); ctx.fill();
  ctx.strokeStyle = '#222';
  ctx.lineWidth = 1.5;
  ctx.beginPath();
  ctx.moveTo(-6, -21); ctx.lineTo(-2, -20);
  ctx.moveTo(6, -21); ctx.lineTo(2, -20);
  ctx.stroke();
  
  // Glow when attacking - chi energy on fists
  if (showGlow) {
    ctx.fillStyle = 'rgba(255, 150, 50, 0.6)';
    ctx.beginPath(); ctx.arc(-14, 9, 8, 0, Math.PI * 2); ctx.fill();
    ctx.beginPath(); ctx.arc(14, 9, 8, 0, Math.PI * 2); ctx.fill();
  }
  
  // Bo Staff held diagonally
  ctx.save();
  ctx.translate(16, 2);
  ctx.rotate(wAng + 0.3);
  ctx.fillStyle = '#8B4513';
  ctx.fillRect(-2, -22, 4, 44);
  ctx.fillStyle = '#888';
  ctx.fillRect(-2.5, -22, 5, 4);
  ctx.fillRect(-2.5, 18, 5, 4);
  ctx.restore();
}

function drawNatureMonk(ctx, wAng, showGlow) {
  const breathe = Math.sin(frame * 0.05) * 0.5;
  const legMove = player.state === 'moving' ? Math.sin(frame * 0.15) * 2.5 : 0;
  
  // Shadow
  ctx.fillStyle = 'rgba(20, 60, 20, 0.4)';
  ctx.beginPath();
  ctx.ellipse(0, 18, 14, 5, 0, 0, Math.PI * 2);
  ctx.fill();
  
  // Legs - deep green gi pants
  ctx.fillStyle = '#2d5a27';
  ctx.fillRect(-8, 4, 6, 12 + legMove);
  ctx.fillRect(2, 4, 6, 12 - legMove);
  // Leg wraps - vine-like
  ctx.strokeStyle = '#7CFC00';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(-7, 10); ctx.lineTo(-4, 14);
  ctx.moveTo(3, 10); ctx.lineTo(6, 14);
  ctx.stroke();
  
  // Bare feet
  ctx.fillStyle = '#8B7355';
  ctx.fillRect(-9, 15 + legMove, 7, 3);
  ctx.fillRect(2, 15 - legMove, 7, 3);
  
  // Muscular body - sleeveless forest green gi
  ctx.fillStyle = '#228B22';
  ctx.beginPath();
  ctx.moveTo(-12, 4); ctx.lineTo(-12, -6); ctx.lineTo(-6, -12);
  ctx.lineTo(6, -12); ctx.lineTo(12, -6); ctx.lineTo(12, 4);
  ctx.lineTo(8, 6); ctx.lineTo(-8, 6);
  ctx.closePath();
  ctx.fill();
  
  // Vine belt
  ctx.fillStyle = '#4a3728';
  ctx.fillRect(-10, 2, 20, 4);
  ctx.fillStyle = '#7CFC00';
  ctx.fillRect(-3, 2, 6, 4);
  ctx.fillRect(-4, 4, 2, 6);
  ctx.fillRect(2, 4, 2, 6);
  
  // Bare muscular arms (tanned skin)
  ctx.fillStyle = '#8B7355';
  ctx.beginPath(); ctx.ellipse(-14, -4, 5, 6, 0.2, 0, Math.PI * 2); ctx.fill();
  ctx.beginPath(); ctx.ellipse(14, -4, 5, 6, -0.2, 0, Math.PI * 2); ctx.fill();
  ctx.fillRect(-16, -2, 5, 10);
  ctx.fillRect(11, -2, 5, 10);
  
  // Fists with leaf wraps
  ctx.fillStyle = '#8B7355';
  ctx.beginPath(); ctx.arc(-14, 9, 4, 0, Math.PI * 2); ctx.fill();
  ctx.beginPath(); ctx.arc(14, 9, 4, 0, Math.PI * 2); ctx.fill();
  ctx.strokeStyle = '#7CFC00';
  ctx.lineWidth = 1.5;
  ctx.beginPath(); ctx.arc(-14, 9, 4, 0, Math.PI * 2); ctx.stroke();
  ctx.beginPath(); ctx.arc(14, 9, 4, 0, Math.PI * 2); ctx.stroke();
  
  // Head - bald with topknot
  ctx.fillStyle = '#8B7355';
  ctx.beginPath(); ctx.arc(0, -18, 10, 0, Math.PI * 2); ctx.fill();
  
  // Leaf topknot
  ctx.fillStyle = '#228B22';
  ctx.beginPath();
  ctx.moveTo(-3, -28); ctx.quadraticCurveTo(0, -34, 3, -28);
  ctx.quadraticCurveTo(0, -26, -3, -28);
  ctx.fill();
  
  // Green headband with leaves
  ctx.fillStyle = '#32CD32';
  ctx.fillRect(-10, -22, 20, 3);
  ctx.beginPath();
  ctx.moveTo(10, -22); ctx.lineTo(16, -20 + Math.sin(frame * 0.1) * 2);
  ctx.lineTo(14, -18); ctx.lineTo(10, -19);
  ctx.fill();
  
  // Face - determined expression
  ctx.fillStyle = '#222';
  ctx.beginPath(); ctx.ellipse(-4, -18, 1.5, 1.2, 0, 0, Math.PI * 2); ctx.fill();
  ctx.beginPath(); ctx.ellipse(4, -18, 1.5, 1.2, 0, 0, Math.PI * 2); ctx.fill();
  ctx.strokeStyle = '#222';
  ctx.lineWidth = 1.5;
  ctx.beginPath();
  ctx.moveTo(-6, -21); ctx.lineTo(-2, -20);
  ctx.moveTo(6, -21); ctx.lineTo(2, -20);
  ctx.stroke();
  
  // Glow when attacking - nature chi energy on fists
  if (showGlow) {
    ctx.fillStyle = 'rgba(50, 205, 50, 0.6)';
    ctx.beginPath(); ctx.arc(-14, 9, 8, 0, Math.PI * 2); ctx.fill();
    ctx.beginPath(); ctx.arc(14, 9, 8, 0, Math.PI * 2); ctx.fill();
  }
  
  // Bo Staff - living wood
  ctx.save();
  ctx.translate(16, 2);
  ctx.rotate(wAng + 0.3);
  ctx.fillStyle = '#5D4037';
  ctx.fillRect(-2, -22, 4, 44);
  ctx.fillStyle = '#7CFC00';
  ctx.beginPath(); ctx.arc(0, -22, 5, 0, Math.PI * 2); ctx.fill();
  ctx.fillRect(-2.5, 18, 5, 4);
  ctx.restore();
}

function drawLightningMonk(ctx, wAng, showGlow) {
  const breathe = Math.sin(frame * 0.05) * 0.5;
  const legMove = player.state === 'moving' ? Math.sin(frame * 0.15) * 2.5 : 0;
  
  // Shadow
  ctx.fillStyle = 'rgba(30, 30, 80, 0.4)';
  ctx.beginPath();
  ctx.ellipse(0, 18, 14, 5, 0, 0, Math.PI * 2);
  ctx.fill();
  
  // Legs - deep blue gi pants
  ctx.fillStyle = '#3a4a7a';
  ctx.fillRect(-8, 4, 6, 12 + legMove);
  ctx.fillRect(2, 4, 6, 12 - legMove);
  // Leg wraps - electric
  ctx.strokeStyle = '#FFD700';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(-7, 10); ctx.lineTo(-4, 14);
  ctx.moveTo(3, 10); ctx.lineTo(6, 14);
  ctx.stroke();
  
  // Bare feet
  ctx.fillStyle = '#C4A35A';
  ctx.fillRect(-9, 15 + legMove, 7, 3);
  ctx.fillRect(2, 15 - legMove, 7, 3);
  
  // Muscular body - sleeveless storm blue gi
  ctx.fillStyle = '#4169E1';
  ctx.beginPath();
  ctx.moveTo(-12, 4); ctx.lineTo(-12, -6); ctx.lineTo(-6, -12);
  ctx.lineTo(6, -12); ctx.lineTo(12, -6); ctx.lineTo(12, 4);
  ctx.lineTo(8, 6); ctx.lineTo(-8, 6);
  ctx.closePath();
  ctx.fill();
  
  // Lightning bolt on chest
  ctx.fillStyle = '#FFD700';
  ctx.beginPath();
  ctx.moveTo(0, -8); ctx.lineTo(4, -2); ctx.lineTo(1, -2);
  ctx.lineTo(3, 4); ctx.lineTo(-1, 0); ctx.lineTo(2, 0);
  ctx.closePath();
  ctx.fill();
  
  // Yellow belt
  ctx.fillStyle = '#DAA520';
  ctx.fillRect(-10, 2, 20, 4);
  ctx.fillStyle = '#FFD700';
  ctx.fillRect(-3, 2, 6, 4);
  ctx.fillRect(-4, 4, 2, 6);
  ctx.fillRect(2, 4, 2, 6);
  
  // Bare muscular arms
  ctx.fillStyle = '#C4A35A';
  ctx.beginPath(); ctx.ellipse(-14, -4, 5, 6, 0.2, 0, Math.PI * 2); ctx.fill();
  ctx.beginPath(); ctx.ellipse(14, -4, 5, 6, -0.2, 0, Math.PI * 2); ctx.fill();
  ctx.fillRect(-16, -2, 5, 10);
  ctx.fillRect(11, -2, 5, 10);
  
  // Fists with electric wraps
  ctx.fillStyle = '#C4A35A';
  ctx.beginPath(); ctx.arc(-14, 9, 4, 0, Math.PI * 2); ctx.fill();
  ctx.beginPath(); ctx.arc(14, 9, 4, 0, Math.PI * 2); ctx.fill();
  ctx.strokeStyle = '#FFD700';
  ctx.lineWidth = 1.5;
  ctx.beginPath(); ctx.arc(-14, 9, 4, 0, Math.PI * 2); ctx.stroke();
  ctx.beginPath(); ctx.arc(14, 9, 4, 0, Math.PI * 2); ctx.stroke();
  
  // Head - bald with topknot
  ctx.fillStyle = '#C4A35A';
  ctx.beginPath(); ctx.arc(0, -18, 10, 0, Math.PI * 2); ctx.fill();
  
  // Storm topknot
  ctx.fillStyle = '#4169E1';
  ctx.beginPath();
  ctx.moveTo(-3, -28); ctx.quadraticCurveTo(0, -32, 3, -28);
  ctx.quadraticCurveTo(0, -26, -3, -28);
  ctx.fill();
  
  // Yellow headband
  ctx.fillStyle = '#FFD700';
  ctx.fillRect(-10, -22, 20, 3);
  ctx.beginPath();
  ctx.moveTo(10, -22); ctx.lineTo(16, -20 + Math.sin(frame * 0.1) * 2);
  ctx.lineTo(14, -18); ctx.lineTo(10, -19);
  ctx.fill();
  
  // Face - determined expression
  ctx.fillStyle = '#222';
  ctx.beginPath(); ctx.ellipse(-4, -18, 1.5, 1.2, 0, 0, Math.PI * 2); ctx.fill();
  ctx.beginPath(); ctx.ellipse(4, -18, 1.5, 1.2, 0, 0, Math.PI * 2); ctx.fill();
  ctx.strokeStyle = '#222';
  ctx.lineWidth = 1.5;
  ctx.beginPath();
  ctx.moveTo(-6, -21); ctx.lineTo(-2, -20);
  ctx.moveTo(6, -21); ctx.lineTo(2, -20);
  ctx.stroke();
  
  // Glow when attacking - lightning chi energy on fists
  if (showGlow) {
    ctx.fillStyle = 'rgba(255, 215, 0, 0.6)';
    ctx.beginPath(); ctx.arc(-14, 9, 8, 0, Math.PI * 2); ctx.fill();
    ctx.beginPath(); ctx.arc(14, 9, 8, 0, Math.PI * 2); ctx.fill();
  }
  
  // Bo Staff - storm rod
  ctx.save();
  ctx.translate(16, 2);
  ctx.rotate(wAng + 0.3);
  ctx.fillStyle = '#4169E1';
  ctx.fillRect(-2, -22, 4, 44);
  ctx.fillStyle = '#FFD700';
  ctx.beginPath(); ctx.arc(0, -22, 5, 0, Math.PI * 2); ctx.fill();
  ctx.fillRect(-2.5, 18, 5, 4);
  ctx.restore();
}

function drawFireMonk(ctx, wAng, showGlow) {
  const breathe = Math.sin(frame * 0.05) * 0.5;
  const legMove = player.state === 'moving' ? Math.sin(frame * 0.15) * 2.5 : 0;
  
  // Shadow
  ctx.fillStyle = 'rgba(80, 30, 0, 0.4)';
  ctx.beginPath();
  ctx.ellipse(0, 18, 14, 5, 0, 0, Math.PI * 2);
  ctx.fill();
  
  // Legs - deep red gi pants
  ctx.fillStyle = '#8B2500';
  ctx.fillRect(-8, 4, 6, 12 + legMove);
  ctx.fillRect(2, 4, 6, 12 - legMove);
  // Leg wraps - flame colored
  ctx.strokeStyle = '#FF4500';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(-7, 10); ctx.lineTo(-4, 14);
  ctx.moveTo(3, 10); ctx.lineTo(6, 14);
  ctx.stroke();
  
  // Bare feet
  ctx.fillStyle = '#8B4513';
  ctx.fillRect(-9, 15 + legMove, 7, 3);
  ctx.fillRect(2, 15 - legMove, 7, 3);
  
  // Muscular body - sleeveless crimson gi
  ctx.fillStyle = '#B22222';
  ctx.beginPath();
  ctx.moveTo(-12, 4); ctx.lineTo(-12, -6); ctx.lineTo(-6, -12);
  ctx.lineTo(6, -12); ctx.lineTo(12, -6); ctx.lineTo(12, 4);
  ctx.lineTo(8, 6); ctx.lineTo(-8, 6);
  ctx.closePath();
  ctx.fill();
  
  // Flame symbol on chest
  ctx.fillStyle = '#FF4500';
  ctx.beginPath();
  ctx.moveTo(0, -7); ctx.lineTo(-4, 3); ctx.lineTo(4, 3);
  ctx.closePath();
  ctx.fill();
  ctx.fillStyle = '#FFD700';
  ctx.beginPath();
  ctx.moveTo(0, -4); ctx.lineTo(-2, 1); ctx.lineTo(2, 1);
  ctx.closePath();
  ctx.fill();
  
  // Orange belt
  ctx.fillStyle = '#8B4513';
  ctx.fillRect(-10, 2, 20, 4);
  ctx.fillStyle = '#FF4500';
  ctx.fillRect(-3, 2, 6, 4);
  ctx.fillRect(-4, 4, 2, 6);
  ctx.fillRect(2, 4, 2, 6);
  
  // Bare muscular arms
  ctx.fillStyle = '#8B4513';
  ctx.beginPath(); ctx.ellipse(-14, -4, 5, 6, 0.2, 0, Math.PI * 2); ctx.fill();
  ctx.beginPath(); ctx.ellipse(14, -4, 5, 6, -0.2, 0, Math.PI * 2); ctx.fill();
  ctx.fillRect(-16, -2, 5, 10);
  ctx.fillRect(11, -2, 5, 10);
  
  // Fists with flame wraps
  ctx.fillStyle = '#8B4513';
  ctx.beginPath(); ctx.arc(-14, 9, 4, 0, Math.PI * 2); ctx.fill();
  ctx.beginPath(); ctx.arc(14, 9, 4, 0, Math.PI * 2); ctx.fill();
  ctx.strokeStyle = '#FF4500';
  ctx.lineWidth = 1.5;
  ctx.beginPath(); ctx.arc(-14, 9, 4, 0, Math.PI * 2); ctx.stroke();
  ctx.beginPath(); ctx.arc(14, 9, 4, 0, Math.PI * 2); ctx.stroke();
  
  // Head - bald with topknot
  ctx.fillStyle = '#8B4513';
  ctx.beginPath(); ctx.arc(0, -18, 10, 0, Math.PI * 2); ctx.fill();
  
  // Flame topknot (animated)
  ctx.fillStyle = '#FF4500';
  ctx.beginPath();
  ctx.moveTo(-3, -28); ctx.quadraticCurveTo(0, -34 + Math.sin(frame * 0.15) * 2, 3, -28);
  ctx.quadraticCurveTo(0, -26, -3, -28);
  ctx.fill();
  ctx.fillStyle = '#FFD700';
  ctx.beginPath();
  ctx.moveTo(-1, -28); ctx.quadraticCurveTo(0, -31, 1, -28);
  ctx.fill();
  
  // Red headband
  ctx.fillStyle = '#FF4500';
  ctx.fillRect(-10, -22, 20, 3);
  ctx.beginPath();
  ctx.moveTo(10, -22); ctx.lineTo(16, -20 + Math.sin(frame * 0.1) * 2);
  ctx.lineTo(14, -18); ctx.lineTo(10, -19);
  ctx.fill();
  
  // Face - determined expression
  ctx.fillStyle = '#222';
  ctx.beginPath(); ctx.ellipse(-4, -18, 1.5, 1.2, 0, 0, Math.PI * 2); ctx.fill();
  ctx.beginPath(); ctx.ellipse(4, -18, 1.5, 1.2, 0, 0, Math.PI * 2); ctx.fill();
  ctx.strokeStyle = '#222';
  ctx.lineWidth = 1.5;
  ctx.beginPath();
  ctx.moveTo(-6, -21); ctx.lineTo(-2, -20);
  ctx.moveTo(6, -21); ctx.lineTo(2, -20);
  ctx.stroke();
  
  // Glow when attacking - fire chi energy on fists
  if (showGlow) {
    ctx.fillStyle = 'rgba(255, 100, 0, 0.6)';
    ctx.beginPath(); ctx.arc(-14, 9, 8, 0, Math.PI * 2); ctx.fill();
    ctx.beginPath(); ctx.arc(14, 9, 8, 0, Math.PI * 2); ctx.fill();
  }
  
  // Bo Staff - ember rod
  ctx.save();
  ctx.translate(16, 2);
  ctx.rotate(wAng + 0.3);
  ctx.fillStyle = '#5a1500';
  ctx.fillRect(-2, -22, 4, 44);
  ctx.fillStyle = '#FF4500';
  ctx.beginPath(); ctx.arc(0, -22, 5, 0, Math.PI * 2); ctx.fill();
  ctx.fillRect(-2.5, 18, 5, 4);
  ctx.restore();
}

function drawFrostMonk(ctx, wAng, showGlow) {
  const breathe = Math.sin(frame * 0.05) * 0.5;
  const legMove = player.state === 'moving' ? Math.sin(frame * 0.15) * 2.5 : 0;
  
  // Shadow
  ctx.fillStyle = 'rgba(0, 50, 80, 0.4)';
  ctx.beginPath();
  ctx.ellipse(0, 18, 14, 5, 0, 0, Math.PI * 2);
  ctx.fill();
  
  // Legs - icy blue gi pants
  ctx.fillStyle = '#4682B4';
  ctx.fillRect(-8, 4, 6, 12 + legMove);
  ctx.fillRect(2, 4, 6, 12 - legMove);
  // Leg wraps - frost colored
  ctx.strokeStyle = '#B0E0E6';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(-7, 10); ctx.lineTo(-4, 14);
  ctx.moveTo(3, 10); ctx.lineTo(6, 14);
  ctx.stroke();
  
  // Bare feet (pale)
  ctx.fillStyle = '#B0C4DE';
  ctx.fillRect(-9, 15 + legMove, 7, 3);
  ctx.fillRect(2, 15 - legMove, 7, 3);
  
  // Muscular body - sleeveless frost blue gi
  ctx.fillStyle = '#5F9EA0';
  ctx.beginPath();
  ctx.moveTo(-12, 4); ctx.lineTo(-12, -6); ctx.lineTo(-6, -12);
  ctx.lineTo(6, -12); ctx.lineTo(12, -6); ctx.lineTo(12, 4);
  ctx.lineTo(8, 6); ctx.lineTo(-8, 6);
  ctx.closePath();
  ctx.fill();
  
  // Ice crystal symbol on chest
  ctx.strokeStyle = '#E0FFFF';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(0, -8); ctx.lineTo(0, 2);
  ctx.moveTo(-4, -3); ctx.lineTo(4, -3);
  ctx.moveTo(-3, -6); ctx.lineTo(3, 0);
  ctx.moveTo(3, -6); ctx.lineTo(-3, 0);
  ctx.stroke();
  
  // White belt
  ctx.fillStyle = '#87CEEB';
  ctx.fillRect(-10, 2, 20, 4);
  ctx.fillStyle = '#E0FFFF';
  ctx.fillRect(-3, 2, 6, 4);
  ctx.fillRect(-4, 4, 2, 6);
  ctx.fillRect(2, 4, 2, 6);
  
  // Bare muscular arms (pale, frost-touched)
  ctx.fillStyle = '#B0C4DE';
  ctx.beginPath(); ctx.ellipse(-14, -4, 5, 6, 0.2, 0, Math.PI * 2); ctx.fill();
  ctx.beginPath(); ctx.ellipse(14, -4, 5, 6, -0.2, 0, Math.PI * 2); ctx.fill();
  ctx.fillRect(-16, -2, 5, 10);
  ctx.fillRect(11, -2, 5, 10);
  
  // Fists with ice wraps
  ctx.fillStyle = '#B0C4DE';
  ctx.beginPath(); ctx.arc(-14, 9, 4, 0, Math.PI * 2); ctx.fill();
  ctx.beginPath(); ctx.arc(14, 9, 4, 0, Math.PI * 2); ctx.fill();
  ctx.strokeStyle = '#E0FFFF';
  ctx.lineWidth = 1.5;
  ctx.beginPath(); ctx.arc(-14, 9, 4, 0, Math.PI * 2); ctx.stroke();
  ctx.beginPath(); ctx.arc(14, 9, 4, 0, Math.PI * 2); ctx.stroke();
  
  // Head - bald with topknot (pale)
  ctx.fillStyle = '#B0C4DE';
  ctx.beginPath(); ctx.arc(0, -18, 10, 0, Math.PI * 2); ctx.fill();
  
  // Ice crystal topknot
  ctx.fillStyle = '#E0FFFF';
  ctx.beginPath();
  ctx.moveTo(-3, -28); ctx.lineTo(0, -34); ctx.lineTo(3, -28);
  ctx.lineTo(0, -26);
  ctx.closePath();
  ctx.fill();
  
  // White headband
  ctx.fillStyle = '#87CEEB';
  ctx.fillRect(-10, -22, 20, 3);
  ctx.beginPath();
  ctx.moveTo(10, -22); ctx.lineTo(16, -20 + Math.sin(frame * 0.1) * 2);
  ctx.lineTo(14, -18); ctx.lineTo(10, -19);
  ctx.fill();
  
  // Face - determined expression with glowing eyes
  ctx.fillStyle = '#00FFFF';
  ctx.beginPath(); ctx.ellipse(-4, -18, 1.5, 1.2, 0, 0, Math.PI * 2); ctx.fill();
  ctx.beginPath(); ctx.ellipse(4, -18, 1.5, 1.2, 0, 0, Math.PI * 2); ctx.fill();
  ctx.strokeStyle = '#4682B4';
  ctx.lineWidth = 1.5;
  ctx.beginPath();
  ctx.moveTo(-6, -21); ctx.lineTo(-2, -20);
  ctx.moveTo(6, -21); ctx.lineTo(2, -20);
  ctx.stroke();
  
  // Glow when attacking - frost chi energy on fists
  if (showGlow) {
    ctx.fillStyle = 'rgba(150, 220, 255, 0.6)';
    ctx.beginPath(); ctx.arc(-14, 9, 8, 0, Math.PI * 2); ctx.fill();
    ctx.beginPath(); ctx.arc(14, 9, 8, 0, Math.PI * 2); ctx.fill();
  }
  
  // Bo Staff - ice rod
  ctx.save();
  ctx.translate(16, 2);
  ctx.rotate(wAng + 0.3);
  ctx.fillStyle = '#4682B4';
  ctx.fillRect(-2, -22, 4, 44);
  ctx.fillStyle = '#E0FFFF';
  ctx.beginPath(); ctx.arc(0, -22, 5, 0, Math.PI * 2); ctx.fill();
  ctx.fillRect(-2.5, 18, 5, 4);
  ctx.restore();
}

// ============ RANGER SKIN DRAWING FUNCTIONS ============
// Performance: ~15-20 draw calls per skin, <1ms render time

function drawRangerSkin(ctx, skinId, wAng, showGlow) {
  switch(skinId) {
    case 'nature': drawNatureRanger(ctx, wAng, showGlow); break;
    case 'lightning': drawLightningRanger(ctx, wAng, showGlow); break;
    case 'fire': drawFireRanger(ctx, wAng, showGlow); break;
    case 'frost': drawFrostRanger(ctx, wAng, showGlow); break;
    default: drawDefaultRanger(ctx, wAng, showGlow);
  }
}

function drawDefaultRanger(ctx, wAng, showGlow) {
  const breathe = Math.sin(frame * 0.05) * 0.5;
  const legMove = player.state === 'moving' ? Math.sin(frame * 0.15) * 2.5 : 0;
  
  // Shadow
  ctx.fillStyle = 'rgba(0,0,0,0.4)';
  ctx.beginPath();
  ctx.ellipse(0, 18, 12, 4, 0, 0, Math.PI * 2);
  ctx.fill();
  
  // Legs - lean and agile
  ctx.fillStyle = '#4a5040';
  ctx.fillRect(-6, 6, 4, 11 + legMove);
  ctx.fillRect(2, 6, 4, 11 - legMove);
  
  // Boots - leather
  ctx.fillStyle = '#3a3020';
  ctx.fillRect(-7, 15 + legMove, 5, 3);
  ctx.fillRect(2, 15 - legMove, 5, 3);
  
  // Cloak/Cape - forest green
  ctx.fillStyle = '#2a4020';
  ctx.beginPath();
  ctx.moveTo(-8, -4); ctx.lineTo(-12, 16); ctx.lineTo(-4, 18);
  ctx.lineTo(4, 18); ctx.lineTo(12, 16); ctx.lineTo(8, -4);
  ctx.closePath();
  ctx.fill();
  
  // Body - leather armor
  ctx.fillStyle = '#5a4a35';
  ctx.beginPath();
  ctx.ellipse(0, -2 + breathe, 9, 10, 0, 0, Math.PI * 2);
  ctx.fill();
  
  // Belt with pouches
  ctx.fillStyle = '#3a3020';
  ctx.fillRect(-10, 4, 20, 3);
  ctx.fillStyle = '#4a4030';
  ctx.fillRect(-8, 3, 4, 5);
  ctx.fillRect(4, 3, 4, 5);
  
  // Shoulders - light padding
  ctx.fillStyle = '#4a5040';
  ctx.beginPath(); ctx.ellipse(-9, -4, 3, 4, 0.3, 0, Math.PI * 2); ctx.fill();
  ctx.beginPath(); ctx.ellipse(9, -4, 3, 4, -0.3, 0, Math.PI * 2); ctx.fill();
  
  // Arms - slender
  ctx.fillStyle = '#5a4a35';
  ctx.fillRect(-12, -5, 4, 9);
  ctx.fillRect(8, -5, 4, 9);
  
  // Gloves
  ctx.fillStyle = '#3a3020';
  ctx.beginPath(); ctx.arc(-10, 5, 3, 0, Math.PI * 2); ctx.fill();
  ctx.beginPath(); ctx.arc(10, 5, 3, 0, Math.PI * 2); ctx.fill();
  
  // Hood
  ctx.fillStyle = '#2a4020';
  ctx.beginPath();
  ctx.arc(0, -16, 11, Math.PI, 0, false);
  ctx.lineTo(8, -8);
  ctx.lineTo(-8, -8);
  ctx.closePath();
  ctx.fill();
  
  // Face in shadow
  ctx.fillStyle = '#6a5a45';
  ctx.beginPath(); ctx.arc(0, -16, 8, 0, Math.PI * 2); ctx.fill();
  
  // Eyes - sharp
  ctx.fillStyle = '#1a1a10';
  ctx.beginPath(); ctx.ellipse(-3, -16, 1.2, 0.8, -0.2, 0, Math.PI * 2); ctx.fill();
  ctx.beginPath(); ctx.ellipse(3, -16, 1.2, 0.8, 0.2, 0, Math.PI * 2); ctx.fill();
  
  // Quiver on back - larger
  ctx.fillStyle = '#4a3020';
  ctx.fillRect(4, -12, 6, 18);
  ctx.fillStyle = '#3a2015';
  ctx.fillRect(4, -12, 6, 2); // Top rim
  ctx.fillStyle = '#8a7050';
  // Arrow feathers sticking out
  ctx.fillRect(5, -15, 1.5, 5);
  ctx.fillRect(7, -14, 1.5, 4);
  ctx.fillRect(9, -15, 1.5, 5);
  
  // Bow - held in right hand (smaller)
  ctx.save();
  ctx.translate(10, 0);
  ctx.rotate(-wAng * 0.3);
  // Bow limbs - curve away from body
  ctx.strokeStyle = '#5a4020';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.arc(-5, 0, 11, -Math.PI * 0.45, Math.PI * 0.45, false);
  ctx.stroke();
  // Bowstring
  ctx.strokeStyle = '#aaa';
  ctx.lineWidth = 1;
  const stringPull = showGlow ? 4 : 0;
  ctx.beginPath();
  ctx.moveTo(-5 + Math.cos(-Math.PI * 0.45) * 11, Math.sin(-Math.PI * 0.45) * 11);
  ctx.lineTo(-5 + stringPull, 0);
  ctx.lineTo(-5 + Math.cos(Math.PI * 0.45) * 11, Math.sin(Math.PI * 0.45) * 11);
  ctx.stroke();
  // Arrow when attacking
  if (showGlow) {
    ctx.fillStyle = '#8a7050';
    ctx.fillRect(-10, -1, 10, 2);
    ctx.fillStyle = '#888';
    ctx.beginPath();
    ctx.moveTo(-12, 0); ctx.lineTo(-9, -2); ctx.lineTo(-9, 2);
    ctx.closePath();
    ctx.fill();
  }
  ctx.restore();
}

function drawFireRanger(ctx, wAng, showGlow) {
  const breathe = Math.sin(frame * 0.05) * 0.5;
  const legMove = player.state === 'moving' ? Math.sin(frame * 0.15) * 2.5 : 0;
  
  // Shadow with ember glow
  ctx.fillStyle = 'rgba(60,20,0,0.5)';
  ctx.beginPath();
  ctx.ellipse(0, 18, 12, 4, 0, 0, Math.PI * 2);
  ctx.fill();
  
  // Legs
  ctx.fillStyle = '#5a2010';
  ctx.fillRect(-6, 6, 4, 11 + legMove);
  ctx.fillRect(2, 6, 4, 11 - legMove);
  
  // Boots
  ctx.fillStyle = '#3a1008';
  ctx.fillRect(-7, 15 + legMove, 5, 3);
  ctx.fillRect(2, 15 - legMove, 5, 3);
  
  // Cloak - ember red
  ctx.fillStyle = '#6a2010';
  ctx.beginPath();
  ctx.moveTo(-8, -4); ctx.lineTo(-12, 16); ctx.lineTo(-4, 18);
  ctx.lineTo(4, 18); ctx.lineTo(12, 16); ctx.lineTo(8, -4);
  ctx.closePath();
  ctx.fill();
  // Ember edge
  ctx.fillStyle = '#FF6600';
  ctx.beginPath();
  ctx.moveTo(-10, 14); ctx.lineTo(-12, 16); ctx.lineTo(-4, 18); ctx.lineTo(-6, 15);
  ctx.fill();
  ctx.beginPath();
  ctx.moveTo(10, 14); ctx.lineTo(12, 16); ctx.lineTo(4, 18); ctx.lineTo(6, 15);
  ctx.fill();
  
  // Body
  ctx.fillStyle = '#4a2515';
  ctx.beginPath();
  ctx.ellipse(0, -2 + breathe, 9, 10, 0, 0, Math.PI * 2);
  ctx.fill();
  
  // Fire emblem on chest
  ctx.fillStyle = '#FF6600';
  ctx.beginPath();
  ctx.moveTo(0, -6 + breathe); ctx.lineTo(-3, 2 + breathe);
  ctx.lineTo(0, -1 + breathe); ctx.lineTo(3, 2 + breathe);
  ctx.closePath();
  ctx.fill();
  
  // Belt
  ctx.fillStyle = '#3a1008';
  ctx.fillRect(-10, 4, 20, 3);
  
  // Shoulders
  ctx.fillStyle = '#5a2515';
  ctx.beginPath(); ctx.ellipse(-9, -4, 3, 4, 0.3, 0, Math.PI * 2); ctx.fill();
  ctx.beginPath(); ctx.ellipse(9, -4, 3, 4, -0.3, 0, Math.PI * 2); ctx.fill();
  ctx.fillStyle = '#FF6600';
  ctx.beginPath(); ctx.arc(-9, -6, 2, 0, Math.PI * 2); ctx.fill();
  ctx.beginPath(); ctx.arc(9, -6, 2, 0, Math.PI * 2); ctx.fill();
  
  // Arms
  ctx.fillStyle = '#4a2515';
  ctx.fillRect(-12, -5, 4, 9);
  ctx.fillRect(8, -5, 4, 9);
  
  // Gloves
  ctx.fillStyle = '#3a1008';
  ctx.beginPath(); ctx.arc(-10, 5, 3, 0, Math.PI * 2); ctx.fill();
  ctx.beginPath(); ctx.arc(10, 5, 3, 0, Math.PI * 2); ctx.fill();
  
  // Hood
  ctx.fillStyle = '#5a1810';
  ctx.beginPath();
  ctx.arc(0, -16, 11, Math.PI, 0, false);
  ctx.lineTo(8, -8);
  ctx.lineTo(-8, -8);
  ctx.closePath();
  ctx.fill();
  
  // Face
  ctx.fillStyle = '#7a5a40';
  ctx.beginPath(); ctx.arc(0, -16, 8, 0, Math.PI * 2); ctx.fill();
  
  // Glowing eyes
  ctx.fillStyle = showGlow ? '#FF8800' : '#FF6600';
  ctx.beginPath(); ctx.ellipse(-3, -16, 1.5, 1, -0.2, 0, Math.PI * 2); ctx.fill();
  ctx.beginPath(); ctx.ellipse(3, -16, 1.5, 1, 0.2, 0, Math.PI * 2); ctx.fill();
  
  // Quiver - larger with fire arrows
  ctx.fillStyle = '#4a2010';
  ctx.fillRect(4, -12, 6, 18);
  ctx.fillStyle = '#3a1008';
  ctx.fillRect(4, -12, 6, 2);
  ctx.fillStyle = '#FF6600';
  ctx.fillRect(5, -15, 1.5, 5);
  ctx.fillRect(7, -14, 1.5, 4);
  ctx.fillRect(9, -15, 1.5, 5);
  
  // Fire Bow - right side, smaller
  ctx.save();
  ctx.translate(10, 0);
  ctx.rotate(-wAng * 0.3);
  ctx.strokeStyle = '#8a3010';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.arc(-5, 0, 11, -Math.PI * 0.45, Math.PI * 0.45, false);
  ctx.stroke();
  // Flame accents
  ctx.fillStyle = '#FF6600';
  ctx.beginPath(); ctx.arc(-5 + Math.cos(-Math.PI * 0.45) * 11, Math.sin(-Math.PI * 0.45) * 11, 2, 0, Math.PI * 2); ctx.fill();
  ctx.beginPath(); ctx.arc(-5 + Math.cos(Math.PI * 0.45) * 11, Math.sin(Math.PI * 0.45) * 11, 2, 0, Math.PI * 2); ctx.fill();
  ctx.strokeStyle = '#FF8844';
  ctx.lineWidth = 1;
  const stringPull = showGlow ? 4 : 0;
  ctx.beginPath();
  ctx.moveTo(-5 + Math.cos(-Math.PI * 0.45) * 11, Math.sin(-Math.PI * 0.45) * 11);
  ctx.lineTo(-5 + stringPull, 0);
  ctx.lineTo(-5 + Math.cos(Math.PI * 0.45) * 11, Math.sin(Math.PI * 0.45) * 11);
  ctx.stroke();
  if (showGlow) {
    ctx.fillStyle = '#FF4400';
    ctx.fillRect(-10, -1, 10, 2);
    ctx.beginPath();
    ctx.moveTo(-12, 0); ctx.lineTo(-9, -2); ctx.lineTo(-9, 2);
    ctx.closePath();
    ctx.fill();
  }
  ctx.restore();
}

function drawFrostRanger(ctx, wAng, showGlow) {
  const breathe = Math.sin(frame * 0.05) * 0.5;
  const legMove = player.state === 'moving' ? Math.sin(frame * 0.15) * 2.5 : 0;
  
  // Shadow with frost
  ctx.fillStyle = 'rgba(40,60,80,0.4)';
  ctx.beginPath();
  ctx.ellipse(0, 18, 12, 4, 0, 0, Math.PI * 2);
  ctx.fill();
  
  // Legs
  ctx.fillStyle = '#4a6080';
  ctx.fillRect(-6, 6, 4, 11 + legMove);
  ctx.fillRect(2, 6, 4, 11 - legMove);
  
  // Boots - fur-lined
  ctx.fillStyle = '#3a5070';
  ctx.fillRect(-7, 15 + legMove, 5, 3);
  ctx.fillRect(2, 15 - legMove, 5, 3);
  ctx.fillStyle = '#DDEEFF';
  ctx.fillRect(-7, 14 + legMove, 5, 2);
  ctx.fillRect(2, 14 - legMove, 5, 2);
  
  // Cloak - ice blue
  ctx.fillStyle = '#3a5a80';
  ctx.beginPath();
  ctx.moveTo(-8, -4); ctx.lineTo(-12, 16); ctx.lineTo(-4, 18);
  ctx.lineTo(4, 18); ctx.lineTo(12, 16); ctx.lineTo(8, -4);
  ctx.closePath();
  ctx.fill();
  // Frost edge
  ctx.fillStyle = '#88CCFF';
  ctx.beginPath();
  ctx.moveTo(-11, 15); ctx.lineTo(-10, 17); ctx.lineTo(-6, 17); ctx.lineTo(-7, 14);
  ctx.fill();
  ctx.beginPath();
  ctx.moveTo(11, 15); ctx.lineTo(10, 17); ctx.lineTo(6, 17); ctx.lineTo(7, 14);
  ctx.fill();
  
  // Body
  ctx.fillStyle = '#4a6a8a';
  ctx.beginPath();
  ctx.ellipse(0, -2 + breathe, 9, 10, 0, 0, Math.PI * 2);
  ctx.fill();
  
  // Snowflake emblem
  ctx.fillStyle = '#AADDFF';
  ctx.fillRect(-1, -6 + breathe, 2, 8);
  ctx.fillRect(-4, -3 + breathe, 8, 2);
  
  // Belt
  ctx.fillStyle = '#3a5070';
  ctx.fillRect(-10, 4, 20, 3);
  
  // Shoulders with fur
  ctx.fillStyle = '#4a6a8a';
  ctx.beginPath(); ctx.ellipse(-9, -4, 3, 4, 0.3, 0, Math.PI * 2); ctx.fill();
  ctx.beginPath(); ctx.ellipse(9, -4, 3, 4, -0.3, 0, Math.PI * 2); ctx.fill();
  ctx.fillStyle = '#DDEEFF';
  ctx.beginPath(); ctx.ellipse(-9, -6, 4, 2, 0, 0, Math.PI * 2); ctx.fill();
  ctx.beginPath(); ctx.ellipse(9, -6, 4, 2, 0, 0, Math.PI * 2); ctx.fill();
  
  // Arms
  ctx.fillStyle = '#4a6a8a';
  ctx.fillRect(-12, -5, 4, 9);
  ctx.fillRect(8, -5, 4, 9);
  
  // Gloves
  ctx.fillStyle = '#3a5070';
  ctx.beginPath(); ctx.arc(-10, 5, 3, 0, Math.PI * 2); ctx.fill();
  ctx.beginPath(); ctx.arc(10, 5, 3, 0, Math.PI * 2); ctx.fill();
  
  // Hood with fur trim
  ctx.fillStyle = '#3a5a80';
  ctx.beginPath();
  ctx.arc(0, -16, 11, Math.PI, 0, false);
  ctx.lineTo(8, -8);
  ctx.lineTo(-8, -8);
  ctx.closePath();
  ctx.fill();
  ctx.fillStyle = '#DDEEFF';
  ctx.beginPath();
  ctx.arc(0, -16, 11, Math.PI * 0.85, Math.PI * 0.15, true);
  ctx.lineTo(6, -10);
  ctx.lineTo(-6, -10);
  ctx.closePath();
  ctx.fill();
  
  // Face
  ctx.fillStyle = '#8a9aaa';
  ctx.beginPath(); ctx.arc(0, -16, 8, 0, Math.PI * 2); ctx.fill();
  
  // Ice eyes
  ctx.fillStyle = '#00CCFF';
  ctx.beginPath(); ctx.ellipse(-3, -16, 1.5, 1, -0.2, 0, Math.PI * 2); ctx.fill();
  ctx.beginPath(); ctx.ellipse(3, -16, 1.5, 1, 0.2, 0, Math.PI * 2); ctx.fill();
  
  // Quiver - larger with ice arrows
  ctx.fillStyle = '#3a5070';
  ctx.fillRect(4, -12, 6, 18);
  ctx.fillStyle = '#2a4060';
  ctx.fillRect(4, -12, 6, 2);
  ctx.fillStyle = '#88CCFF';
  ctx.fillRect(5, -15, 1.5, 5);
  ctx.fillRect(7, -14, 1.5, 4);
  ctx.fillRect(9, -15, 1.5, 5);
  
  // Ice Bow - right side, smaller
  ctx.save();
  ctx.translate(10, 0);
  ctx.rotate(-wAng * 0.3);
  ctx.strokeStyle = '#4a7a9a';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.arc(-5, 0, 11, -Math.PI * 0.45, Math.PI * 0.45, false);
  ctx.stroke();
  ctx.fillStyle = '#88DDFF';
  ctx.beginPath(); ctx.arc(-5 + Math.cos(-Math.PI * 0.45) * 11, Math.sin(-Math.PI * 0.45) * 11, 2, 0, Math.PI * 2); ctx.fill();
  ctx.beginPath(); ctx.arc(-5 + Math.cos(Math.PI * 0.45) * 11, Math.sin(Math.PI * 0.45) * 11, 2, 0, Math.PI * 2); ctx.fill();
  ctx.strokeStyle = '#AAEEFF';
  ctx.lineWidth = 1;
  const stringPull = showGlow ? 4 : 0;
  ctx.beginPath();
  ctx.moveTo(-5 + Math.cos(-Math.PI * 0.45) * 11, Math.sin(-Math.PI * 0.45) * 11);
  ctx.lineTo(-5 + stringPull, 0);
  ctx.lineTo(-5 + Math.cos(Math.PI * 0.45) * 11, Math.sin(Math.PI * 0.45) * 11);
  ctx.stroke();
  if (showGlow) {
    ctx.fillStyle = '#00CCFF';
    ctx.fillRect(-10, -1, 10, 2);
    ctx.beginPath();
    ctx.moveTo(-12, 0); ctx.lineTo(-9, -2); ctx.lineTo(-9, 2);
    ctx.closePath();
    ctx.fill();
  }
  ctx.restore();
}

function drawLightningRanger(ctx, wAng, showGlow) {
  const breathe = Math.sin(frame * 0.05) * 0.5;
  const legMove = player.state === 'moving' ? Math.sin(frame * 0.15) * 2.5 : 0;
  
  // Shadow
  ctx.fillStyle = 'rgba(40,30,60,0.4)';
  ctx.beginPath();
  ctx.ellipse(0, 18, 12, 4, 0, 0, Math.PI * 2);
  ctx.fill();
  
  // Legs
  ctx.fillStyle = '#4a4060';
  ctx.fillRect(-6, 6, 4, 11 + legMove);
  ctx.fillRect(2, 6, 4, 11 - legMove);
  
  // Boots
  ctx.fillStyle = '#3a3050';
  ctx.fillRect(-7, 15 + legMove, 5, 3);
  ctx.fillRect(2, 15 - legMove, 5, 3);
  
  // Cloak - storm purple
  ctx.fillStyle = '#4a3a6a';
  ctx.beginPath();
  ctx.moveTo(-8, -4); ctx.lineTo(-12, 16); ctx.lineTo(-4, 18);
  ctx.lineTo(4, 18); ctx.lineTo(12, 16); ctx.lineTo(8, -4);
  ctx.closePath();
  ctx.fill();
  // Lightning edge
  ctx.fillStyle = '#FFDD00';
  ctx.beginPath();
  ctx.moveTo(-10, 12); ctx.lineTo(-8, 16); ctx.lineTo(-6, 12); ctx.lineTo(-4, 17);
  ctx.stroke();
  
  // Body
  ctx.fillStyle = '#5a4a7a';
  ctx.beginPath();
  ctx.ellipse(0, -2 + breathe, 9, 10, 0, 0, Math.PI * 2);
  ctx.fill();
  
  // Lightning bolt emblem
  ctx.fillStyle = '#FFDD00';
  ctx.beginPath();
  ctx.moveTo(2, -7 + breathe); ctx.lineTo(-2, -1 + breathe);
  ctx.lineTo(0, -1 + breathe); ctx.lineTo(-2, 4 + breathe);
  ctx.lineTo(2, -2 + breathe); ctx.lineTo(0, -2 + breathe);
  ctx.closePath();
  ctx.fill();
  
  // Belt
  ctx.fillStyle = '#3a3050';
  ctx.fillRect(-10, 4, 20, 3);
  ctx.fillStyle = '#FFDD00';
  ctx.fillRect(-2, 4, 4, 3);
  
  // Shoulders
  ctx.fillStyle = '#5a4a7a';
  ctx.beginPath(); ctx.ellipse(-9, -4, 3, 4, 0.3, 0, Math.PI * 2); ctx.fill();
  ctx.beginPath(); ctx.ellipse(9, -4, 3, 4, -0.3, 0, Math.PI * 2); ctx.fill();
  ctx.fillStyle = '#FFDD00';
  ctx.beginPath(); ctx.arc(-9, -6, 2, 0, Math.PI * 2); ctx.fill();
  ctx.beginPath(); ctx.arc(9, -6, 2, 0, Math.PI * 2); ctx.fill();
  
  // Arms
  ctx.fillStyle = '#5a4a7a';
  ctx.fillRect(-12, -5, 4, 9);
  ctx.fillRect(8, -5, 4, 9);
  
  // Gloves
  ctx.fillStyle = '#3a3050';
  ctx.beginPath(); ctx.arc(-10, 5, 3, 0, Math.PI * 2); ctx.fill();
  ctx.beginPath(); ctx.arc(10, 5, 3, 0, Math.PI * 2); ctx.fill();
  
  // Hood
  ctx.fillStyle = '#4a3a6a';
  ctx.beginPath();
  ctx.arc(0, -16, 11, Math.PI, 0, false);
  ctx.lineTo(8, -8);
  ctx.lineTo(-8, -8);
  ctx.closePath();
  ctx.fill();
  
  // Face
  ctx.fillStyle = '#7a6a8a';
  ctx.beginPath(); ctx.arc(0, -16, 8, 0, Math.PI * 2); ctx.fill();
  
  // Electric eyes
  ctx.fillStyle = showGlow ? '#FFFF00' : '#FFDD00';
  ctx.beginPath(); ctx.ellipse(-3, -16, 1.5, 1, -0.2, 0, Math.PI * 2); ctx.fill();
  ctx.beginPath(); ctx.ellipse(3, -16, 1.5, 1, 0.2, 0, Math.PI * 2); ctx.fill();
  
  // Quiver - larger with lightning arrows
  ctx.fillStyle = '#4a3a5a';
  ctx.fillRect(4, -12, 6, 18);
  ctx.fillStyle = '#3a2a4a';
  ctx.fillRect(4, -12, 6, 2);
  ctx.fillStyle = '#FFDD00';
  ctx.fillRect(5, -15, 1.5, 5);
  ctx.fillRect(7, -14, 1.5, 4);
  ctx.fillRect(9, -15, 1.5, 5);
  
  // Lightning Bow - right side, smaller
  ctx.save();
  ctx.translate(10, 0);
  ctx.rotate(-wAng * 0.3);
  ctx.strokeStyle = '#6a5a8a';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.arc(-5, 0, 11, -Math.PI * 0.45, Math.PI * 0.45, false);
  ctx.stroke();
  ctx.fillStyle = '#FFDD00';
  ctx.beginPath(); ctx.arc(-5 + Math.cos(-Math.PI * 0.45) * 11, Math.sin(-Math.PI * 0.45) * 11, 2, 0, Math.PI * 2); ctx.fill();
  ctx.beginPath(); ctx.arc(-5 + Math.cos(Math.PI * 0.45) * 11, Math.sin(Math.PI * 0.45) * 11, 2, 0, Math.PI * 2); ctx.fill();
  ctx.strokeStyle = '#FFFF88';
  ctx.lineWidth = 1;
  const stringPull = showGlow ? 4 : 0;
  ctx.beginPath();
  ctx.moveTo(-5 + Math.cos(-Math.PI * 0.45) * 11, Math.sin(-Math.PI * 0.45) * 11);
  ctx.lineTo(-5 + stringPull, 0);
  ctx.lineTo(-5 + Math.cos(Math.PI * 0.45) * 11, Math.sin(Math.PI * 0.45) * 11);
  ctx.stroke();
  if (showGlow) {
    ctx.fillStyle = '#FFFF00';
    ctx.fillRect(-10, -1, 10, 2);
    ctx.beginPath();
    ctx.moveTo(-12, 0); ctx.lineTo(-9, -2); ctx.lineTo(-9, 2);
    ctx.closePath();
    ctx.fill();
  }
  ctx.restore();
}

function drawNatureRanger(ctx, wAng, showGlow) {
  const breathe = Math.sin(frame * 0.05) * 0.5;
  const legMove = player.state === 'moving' ? Math.sin(frame * 0.15) * 2.5 : 0;
  
  // Shadow
  ctx.fillStyle = 'rgba(20,50,20,0.4)';
  ctx.beginPath();
  ctx.ellipse(0, 18, 12, 4, 0, 0, Math.PI * 2);
  ctx.fill();
  
  // Legs - bark brown
  ctx.fillStyle = '#4a5030';
  ctx.fillRect(-6, 6, 4, 11 + legMove);
  ctx.fillRect(2, 6, 4, 11 - legMove);
  
  // Boots - leaf wrapped
  ctx.fillStyle = '#3a4020';
  ctx.fillRect(-7, 15 + legMove, 5, 3);
  ctx.fillRect(2, 15 - legMove, 5, 3);
  ctx.fillStyle = '#5a8030';
  ctx.fillRect(-6, 14 + legMove, 3, 2);
  ctx.fillRect(3, 14 - legMove, 3, 2);
  
  // Cloak - forest
  ctx.fillStyle = '#2a5020';
  ctx.beginPath();
  ctx.moveTo(-8, -4); ctx.lineTo(-12, 16); ctx.lineTo(-4, 18);
  ctx.lineTo(4, 18); ctx.lineTo(12, 16); ctx.lineTo(8, -4);
  ctx.closePath();
  ctx.fill();
  // Leaf trim
  ctx.fillStyle = '#4a8030';
  ctx.beginPath();
  ctx.moveTo(-10, 14); ctx.lineTo(-8, 17); ctx.lineTo(-6, 14); ctx.lineTo(-4, 17); ctx.lineTo(-2, 14);
  ctx.stroke();
  
  // Body
  ctx.fillStyle = '#4a6030';
  ctx.beginPath();
  ctx.ellipse(0, -2 + breathe, 9, 10, 0, 0, Math.PI * 2);
  ctx.fill();
  
  // Leaf emblem
  ctx.fillStyle = '#6aA040';
  ctx.beginPath();
  ctx.moveTo(0, -7 + breathe);
  ctx.quadraticCurveTo(5, -2 + breathe, 0, 4 + breathe);
  ctx.quadraticCurveTo(-5, -2 + breathe, 0, -7 + breathe);
  ctx.fill();
  ctx.strokeStyle = '#4a7020';
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(0, -6 + breathe); ctx.lineTo(0, 3 + breathe);
  ctx.stroke();
  
  // Belt
  ctx.fillStyle = '#3a4020';
  ctx.fillRect(-10, 4, 20, 3);
  
  // Shoulders with leaves
  ctx.fillStyle = '#4a6030';
  ctx.beginPath(); ctx.ellipse(-9, -4, 3, 4, 0.3, 0, Math.PI * 2); ctx.fill();
  ctx.beginPath(); ctx.ellipse(9, -4, 3, 4, -0.3, 0, Math.PI * 2); ctx.fill();
  ctx.fillStyle = '#5a9030';
  ctx.beginPath(); ctx.ellipse(-10, -7, 3, 2, -0.5, 0, Math.PI * 2); ctx.fill();
  ctx.beginPath(); ctx.ellipse(10, -7, 3, 2, 0.5, 0, Math.PI * 2); ctx.fill();
  
  // Arms
  ctx.fillStyle = '#4a6030';
  ctx.fillRect(-12, -5, 4, 9);
  ctx.fillRect(8, -5, 4, 9);
  
  // Gloves
  ctx.fillStyle = '#3a4020';
  ctx.beginPath(); ctx.arc(-10, 5, 3, 0, Math.PI * 2); ctx.fill();
  ctx.beginPath(); ctx.arc(10, 5, 3, 0, Math.PI * 2); ctx.fill();
  
  // Hood with antler hints
  ctx.fillStyle = '#2a5020';
  ctx.beginPath();
  ctx.arc(0, -16, 11, Math.PI, 0, false);
  ctx.lineTo(8, -8);
  ctx.lineTo(-8, -8);
  ctx.closePath();
  ctx.fill();
  // Small antlers
  ctx.strokeStyle = '#5a4030';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(-6, -24); ctx.lineTo(-8, -28); ctx.lineTo(-10, -26);
  ctx.stroke();
  ctx.beginPath();
  ctx.moveTo(6, -24); ctx.lineTo(8, -28); ctx.lineTo(10, -26);
  ctx.stroke();
  
  // Face
  ctx.fillStyle = '#6a7a50';
  ctx.beginPath(); ctx.arc(0, -16, 8, 0, Math.PI * 2); ctx.fill();
  
  // Nature eyes
  ctx.fillStyle = showGlow ? '#88FF44' : '#66AA30';
  ctx.beginPath(); ctx.ellipse(-3, -16, 1.5, 1, -0.2, 0, Math.PI * 2); ctx.fill();
  ctx.beginPath(); ctx.ellipse(3, -16, 1.5, 1, 0.2, 0, Math.PI * 2); ctx.fill();
  
  // Quiver - larger with nature arrows
  ctx.fillStyle = '#4a4020';
  ctx.fillRect(4, -12, 6, 18);
  ctx.fillStyle = '#3a3015';
  ctx.fillRect(4, -12, 6, 2);
  ctx.fillStyle = '#5a9030';
  ctx.fillRect(5, -15, 1.5, 5);
  ctx.fillRect(7, -14, 1.5, 4);
  ctx.fillRect(9, -15, 1.5, 5);
  
  // Nature Bow - living wood, right side, smaller
  ctx.save();
  ctx.translate(10, 0);
  ctx.rotate(-wAng * 0.3);
  ctx.strokeStyle = '#5a4020';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.arc(-5, 0, 11, -Math.PI * 0.45, Math.PI * 0.45, false);
  ctx.stroke();
  // Vine wraps and leaves
  ctx.strokeStyle = '#4a8030';
  ctx.lineWidth = 1.5;
  const topY = Math.sin(-Math.PI * 0.45) * 11;
  const topX = -5 + Math.cos(-Math.PI * 0.45) * 11;
  const botY = Math.sin(Math.PI * 0.45) * 11;
  const botX = -5 + Math.cos(Math.PI * 0.45) * 11;
  ctx.beginPath();
  ctx.arc(topX, topY, 2, 0, Math.PI * 2);
  ctx.stroke();
  ctx.beginPath();
  ctx.arc(botX, botY, 2, 0, Math.PI * 2);
  ctx.stroke();
  ctx.fillStyle = '#6aA040';
  ctx.beginPath(); ctx.ellipse(topX - 1, topY, 2, 1.5, 0.3, 0, Math.PI * 2); ctx.fill();
  ctx.beginPath(); ctx.ellipse(botX - 1, botY, 2, 1.5, -0.3, 0, Math.PI * 2); ctx.fill();
  ctx.strokeStyle = '#8a8060';
  ctx.lineWidth = 1;
  const stringPull = showGlow ? 4 : 0;
  ctx.beginPath();
  ctx.moveTo(topX, topY);
  ctx.lineTo(-5 + stringPull, 0);
  ctx.lineTo(botX, botY);
  ctx.stroke();
  if (showGlow) {
    ctx.fillStyle = '#88CC44';
    ctx.fillRect(-10, -1, 10, 2);
    ctx.beginPath();
    ctx.moveTo(-12, 0); ctx.lineTo(-9, -2); ctx.lineTo(-9, 2);
    ctx.closePath();
    ctx.fill();
  }
  ctx.restore();
}

// ============ MAGE SKIN DRAWING FUNCTIONS ============
// Performance: ~18-22 draw calls per skin, <1ms render time

function drawMageSkin(ctx, skinId, wAng, showGlow) {
  switch(skinId) {
    case 'nature': drawNatureMage(ctx, wAng, showGlow); break;
    case 'lightning': drawLightningMage(ctx, wAng, showGlow); break;
    case 'fire': drawFireMage(ctx, wAng, showGlow); break;
    case 'frost': drawFrostMage(ctx, wAng, showGlow); break;
    default: drawDefaultMage(ctx, wAng, showGlow);
  }
}

function drawDefaultMage(ctx, wAng, showGlow) {
  const breathe = Math.sin(frame * 0.05) * 0.5;
  const legMove = player.state === 'moving' ? Math.sin(frame * 0.15) * 2 : 0;
  
  // Shadow
  ctx.fillStyle = 'rgba(20,10,40,0.4)';
  ctx.beginPath();
  ctx.ellipse(0, 18, 14, 5, 0, 0, Math.PI * 2);
  ctx.fill();
  
  // Long robe base
  ctx.fillStyle = '#3a2050';
  ctx.beginPath();
  ctx.moveTo(-10, 0); ctx.lineTo(-14, 18); ctx.lineTo(14, 18); ctx.lineTo(10, 0);
  ctx.closePath();
  ctx.fill();
  
  // Robe movement
  ctx.fillStyle = '#4a3060';
  ctx.beginPath();
  ctx.moveTo(-12, 12 + legMove); ctx.lineTo(-14, 18); ctx.lineTo(-8, 18);
  ctx.fill();
  ctx.beginPath();
  ctx.moveTo(12, 12 - legMove); ctx.lineTo(14, 18); ctx.lineTo(8, 18);
  ctx.fill();
  
  // Body
  ctx.fillStyle = '#4a3060';
  ctx.beginPath();
  ctx.ellipse(0, -2 + breathe, 10, 11, 0, 0, Math.PI * 2);
  ctx.fill();
  
  // Arcane symbol on chest
  ctx.strokeStyle = '#9966CC';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.arc(0, -2 + breathe, 5, 0, Math.PI * 2);
  ctx.stroke();
  ctx.beginPath();
  ctx.moveTo(0, -7 + breathe); ctx.lineTo(0, 3 + breathe);
  ctx.moveTo(-5, -2 + breathe); ctx.lineTo(5, -2 + breathe);
  ctx.stroke();
  
  // Shoulders - pauldrons
  ctx.fillStyle = '#5a4070';
  ctx.beginPath(); ctx.ellipse(-11, -4, 4, 5, 0.3, 0, Math.PI * 2); ctx.fill();
  ctx.beginPath(); ctx.ellipse(11, -4, 4, 5, -0.3, 0, Math.PI * 2); ctx.fill();
  
  // Arms
  ctx.fillStyle = '#4a3060';
  ctx.fillRect(-14, -5, 4, 10);
  ctx.fillRect(10, -5, 4, 10);
  
  // Hands
  ctx.fillStyle = '#8a7a9a';
  ctx.beginPath(); ctx.arc(-12, 6, 3, 0, Math.PI * 2); ctx.fill();
  ctx.beginPath(); ctx.arc(12, 6, 3, 0, Math.PI * 2); ctx.fill();
  
  // Head
  ctx.fillStyle = '#8a7a9a';
  ctx.beginPath(); ctx.arc(0, -18, 9, 0, Math.PI * 2); ctx.fill();
  
  // Wizard hat
  ctx.fillStyle = '#3a2050';
  ctx.beginPath();
  ctx.moveTo(-10, -20); ctx.lineTo(0, -38); ctx.lineTo(10, -20);
  ctx.quadraticCurveTo(8, -18, 0, -16);
  ctx.quadraticCurveTo(-8, -18, -10, -20);
  ctx.fill();
  // Hat band
  ctx.fillStyle = '#9966CC';
  ctx.fillRect(-9, -21, 18, 2);
  
  // Eyes
  ctx.fillStyle = showGlow ? '#CC99FF' : '#9966CC';
  ctx.beginPath(); ctx.ellipse(-3, -18, 1.5, 1.2, 0, 0, Math.PI * 2); ctx.fill();
  ctx.beginPath(); ctx.ellipse(3, -18, 1.5, 1.2, 0, 0, Math.PI * 2); ctx.fill();
  
  // Staff
  ctx.save();
  ctx.translate(14, -2);
  ctx.rotate(wAng);
  ctx.fillStyle = '#5a4030';
  ctx.fillRect(-2, -30, 4, 42);
  // Crystal on top
  ctx.fillStyle = '#9966CC';
  ctx.beginPath();
  ctx.moveTo(0, -36); ctx.lineTo(-4, -30); ctx.lineTo(0, -28); ctx.lineTo(4, -30);
  ctx.closePath();
  ctx.fill();
  if (showGlow) {
    ctx.fillStyle = 'rgba(150,100,200,0.5)';
    ctx.beginPath(); ctx.arc(0, -22, 8, 0, Math.PI * 2); ctx.fill();
  }
  ctx.restore();
}

function drawFireMage(ctx, wAng, showGlow) {
  const breathe = Math.sin(frame * 0.05) * 0.5;
  const legMove = player.state === 'moving' ? Math.sin(frame * 0.15) * 2 : 0;
  
  // Shadow
  ctx.fillStyle = 'rgba(50,20,0,0.4)';
  ctx.beginPath();
  ctx.ellipse(0, 18, 14, 5, 0, 0, Math.PI * 2);
  ctx.fill();
  
  // Long robe - crimson
  ctx.fillStyle = '#6a1010';
  ctx.beginPath();
  ctx.moveTo(-10, 0); ctx.lineTo(-14, 18); ctx.lineTo(14, 18); ctx.lineTo(10, 0);
  ctx.closePath();
  ctx.fill();
  // Flame hem
  ctx.fillStyle = '#FF6600';
  ctx.beginPath();
  ctx.moveTo(-14, 18); ctx.lineTo(-12, 14); ctx.lineTo(-10, 18);
  ctx.lineTo(-8, 14); ctx.lineTo(-6, 18); ctx.lineTo(-4, 14);
  ctx.lineTo(-2, 18); ctx.lineTo(0, 14); ctx.lineTo(2, 18);
  ctx.lineTo(4, 14); ctx.lineTo(6, 18); ctx.lineTo(8, 14);
  ctx.lineTo(10, 18); ctx.lineTo(12, 14); ctx.lineTo(14, 18);
  ctx.closePath();
  ctx.fill();
  
  // Body
  ctx.fillStyle = '#5a1515';
  ctx.beginPath();
  ctx.ellipse(0, -2 + breathe, 10, 11, 0, 0, Math.PI * 2);
  ctx.fill();
  
  // Fire symbol
  ctx.fillStyle = '#FF6600';
  ctx.beginPath();
  ctx.moveTo(0, -8 + breathe);
  ctx.quadraticCurveTo(4, -4 + breathe, 2, 2 + breathe);
  ctx.quadraticCurveTo(0, 0 + breathe, -2, 2 + breathe);
  ctx.quadraticCurveTo(-4, -4 + breathe, 0, -8 + breathe);
  ctx.fill();
  ctx.fillStyle = '#FFAA00';
  ctx.beginPath();
  ctx.moveTo(0, -5 + breathe);
  ctx.quadraticCurveTo(2, -2 + breathe, 1, 1 + breathe);
  ctx.quadraticCurveTo(0, 0 + breathe, -1, 1 + breathe);
  ctx.quadraticCurveTo(-2, -2 + breathe, 0, -5 + breathe);
  ctx.fill();
  
  // Shoulders
  ctx.fillStyle = '#6a2020';
  ctx.beginPath(); ctx.ellipse(-11, -4, 4, 5, 0.3, 0, Math.PI * 2); ctx.fill();
  ctx.beginPath(); ctx.ellipse(11, -4, 4, 5, -0.3, 0, Math.PI * 2); ctx.fill();
  ctx.fillStyle = '#FF6600';
  ctx.beginPath(); ctx.arc(-11, -7, 2, 0, Math.PI * 2); ctx.fill();
  ctx.beginPath(); ctx.arc(11, -7, 2, 0, Math.PI * 2); ctx.fill();
  
  // Arms
  ctx.fillStyle = '#5a1515';
  ctx.fillRect(-14, -5, 4, 10);
  ctx.fillRect(10, -5, 4, 10);
  
  // Hands
  ctx.fillStyle = '#8a6050';
  ctx.beginPath(); ctx.arc(-12, 6, 3, 0, Math.PI * 2); ctx.fill();
  ctx.beginPath(); ctx.arc(12, 6, 3, 0, Math.PI * 2); ctx.fill();
  
  // Head
  ctx.fillStyle = '#8a6050';
  ctx.beginPath(); ctx.arc(0, -18, 9, 0, Math.PI * 2); ctx.fill();
  
  // Fire crown/circlet
  ctx.fillStyle = '#FF6600';
  ctx.beginPath();
  ctx.moveTo(-7, -24); ctx.lineTo(-5, -28); ctx.lineTo(-3, -24);
  ctx.lineTo(-1, -30); ctx.lineTo(1, -24);
  ctx.lineTo(3, -28); ctx.lineTo(5, -24);
  ctx.lineTo(7, -26); ctx.lineTo(7, -22);
  ctx.lineTo(-7, -22);
  ctx.closePath();
  ctx.fill();
  
  // Eyes
  ctx.fillStyle = showGlow ? '#FFAA00' : '#FF6600';
  ctx.beginPath(); ctx.ellipse(-3, -18, 1.5, 1.2, 0, 0, Math.PI * 2); ctx.fill();
  ctx.beginPath(); ctx.ellipse(3, -18, 1.5, 1.2, 0, 0, Math.PI * 2); ctx.fill();
  
  // Fire Staff
  ctx.save();
  ctx.translate(14, -2);
  ctx.rotate(wAng);
  ctx.fillStyle = '#4a2010';
  ctx.fillRect(-2, -30, 4, 42);
  ctx.fillStyle = '#FF4400';
  ctx.beginPath();
  ctx.moveTo(0, -38); ctx.lineTo(-5, -30); ctx.lineTo(0, -26); ctx.lineTo(5, -30);
  ctx.closePath();
  ctx.fill();
  ctx.fillStyle = '#FFAA00';
  ctx.beginPath();
  ctx.moveTo(0, -36); ctx.lineTo(-3, -31); ctx.lineTo(0, -28); ctx.lineTo(3, -31);
  ctx.closePath();
  ctx.fill();
  if (showGlow) {
    ctx.fillStyle = 'rgba(255,100,0,0.4)';
    ctx.beginPath(); ctx.arc(0, -22, 10, 0, Math.PI * 2); ctx.fill();
  }
  ctx.restore();
}

function drawFrostMage(ctx, wAng, showGlow) {
  const breathe = Math.sin(frame * 0.05) * 0.5;
  const legMove = player.state === 'moving' ? Math.sin(frame * 0.15) * 2 : 0;
  
  // Shadow
  ctx.fillStyle = 'rgba(30,50,70,0.4)';
  ctx.beginPath();
  ctx.ellipse(0, 18, 14, 5, 0, 0, Math.PI * 2);
  ctx.fill();
  
  // Long robe - ice blue
  ctx.fillStyle = '#2a4a6a';
  ctx.beginPath();
  ctx.moveTo(-10, 0); ctx.lineTo(-14, 18); ctx.lineTo(14, 18); ctx.lineTo(10, 0);
  ctx.closePath();
  ctx.fill();
  // Frost edge
  ctx.fillStyle = '#88CCFF';
  ctx.fillRect(-14, 16, 28, 2);
  ctx.fillStyle = '#AAEEFF';
  ctx.beginPath();
  ctx.moveTo(-12, 16); ctx.lineTo(-11, 14); ctx.lineTo(-10, 16);
  ctx.moveTo(-6, 16); ctx.lineTo(-5, 13); ctx.lineTo(-4, 16);
  ctx.moveTo(0, 16); ctx.lineTo(1, 14); ctx.lineTo(2, 16);
  ctx.moveTo(6, 16); ctx.lineTo(7, 13); ctx.lineTo(8, 16);
  ctx.fill();
  
  // Body
  ctx.fillStyle = '#3a5a7a';
  ctx.beginPath();
  ctx.ellipse(0, -2 + breathe, 10, 11, 0, 0, Math.PI * 2);
  ctx.fill();
  
  // Snowflake symbol
  ctx.fillStyle = '#AAEEFF';
  ctx.fillRect(-1, -7 + breathe, 2, 10);
  ctx.fillRect(-5, -3 + breathe, 10, 2);
  ctx.save();
  ctx.translate(0, -2 + breathe);
  ctx.rotate(Math.PI / 4);
  ctx.fillRect(-1, -4, 2, 8);
  ctx.fillRect(-4, -1, 8, 2);
  ctx.restore();
  
  // Shoulders with ice crystals
  ctx.fillStyle = '#4a6a8a';
  ctx.beginPath(); ctx.ellipse(-11, -4, 4, 5, 0.3, 0, Math.PI * 2); ctx.fill();
  ctx.beginPath(); ctx.ellipse(11, -4, 4, 5, -0.3, 0, Math.PI * 2); ctx.fill();
  ctx.fillStyle = '#88CCFF';
  ctx.beginPath();
  ctx.moveTo(-13, -8); ctx.lineTo(-11, -4); ctx.lineTo(-9, -9);
  ctx.fill();
  ctx.beginPath();
  ctx.moveTo(13, -8); ctx.lineTo(11, -4); ctx.lineTo(9, -9);
  ctx.fill();
  
  // Arms
  ctx.fillStyle = '#3a5a7a';
  ctx.fillRect(-14, -5, 4, 10);
  ctx.fillRect(10, -5, 4, 10);
  
  // Hands
  ctx.fillStyle = '#8a9aaa';
  ctx.beginPath(); ctx.arc(-12, 6, 3, 0, Math.PI * 2); ctx.fill();
  ctx.beginPath(); ctx.arc(12, 6, 3, 0, Math.PI * 2); ctx.fill();
  
  // Head
  ctx.fillStyle = '#9aaaBA';
  ctx.beginPath(); ctx.arc(0, -18, 9, 0, Math.PI * 2); ctx.fill();
  
  // Ice crown
  ctx.fillStyle = '#88CCFF';
  ctx.beginPath();
  ctx.moveTo(-6, -24); ctx.lineTo(-4, -30); ctx.lineTo(-2, -24);
  ctx.lineTo(0, -28); ctx.lineTo(2, -24);
  ctx.lineTo(4, -30); ctx.lineTo(6, -24);
  ctx.lineTo(6, -22); ctx.lineTo(-6, -22);
  ctx.closePath();
  ctx.fill();
  ctx.fillStyle = '#AAEEFF';
  ctx.beginPath(); ctx.arc(0, -25, 2, 0, Math.PI * 2); ctx.fill();
  
  // Eyes
  ctx.fillStyle = showGlow ? '#AAEEFF' : '#88CCFF';
  ctx.beginPath(); ctx.ellipse(-3, -18, 1.5, 1.2, 0, 0, Math.PI * 2); ctx.fill();
  ctx.beginPath(); ctx.ellipse(3, -18, 1.5, 1.2, 0, 0, Math.PI * 2); ctx.fill();
  
  // Ice Staff
  ctx.save();
  ctx.translate(14, -2);
  ctx.rotate(wAng);
  ctx.fillStyle = '#4a6a8a';
  ctx.fillRect(-2, -30, 4, 42);
  ctx.fillStyle = '#88CCFF';
  ctx.beginPath();
  ctx.moveTo(0, -38); ctx.lineTo(-5, -30); ctx.lineTo(0, -26); ctx.lineTo(5, -30);
  ctx.closePath();
  ctx.fill();
  ctx.fillStyle = '#AAEEFF';
  ctx.beginPath(); ctx.arc(0, -22, 4, 0, Math.PI * 2); ctx.fill();
  if (showGlow) {
    ctx.fillStyle = 'rgba(150,220,255,0.4)';
    ctx.beginPath(); ctx.arc(0, -22, 10, 0, Math.PI * 2); ctx.fill();
  }
  ctx.restore();
}

function drawLightningMage(ctx, wAng, showGlow) {
  const breathe = Math.sin(frame * 0.05) * 0.5;
  const legMove = player.state === 'moving' ? Math.sin(frame * 0.15) * 2 : 0;
  
  // Shadow
  ctx.fillStyle = 'rgba(40,30,60,0.4)';
  ctx.beginPath();
  ctx.ellipse(0, 18, 14, 5, 0, 0, Math.PI * 2);
  ctx.fill();
  
  // Long robe - storm purple
  ctx.fillStyle = '#3a2a5a';
  ctx.beginPath();
  ctx.moveTo(-10, 0); ctx.lineTo(-14, 18); ctx.lineTo(14, 18); ctx.lineTo(10, 0);
  ctx.closePath();
  ctx.fill();
  // Lightning hem
  ctx.strokeStyle = '#FFDD00';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(-13, 17); ctx.lineTo(-10, 14); ctx.lineTo(-7, 17);
  ctx.lineTo(-4, 13); ctx.lineTo(-1, 17); ctx.lineTo(2, 14);
  ctx.lineTo(5, 17); ctx.lineTo(8, 13); ctx.lineTo(11, 17);
  ctx.stroke();
  
  // Body
  ctx.fillStyle = '#4a3a6a';
  ctx.beginPath();
  ctx.ellipse(0, -2 + breathe, 10, 11, 0, 0, Math.PI * 2);
  ctx.fill();
  
  // Lightning bolt symbol
  ctx.fillStyle = '#FFDD00';
  ctx.beginPath();
  ctx.moveTo(3, -8 + breathe); ctx.lineTo(-1, -2 + breathe);
  ctx.lineTo(1, -2 + breathe); ctx.lineTo(-3, 4 + breathe);
  ctx.lineTo(1, -1 + breathe); ctx.lineTo(-1, -1 + breathe);
  ctx.closePath();
  ctx.fill();
  
  // Shoulders
  ctx.fillStyle = '#5a4a7a';
  ctx.beginPath(); ctx.ellipse(-11, -4, 4, 5, 0.3, 0, Math.PI * 2); ctx.fill();
  ctx.beginPath(); ctx.ellipse(11, -4, 4, 5, -0.3, 0, Math.PI * 2); ctx.fill();
  ctx.fillStyle = '#FFDD00';
  ctx.beginPath(); ctx.arc(-11, -7, 2, 0, Math.PI * 2); ctx.fill();
  ctx.beginPath(); ctx.arc(11, -7, 2, 0, Math.PI * 2); ctx.fill();
  
  // Arms
  ctx.fillStyle = '#4a3a6a';
  ctx.fillRect(-14, -5, 4, 10);
  ctx.fillRect(10, -5, 4, 10);
  
  // Hands with spark
  ctx.fillStyle = '#8a7a9a';
  ctx.beginPath(); ctx.arc(-12, 6, 3, 0, Math.PI * 2); ctx.fill();
  ctx.beginPath(); ctx.arc(12, 6, 3, 0, Math.PI * 2); ctx.fill();
  
  // Head
  ctx.fillStyle = '#8a7a9a';
  ctx.beginPath(); ctx.arc(0, -18, 9, 0, Math.PI * 2); ctx.fill();
  
  // Storm crown
  ctx.fillStyle = '#FFDD00';
  ctx.beginPath();
  ctx.moveTo(-6, -24); ctx.lineTo(-4, -29); ctx.lineTo(-2, -24);
  ctx.lineTo(0, -31); ctx.lineTo(2, -24);
  ctx.lineTo(4, -29); ctx.lineTo(6, -24);
  ctx.lineTo(6, -22); ctx.lineTo(-6, -22);
  ctx.closePath();
  ctx.fill();
  
  // Eyes
  ctx.fillStyle = showGlow ? '#FFFF88' : '#FFDD00';
  ctx.beginPath(); ctx.ellipse(-3, -18, 1.5, 1.2, 0, 0, Math.PI * 2); ctx.fill();
  ctx.beginPath(); ctx.ellipse(3, -18, 1.5, 1.2, 0, 0, Math.PI * 2); ctx.fill();
  
  // Lightning Staff
  ctx.save();
  ctx.translate(14, -2);
  ctx.rotate(wAng);
  ctx.fillStyle = '#4a3a5a';
  ctx.fillRect(-2, -30, 4, 42);
  ctx.fillStyle = '#FFDD00';
  ctx.beginPath();
  ctx.moveTo(0, -36); ctx.lineTo(-4, -30); ctx.lineTo(4, -30);
  ctx.closePath();
  ctx.fill();
  ctx.beginPath(); ctx.arc(0, -22, 5, 0, Math.PI * 2); ctx.fill();
  if (showGlow) {
    ctx.strokeStyle = 'rgba(255,255,100,0.6)';
    ctx.lineWidth = 2;
    const ang = frame * 0.15;
    ctx.beginPath();
    ctx.moveTo(Math.cos(ang) * 8, -32 + Math.sin(ang) * 8);
    ctx.lineTo(Math.cos(ang + Math.PI) * 8, -32 + Math.sin(ang + Math.PI) * 8);
    ctx.stroke();
  }
  ctx.restore();
}

function drawNatureMage(ctx, wAng, showGlow) {
  const breathe = Math.sin(frame * 0.05) * 0.5;
  const legMove = player.state === 'moving' ? Math.sin(frame * 0.15) * 2 : 0;
  
  // Shadow
  ctx.fillStyle = 'rgba(20,50,20,0.4)';
  ctx.beginPath();
  ctx.ellipse(0, 18, 14, 5, 0, 0, Math.PI * 2);
  ctx.fill();
  
  // Long robe - forest green
  ctx.fillStyle = '#1a4020';
  ctx.beginPath();
  ctx.moveTo(-10, 0); ctx.lineTo(-14, 18); ctx.lineTo(14, 18); ctx.lineTo(10, 0);
  ctx.closePath();
  ctx.fill();
  // Leaf pattern hem
  ctx.fillStyle = '#4a8030';
  ctx.beginPath();
  ctx.moveTo(-12, 16); ctx.quadraticCurveTo(-10, 12, -8, 16);
  ctx.quadraticCurveTo(-6, 12, -4, 16);
  ctx.quadraticCurveTo(-2, 12, 0, 16);
  ctx.quadraticCurveTo(2, 12, 4, 16);
  ctx.quadraticCurveTo(6, 12, 8, 16);
  ctx.quadraticCurveTo(10, 12, 12, 16);
  ctx.lineTo(12, 18); ctx.lineTo(-12, 18);
  ctx.fill();
  
  // Body
  ctx.fillStyle = '#2a5030';
  ctx.beginPath();
  ctx.ellipse(0, -2 + breathe, 10, 11, 0, 0, Math.PI * 2);
  ctx.fill();
  
  // Tree of life symbol
  ctx.strokeStyle = '#6aA040';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(0, 4 + breathe); ctx.lineTo(0, -4 + breathe);
  ctx.moveTo(0, -2 + breathe); ctx.lineTo(-3, -5 + breathe);
  ctx.moveTo(0, -2 + breathe); ctx.lineTo(3, -5 + breathe);
  ctx.moveTo(0, -4 + breathe); ctx.lineTo(-2, -7 + breathe);
  ctx.moveTo(0, -4 + breathe); ctx.lineTo(2, -7 + breathe);
  ctx.stroke();
  ctx.fillStyle = '#88CC50';
  ctx.beginPath(); ctx.arc(0, -6 + breathe, 3, 0, Math.PI * 2); ctx.fill();
  
  // Shoulders with bark
  ctx.fillStyle = '#3a5a40';
  ctx.beginPath(); ctx.ellipse(-11, -4, 4, 5, 0.3, 0, Math.PI * 2); ctx.fill();
  ctx.beginPath(); ctx.ellipse(11, -4, 4, 5, -0.3, 0, Math.PI * 2); ctx.fill();
  ctx.fillStyle = '#5a9040';
  ctx.beginPath(); ctx.ellipse(-12, -7, 3, 2, -0.3, 0, Math.PI * 2); ctx.fill();
  ctx.beginPath(); ctx.ellipse(12, -7, 3, 2, 0.3, 0, Math.PI * 2); ctx.fill();
  
  // Arms
  ctx.fillStyle = '#2a5030';
  ctx.fillRect(-14, -5, 4, 10);
  ctx.fillRect(10, -5, 4, 10);
  
  // Hands
  ctx.fillStyle = '#7a8a60';
  ctx.beginPath(); ctx.arc(-12, 6, 3, 0, Math.PI * 2); ctx.fill();
  ctx.beginPath(); ctx.arc(12, 6, 3, 0, Math.PI * 2); ctx.fill();
  
  // Head
  ctx.fillStyle = '#7a8a60';
  ctx.beginPath(); ctx.arc(0, -18, 9, 0, Math.PI * 2); ctx.fill();
  
  // Leaf crown
  ctx.fillStyle = '#4a8030';
  ctx.beginPath();
  ctx.moveTo(-7, -23); ctx.quadraticCurveTo(-5, -28, -3, -23);
  ctx.quadraticCurveTo(-1, -30, 1, -23);
  ctx.quadraticCurveTo(3, -28, 5, -23);
  ctx.quadraticCurveTo(7, -26, 7, -21);
  ctx.lineTo(-7, -21);
  ctx.closePath();
  ctx.fill();
  ctx.fillStyle = '#6aA040';
  ctx.beginPath(); ctx.arc(0, -24, 2, 0, Math.PI * 2); ctx.fill();
  
  // Eyes
  ctx.fillStyle = showGlow ? '#AAFF66' : '#88CC44';
  ctx.beginPath(); ctx.ellipse(-3, -18, 1.5, 1.2, 0, 0, Math.PI * 2); ctx.fill();
  ctx.beginPath(); ctx.ellipse(3, -18, 1.5, 1.2, 0, 0, Math.PI * 2); ctx.fill();
  
  // Nature Staff - living wood
  ctx.save();
  ctx.translate(14, -2);
  ctx.rotate(wAng);
  ctx.fillStyle = '#5a4030';
  ctx.fillRect(-2, -30, 4, 42);
  // Vine wraps
  ctx.strokeStyle = '#4a8030';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.arc(0, -20, 4, 0, Math.PI);
  ctx.arc(0, -10, 4, Math.PI, 0);
  ctx.arc(0, 0, 4, 0, Math.PI);
  ctx.stroke();
  // Flower top
  ctx.fillStyle = '#88CC50';
  ctx.beginPath(); ctx.arc(0, -22, 6, 0, Math.PI * 2); ctx.fill();
  ctx.fillStyle = '#FFDD44';
  ctx.beginPath(); ctx.arc(0, -22, 3, 0, Math.PI * 2); ctx.fill();
  if (showGlow) {
    ctx.fillStyle = 'rgba(100,200,80,0.4)';
    ctx.beginPath(); ctx.arc(0, -22, 12, 0, Math.PI * 2); ctx.fill();
  }
  ctx.restore();
}

// ============ WARRIOR SKIN DRAWING FUNCTIONS ============
// Performance: ~18-22 draw calls per skin, <1ms render time

function drawWarriorSkin(ctx, skinId, wAng, showGlow) {
  switch(skinId) {
    case 'nature': drawNatureWarrior(ctx, wAng, showGlow); break;
    case 'lightning': drawLightningWarrior(ctx, wAng, showGlow); break;
    case 'fire': drawFireWarrior(ctx, wAng, showGlow); break;
    case 'frost': drawFrostWarrior(ctx, wAng, showGlow); break;
    default: drawDefaultWarrior(ctx, wAng, showGlow);
  }
}

function drawDefaultWarrior(ctx, wAng, showGlow) {
  const breathe = Math.sin(frame * 0.05) * 0.5;
  const legMove = player.state === 'moving' ? Math.sin(frame * 0.15) * 2.5 : 0;
  
  // Shadow
  ctx.fillStyle = 'rgba(30,30,30,0.4)';
  ctx.beginPath();
  ctx.ellipse(0, 18, 14, 5, 0, 0, Math.PI * 2);
  ctx.fill();
  
  // Legs - armored greaves
  ctx.fillStyle = '#555';
  ctx.fillRect(-7, 8 + legMove, 5, 12);
  ctx.fillRect(2, 8 - legMove, 5, 12);
  ctx.fillStyle = '#777';
  ctx.fillRect(-6, 10 + legMove, 3, 4);
  ctx.fillRect(3, 10 - legMove, 3, 4);
  
  // Body - plate armor
  ctx.fillStyle = '#666';
  ctx.beginPath();
  ctx.moveTo(-12, 8);
  ctx.lineTo(-10, -8 + breathe);
  ctx.lineTo(10, -8 + breathe);
  ctx.lineTo(12, 8);
  ctx.closePath();
  ctx.fill();
  
  // Chest plate detail
  ctx.fillStyle = '#888';
  ctx.beginPath();
  ctx.moveTo(-6, -6 + breathe);
  ctx.lineTo(0, -2 + breathe);
  ctx.lineTo(6, -6 + breathe);
  ctx.lineTo(4, 6);
  ctx.lineTo(-4, 6);
  ctx.closePath();
  ctx.fill();
  
  // Shoulder pauldrons
  ctx.fillStyle = '#555';
  ctx.beginPath(); ctx.arc(-11, -6, 6, 0, Math.PI * 2); ctx.fill();
  ctx.beginPath(); ctx.arc(11, -6, 6, 0, Math.PI * 2); ctx.fill();
  ctx.fillStyle = '#777';
  ctx.beginPath(); ctx.arc(-11, -6, 3, 0, Math.PI * 2); ctx.fill();
  ctx.beginPath(); ctx.arc(11, -6, 3, 0, Math.PI * 2); ctx.fill();
  
  // Helmet
  ctx.fillStyle = '#666';
  ctx.beginPath();
  ctx.arc(0, -16, 10, 0, Math.PI * 2);
  ctx.fill();
  // Visor
  ctx.fillStyle = '#444';
  ctx.fillRect(-7, -18, 14, 5);
  // Eye slits
  ctx.fillStyle = '#222';
  ctx.fillRect(-5, -17, 3, 2);
  ctx.fillRect(2, -17, 3, 2);
  // Helmet crest
  ctx.fillStyle = '#c41';
  ctx.beginPath();
  ctx.moveTo(0, -26);
  ctx.lineTo(-3, -20);
  ctx.lineTo(3, -20);
  ctx.closePath();
  ctx.fill();
  
  // Sword - on right side (no shield - removed from game)
  ctx.save();
  ctx.translate(12, -4);
  ctx.rotate(wAng * 0.6 + 0.3);
  // Blade
  ctx.fillStyle = '#aaa';
  ctx.beginPath();
  ctx.moveTo(0, 0);
  ctx.lineTo(3, -4);
  ctx.lineTo(2, -22);
  ctx.lineTo(0, -24);
  ctx.lineTo(-2, -22);
  ctx.lineTo(-3, -4);
  ctx.closePath();
  ctx.fill();
  // Guard
  ctx.fillStyle = '#654';
  ctx.fillRect(-5, -2, 10, 3);
  // Handle
  ctx.fillStyle = '#432';
  ctx.fillRect(-2, 0, 4, 8);
  // Pommel
  ctx.fillStyle = '#c41';
  ctx.beginPath(); ctx.arc(0, 9, 3, 0, Math.PI * 2); ctx.fill();
  if (showGlow) {
    ctx.strokeStyle = 'rgba(255,255,255,0.4)';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(0, -24);
    ctx.lineTo(0, -4);
    ctx.stroke();
  }
  ctx.restore();
}

function drawFireWarrior(ctx, wAng, showGlow) {
  const breathe = Math.sin(frame * 0.05) * 0.5;
  const legMove = player.state === 'moving' ? Math.sin(frame * 0.15) * 2.5 : 0;
  
  // Shadow
  ctx.fillStyle = 'rgba(50,20,10,0.4)';
  ctx.beginPath();
  ctx.ellipse(0, 18, 14, 5, 0, 0, Math.PI * 2);
  ctx.fill();
  
  // Legs - volcanic greaves
  ctx.fillStyle = '#4a2010';
  ctx.fillRect(-7, 8 + legMove, 5, 12);
  ctx.fillRect(2, 8 - legMove, 5, 12);
  ctx.fillStyle = '#FF6600';
  ctx.fillRect(-6, 14 + legMove, 3, 4);
  ctx.fillRect(3, 14 - legMove, 3, 4);
  
  // Body - volcanic plate
  ctx.fillStyle = '#5a2010';
  ctx.beginPath();
  ctx.moveTo(-12, 8);
  ctx.lineTo(-10, -8 + breathe);
  ctx.lineTo(10, -8 + breathe);
  ctx.lineTo(12, 8);
  ctx.closePath();
  ctx.fill();
  
  // Lava cracks
  ctx.strokeStyle = '#FF4400';
  ctx.lineWidth = 1.5;
  ctx.beginPath();
  ctx.moveTo(-4, -4);
  ctx.lineTo(-2, 2);
  ctx.lineTo(2, 0);
  ctx.lineTo(4, 4);
  ctx.stroke();
  
  // Shoulder pauldrons - fiery
  ctx.fillStyle = '#6a3010';
  ctx.beginPath(); ctx.arc(-11, -6, 6, 0, Math.PI * 2); ctx.fill();
  ctx.beginPath(); ctx.arc(11, -6, 6, 0, Math.PI * 2); ctx.fill();
  ctx.fillStyle = '#FF6600';
  ctx.beginPath(); ctx.arc(-11, -6, 3, 0, Math.PI * 2); ctx.fill();
  ctx.beginPath(); ctx.arc(11, -6, 3, 0, Math.PI * 2); ctx.fill();
  
  // Helmet - demonic
  ctx.fillStyle = '#5a2010';
  ctx.beginPath();
  ctx.arc(0, -16, 10, 0, Math.PI * 2);
  ctx.fill();
  ctx.fillStyle = '#3a1008';
  ctx.fillRect(-7, -18, 14, 5);
  // Glowing eyes
  ctx.fillStyle = showGlow ? '#FFAA00' : '#FF6600';
  ctx.fillRect(-5, -17, 3, 2);
  ctx.fillRect(2, -17, 3, 2);
  // Horns
  ctx.fillStyle = '#4a2010';
  ctx.beginPath();
  ctx.moveTo(-8, -20);
  ctx.lineTo(-12, -28);
  ctx.lineTo(-6, -22);
  ctx.closePath();
  ctx.fill();
  ctx.beginPath();
  ctx.moveTo(8, -20);
  ctx.lineTo(12, -28);
  ctx.lineTo(6, -22);
  ctx.closePath();
  ctx.fill();
  
  // Sword - flaming (no shield - removed from game)
  ctx.save();
  ctx.translate(12, -4);
  ctx.rotate(wAng * 0.6 + 0.3);
  ctx.fillStyle = '#888';
  ctx.beginPath();
  ctx.moveTo(0, 0);
  ctx.lineTo(3, -4);
  ctx.lineTo(2, -22);
  ctx.lineTo(0, -24);
  ctx.lineTo(-2, -22);
  ctx.lineTo(-3, -4);
  ctx.closePath();
  ctx.fill();
  ctx.fillStyle = '#654';
  ctx.fillRect(-5, -2, 10, 3);
  ctx.fillStyle = '#432';
  ctx.fillRect(-2, 0, 4, 8);
  ctx.fillStyle = '#FF4400';
  ctx.beginPath(); ctx.arc(0, 9, 3, 0, Math.PI * 2); ctx.fill();
  if (showGlow) {
    ctx.fillStyle = 'rgba(255,100,0,0.5)';
    ctx.beginPath();
    ctx.moveTo(-3, -20);
    ctx.lineTo(0, -30);
    ctx.lineTo(3, -20);
    ctx.closePath();
    ctx.fill();
  }
  ctx.restore();
}

function drawFrostWarrior(ctx, wAng, showGlow) {
  const breathe = Math.sin(frame * 0.05) * 0.5;
  const legMove = player.state === 'moving' ? Math.sin(frame * 0.15) * 2.5 : 0;
  
  // Shadow
  ctx.fillStyle = 'rgba(30,50,70,0.4)';
  ctx.beginPath();
  ctx.ellipse(0, 18, 14, 5, 0, 0, Math.PI * 2);
  ctx.fill();
  
  // Legs - ice greaves
  ctx.fillStyle = '#4a6a8a';
  ctx.fillRect(-7, 8 + legMove, 5, 12);
  ctx.fillRect(2, 8 - legMove, 5, 12);
  ctx.fillStyle = '#88CCFF';
  ctx.fillRect(-6, 10 + legMove, 3, 4);
  ctx.fillRect(3, 10 - legMove, 3, 4);
  
  // Body - ice plate
  ctx.fillStyle = '#5a7a9a';
  ctx.beginPath();
  ctx.moveTo(-12, 8);
  ctx.lineTo(-10, -8 + breathe);
  ctx.lineTo(10, -8 + breathe);
  ctx.lineTo(12, 8);
  ctx.closePath();
  ctx.fill();
  
  // Frost pattern
  ctx.fillStyle = '#88DDFF';
  ctx.beginPath();
  ctx.moveTo(0, -4 + breathe);
  ctx.lineTo(-4, 0);
  ctx.lineTo(0, 4);
  ctx.lineTo(4, 0);
  ctx.closePath();
  ctx.fill();
  
  // Shoulder pauldrons - icy
  ctx.fillStyle = '#6a8aaa';
  ctx.beginPath(); ctx.arc(-11, -6, 6, 0, Math.PI * 2); ctx.fill();
  ctx.beginPath(); ctx.arc(11, -6, 6, 0, Math.PI * 2); ctx.fill();
  ctx.fillStyle = '#88CCFF';
  ctx.beginPath(); ctx.arc(-11, -6, 3, 0, Math.PI * 2); ctx.fill();
  ctx.beginPath(); ctx.arc(11, -6, 3, 0, Math.PI * 2); ctx.fill();
  
  // Helmet - ice crown
  ctx.fillStyle = '#5a7a9a';
  ctx.beginPath();
  ctx.arc(0, -16, 10, 0, Math.PI * 2);
  ctx.fill();
  ctx.fillStyle = '#4a6a8a';
  ctx.fillRect(-7, -18, 14, 5);
  // Ice eyes
  ctx.fillStyle = showGlow ? '#AAEEFF' : '#88CCFF';
  ctx.fillRect(-5, -17, 3, 2);
  ctx.fillRect(2, -17, 3, 2);
  // Ice spikes crown
  ctx.fillStyle = '#88DDFF';
  ctx.beginPath();
  ctx.moveTo(-6, -24);
  ctx.lineTo(-4, -20);
  ctx.lineTo(-2, -24);
  ctx.lineTo(0, -20);
  ctx.lineTo(2, -24);
  ctx.lineTo(4, -20);
  ctx.lineTo(6, -24);
  ctx.stroke();
  ctx.fill();
  
  // Sword - ice blade (no shield - removed from game)
  ctx.save();
  ctx.translate(12, -4);
  ctx.rotate(wAng * 0.6 + 0.3);
  ctx.fillStyle = '#88CCFF';
  ctx.beginPath();
  ctx.moveTo(0, 0);
  ctx.lineTo(3, -4);
  ctx.lineTo(2, -22);
  ctx.lineTo(0, -24);
  ctx.lineTo(-2, -22);
  ctx.lineTo(-3, -4);
  ctx.closePath();
  ctx.fill();
  ctx.fillStyle = '#4a6a8a';
  ctx.fillRect(-5, -2, 10, 3);
  ctx.fillStyle = '#3a5a7a';
  ctx.fillRect(-2, 0, 4, 8);
  ctx.fillStyle = '#88DDFF';
  ctx.beginPath(); ctx.arc(0, 9, 3, 0, Math.PI * 2); ctx.fill();
  if (showGlow) {
    ctx.fillStyle = 'rgba(136,220,255,0.4)';
    ctx.beginPath(); ctx.arc(0, -14, 8, 0, Math.PI * 2); ctx.fill();
  }
  ctx.restore();
}

function drawLightningWarrior(ctx, wAng, showGlow) {
  const breathe = Math.sin(frame * 0.05) * 0.5;
  const legMove = player.state === 'moving' ? Math.sin(frame * 0.15) * 2.5 : 0;
  
  // Shadow
  ctx.fillStyle = 'rgba(50,40,70,0.4)';
  ctx.beginPath();
  ctx.ellipse(0, 18, 14, 5, 0, 0, Math.PI * 2);
  ctx.fill();
  
  // Legs - storm greaves
  ctx.fillStyle = '#4a3a6a';
  ctx.fillRect(-7, 8 + legMove, 5, 12);
  ctx.fillRect(2, 8 - legMove, 5, 12);
  ctx.fillStyle = '#FFDD00';
  ctx.fillRect(-6, 12 + legMove, 3, 2);
  ctx.fillRect(3, 12 - legMove, 3, 2);
  
  // Body - storm plate
  ctx.fillStyle = '#5a4a7a';
  ctx.beginPath();
  ctx.moveTo(-12, 8);
  ctx.lineTo(-10, -8 + breathe);
  ctx.lineTo(10, -8 + breathe);
  ctx.lineTo(12, 8);
  ctx.closePath();
  ctx.fill();
  
  // Lightning bolt emblem
  ctx.fillStyle = '#FFDD00';
  ctx.beginPath();
  ctx.moveTo(2, -6 + breathe);
  ctx.lineTo(-2, 0);
  ctx.lineTo(1, 0);
  ctx.lineTo(-2, 6);
  ctx.lineTo(4, -1);
  ctx.lineTo(1, -1);
  ctx.closePath();
  ctx.fill();
  
  // Shoulder pauldrons - electric
  ctx.fillStyle = '#6a5a8a';
  ctx.beginPath(); ctx.arc(-11, -6, 6, 0, Math.PI * 2); ctx.fill();
  ctx.beginPath(); ctx.arc(11, -6, 6, 0, Math.PI * 2); ctx.fill();
  ctx.fillStyle = '#FFDD00';
  ctx.beginPath(); ctx.arc(-11, -6, 3, 0, Math.PI * 2); ctx.fill();
  ctx.beginPath(); ctx.arc(11, -6, 3, 0, Math.PI * 2); ctx.fill();
  
  // Helmet - storm helm
  ctx.fillStyle = '#5a4a7a';
  ctx.beginPath();
  ctx.arc(0, -16, 10, 0, Math.PI * 2);
  ctx.fill();
  ctx.fillStyle = '#4a3a6a';
  ctx.fillRect(-7, -18, 14, 5);
  // Electric eyes
  ctx.fillStyle = showGlow ? '#FFFF00' : '#FFDD00';
  ctx.fillRect(-5, -17, 3, 2);
  ctx.fillRect(2, -17, 3, 2);
  // Lightning crest
  ctx.fillStyle = '#FFDD00';
  ctx.beginPath();
  ctx.moveTo(0, -26);
  ctx.lineTo(-3, -22);
  ctx.lineTo(0, -20);
  ctx.lineTo(3, -22);
  ctx.closePath();
  ctx.fill();
  
  // Sword - lightning (no shield - removed from game)
  ctx.save();
  ctx.translate(12, -4);
  ctx.rotate(wAng * 0.6 + 0.3);
  ctx.fillStyle = '#aaa';
  ctx.beginPath();
  ctx.moveTo(0, 0);
  ctx.lineTo(3, -4);
  ctx.lineTo(2, -22);
  ctx.lineTo(0, -24);
  ctx.lineTo(-2, -22);
  ctx.lineTo(-3, -4);
  ctx.closePath();
  ctx.fill();
  ctx.fillStyle = '#5a4a7a';
  ctx.fillRect(-5, -2, 10, 3);
  ctx.fillStyle = '#4a3a6a';
  ctx.fillRect(-2, 0, 4, 8);
  ctx.fillStyle = '#FFDD00';
  ctx.beginPath(); ctx.arc(0, 9, 3, 0, Math.PI * 2); ctx.fill();
  if (showGlow) {
    ctx.strokeStyle = '#FFFF00';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(0, -24);
    ctx.lineTo(-2, -28);
    ctx.lineTo(1, -26);
    ctx.lineTo(-1, -30);
    ctx.stroke();
  }
  ctx.restore();
}

function drawNatureWarrior(ctx, wAng, showGlow) {
  const breathe = Math.sin(frame * 0.05) * 0.5;
  const legMove = player.state === 'moving' ? Math.sin(frame * 0.15) * 2.5 : 0;
  
  // Shadow
  ctx.fillStyle = 'rgba(30,50,20,0.4)';
  ctx.beginPath();
  ctx.ellipse(0, 18, 14, 5, 0, 0, Math.PI * 2);
  ctx.fill();
  
  // Legs - bark greaves
  ctx.fillStyle = '#4a5030';
  ctx.fillRect(-7, 8 + legMove, 5, 12);
  ctx.fillRect(2, 8 - legMove, 5, 12);
  ctx.fillStyle = '#6a8040';
  ctx.fillRect(-6, 10 + legMove, 3, 4);
  ctx.fillRect(3, 10 - legMove, 3, 4);
  
  // Body - living armor
  ctx.fillStyle = '#5a6040';
  ctx.beginPath();
  ctx.moveTo(-12, 8);
  ctx.lineTo(-10, -8 + breathe);
  ctx.lineTo(10, -8 + breathe);
  ctx.lineTo(12, 8);
  ctx.closePath();
  ctx.fill();
  
  // Vine pattern
  ctx.strokeStyle = '#6a9040';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(-6, -4);
  ctx.quadraticCurveTo(0, 2, 6, -4);
  ctx.stroke();
  ctx.fillStyle = '#88AA50';
  ctx.beginPath(); ctx.ellipse(-3, -2, 3, 2, -0.3, 0, Math.PI * 2); ctx.fill();
  ctx.beginPath(); ctx.ellipse(3, -2, 3, 2, 0.3, 0, Math.PI * 2); ctx.fill();
  
  // Shoulder pauldrons - bark
  ctx.fillStyle = '#5a6040';
  ctx.beginPath(); ctx.arc(-11, -6, 6, 0, Math.PI * 2); ctx.fill();
  ctx.beginPath(); ctx.arc(11, -6, 6, 0, Math.PI * 2); ctx.fill();
  ctx.fillStyle = '#6a8040';
  ctx.beginPath(); ctx.arc(-11, -6, 3, 0, Math.PI * 2); ctx.fill();
  ctx.beginPath(); ctx.arc(11, -6, 3, 0, Math.PI * 2); ctx.fill();
  
  // Helmet - nature helm with antlers
  ctx.fillStyle = '#5a6040';
  ctx.beginPath();
  ctx.arc(0, -16, 10, 0, Math.PI * 2);
  ctx.fill();
  ctx.fillStyle = '#4a5030';
  ctx.fillRect(-7, -18, 14, 5);
  // Nature eyes
  ctx.fillStyle = showGlow ? '#88FF44' : '#66AA30';
  ctx.fillRect(-5, -17, 3, 2);
  ctx.fillRect(2, -17, 3, 2);
  // Antlers
  ctx.strokeStyle = '#5a4020';
  ctx.lineWidth = 3;
  ctx.beginPath();
  ctx.moveTo(-7, -22);
  ctx.lineTo(-10, -28);
  ctx.moveTo(-9, -25);
  ctx.lineTo(-12, -26);
  ctx.stroke();
  ctx.beginPath();
  ctx.moveTo(7, -22);
  ctx.lineTo(10, -28);
  ctx.moveTo(9, -25);
  ctx.lineTo(12, -26);
  ctx.stroke();
  
  // Sword - living wood (no shield - removed from game)
  ctx.save();
  ctx.translate(12, -4);
  ctx.rotate(wAng * 0.6 + 0.3);
  ctx.fillStyle = '#5a4020';
  ctx.beginPath();
  ctx.moveTo(0, 0);
  ctx.lineTo(3, -4);
  ctx.lineTo(2, -22);
  ctx.lineTo(0, -24);
  ctx.lineTo(-2, -22);
  ctx.lineTo(-3, -4);
  ctx.closePath();
  ctx.fill();
  ctx.fillStyle = '#4a5030';
  ctx.fillRect(-5, -2, 10, 3);
  ctx.fillStyle = '#3a4020';
  ctx.fillRect(-2, 0, 4, 8);
  ctx.fillStyle = '#6a9040';
  ctx.beginPath(); ctx.arc(0, 9, 3, 0, Math.PI * 2); ctx.fill();
  if (showGlow) {
    ctx.fillStyle = '#88AA50';
    ctx.beginPath(); ctx.ellipse(0, -20, 4, 2, 0, 0, Math.PI * 2); ctx.fill();
  }
  ctx.restore();
}

// ╔══════════════════════════════════════════════════════════════════════════════╗
// ║                    SKILL DAMAGE BANDS - LOCKED RULES                        ║
// ╠══════════════════════════════════════════════════════════════════════════════╣
// ║ These bands are FINAL. No skill should exceed its band, even at T5 gems.   ║
// ║                                                                              ║
// ║ PRIMARIES (Slot 0 only):                                                    ║
// ║   • Damage: 0.8x - 1.2x weapon/spell damage                                 ║
// ║   • Mana: 0 (always free)                                                   ║
// ║   • Cooldown: Attack/cast speed based                                       ║
// ║   • Role: Reliable sustained DPS, never useless                             ║
// ║                                                                              ║
// ║ CORE ACTIVES:                                                               ║
// ║   • Damage: 1.5x - 2.5x (single target or per-hit for multi-hit)           ║
// ║   • Mana: 8-20                                                              ║
// ║   • Cooldown: 1-3 seconds                                                   ║
// ║   • Role: Situational spikes, AoE clear, utility                           ║
// ║                                                                              ║
// ║ ULTIMATES / FINISHERS:                                                      ║
// ║   • Damage: 3.0x - 4.0x (total effective, including multi-hit)             ║
// ║   • Mana: 25-40                                                             ║
// ║   • Cooldown: 3-6+ seconds                                                  ║
// ║   • Role: Big moments, not rotation buttons                                 ║
// ║                                                                              ║
// ║ UTILITY SKILLS:                                                             ║
// ║   • Damage: 0x (no damage)                                                  ║
// ║   • Provides: Movement, buffs, debuffs, CC                                  ║
// ║   • Role: Tactical options, survivability                                   ║
// ║                                                                              ║
// ║ MULTI-HIT RULE:                                                             ║
// ║   • Evaluate by TOTAL damage (per-hit × hits)                              ║
// ║   • A 6-hit skill at 0.4x each = 2.4x total (core active tier)            ║
// ║   • A 10-hit skill at 0.35x each = 3.5x total (ultimate tier)             ║
// ║                                                                              ║
// ║ GEM TIER SCALING (Diminishing Returns):                                     ║
// ║   • T1: 1.00x (base)                                                        ║
// ║   • T2: 1.03x (+3%)                                                         ║
// ║   • T3: 1.06x (+6%)                                                         ║
// ║   • T4: 1.10x (+10%)                                                        ║
// ║   • T5: 1.15x (+15% max)                                                    ║
// ║   • NO skill should exceed its band even at T5                             ║
// ║   • Future: Higher tiers add utility, not more damage                      ║
// ╚══════════════════════════════════════════════════════════════════════════════╝

const DAMAGE_BANDS = {
  PRIMARY: { min: 0.8, max: 1.2, manaMin: 0, manaMax: 0 },
  CORE_ACTIVE: { min: 1.5, max: 2.5, manaMin: 8, manaMax: 20 },
  ULTIMATE: { min: 3.0, max: 4.0, manaMin: 25, manaMax: 40 },
  UTILITY: { min: 0, max: 0, manaMin: 0, manaMax: 30 }
};

const GEM_TIER_MULTIPLIERS = {
  1: 1.00,  // Base
  2: 1.03,  // +3%
  3: 1.06,  // +6%
  4: 1.10,  // +10%
  5: 1.15   // +15% max - diminishing returns
};

// Helper to validate a skill stays within its band at max tier
function validateSkillBand(skillId, baseDamage, hits = 1, band = 'CORE_ACTIVE') {
  const effectiveDamage = baseDamage * hits;
  const maxTierDamage = effectiveDamage * GEM_TIER_MULTIPLIERS[5];
  const bandLimits = DAMAGE_BANDS[band];
  
  if (maxTierDamage > bandLimits.max) {
    console.warn(`⚠️ SKILL BAND VIOLATION: ${skillId} at T5 = ${maxTierDamage.toFixed(2)}x exceeds ${band} max of ${bandLimits.max}x`);
    return false;
  }
  return true;
}

// Skill System
const SKILLS = {
  // ============ PRIMARY SKILLS ============
  // Attack primaries: weapon damage + attack speed
  // Spell primaries: spell damage + cast speed
  
  // ============ PRIMARY SKILLS (Per Class) ============
  // Monk Primary - Fists of Thunder
  fistsOfThunderPrimary: {
    name: 'Fists of Thunder',
    icon: '⚡',
    class: 'monk',
    manaCost: 0,
    cooldown: 0,
    maxCooldown: 8,  // Fast primary like others
    damage: 0.9,     // 0.9x per hit (slightly stronger than other primaries)
    thirdHitDamage: 1.5, // Every 3rd hit does 1.5x AoE
    radius: 45,
    engageRange: 200, // Large dash range for monk mobility
    chainTargets: 3,
    isPrimary: true,
    element: 'lightning',
    description: 'Teleport to the target and unleash rapid lightning punches. Every third hit erupts in a crackling shockwave.'
  },
  
  // ============ RANGER SKILLS (6 New Skills - D4 Inspired) ============
  // Ranger: DEX + Sustained DPS. Physical, Nature, Lightning.
  // Primary pressure + huge AoE spikes. Attack speed matters everywhere.
  
  // PRIMARY: Hungry Arrow - Seeking arrows with pierce chance
  hungryArrow: {
    name: 'Hungry Arrow',
    icon: '🏹',
    imageUrl: 'https://raw.githubusercontent.com/Graphic37/ARPG-/main/Ranger/hungry%20arrow.png',
    class: 'ranger',
    unlockLevel: 1,
    manaCost: 0,
    cooldown: 0,
    maxCooldown: 10,  // Scales with attack speed
    damage: 0.9,      // PRIMARY band (0.8-1.2x)
    speed: 14,
    pierceChance: 0.35,  // 35% chance to pierce
    homing: true,        // Slight homing toward unhit targets
    isPrimary: true,
    element: 'physical',
    description: 'Seeking arrow. 35% pierce chance, prefers unhit targets.'
  },
  
  // CORE ACTIVE: Chakram - Returning disc weapon
  chakram: {
    name: 'Chakram',
    icon: '💫',
    imageUrl: 'https://raw.githubusercontent.com/Graphic37/ARPG-/main/Ranger/chakram.png',
    class: 'ranger',
    unlockLevel: 5,
    manaCost: 10,
    cooldown: 0,
    maxCooldown: 300,    // 5s cooldown
    damage: 1.8,         // 180% weapon damage (360% total with return hit)
    speed: 7,            // Slower projectile
    returnSpeed: 9,
    range: 280,          // Max travel distance before return
    element: 'physical',
    description: 'Throw a spinning chakram that returns. Hits enemies both ways. 180% damage.'
  },
  
  // UTILITY: Caltrops - Ground trap
  caltrops: {
    name: 'Caltrops',
    icon: '🔺',
    imageUrl: 'https://raw.githubusercontent.com/Graphic37/ARPG-/main/Ranger/caltrops.png',
    class: 'ranger',
    unlockLevel: 10,
    manaCost: 15,
    cooldown: 0,
    maxCooldown: 300,    // 5s cooldown
    damage: 0.5,         // 50% weapon damage per second
    slowAmount: 0.8,     // 80% slow
    damageReduction: 0.15, // Enemies deal 15% less damage
    radius: 80,
    duration: 360,       // 6 seconds
    element: 'physical',
    description: 'Scatter caltrops. Enemies take 50%/sec, 80% slow, -15% damage. Lasts 6s.'
  },
  
  // UTILITY: Marked for Death - Boss debuff
  markedForDeath: {
    name: 'Marked for Death',
    icon: '💀',
    imageUrl: 'https://raw.githubusercontent.com/Graphic37/ARPG-/main/Ranger/mark.png',
    class: 'ranger',
    unlockLevel: 15,
    manaCost: 20,
    cooldown: 0,
    maxCooldown: 480,    // 8s cooldown
    damageAmp: 0.25,     // +25% damage taken
    duration: 480,       // 8 seconds
    element: 'physical',
    description: 'Mark target. They take 25% more damage for 8s. Auto-targets bosses.'
  },
  
  // CORE ACTIVE: Multishot - 5 arrow spread (classic style)
  multiShot: {
    name: 'Multishot',
    icon: '🏹',
    imageUrl: 'https://raw.githubusercontent.com/Graphic37/ARPG-/main/Ranger/multishot.png',
    class: 'ranger',
    unlockLevel: 2,
    manaCost: 25,
    cooldown: 0,
    maxCooldown: 60,     // ~1s
    damage: 2.8,         // Total damage spread across 5 arrows
    element: 'physical',
    description: '5 arrow spread volley. 2.8x total damage.'
  },
  
  // UTILITY: Sentry - Deployable turret
  sentry: {
    name: 'Sentry',
    icon: '🗼',
    imageUrl: 'https://raw.githubusercontent.com/Graphic37/ARPG-/main/Ranger/sentry.png',
    class: 'ranger',
    unlockLevel: 8,
    manaCost: 20,
    cooldown: 0,
    maxCooldown: 720,    // 12s cooldown
    damage: 0.9,         // Each shot
    fireRate: 72,        // Fires every 1.2s (72 frames)
    maxSentries: 2,
    duration: 1200,      // 20 seconds
    element: 'physical',
    description: 'Deploy a ballista (max 2). Fires 0.9x every 1.2s.'
  },
  
  // ULTIMATE: Rain of Arrows - Screen clear with bleed
  rainOfArrows: {
    name: 'Rain of Arrows',
    icon: '🌧️',
    imageUrl: 'https://raw.githubusercontent.com/Graphic37/ARPG-/main/Ranger/rain%20of%20arrows.png',
    class: 'ranger',
    unlockLevel: 20,
    manaCost: 40,
    cooldown: 0,
    maxCooldown: 1800,   // 30s cooldown
    damage: 4.2,         // Total over duration
    radius: 180,         // Large area
    duration: 240,       // 4 seconds
    bleedDamage: 0.2,    // 20% weapon damage/sec
    bleedDuration: 180,  // 3 seconds
    element: 'physical', // + Nature for bleed
    description: 'Devastating arrow rain. 4.2x over 4s + Nature bleed.'
  },
  
  basicSlash: {
    name: 'Basic Slash',
    icon: '⚔️',
    class: 'warrior',
    manaCost: 0,
    cooldown: 0,
    maxCooldown: 8,  // ~0.13s - fast warrior attacks
    damage: 1.0,     // Warrior primary - same as others for band compliance
    radius: 50,
    isPrimary: true,
    description: 'A simple sword slash. No mana cost, attack speed based.'
  },

  // ============ MONK SKILLS (7 New D3-Converted Skills) ============
  
  // PRIMARY: Fists of Thunder - Lightning punches with gap-closer
  fistsOfThunder: {
    name: 'Fists of Thunder',
    icon: '⚡',
    class: 'monk',
    manaCost: 0,
    cooldown: 0,
    maxCooldown: 8,  // Fast primary
    damage: 0.9,     // 0.9x per hit
    thirdHitDamage: 1.5, // Every 3rd hit does 1.5x in a cone
    radius: 45,
    engageRange: 200, // Large dash range for monk mobility
    chainTargets: 3,  // Chain lightning hits up to 3 enemies
    isPrimary: true,
    element: 'lightning',
    description: 'Teleport to the target and unleash rapid lightning punches. Every third hit erupts in a crackling shockwave that chains to nearby foes.'
  },
  
  // PRIMARY: Way of the Glacier - Cold strikes with freeze
  wayOfTheGlacier: {
    name: 'Way of the Glacier',
    icon: '❄️',
    class: 'monk',
    manaCost: 0,
    cooldown: 0,
    maxCooldown: 8,
    damage: 0.85,    // Slightly less base, compensated by freeze
    thirdHitDamage: 1.8, // Strong 3rd hit
    radius: 45,
    engageRange: 200,
    freezeChance: 0.15,  // 15% freeze on hit
    thirdHitFreeze: 0.5, // 50% freeze on 3rd hit
    freezeDuration: 45,  // 0.75 seconds
    isPrimary: true,
    element: 'cold',
    description: 'Glacial fists crash into foes with bone-chilling force. Each strike may freeze, and every third hit shatters the air in a freezing nova.'
  },
  
  // PRIMARY: Blazing Fists - Fire strikes with ignite
  blazingFists: {
    name: 'Blazing Fists',
    icon: '🔥',
    class: 'monk',
    manaCost: 0,
    cooldown: 0,
    maxCooldown: 8,
    damage: 0.95,    // Good base damage
    thirdHitDamage: 2.0, // Big explosion on 3rd
    radius: 45,
    engageRange: 200,
    burnDamage: 0.3,  // 30% weapon damage burn on 3rd hit
    burnDuration: 60, // 1 second burn
    burnRadius: 60,   // AoE burn
    isPrimary: true,
    element: 'fire',
    description: 'Fists wreathed in flames scorch all they touch. Every third strike erupts in a fiery explosion that ignites nearby enemies.'
  },
  
  // PRIMARY: Jade Wind Strike - Nature strikes with healing
  jadeWindStrike: {
    name: 'Jade Wind Strike',
    icon: '🌿',
    class: 'monk',
    manaCost: 0,
    cooldown: 0,
    maxCooldown: 8,
    damage: 0.85,
    thirdHitDamage: 1.6,
    radius: 45,
    engageRange: 200,
    healOnHit: 0.01,     // 1% max HP on hit
    thirdHitHeal: 0.05,  // 5% max HP on 3rd hit
    thirdHitRadius: 80,  // Large AoE
    isPrimary: true,
    element: 'nature',
    description: 'Channel the vital energy of nature through each strike. Every blow mends your wounds, and every third strike releases a burst of rejuvenating force.'
  },
  
  // DEFENSIVE CORE: Blinding Flash - Blind enemies + dodge buff
  blindingFlash: {
    name: 'Blinding Flash',
    icon: '✨',
    class: 'monk',
    manaCost: 12,
    cooldown: 0,
    maxCooldown: 90,  // ~1.5s
    damage: 0,
    radius: 120,
    blindDuration: 60,    // 1 second blind
    blindMissChance: 0.4, // 40% miss chance (20% for bosses)
    dodgeBuff: 0.15,      // +15% dodge
    dodgeBuffDuration: 90, // 1.5s
    element: 'nature',
    description: 'Unleash a burst of blinding radiance, causing enemies to whiff their attacks while you slip between blows with heightened agility.'
  },
  
  // DEFENSIVE CORE: Breath of Heaven - Instant heal + buff
  breathOfHeaven: {
    name: 'Breath of Heaven',
    icon: '💨',
    class: 'monk',
    manaCost: 20,
    cooldown: 0,
    maxCooldown: 480,  // 8 seconds
    damage: 0,
    healPercent: 0.30, // 30% max HP
    attackSpeedBuff: 0.15, // +15% attack speed (doubled to 30% with aspect)
    moveSpeedBuff: 0.10,   // +10% move speed
    buffDuration: 120,     // 2 seconds (doubled to 4s with aspect)
    element: 'nature',
    description: 'Channel a surge of vital energy, mending your wounds in a flash and surging forward with renewed speed and focus.'
  },
  
  // SECONDARY ULTIMATE: Wave of Light - Line nuke
  waveOfLight: {
    name: 'Wave of Light',
    icon: '🔔',
    class: 'monk',
    manaCost: 30,
    cooldown: 0,
    maxCooldown: 600,  // 10 seconds (halved to 5s with aspect)
    damage: 3.5,       // 3.5x along the line
    crushDamage: 1.5,  // Extra 1.5x on first target (5.0x total)
    range: 120,        // Target range
    lineLength: 200,   // Shockwave length
    lineWidth: 60,
    element: 'fire',
    description: 'Drop a blazing idol of flame that explodes into a scorching shockwave, obliterating anything caught in its path.'
  },
  
  // TECHNIQUE ULTIMATE: Exploding Palm - DoT + chain explosion
  explodingPalm: {
    name: 'Exploding Palm',
    icon: '💥',
    class: 'monk',
    manaCost: 25,
    cooldown: 0,
    maxCooldown: 120,  // ~2s
    bleedDamage: 1.8,  // 1.8x over duration
    bleedDuration: 90, // 1.5s
    explosionDamage: 3.0, // 3.0x on death
    explosionRadius: 120,
    element: 'physical',
    description: 'Mark an enemy with a lethal strike. When they fall, their body detonates in a violent blast that rips through surrounding foes.'
  },
  
  // FOCUS CORE: Cyclone Strike - Pull + AoE burst
  cycloneStrike: {
    name: 'Cyclone Strike',
    icon: '🌪️',
    class: 'monk',
    manaCost: 20,
    cooldown: 0,
    maxCooldown: 90,   // ~1.5s
    damage: 2.0,       // 2.0x damage
    pullRadius: 180,   // Pull range
    maxTargets: 12,
    bossSlowDuration: 60, // 1s slow on bosses
    bossSlowAmount: 0.2,  // 20% slow
    element: 'lightning',
    description: 'Summon a raging wind that drags enemies into striking distance, then detonate the swirling storm in a crackling burst of lightning.'
  },
  
  // ULTIMATE: Seven-Sided Strike - Rapid teleport strikes
  sevenSidedStrike: {
    name: 'Seven-Sided Strike',
    icon: '⚔️',
    class: 'monk',
    manaCost: 35,
    cooldown: 0,
    maxCooldown: 900,  // 15 seconds
    damagePerHit: 1.0, // 1.0x per strike
    strikes: 7,        // 7 hits total
    radius: 200,       // Target acquisition range
    invulnerable: true, // Invulnerable during strikes
    element: 'physical',
    description: 'Become a blur of motion, teleporting between enemies and striking 7 times in rapid succession. Invulnerable while attacking.'
  },
  
  // DEFENSIVE: Inner Sanctuary - Protective zone
  innerSanctuary: {
    name: 'Inner Sanctuary',
    icon: '🛡️',
    class: 'monk',
    manaCost: 25,
    cooldown: 0,
    maxCooldown: 720,  // 12 seconds
    damage: 0,
    damageReduction: 0.50, // 50% damage reduction inside
    duration: 300,     // 5 seconds
    radius: 100,       // Zone radius
    healPerSecond: 0.03, // 3% max HP per second
    element: 'nature',
    description: 'Create a sacred zone of protection. While inside, take 50% less damage and regenerate health.'
  },

  // ============ PASSIVE SKILLS ============
  // Class-specific passives - same effect, different names per class
  // Simple, balanced choices: offensive, defensive, or utility
  // Aspects can double these bonuses (12 total aspects)
  
  // MONK PASSIVES
  monkPower: {
    name: 'Monk Power',
    icon: '⚔️',
    class: 'monk',
    isPassive: true,
    passiveType: 'offensive',
    bonuses: { damageMult: 0.05 },
    description: '+5% Damage. Equip Aspect of Monk Power to double this bonus.'
  },
  monkVitality: {
    name: 'Monk Vitality',
    icon: '❤️',
    class: 'monk',
    isPassive: true,
    passiveType: 'defensive',
    bonuses: { maxHpMult: 0.05 },
    description: '+5% Maximum HP. Equip Aspect of Monk Vitality to double this bonus.'
  },
  monkResistance: {
    name: 'Monk Resistance',
    icon: '🛡️',
    class: 'monk',
    isPassive: true,
    passiveType: 'utility',
    bonuses: { allResist: 0.05 },
    description: '+5% All Elemental Resistance. Equip Aspect of Monk Resistance to double this bonus.'
  },
  
  // WARRIOR PASSIVES
  warriorPower: {
    name: 'Warrior Power',
    icon: '⚔️',
    class: 'warrior',
    isPassive: true,
    passiveType: 'offensive',
    bonuses: { damageMult: 0.05 },
    description: '+5% Damage. Equip Aspect of Warrior Power to double this bonus.'
  },
  warriorVitality: {
    name: 'Warrior Vitality',
    icon: '❤️',
    class: 'warrior',
    isPassive: true,
    passiveType: 'defensive',
    bonuses: { maxHpMult: 0.05 },
    description: '+5% Maximum HP. Equip Aspect of Warrior Vitality to double this bonus.'
  },
  warriorResistance: {
    name: 'Warrior Resistance',
    icon: '🛡️',
    class: 'warrior',
    isPassive: true,
    passiveType: 'utility',
    bonuses: { allResist: 0.05 },
    description: '+5% All Elemental Resistance. Equip Aspect of Warrior Resistance to double this bonus.'
  },
  
  // RANGER PASSIVES
  rangerPower: {
    name: 'Ranger Power',
    icon: '⚔️',
    imageUrl: 'https://raw.githubusercontent.com/Graphic37/ARPG-/main/Ranger/damage.png',
    class: 'ranger',
    unlockLevel: 25,
    isPassive: true,
    passiveType: 'offensive',
    bonuses: { damageMult: 0.05 },
    description: '+5% Damage. Equip Aspect of Ranger Power to double this bonus.'
  },
  rangerVitality: {
    name: 'Ranger Vitality',
    icon: '❤️',
    imageUrl: 'https://raw.githubusercontent.com/Graphic37/ARPG-/main/Ranger/life.png',
    class: 'ranger',
    unlockLevel: 25,
    isPassive: true,
    passiveType: 'defensive',
    bonuses: { maxHpMult: 0.05 },
    description: '+5% Maximum HP. Equip Aspect of Ranger Vitality to double this bonus.'
  },
  rangerResistance: {
    name: 'Ranger Resistance',
    icon: '🛡️',
    imageUrl: 'https://raw.githubusercontent.com/Graphic37/ARPG-/main/Ranger/elemental%20shield.png',
    class: 'ranger',
    unlockLevel: 25,
    isPassive: true,
    passiveType: 'utility',
    bonuses: { allResist: 0.05 },
    description: '+5% All Elemental Resistance. Equip Aspect of Ranger Resistance to double this bonus.'
  },
  
  // MAGE PASSIVES
  magePower: {
    name: 'Mage Power',
    icon: '⚔️',
    class: 'mage',
    isPassive: true,
    passiveType: 'offensive',
    bonuses: { damageMult: 0.05 },
    description: '+5% Damage. Equip Aspect of Mage Power to double this bonus.'
  },
  mageVitality: {
    name: 'Mage Vitality',
    icon: '❤️',
    class: 'mage',
    isPassive: true,
    passiveType: 'defensive',
    bonuses: { maxHpMult: 0.05 },
    description: '+5% Maximum HP. Equip Aspect of Mage Vitality to double this bonus.'
  },
  mageResistance: {
    name: 'Mage Resistance',
    icon: '🛡️',
    class: 'mage',
    isPassive: true,
    passiveType: 'utility',
    bonuses: { allResist: 0.05 },
    description: '+5% All Elemental Resistance. Equip Aspect of Mage Resistance to double this bonus.'
  },

  // ============ RANGER SKILLS (10) ============
  // ============ MAGE SKILLS (10) ============
  // ============ MAGE SKILLS (7 D3/D4-Converted) ============
  // Mage: INT + Shield caster. Fire, Cold, Lightning, Nature, Physical.
  // No allies. No healing. Defensive power from control and shields.
  
  magicMissile: {
    name: 'Magic Missile',
    icon: '🔮',
    class: 'mage',
    manaCost: 0,
    cooldown: 0,
    maxCooldown: 8,  // ~0.13s cast time
    damage: 0.9,     // PRIMARY band (0.8-1.2x)
    range: 350,
    speed: 14,
    isPrimary: true,
    isSpell: true,   // Uses cast speed
    element: 'physical',
    description: 'Force projectile, every 3rd cast fires an extra missile'
  },
  electrocute: {
    name: 'Electrocute',
    icon: '⚡',
    class: 'mage',
    manaCost: 0,
    cooldown: 0,
    maxCooldown: 12,  // Slightly slower than Magic Missile
    damage: 0.7,      // PRIMARY band - lower per hit but chains
    chains: 2,        // Chains to 2 additional enemies
    chainRange: 120,
    isPrimary: true,
    isSpell: true,    // Uses cast speed
    element: 'lightning',
    description: 'Lightning bolt that chains to 2 additional enemies'
  },
  frostNova: {
    name: 'Frost Nova',
    icon: '❄️',
    class: 'mage',
    manaCost: 18,
    cooldown: 0,
    maxCooldown: 600,  // 10s cooldown
    damage: 1.2,       // Defensive utility damage
    radius: 140,
    freezeDuration: 90,  // 1.5s freeze
    slowDuration: 180,   // 3s slow for bosses
    element: 'cold',
    description: 'Freezing burst, bosses slowed instead'
  },
  chaosOrb: {
    name: 'Chaos Orb',
    icon: '🌀',
    class: 'mage',
    manaCost: 25,
    cooldown: 0,
    maxCooldown: 60,   // 1s cooldown
    damage: 2.4,       // CORE_ACTIVE band (1.5-2.5x)
    radius: 80,
    speed: 5,          // Slow moving
    element: 'physical',
    description: 'Slow orb that explodes on contact'
  },
  blizzard: {
    name: 'Blizzard',
    icon: '🌨️',
    class: 'mage',
    manaCost: 30,
    cooldown: 0,
    maxCooldown: 360,  // 6s cooldown
    damage: 3.0,       // ULTIMATE band total over duration
    radius: 120,
    duration: 240,     // 4 seconds
    tickRate: 30,      // Damage every 0.5s (8 ticks)
    slowAmount: 0.3,   // 30% slow, stacking
    element: 'cold',
    description: 'Cold shards over 4s, progressively slows'
  },
  meteor: {
    name: 'Meteor',
    icon: '☄️',
    class: 'mage',
    manaCost: 40,
    cooldown: 0,
    maxCooldown: 600,  // 10s cooldown
    damage: 4.0,       // ULTIMATE band (3-4x)
    burnDamage: 1.5,   // Additional burn over 3s
    burnDuration: 180, // 3 seconds
    radius: 140,
    delay: 45,         // 0.75s delay before impact
    element: 'fire',
    description: 'Massive meteor with burning ground'
  },
  energyArmor: {
    name: 'Energy Armor',
    icon: '💠',
    class: 'mage',
    manaCost: 25,
    cooldown: 0,
    maxCooldown: 1200,  // 20s cooldown
    damage: 0,
    shieldBonus: 0.30,  // +30% Shield
    damageReduction: 0.15,  // 15% DR
    duration: 360,      // 6 seconds
    element: 'physical',
    description: '+30% Shield, 15% DR for 6s'
  },

  // ============ WARRIOR SKILLS (10) ============
  shieldBash: {
    name: 'Shield Bash',
    icon: '🛡️',
    class: 'warrior',
    manaCost: 8,
    cooldown: 0,
    maxCooldown: 30,
    damage: 1.5,
    stunDuration: 60,
    radius: 50,
    description: 'Bash enemies with shield, stun'
  },
  cleave: {
    name: 'Cleave',
    icon: '⚔️',
    class: 'warrior',
    manaCost: 10,
    cooldown: 0,
    maxCooldown: 35,
    damage: 1.8,
    radius: 90,
    arc: 180,
    description: 'Wide sweeping sword attack'
  },
  groundSlam: {
    name: 'Ground Slam',
    icon: '💥',
    class: 'warrior',
    manaCost: 15,
    cooldown: 0,
    maxCooldown: 60,
    damage: 2.15,
    radius: 120,
    description: 'Slam ground, damaging nearby'
  },
  charge: {
    name: 'Charge',
    icon: '🏃',
    class: 'warrior',
    manaCost: 12,
    cooldown: 0,
    maxCooldown: 45,
    damage: 2.0,
    distance: 200,
    description: 'Charge forward, damaging enemies'
  },
  warCry: {
    name: 'War Cry',
    icon: '📢',
    class: 'warrior',
    manaCost: 15,
    cooldown: 0,
    maxCooldown: 120,
    damage: 0,
    damageBoost: 0.25,
    duration: 240,
    description: 'Boost damage by 25% for 4s'
  },
  shieldWall: {
    name: 'Shield Wall',
    icon: '🏰',
    class: 'warrior',
    manaCost: 20,
    cooldown: 0,
    maxCooldown: 180,
    damage: 0,
    damageReduction: 0.7,
    duration: 180,
    description: 'Block 70% damage for 3s'
  },
  execute: {
    name: 'Execute',
    icon: '💀',
    class: 'warrior',
    manaCost: 20,
    cooldown: 0,
    maxCooldown: 90,
    damage: 3.0,  // High-end core active, borderline ultimate
    radius: 60,
    description: 'Powerful finisher attack'
  },
  whirlwind: {
    name: 'Whirlwind',
    icon: '🌀',
    class: 'warrior',
    manaCost: 12,
    cooldown: 0,
    maxCooldown: 50,
    damage: 1.0,
    radius: 100,
    duration: 60,
    description: 'Spin with sword hitting all'
  },
  revenge: {
    name: 'Revenge',
    icon: '⚔️',
    class: 'warrior',
    manaCost: 8,
    cooldown: 0,
    maxCooldown: 25,
    damage: 2.2,
    radius: 70,
    description: 'Counter-attack nearby enemies'
  },
  earthquake: {
    name: 'Earthquake',
    icon: '🌋',
    class: 'warrior',
    manaCost: 35,
    cooldown: 0,
    maxCooldown: 240,
    damage: 1.1,  // 3 waves × 1.1x = 3.3x effective (ultimate band)
    radius: 180,
    waves: 3,
    description: 'Massive quake in 3 waves'
  }
};

let activeSkill = null;
let skillProjectiles = [];
let cycloneActive = false;
let cycloneTimer = 0;
let cycloneTierMultiplier = 1;

// ════════════════════════════════════════════════════════════════════════════════
// DUNGEON DIFFICULTY SYSTEM
// Press 'D' to open dungeon selection. Each difficulty sets item level range.
// Higher difficulties = better loot (higher tier mods) but tougher enemies.
// ════════════════════════════════════════════════════════════════════════════════

// ════════════════════════════════════════════════════════════════════════════════
// DUNGEON DIFFICULTY TIERS
// Each difficulty sets the BEST POSSIBLE affix tier that can drop (not guaranteed).
// Lower tier number = better roll (T1 is best, T8 is worst).
// Example: Core allows T1-T8, but T1 is rare. Nightmare allows T2-T8 max.
// ════════════════════════════════════════════════════════════════════════════════

const DUNGEON_DIFFICULTIES = {
  easy: {
    name: 'Easy',
    subtitle: 'The Training Grounds',
    recommendedLevel: '1-5',
    ilvlMin: 1,
    ilvlMax: 20,
    bestTier: 6,        // T6-T8 possible (T6 = best available)
    enemyHpMult: 0.3,   // 50% less HP than before - very easy mode
    enemyDmgMult: 0.25, // Quarter damage - almost no threat
    accuracyMult: 0.7,  // Enemies are less accurate - easier to dodge
    expMult: 0.5,       // Reduced rewards
    goldMult: 0.5,      // Reduced rewards
    color: '#88cc88',
    icon: '🌿',
    unlockLevel: 1,
    aspectInfo: 'Boss Aspect: 0.1% (Common only)',
    defenseRec: 'No defense needed'
  },
  normal: {
    name: 'Normal',
    subtitle: 'The Verdant Wilds',
    recommendedLevel: '5-10',
    ilvlMin: 21,
    ilvlMax: 30,
    bestTier: 5,        // T5-T8 possible
    enemyHpMult: 1.3,
    enemyDmgMult: 1.5,
    accuracyMult: 1.0,  // Baseline accuracy
    expMult: 1.5,
    goldMult: 1.5,
    color: '#cccc88',
    icon: '🌲',
    unlockLevel: 5,
    aspectInfo: 'Boss Aspect: 0.1% (Common only)',
    defenseRec: 'Light defense helps'
  },
  hard: {
    name: 'Hard',
    subtitle: 'The Scorched Wastes',
    recommendedLevel: '10-20',
    ilvlMin: 31,
    ilvlMax: 40,
    bestTier: 4,        // T4-T8 possible
    enemyHpMult: 1.8,
    enemyDmgMult: 2.5,
    accuracyMult: 1.3,  // Harder to dodge
    expMult: 2.0,
    goldMult: 2.0,
    color: '#cc8844',
    icon: '🔥',
    unlockLevel: 10,
    aspectInfo: 'Boss Aspect: 0.1% (Common only)',
    defenseRec: '30%+ resists recommended'
  },
  elite: {
    name: 'Elite',
    subtitle: 'The Frozen Depths',
    recommendedLevel: '20-40',
    ilvlMin: 41,
    ilvlMax: 50,
    bestTier: 3,        // T3-T8 possible
    enemyHpMult: 2.5,
    enemyDmgMult: 4.0,
    accuracyMult: 1.6,  // Significantly harder to dodge
    expMult: 3.0,
    goldMult: 3.0,
    color: '#8888cc',
    icon: '❄️',
    unlockLevel: 20,
    aspectInfo: 'Boss Aspect: 0.1% (80% C, 20% R)',
    defenseRec: '50%+ resists recommended'
  },
  nightmare: {
    name: 'Nightmare',
    subtitle: 'The Abyssal Rift',
    recommendedLevel: '40-60',
    ilvlMin: 51,
    ilvlMax: 69,
    bestTier: 2,        // T2-T8 possible
    enemyHpMult: 3.5,
    enemyDmgMult: 6.0,
    accuracyMult: 2.0,  // Very hard to dodge - need resist priority
    expMult: 4.0,
    goldMult: 4.0,
    color: '#aa44aa',
    icon: '👁️',
    unlockLevel: 30,
    aspectInfo: 'Boss Aspect: 0.1% (80% C, 20% R)',
    defenseRec: '70%+ resists recommended'
  },
  core: {
    name: 'Core',
    subtitle: 'The Heart of Corruption',
    recommendedLevel: '60+',
    ilvlMin: 70,
    ilvlMax: 80,
    bestTier: 1,        // T1-T8 possible (T1 = perfect rolls!)
    enemyHpMult: 5.0,
    enemyDmgMult: 8.0,
    accuracyMult: 2.5,  // Extremely hard to dodge - resists mandatory
    expMult: 5.0,
    goldMult: 5.0,
    color: '#cc4444',
    icon: '💀',
    unlockLevel: 40,
    aspectInfo: 'Boss Aspect: 0.1% (55% C, 40% R, 5% L)',
    defenseRec: '75% resists recommended'
  }
};

let currentDifficulty = 'easy';
let dungeonSelectorOpen = false;

// ════════════════════════════════════════════════════════════════════════════════
// DEFENSE CALCULATIONS (PoE2-Style Diminishing Returns)
// Priority: Resistances > Dodge > Armor
// ════════════════════════════════════════════════════════════════════════════════
// 
// DESIGN GOALS:
// - "Big hits are dangerous" - stacking one defense isn't enough
// - "Multiple defensive layers required" - need armor + dodge + resists + life
// - "Bosses counter evasion via higher accuracy" - can't just stack dodge
// - All defenses use rating-based diminishing returns (no flat %)
//
// RESISTANCES (75% cap each): Priority #1
// - Reduces elemental damage by percentage
// - Bosses deal 70-90% elemental damage (after shift)
// - Must cap all 4 resists for endgame
//
// DODGE RATING: Priority #2  
// - Formula: DodgeChance = DodgeRating / (DodgeRating + EnemyAccuracy × 3)
// - 1 DEX = +1.5 Dodge Rating (easier to achieve)
// - 3 rating ≈ 1% dodge at start (diminishing returns)
// - Example: 200 DEX = 300 rating = 50% dodge vs normal enemies
// - Bosses have +50% accuracy, Elites +25%
// - Higher difficulties multiply enemy accuracy (0.7x to 2.5x)
// - Soft cap at 95% (always 5% hit chance minimum)
//
// ARMOR: Priority #3
// - Formula: Reduction = Armor / (Armor + Damage * 5)
// - 1 STR = +1 Armor per 10 points
// - Strong vs small hits, weak vs boss slams
// - Example: 100 armor vs 20 damage = 50% reduction
// - Example: 100 armor vs 100 damage = 17% reduction
//
// ACCURACY BY DIFFICULTY:
// Easy: 0.7x | Normal: 1.0x | Hard: 1.3x | Elite: 1.6x | Nightmare: 2.0x | Core: 2.5x
//
// ENEMY BASE ACCURACY (before difficulty):
// Slime: 60 | Golem: 75 | Zombie: 80 | Spider: 85 | Specter: 90 | Mage: 90
// Wraith: 95 | Skeleton: 100 | Giant Spider: 100 | Cultist: 100 | Bandit: 105
// Skeleton Warrior: 110 | Wolf: 110 | Demon: 115 | Bat: 120
// ════════════════════════════════════════════════════════════════════════════════

// Calculate dodge chance using evasion formula
// Formula: DodgeChance = DodgeRating / (DodgeRating + EnemyAccuracy × K)
// K = 3 means 3 rating = ~1% dodge at the start (diminishing returns)
// Returns 0-100 (percentage), no hard cap - diminishing returns handle scaling
function calculateDodgeChance(dodgeRating, enemyAccuracy) {
  if (dodgeRating <= 0) return 0;
  if (enemyAccuracy <= 0) return 95; // Near-guaranteed dodge vs 0 accuracy
  const K = 3; // Scaling constant: 3 rating ≈ 1% at start
  const chance = (dodgeRating / (dodgeRating + enemyAccuracy * K)) * 100;
  return Math.min(95, chance); // Soft cap at 95% (always some hit chance)
}

// Calculate armor damage reduction using PoE-style formula
// Formula: Reduction = Armor / (Armor + Damage * K) where K = 5
// Returns 0-1 (multiplier), scales with hit size
function calculateArmorReduction(armor, damage) {
  if (armor <= 0 || damage <= 0) return 0;
  return armor / (armor + damage * 5);
}

// Get enemy accuracy with difficulty and type modifiers
// Base accuracy from enemy template, scaled by difficulty, boosted for bosses/elites
function getEnemyAccuracy(enemy, difficultySettings) {
  const baseAccuracy = enemy.accuracy || 100;
  
  // Difficulty scaling: higher difficulties have more accurate enemies
  // Easy: 0.7x, Normal: 1.0x, Hard: 1.3x, Elite: 1.6x, Nightmare: 2.0x, Core: 2.5x
  const difficultyMult = difficultySettings?.accuracyMult || 1.0;
  
  // Boss accuracy bonus: +50%
  const bossBonus = enemy.isBoss ? 1.5 : 1.0;
  
  // Elite accuracy bonus: +25%
  const eliteBonus = enemy.isElite ? 1.25 : 1.0;
  
  return Math.floor(baseAccuracy * difficultyMult * bossBonus * eliteBonus);
}

// Estimate dodge chance vs "average" enemy for UI display
// Uses base 100 accuracy with current difficulty multiplier
function getEstimatedDodgeChance() {
  const settings = DUNGEON_DIFFICULTIES[currentDifficulty];
  const avgAccuracy = 100 * (settings?.accuracyMult || 1.0);
  return calculateDodgeChance(player.dodgeRating || 0, avgAccuracy);
}

// Get current dungeon settings
function getDungeonSettings() {
  return DUNGEON_DIFFICULTIES[currentDifficulty];
}

// Get item level for current dungeon (random within range)
function getDungeonItemLevel() {
  const settings = getDungeonSettings();
  return Math.floor(Math.random() * (settings.ilvlMax - settings.ilvlMin + 1)) + settings.ilvlMin;
}

// Check if a difficulty is unlocked
function isDifficultyUnlocked(diffKey) {
  const diff = DUNGEON_DIFFICULTIES[diffKey];
  return player.level >= diff.unlockLevel;
}

// ════════════════════════════════════════════════════════════════════════════════
// SHARD SYSTEM
// Shards are account-wide currencies used to activate special dungeon mechanics.
// They drop from enemies and are NOT inventory items.
// ════════════════════════════════════════════════════════════════════════════════

const SHARD_TYPES = {
  rift: {
    name: 'Rift Shards',
    icon: '🌀',
    color: '#8af',
    dropChance: 0.08,  // 8% chance per enemy kill
    dropAmount: [1, 3]  // 1-3 shards per drop
  },
  echo: {
    name: 'Echo Shards',
    icon: '⚡',
    color: '#fa8',
    dropChance: 0,  // Earned from Echo Domain completion, not drops
    dropAmount: [1, 2]
  }
};

// Shard storage (account-wide, not per-character)
let shards = {
  rift: 0,
  echo: 0
};

// Rift Surge state - Horizontal Gauntlet System
let riftSurgeActive = false;
let riftSurgeStartTime = 0;       // Real timestamp when rift started
let riftSurgeTier = 1;
let riftSurgeKills = 0;
let riftSurgeShardBonus = 1;
let riftSurgeTimeLimit = 60;      // Seconds (real time)
let riftSurgeEliteKills = 0;
let riftSurgeBossKills = 0;

// Store original game state to restore after rift
let riftSavedState = null;

// ════════════════════════════════════════════════════════════════════════════════
// SESSION STATS DASHBOARD
// Tracks kills/hr, gold/hr, items/hr for current session
// ════════════════════════════════════════════════════════════════════════════════
let sessionStats = {
  startTime: Date.now(),
  kills: 0,
  bossKills: 0,
  goldEarned: 0,
  itemsLooted: 0,
  itemsSalvaged: 0,
  coresEarned: 0,
  prismsEarned: 0,
  aspectsFound: 0,
  highestStarDrop: 0,
  deathCount: 0,
  craftsUsed: 0
};

// Reset session stats
function resetSessionStats() {
  sessionStats = {
    startTime: Date.now(),
    kills: 0,
    bossKills: 0,
    goldEarned: 0,
    itemsLooted: 0,
    itemsSalvaged: 0,
    coresEarned: 0,
    prismsEarned: 0,
    aspectsFound: 0,
    highestStarDrop: 0,
    deathCount: 0,
    craftsUsed: 0
  };
  updateStatsDashboard();
}

// Get session duration in hours (minimum 0.001 to avoid division by zero)
function getSessionHours() {
  const ms = Date.now() - sessionStats.startTime;
  return Math.max(ms / (1000 * 60 * 60), 0.001);
}

// Format number with K/M suffix
function formatStatNumber(num) {
  if (num >= 1000000) return (num / 1000000).toFixed(1) + 'M';
  if (num >= 1000) return (num / 1000).toFixed(1) + 'K';
  return Math.floor(num).toString();
}

// Format duration as HH:MM:SS
function formatSessionDuration() {
  const ms = Date.now() - sessionStats.startTime;
  const seconds = Math.floor(ms / 1000) % 60;
  const minutes = Math.floor(ms / (1000 * 60)) % 60;
  const hours = Math.floor(ms / (1000 * 60 * 60));
  return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
}

// Update the stats dashboard display
function updateStatsDashboard() {
  const dashboard = document.getElementById('statsDashboard');
  if (!dashboard || !dashboard.classList.contains('visible')) return;
  
  const hours = getSessionHours();
  
  // Update all stat values
  document.getElementById('statDuration').textContent = formatSessionDuration();
  
  document.getElementById('statKills').textContent = formatStatNumber(sessionStats.kills);
  document.getElementById('statKillsHr').textContent = formatStatNumber(sessionStats.kills / hours) + '/hr';
  
  document.getElementById('statBossKills').textContent = formatStatNumber(sessionStats.bossKills);
  
  document.getElementById('statGold').textContent = formatStatNumber(sessionStats.goldEarned);
  document.getElementById('statGoldHr').textContent = formatStatNumber(sessionStats.goldEarned / hours) + '/hr';
  
  document.getElementById('statItems').textContent = formatStatNumber(sessionStats.itemsLooted);
  document.getElementById('statItemsHr').textContent = formatStatNumber(sessionStats.itemsLooted / hours) + '/hr';
  
  document.getElementById('statSalvaged').textContent = formatStatNumber(sessionStats.itemsSalvaged);
  
  document.getElementById('statCores').textContent = formatStatNumber(sessionStats.coresEarned);
  document.getElementById('statPrisms').textContent = formatStatNumber(sessionStats.prismsEarned);
  document.getElementById('statAspects').textContent = sessionStats.aspectsFound.toString();
  document.getElementById('statDeaths').textContent = sessionStats.deathCount.toString();
  
  // Best drop display
  const starDisplay = sessionStats.highestStarDrop > 0 ? '★'.repeat(sessionStats.highestStarDrop) : '☆';
  document.getElementById('statBestDrop').textContent = starDisplay;
}

// Toggle stats dashboard visibility
function toggleStatsDashboard() {
  const dashboard = document.getElementById('statsDashboard');
  if (dashboard.classList.contains('visible')) {
    dashboard.classList.remove('visible');
  } else {
    dashboard.classList.add('visible');
    updateStatsDashboard();
  }
}

// Death state
let playerDead = false;
let deathTimer = 0;
let lastKiller = null;
let lastKillerDamage = 0;

// Rift Surge tier costs
const RIFT_SURGE_COSTS = {
  1: 50,
  2: 75,
  3: 100
};

// Award shards on enemy kill
function awardShards(enemy) {
  // Shards only drop from boss kills (not during rift/domain)
  if (!enemy.isBoss || riftSurgeActive || echoDomainActive) {
    // Still track rift kills
    if (riftSurgeActive && enemy.isRift) {
      riftSurgeKills++;
      if (enemy.isElite && !enemy.isBoss) riftSurgeEliteKills++;
      if (enemy.isRiftBoss || enemy.isBoss) riftSurgeBossKills++;
    }
    return;
  }
  
  // Get difficulty index for bonus (0=easy, 1=normal, 2=hard, 3=elite, 4=nightmare, 5=core)
  const difficultyOrder = ['easy', 'normal', 'hard', 'elite', 'nightmare', 'core'];
  const diffIndex = difficultyOrder.indexOf(currentDifficulty);
  const diffBonus = diffIndex * 0.02; // +2% per difficulty tier
  
  // Rift Shards: 15% base + 2% per difficulty
  const riftChance = 0.15 + diffBonus;
  if (Math.random() < riftChance) {
    const amount = 1 + Math.floor(Math.random() * 3); // 1-3 shards
    shards.rift += amount;
    spawnShardParticle(enemy.x, enemy.y, '#8af', amount);
    addLog(`+${amount} Rift Shard${amount > 1 ? 's' : ''}!`, 'loot');
  }
  
  // Echo Shards: 10% base + 2% per difficulty
  const echoChance = 0.10 + diffBonus;
  if (Math.random() < echoChance) {
    const amount = 1 + Math.floor(Math.random() * 2); // 1-2 shards
    shards.echo += amount;
    spawnShardParticle(enemy.x, enemy.y, '#fa8', amount);
    addLog(`+${amount} Echo Shard${amount > 1 ? 's' : ''}!`, 'loot');
  }
  
  updateShardDisplays();
}

// Spawn shard particle effect
function spawnShardParticle(x, y, color, amount) {
  for (let i = 0; i < 3; i++) {
    particles.push({
      x: x + (Math.random() - 0.5) * 20,
      y: y + (Math.random() - 0.5) * 20,
      vx: (Math.random() - 0.5) * 2,
      vy: -2 - Math.random() * 2,
      color: color,
      life: 40,
      maxLife: 40,
      size: 4,
      type: 'shard'
    });
  }
  
  // Floating text
  damageNumbers.push({
    x: x,
    y: y - 20,
    text: `+${amount} 💎`,
    color: color,
    life: 50,
    vy: -1.5
  });
}

// Update shard display in UI
function updateShardDisplay() {
  const riftCount = document.getElementById('riftShardCount');
  if (riftCount) {
    riftCount.textContent = shards.rift.toLocaleString();
  }
  const echoCount = document.getElementById('echoShardCount');
  if (echoCount) {
    echoCount.textContent = shards.echo.toLocaleString();
  }
}

// Game state variables
let dungeon = { level: 1 };
let enemies = [];
let particles = [];
let progressOrbs = [];  // Purple orbs from GR boss kills that give progress
let loot = [];
let blood = [];
let camera = { x: 0, y: 0, shake: 0, zoom: 1.1 };
let frame = 0;
let exitPos = null;
let debugMode = false;  // Toggle with 'G' key for debugging
let testMode = false;  // Toggle with 'T' key for ability testing (disables auto-cast, infinite mana)
let enteringPortal = false;  // Prevent multiple portal entries

// ========== LOOT FILTER SYSTEM ==========
// Drop tiers: T1 (trash) to T5 (amazing) - VISUAL ONLY, not stored on items
// Calculate drop tier based on rarity, affixes, and affix quality
// Returns 1-5 (T1=trash, T5=amazing) - used ONLY for visuals
function calculateDropTier(item) {
  // DROP TIER SYSTEM (PoE-style)
  // Drop tier is rolled at drop time and determines item quality
  // 
  // If item already has a dropTier assigned, use it
  // Otherwise calculate based on mods (for legacy items)
  
  if (item.dropTier !== undefined) {
    return item.dropTier;
  }
  
  // Legacy calculation for items without dropTier
  const mods = item.mods || {};
  const allMods = [...(mods.prefixes || []), ...(mods.suffixes || [])];
  
  // Unique items always 4 stars
  if (item.rarity === 'unique') return 4;
  
  // No affixes = 0 stars
  if (allMods.length === 0) return 0;
  
  // Find best tier
  let bestTier = 8;
  allMods.forEach(mod => {
    if (mod.tier && mod.tier < bestTier) bestTier = mod.tier;
  });
  
  // Legacy star calc based on best tier and mod count
  const maxStarsByTier = { 1: 5, 2: 4, 3: 3, 4: 3, 5: 2, 6: 2, 7: 1, 8: 1 };
  const starCap = maxStarsByTier[bestTier] || 1;
  
  if (allMods.length >= 5) return starCap;
  if (allMods.length >= 3) return Math.max(0, starCap - 1);
  return Math.max(0, starCap - 2);
}

// Roll drop tier at loot creation time (0-5 stars)
// This determines item quality BEFORE affixes are generated
// CAPPED by difficulty - can't get high stars in easy content!
function rollDropTier(difficulty) {
  // MAX STARS BY DIFFICULTY
  // Stars are capped because higher stars require better affix tiers
  // which simply don't exist in lower difficulties
  //
  // | Difficulty | ilvl    | Best Affix | Max Stars |
  // |------------|---------|------------|-----------|
  // | Easy       | 1-20    | T6         | ★★        |
  // | Normal     | 21-30   | T5         | ★★★       |
  // | Hard       | 31-40   | T4         | ★★★★      |
  // | Elite      | 41-50   | T3         | ★★★★      |
  // | Nightmare  | 51-69   | T2         | ★★★★★     |
  // | Core       | 70+     | T1         | ★★★★★     |
  
  const maxStarsByDifficulty = {
    'easy': 2,
    'normal': 3,
    'hard': 4,
    'elite': 4,
    'nightmare': 5,
    'core': 5
  };
  
  const maxStars = maxStarsByDifficulty[difficulty] || 5;
  
  // BASE DROP RATES:
  // T0 (☆):     20%
  // T1 (★):     35%
  // T2 (★★):    25%
  // T3 (★★★):   12%
  // T4 (★★★★):  6%
  // T5 (★★★★★): 2%
  
  const roll = Math.random() * 100;
  let tier;
  
  if (roll < 20) tier = 0;       // 20% - T0
  else if (roll < 55) tier = 1;  // 35% - T1
  else if (roll < 80) tier = 2;  // 25% - T2
  else if (roll < 92) tier = 3;  // 12% - T3
  else if (roll < 98) tier = 4;  // 6%  - T4
  else tier = 5;                  // 2%  - T5
  
  // If rolled higher than difficulty allows, become TRASH (☆)
  // This makes lower difficulties feel punishing for "wasted luck"
  // and higher difficulties feel rewarding
  if (tier > maxStars) {
    return 0; // Trash!
  }
  
  return tier;
}

// Get drop tier constraints for item generation
function getDropTierConstraints(dropTier) {
  // DROP TIER → AFFIX CONSTRAINTS
  // Higher drop tier = better floor on affix tiers + more mods
  //
  // | Tier | Worst Affix | Mod Count | Tier Weight Bias |
  // |------|-------------|-----------|------------------|
  // | T0   | T8 (any)    | 0-1       | ×0.5 (worse)     |
  // | T1   | T8          | 1-2       | ×1.0             |
  // | T2   | T7          | 2-3       | ×1.5             |
  // | T3   | T6          | 3-4       | ×1.5             |
  // | T4   | T4          | 4-5       | ×2.0             |
  // | T5   | T2          | 5-6       | ×2.0             |
  
  const constraints = {
    0: { worstAffix: 8, minMods: 0, maxMods: 1, tierBias: 0.5 },
    1: { worstAffix: 8, minMods: 1, maxMods: 2, tierBias: 1.0 },
    2: { worstAffix: 7, minMods: 2, maxMods: 3, tierBias: 1.5 },
    3: { worstAffix: 6, minMods: 3, maxMods: 4, tierBias: 1.5 },
    4: { worstAffix: 4, minMods: 4, maxMods: 5, tierBias: 2.0 },
    5: { worstAffix: 2, minMods: 5, maxMods: 6, tierBias: 2.0 }
  };
  
  return constraints[dropTier] || constraints[1];
}

// Get drop tier visual properties (0-5 stars)
function getDropTierVisuals(tier) {
  const visuals = {
    0: { labelScale: 0.6, glowIntensity: 0.1, beamHeight: 0, color: '#333333', sound: 'normal', isT5: false, stars: '☆' },
    1: { labelScale: 0.7, glowIntensity: 0.3, beamHeight: 50, color: '#666666', sound: 'normal', isT5: false, stars: '★' },
    2: { labelScale: 0.85, glowIntensity: 0.6, beamHeight: 100, color: '#aaaaaa', sound: 'normal', isT5: false, stars: '★★' },
    3: { labelScale: 1.0, glowIntensity: 1.0, beamHeight: 160, color: '#ffff44', sound: 'magic', isT5: false, stars: '★★★' },
    4: { labelScale: 1.2, glowIntensity: 1.3, beamHeight: 220, color: '#ff8844', sound: 'rare', isT5: false, stars: '★★★★' },
    5: { labelScale: 1.5, glowIntensity: 2.0, beamHeight: 350, color: '#ffdd00', sound: 'legendary', isT5: true, stars: '★★★★★' }
  };
  return visuals[tier] || visuals[0];
}

// ========== POTION SYSTEM ==========
// Potions are unlimited, cooldown-based, auto-triggered - NOT inventory items
// Cooldowns are in REAL SECONDS, not frames
let potions = {
  life: {
    cooldown: 0,        // Seconds until next use allowed
    cooldownMax: 8.0,   // 8 seconds between uses
    threshold: 0.50,    // Auto-trigger when HP drops below 50%
    healPercent: 0.30   // Heals 30% of max HP
  },
  mana: {
    cooldown: 0,
    cooldownMax: 8.0,   // 8 seconds between uses
    threshold: 0.50,    // Auto-trigger when mana drops below 50%
    restorePercent: 0.80 // Restores 80% of max mana
  }
};

// Use life potion (auto or manual)
function useLifePotion() {
  if (potions.life.cooldown > 0) return false;
  if (player.hp >= player.maxHp) return false;
  
  const healAmount = Math.floor(player.maxHp * potions.life.healPercent);
  player.hp = Math.min(player.maxHp, player.hp + healAmount);
  potions.life.cooldown = potions.life.cooldownMax;
  
  // Visual feedback
  spawnDamageNumber(player.x, player.y - 30, '+' + healAmount, '#44ff44');
  addParticle({ x: player.x, y: player.y, vx: 0, vy: -2, life: 30, color: '#44ff44', size: 8 });
  
  updatePotionUI();
  return true;
}

// Use mana potion (auto or manual)
function useManaPotion() {
  if (potions.mana.cooldown > 0) return false;
  if (player.mana >= player.maxMana) return false;
  
  const restoreAmount = Math.floor(player.maxMana * potions.mana.restorePercent);
  player.mana = Math.min(player.maxMana, player.mana + restoreAmount);
  potions.mana.cooldown = potions.mana.cooldownMax;
  
  // Visual feedback
  spawnDamageNumber(player.x, player.y - 30, '+' + restoreAmount, '#4488ff');
  addParticle({ x: player.x, y: player.y, vx: 0, vy: -2, life: 30, color: '#4488ff', size: 8 });
  
  updatePotionUI();
  return true;
}

// No longer needed - potions are unlimited
function onEnemyKillPotionRecharge() {
  // Potions are now unlimited, no charges to restore
}

// Auto-trigger potions when thresholds are crossed
function updatePotions(deltaSeconds) {
  // Cooldown ticks (in real seconds)
  const lifeCdWasActive = potions.life.cooldown > 0;
  const manaCdWasActive = potions.mana.cooldown > 0;
  
  if (potions.life.cooldown > 0) potions.life.cooldown -= deltaSeconds;
  if (potions.mana.cooldown > 0) potions.mana.cooldown -= deltaSeconds;
  
  // Update UI while on cooldown (for radial animation) or when cooldown ends
  if (lifeCdWasActive || manaCdWasActive) {
    updatePotionUI();
  }
  
  // Auto-trigger life potion
  if (player.hp / player.maxHp < potions.life.threshold) {
    useLifePotion();
  }
  
  // Auto-trigger mana potion
  if (player.mana / player.maxMana < potions.mana.threshold) {
    useManaPotion();
  }
}

// Update potion UI display
function updatePotionUI() {
  // Update visual state (cooldown only, no charges)
  const lifeBtn = document.getElementById('lifePotionBtn');
  const manaBtn = document.getElementById('manaPotionBtn');
  const lifeRing = document.getElementById('lifeCooldownRing');
  const manaRing = document.getElementById('manaCooldownRing');
  
  if (lifeBtn) {
    const onCd = potions.life.cooldown > 0;
    lifeBtn.classList.toggle('on-cooldown', onCd);
    if (lifeRing && onCd) {
      const pct = (potions.life.cooldown / potions.life.cooldownMax) * 100;
      lifeRing.style.setProperty('--cooldown-pct', pct + '%');
    }
  }
  if (manaBtn) {
    const onCd = potions.mana.cooldown > 0;
    manaBtn.classList.toggle('on-cooldown', onCd);
    if (manaRing && onCd) {
      const pct = (potions.mana.cooldown / potions.mana.cooldownMax) * 100;
      manaRing.style.setProperty('--cooldown-pct', pct + '%');
    }
  }
}

let path = [];
let pathTarget = null;
let pathTimer = 0;
let stuckFrames = 0;
let lastX = 0, lastY = 0;

let damageNumbers = []; // Canvas-rendered damage numbers
let lootPopups = []; // Canvas-rendered loot popups
const MAX_LOOT_POPUPS = 15; // Safety limit to prevent memory issues

// Guardian hazards system
let guardianHazards = [];
const MAX_HAZARDS = 20;

// Spawn a tornado hazard that moves randomly and damages on contact
function spawnGuardianTornado(guardian) {
  if (guardianHazards.filter(h => h.type === 'tornado').length >= 3) return;
  
  const angle = Math.random() * Math.PI * 2;
  const dist = TILE * 3 + Math.random() * TILE * 3;
  guardianHazards.push({
    type: 'tornado',
    x: guardian.x + Math.cos(angle) * dist,
    y: guardian.y + Math.sin(angle) * dist,
    vx: (Math.random() - 0.5) * 2,
    vy: (Math.random() - 0.5) * 2,
    radius: 25,
    damage: Math.floor(guardian.abilityDamage * 0.4),  // 40% of ability damage
    lifetime: 8,
    rotation: 0,
    element: 'nature'
  });
  addLog('🌪️ Tornado spawned!', 'warning');
}

// Spawn a flamethrower beam from guardian toward player
function spawnGuardianFlamethrower(guardian) {
  if (guardianHazards.filter(h => h.type === 'flamethrower').length >= 1) return;
  
  const angle = Math.atan2(player.y - guardian.y, player.x - guardian.x);
  guardianHazards.push({
    type: 'flamethrower',
    x: guardian.x,
    y: guardian.y,
    angle: angle,
    length: 0,
    maxLength: TILE * 6,
    width: 30,
    damage: Math.floor(guardian.abilityDamage * 0.25),  // 25% of ability damage per tick
    lifetime: 2.5,
    guardianId: guardian.id,
    element: 'fire'
  });
  addLog('🔥 Flamethrower!', 'warning');
}

// Spawn ice explosion warning, then freeze zone
function spawnGuardianIceExplosion(guardian) {
  if (guardianHazards.filter(h => h.type === 'iceExplosion' || h.type === 'iceWarning').length >= 2) return;
  
  // Spawn at player position (delayed explosion)
  guardianHazards.push({
    type: 'iceWarning',
    x: player.x,
    y: player.y,
    radius: 60,
    warningTime: 1.2,
    damage: Math.floor(guardian.abilityDamage * 0.6),  // 60% of ability damage
    freezeDuration: 1.5,
    element: 'cold'
  });
}

// Spawn void zone that persists and damages
function spawnGuardianVoidZone(guardian) {
  if (guardianHazards.filter(h => h.type === 'voidZone').length >= 2) return;
  
  // Spawn between guardian and player
  const midX = (guardian.x + player.x) / 2 + (Math.random() - 0.5) * TILE * 2;
  const midY = (guardian.y + player.y) / 2 + (Math.random() - 0.5) * TILE * 2;
  guardianHazards.push({
    type: 'voidZone',
    x: midX,
    y: midY,
    radius: 50,
    damage: Math.floor(guardian.abilityDamage * 0.15),  // 15% of ability damage per pulse
    lifetime: 6,
    pulseTimer: 0,
    element: 'lightning'
  });
  addLog('⚫ Void zone appeared!', 'warning');
}

// Update all guardian hazards
function updateGuardianHazards(dt) {
  for (let i = guardianHazards.length - 1; i >= 0; i--) {
    const h = guardianHazards[i];
    
    switch (h.type) {
      case 'tornado':
        // Move randomly, bouncing off walls
        h.x += h.vx * dt * 60;
        h.y += h.vy * dt * 60;
        h.rotation += dt * 10;
        
        // Bounce off walls
        if (!isWalkable(h.x + h.vx * 30, h.y)) h.vx *= -1;
        if (!isWalkable(h.x, h.y + h.vy * 30)) h.vy *= -1;
        
        // Random direction changes
        if (Math.random() < 0.02) {
          h.vx += (Math.random() - 0.5) * 0.5;
          h.vy += (Math.random() - 0.5) * 0.5;
        }
        
        // Damage tick timer (every 0.4 seconds)
        h.damageTimer = (h.damageTimer || 0) + window.deltaSeconds;  // FIX: Use real seconds
        
        // Damage player on contact
        const tornadoDist = Math.hypot(player.x - h.x, player.y - h.y);
        if (tornadoDist < h.radius + 15 && !playerDead && !player.invulnerable && h.damageTimer >= 0.4) {
          applyHazardDamage(h.damage, h.element);
          h.damageTimer = 0;
        }
        
        h.lifetime -= window.deltaSeconds;  // FIX: Use real seconds
        break;
        
      case 'flamethrower':
        // Extend beam, track guardian position
        const guardian = enemies.find(e => e.id === h.guardianId);
        if (guardian && !guardian.dead) {
          h.x = guardian.x;
          h.y = guardian.y;
          // Slowly rotate toward player
          const targetAngle = Math.atan2(player.y - h.y, player.x - h.x);
          let angleDiff = targetAngle - h.angle;
          while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
          while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
          h.angle += angleDiff * window.deltaSeconds * 60 * 0.8;  // FIX: Frame-rate independent rotation
        }
        
        h.length = Math.min(h.maxLength, h.length + window.deltaSeconds * 60 * h.maxLength * 2);  // FIX: Frame-rate independent
        
        // Damage tick timer (every 0.3 seconds, not every frame!)
        h.damageTimer = (h.damageTimer || 0) + window.deltaSeconds;  // FIX: Use real seconds
        
        // Check if player is in beam
        const beamEndX = h.x + Math.cos(h.angle) * h.length;
        const beamEndY = h.y + Math.sin(h.angle) * h.length;
        const playerToBeamDist = pointToLineDist(player.x, player.y, h.x, h.y, beamEndX, beamEndY);
        if (playerToBeamDist < h.width / 2 + 15 && !playerDead && !player.invulnerable && h.damageTimer >= 0.3) {
          applyHazardDamage(h.damage, h.element);
          h.damageTimer = 0;
        }
        
        h.lifetime -= window.deltaSeconds;  // FIX: Use real seconds
        break;
        
      case 'iceWarning':
        h.warningTime -= window.deltaSeconds;  // FIX: Use real seconds
        if (h.warningTime <= 0) {
          // Convert to actual explosion
          guardianHazards.push({
            type: 'iceExplosion',
            x: h.x,
            y: h.y,
            radius: h.radius,
            damage: h.damage,
            freezeDuration: h.freezeDuration,
            lifetime: 0.3,
            element: 'cold'
          });
          guardianHazards.splice(i, 1);
          continue;
        }
        break;
        
      case 'iceExplosion':
        // Check if player is in explosion
        const iceDist = Math.hypot(player.x - h.x, player.y - h.y);
        if (iceDist < h.radius && !playerDead && !player.invulnerable && !h.hasHit) {
          applyHazardDamage(h.damage, h.element);
          // Freeze player briefly
          player.frozen = (player.frozen || 0) + h.freezeDuration;
          h.hasHit = true;
          addLog('❄️ Frozen!', 'warning');
        }
        h.lifetime -= window.deltaSeconds;  // FIX: Use real seconds
        break;
        
      case 'voidZone':
        h.pulseTimer += window.deltaSeconds;  // FIX: Use real seconds
        // Damage every 0.5 seconds
        if (h.pulseTimer >= 0.5) {
          h.pulseTimer = 0;
          const voidDist = Math.hypot(player.x - h.x, player.y - h.y);
          if (voidDist < h.radius && !playerDead && !player.invulnerable) {
            applyHazardDamage(h.damage, h.element);
          }
        }
        h.lifetime -= window.deltaSeconds;  // FIX: Use real seconds
        break;
    }
    
    // Remove expired hazards
    if (h.lifetime <= 0) {
      guardianHazards.splice(i, 1);
    }
  }
}

// Apply hazard damage with resistance calculation
function applyHazardDamage(baseDamage, element) {
  if (playerDead || testMode || player.invulnerable) return;
  if (player.inSanctuary && player.innerSanctuary) {
    baseDamage = Math.floor(baseDamage * (1 - player.innerSanctuary.damageReduction));
  }
  
  let resist = 0;
  if (element === 'fire') resist = Math.min(75, player.fireRes || 0);
  else if (element === 'cold') resist = Math.min(75, player.coldRes || 0);
  else if (element === 'lightning') resist = Math.min(75, player.lightRes || 0);
  else if (element === 'nature') resist = Math.min(75, player.natureRes || 0);
  
  const finalDamage = Math.max(1, Math.floor(baseDamage * (1 - resist / 100)));
  player.hp -= finalDamage;
  showDamage(player.x, player.y - 20, finalDamage, element === 'fire' ? '#ff6600' : element === 'cold' ? '#66ccff' : element === 'lightning' ? '#ffff00' : '#66ff66');
  
  if (player.hp <= 0) {
    player.hp = 0;
    playerDead = true;
    player.frozen = 0;  // Clear frozen state on death
    deathTimer = 10;  // 10 seconds to respawn
    document.getElementById('deathScreen').classList.add('visible');
    addLog('You have been slain by guardian hazards!', 'warning');
  }
}

// Helper: point to line segment distance
function pointToLineDist(px, py, x1, y1, x2, y2) {
  const A = px - x1;
  const B = py - y1;
  const C = x2 - x1;
  const D = y2 - y1;
  
  const dot = A * C + B * D;
  const lenSq = C * C + D * D;
  let param = -1;
  if (lenSq !== 0) param = dot / lenSq;
  
  let xx, yy;
  if (param < 0) { xx = x1; yy = y1; }
  else if (param > 1) { xx = x2; yy = y2; }
  else { xx = x1 + param * C; yy = y1 + param * D; }
  
  return Math.hypot(px - xx, py - yy);
}

// Draw all guardian hazards
function drawGuardianHazards(ctx) {
  for (const h of guardianHazards) {
    ctx.save();
    
    switch (h.type) {
      case 'tornado':
        // Spinning tornado effect
        ctx.translate(h.x, h.y);
        ctx.rotate(h.rotation);
        
        // Draw multiple rotating lines for tornado effect
        ctx.strokeStyle = '#88cc88';
        ctx.lineWidth = 3;
        ctx.globalAlpha = 0.7;
        for (let j = 0; j < 4; j++) {
          ctx.rotate(Math.PI / 2);
          ctx.beginPath();
          ctx.moveTo(0, -h.radius * 0.3);
          ctx.quadraticCurveTo(h.radius * 0.5, 0, 0, h.radius * 0.3);
          ctx.stroke();
        }
        
        // Center swirl
        ctx.fillStyle = '#aaffaa';
        ctx.globalAlpha = 0.5;
        ctx.beginPath();
        ctx.arc(0, 0, h.radius * 0.4, 0, Math.PI * 2);
        ctx.fill();
        break;
        
      case 'flamethrower':
        // Fire beam with gradient
        const beamEndX = h.x + Math.cos(h.angle) * h.length;
        const beamEndY = h.y + Math.sin(h.angle) * h.length;
        
        ctx.strokeStyle = '#ff4400';
        ctx.lineWidth = h.width;
        ctx.lineCap = 'round';
        ctx.globalAlpha = 0.6;
        ctx.beginPath();
        ctx.moveTo(h.x, h.y);
        ctx.lineTo(beamEndX, beamEndY);
        ctx.stroke();
        
        // Inner bright core
        ctx.strokeStyle = '#ffaa00';
        ctx.lineWidth = h.width * 0.5;
        ctx.globalAlpha = 0.8;
        ctx.beginPath();
        ctx.moveTo(h.x, h.y);
        ctx.lineTo(beamEndX, beamEndY);
        ctx.stroke();
        
        // Fire particles along beam
        ctx.fillStyle = '#ffcc00';
        for (let j = 0; j < 5; j++) {
          const t = Math.random();
          const px = h.x + (beamEndX - h.x) * t + (Math.random() - 0.5) * h.width * 0.5;
          const py = h.y + (beamEndY - h.y) * t + (Math.random() - 0.5) * h.width * 0.5;
          ctx.globalAlpha = 0.8 * Math.random();
          ctx.beginPath();
          ctx.arc(px, py, 3 + Math.random() * 4, 0, Math.PI * 2);
          ctx.fill();
        }
        break;
        
      case 'iceWarning':
        // Pulsing warning circle
        const pulse = Math.sin(Date.now() * 0.015) * 0.3 + 0.5;
        ctx.strokeStyle = '#66ccff';
        ctx.lineWidth = 3;
        ctx.globalAlpha = pulse;
        ctx.setLineDash([10, 5]);
        ctx.beginPath();
        ctx.arc(h.x, h.y, h.radius, 0, Math.PI * 2);
        ctx.stroke();
        ctx.setLineDash([]);
        
        // Fill warning
        ctx.fillStyle = '#66ccff';
        ctx.globalAlpha = pulse * 0.2;
        ctx.beginPath();
        ctx.arc(h.x, h.y, h.radius, 0, Math.PI * 2);
        ctx.fill();
        break;
        
      case 'iceExplosion':
        // Expanding ice burst
        const expandScale = 1 + (0.3 - h.lifetime) * 2;
        ctx.fillStyle = '#aaddff';
        ctx.globalAlpha = h.lifetime / 0.3;
        ctx.beginPath();
        ctx.arc(h.x, h.y, h.radius * expandScale, 0, Math.PI * 2);
        ctx.fill();
        
        // Ice shards
        ctx.strokeStyle = '#ffffff';
        ctx.lineWidth = 2;
        for (let j = 0; j < 8; j++) {
          const shardAngle = (j / 8) * Math.PI * 2 + Date.now() * 0.001;
          const shardLen = h.radius * expandScale * 0.8;
          ctx.beginPath();
          ctx.moveTo(h.x, h.y);
          ctx.lineTo(h.x + Math.cos(shardAngle) * shardLen, h.y + Math.sin(shardAngle) * shardLen);
          ctx.stroke();
        }
        break;
        
      case 'voidZone':
        // Dark pulsing circle
        const voidPulse = Math.sin(Date.now() * 0.008) * 0.2 + 0.6;
        
        // Outer glow
        ctx.fillStyle = '#4400aa';
        ctx.globalAlpha = voidPulse * 0.3;
        ctx.beginPath();
        ctx.arc(h.x, h.y, h.radius * 1.3, 0, Math.PI * 2);
        ctx.fill();
        
        // Main zone
        ctx.fillStyle = '#220044';
        ctx.globalAlpha = voidPulse * 0.6;
        ctx.beginPath();
        ctx.arc(h.x, h.y, h.radius, 0, Math.PI * 2);
        ctx.fill();
        
        // Inner swirl
        ctx.strokeStyle = '#8844ff';
        ctx.lineWidth = 2;
        ctx.globalAlpha = voidPulse;
        ctx.beginPath();
        ctx.arc(h.x, h.y, h.radius * 0.6, Date.now() * 0.003, Date.now() * 0.003 + Math.PI);
        ctx.stroke();
        break;
    }
    
    ctx.restore();
  }
}

// Process guardian mechanics each frame
function processGuardianMechanics(dt) {
  if (!greaterRiftGuardianSpawned || !greaterRiftGuardian || greaterRiftGuardian.dead) {
    // Clear hazards when guardian dies
    if (guardianHazards.length > 0 && (!greaterRiftGuardian || greaterRiftGuardian.dead)) {
      guardianHazards = [];
    }
    return;
  }
  
  const g = greaterRiftGuardian;
  if (!g.mechanicTimers) return;
  
  // Base cooldown scales with GR level (faster at higher levels)
  const cooldownMult = Math.max(0.5, 1 - greaterRiftLevel * 0.005);
  
  // Process each mechanic this guardian has
  for (const mechanic of g.mechanics) {
    g.mechanicTimers[mechanic] -= window.deltaSeconds;  // FIX: Use real seconds
    
    if (g.mechanicTimers[mechanic] <= 0) {
      switch (mechanic) {
        case 'tornado':
          spawnGuardianTornado(g);
          g.mechanicTimers.tornado = (4 + Math.random() * 3) * cooldownMult;
          break;
        case 'flamethrower':
          spawnGuardianFlamethrower(g);
          g.mechanicTimers.flamethrower = (6 + Math.random() * 4) * cooldownMult;
          break;
        case 'iceExplosion':
          spawnGuardianIceExplosion(g);
          g.mechanicTimers.iceExplosion = (5 + Math.random() * 3) * cooldownMult;
          break;
        case 'voidZone':
          spawnGuardianVoidZone(g);
          g.mechanicTimers.voidZone = (7 + Math.random() * 4) * cooldownMult;
          break;
      }
    }
  }
}

// Skill selector state
let skillSelectorOpen = false;
let selectedSlotIndex = -1;

// Use skill from slot
function useSkillSlot(slotIndex) {
  const skillId = equippedSkills[slotIndex];
  if (skillId) useSkill(skillId);
}

// Open skill selector panel
function openSkillSelector(slotIndex, event) {
  if (event) event.preventDefault();
  selectedSlotIndex = slotIndex;
  skillSelectorOpen = true;
  
  const panel = document.getElementById('skillSelector');
  const grid = document.getElementById('skillSelectorGrid');
  
  // Get skills for current player class
  const classSkills = CLASS_SKILLS[player.class] || CLASS_SKILLS.monk;
  const classPassives = CLASS_PASSIVES[player.class] || CLASS_PASSIVES.monk;
  
  // Slot 0 = PRIMARY SLOT (only primary skills)
  // Slots 1-3 = active skills (only non-primary skills)
  // Slot 4 = PASSIVE SLOT (only passive skills)
  const isPrimarySlot = slotIndex === 0;
  const isPassiveSlot = slotIndex === 4;
  
  // Update panel title to indicate slot type
  const title = panel.querySelector('h3');
  if (title) {
    if (isPrimarySlot) {
      title.textContent = 'Select Primary Skill (Slot 1)';
    } else if (isPassiveSlot) {
      title.textContent = 'Select Passive Skill (Slot 5)';
    } else {
      title.textContent = `Select Active Skill (Slot ${slotIndex + 1})`;
    }
  }
  
  // Populate grid with class-appropriate skills
  grid.innerHTML = '';
  
  if (isPassiveSlot) {
    // Show only passive skills for this class
    classPassives.forEach(skillId => {
      const skillData = SKILL_GEM_DATA[skillId];
      const skillDef = SKILLS[skillId];
      if (!skillData || !skillDef) return;
      
      // Check if skill is locked
      const unlockLevel = skillDef.unlockLevel || 1;
      const isLocked = player.level < unlockLevel;
      
      const isCurrentSlot = equippedSkills[slotIndex] === skillId;
      const skillXP = (player.skillLevels && player.skillLevels[skillId]) || 0;
      const skillLevel = getSkillLevel(skillXP);
      const isHighLevel = skillLevel >= 10;
      
      // Use image if available, otherwise emoji
      const iconHtml = skillDef.imageUrl 
        ? `<img class="skill-select-icon-img" src="${skillDef.imageUrl}" alt="${skillData.name}" draggable="false">`
        : `<span class="skill-select-icon">${skillData.icon}</span>`;
      
      const item = document.createElement('div');
      item.className = 'skill-select-item' + (isCurrentSlot ? ' selected' : '') + (isLocked ? ' locked' : '');
      item.innerHTML = `
        ${isLocked ? `<span class="skill-lock-badge">🔒 Lv${unlockLevel}</span>` : `<span class="skill-level-badge ${isHighLevel ? 'high' : ''}">${skillLevel}</span>`}
        ${iconHtml}
        <span class="skill-select-name">${skillData.name}</span>
        ${isLocked ? `<span class="skill-locked-text">Unlock at Level ${unlockLevel}</span>` : `<span class="skill-passive-badge">${skillDef.passiveType?.toUpperCase() || 'PASSIVE'}</span>`}
      `;
      
      if (!isLocked) {
        item.onclick = () => selectSkillForSlot(skillId);
      }
      item.onmouseenter = (e) => showSkillTooltip(skillId, e);
      item.onmouseleave = hideSkillTooltip;
      
      grid.appendChild(item);
    });
  } else {
    // Show regular skills (primaries for slot 0, non-primaries for slots 1-3)
    classSkills.forEach(skillId => {
      const skillData = SKILL_GEM_DATA[skillId];
      const skillDef = SKILLS[skillId];
      if (!skillData) return;
      
      // Skip passives in regular slots
      if (skillDef && skillDef.isPassive) return;
      
      // Filter by primary/non-primary
      const isSkillPrimary = skillDef && skillDef.isPrimary;
      if (isPrimarySlot && !isSkillPrimary) return; // Only show primaries in slot 0
      if (!isPrimarySlot && isSkillPrimary) return;  // Only show non-primaries in slots 1-3
      
      // Check if skill is locked
      const unlockLevel = skillDef?.unlockLevel || 1;
      const isLocked = player.level < unlockLevel;
      
      const isEquipped = equippedSkills.includes(skillId) && equippedSkills[slotIndex] !== skillId;
      const isCurrentSlot = equippedSkills[slotIndex] === skillId;
      const skillXP = (player.skillLevels && player.skillLevels[skillId]) || 0;
      const skillLevel = getSkillLevel(skillXP);
      const isHighLevel = skillLevel >= 10;
      
      // Use image if available, otherwise emoji
      const iconHtml = skillDef?.imageUrl 
        ? `<img class="skill-select-icon-img" src="${skillDef.imageUrl}" alt="${skillData.name}" draggable="false">`
        : `<span class="skill-select-icon">${skillData.icon}</span>`;
      
      const item = document.createElement('div');
      item.className = 'skill-select-item' + (isEquipped ? ' equipped' : '') + (isCurrentSlot ? ' selected' : '') + (isLocked ? ' locked' : '');
      item.innerHTML = `
        ${isLocked ? `<span class="skill-lock-badge">🔒 Lv${unlockLevel}</span>` : `<span class="skill-level-badge ${isHighLevel ? 'high' : ''}">${skillLevel}</span>`}
        ${iconHtml}
        <span class="skill-select-name">${skillData.name}</span>
        ${isLocked ? `<span class="skill-locked-text">Unlock at Level ${unlockLevel}</span>` : (isSkillPrimary ? '<span class="skill-primary-badge">PRIMARY</span>' : '')}
      `;
      
      if (!isEquipped && !isLocked) {
        item.onclick = () => selectSkillForSlot(skillId);
      }
      item.onmouseenter = (e) => showSkillTooltip(skillId, e);
      item.onmouseleave = hideSkillTooltip;
      
      grid.appendChild(item);
    });
  }
  
  panel.classList.add('visible');
  updateHotkeyLegend();
}

// Close skill selector
function closeSkillSelector() {
  skillSelectorOpen = false;
  selectedSlotIndex = -1;
  document.getElementById('skillSelector').classList.remove('visible');
  hideSkillTooltip();
  updateHotkeyLegend();
}

// Select a skill for the slot
function selectSkillForSlot(skillId) {
  if (selectedSlotIndex < 0) return;
  
  equippedSkills[selectedSlotIndex] = skillId;
  
  // Update the skill slot UI
  const slot = document.getElementById(`skill-slot-${selectedSlotIndex}`);
  const skillData = SKILLS[skillId];
  const gemData = SKILL_GEM_DATA[skillId];
  updateSkillSlotIcon(slot, skillData, gemData);
  
  // Check if this is a passive skill
  const skillDef = SKILLS[skillId];
  if (skillDef && skillDef.isPassive) {
    // Recalculate stats to apply passive bonuses
    recalculateStats();
    updateCharPanel(); // Update stat display
    addLog(`Passive: ${SKILL_GEM_DATA[skillId].name}`, 'skill');
  } else {
    addLog(`Slot ${selectedSlotIndex + 1}: ${SKILL_GEM_DATA[skillId].name}`, 'skill');
  }
  
  closeSkillSelector();
}

// Show tooltip for skill slot
function showSkillSlotTooltip(slotIndex, event) {
  const skillId = equippedSkills[slotIndex];
  if (skillId) showSkillTooltip(skillId, event);
}

function useSkill(skillId) {
  const skill = SKILLS[skillId];
  if (!skill) return;
  
  // Primary skills use player's attack/cast cooldown (in seconds)
  if (skill.isPrimary) {
    if (skill.isSpell) {
      // Spell primaries use cast speed
      if (player.castCD > 0) return;  // Not ready yet - fail silently
      player.castCD = 1.0 / (player.castSpd || 1);  // Cooldown in seconds
    } else {
      // Attack primaries use attack speed
      if (player.atkCD > 0) return;  // Not ready yet - fail silently
      player.atkCD = 1.0 / player.atkSpd;  // Cooldown in seconds
    }
    player.atkAnim = 20;  // Attack animation (visual frames)
    player.skillAnimProgress = 1.0; // Start animation at full
  } else {
    // Regular skills use their own cooldown
    if (skill.cooldown > 0) {
      addLog(`${skill.name} on cooldown!`, 'warning');
      return;
    }
    
    if (player.mana < skill.manaCost) {
      addLog('Not enough mana!', 'warning');
      return;
    }
    
    player.mana -= skill.manaCost;
    // Convert maxCooldown from frames to seconds (maxCooldown is in frames at 60fps)
    let baseCooldown = skill.maxCooldown / 60;
    
    // Aspect of Radiant Speed: Wave of Light cooldown halved
    if (skillId === 'waveOfLight' && isAspectActive('wave_of_light_speed')) {
      baseCooldown = baseCooldown * 0.5;
    }
    
    skill.cooldown = testMode ? (10/60) : baseCooldown;
  }
  
  // Get tier multiplier from equipped skill gems
  const equippedGem = equippedSkillGems.find(g => g.skill === skillId);
  const tier = equippedGem ? equippedGem.tier : 1;
  const tierMultiplier = SKILL_GEM_DATA[skillId]?.tiers?.[tier] || 1;
  
  // Calculate base damage - spells use spell damage, attacks use weapon damage
  // Safety: ensure we always have valid damage values
  const avgWeaponDmg = Math.max(1, (player.minDmg || 1) + (player.maxDmg || 2)) / 2;
  const baseDmg = skill.isSpell 
    ? Math.max(1, player.spellDmg || avgWeaponDmg)
    : avgWeaponDmg;
  
  // Safety: ensure skill.damage has a default
  const skillDamageMult = skill.damage || 1;
  
  switch(skillId) {
    // ============ PRIMARY SKILLS (No Mana Cost) ============
    case 'fistsOfThunderPrimary':
      // Monk primary - lightning punches with dash and every 3rd hit AoE
      player.skillAnimType = 'punch';
      if (!player.fistsComboCount) player.fistsComboCount = 0;
      player.fistsComboCount++;
      
      let fistsTarget = findNearestEnemy(skill.engageRange || 120);
      if (fistsTarget) {
        const distToTarget = Math.hypot(fistsTarget.x - player.x, fistsTarget.y - player.y);
        const meleeRange = skill.radius || 45;
        const minDashDistance = 30;  // Don't micro-dash for tiny distances
        
        // Initialize dash cooldown if not set
        if (!player.fistsDashCD) player.fistsDashCD = 0;
        
        // DASH to target if outside melee range (with minimum distance and internal cooldown)
        const dashDist = distToTarget - meleeRange * 0.7;
        if (distToTarget > meleeRange && distToTarget <= (skill.engageRange || 120) 
            && dashDist >= minDashDistance && player.fistsDashCD <= 0) {
          const angle = Math.atan2(fistsTarget.y - player.y, fistsTarget.x - player.x);
          const startX = player.x;
          const startY = player.y;
          
          player.x += Math.cos(angle) * dashDist;
          player.y += Math.sin(angle) * dashDist;
          
          // Set internal dash cooldown (0.3 seconds)
          player.fistsDashCD = 0.3;
          
          // Lightning trail effect
          const steps = Math.min(6, Math.floor(dashDist / 20));
          for (let i = 0; i < steps; i++) {
            const t = i / steps;
            addParticle({
              x: startX + (player.x - startX) * t,
              y: startY + (player.y - startY) * t,
              vx: (Math.random() - 0.5) * 3, vy: (Math.random() - 0.5) * 3,
              life: 10 + i * 2,
              color: '#88ddff',
              size: 3
            });
          }
        }
        
        // Base damage hit
        const dmg = Math.floor(baseDmg * (skill.damage || 1) * tierMultiplier);
        fistsTarget.hp -= dmg;
        fistsTarget.flash = 8;
        player.facing = fistsTarget.x > player.x ? 1 : -1;
        spawnDamageNumber(fistsTarget.x, fistsTarget.y, dmg, '#88ddff');
        updateBossBarOnHit(fistsTarget);  // Show boss bar if hitting boss
        
        // Lightning punch particles
        for (let i = 0; i < 4; i++) {
          addParticle({
            x: fistsTarget.x + (Math.random() - 0.5) * 20,
            y: fistsTarget.y + (Math.random() - 0.5) * 20,
            vx: (Math.random() - 0.5) * 6,
            vy: (Math.random() - 0.5) * 6,
            life: 12,
            color: i % 2 ? '#aaeeff' : '#ffffff',
            size: 3
          });
        }
        
        // Every 3rd hit: chain lightning burst
        if (player.fistsComboCount >= 3) {
          player.fistsComboCount = 0;
          const coneDmg = Math.floor(baseDmg * (skill.thirdHitDamage || 1.5) * tierMultiplier);
          let chainTargets = [fistsTarget];
          
          // Find chain targets - any nearby enemies (wider search)
          enemies.forEach(e => {
            if (!e.dead && e !== fistsTarget && chainTargets.length < (skill.chainTargets || 3)) {
              const dist = Math.hypot(e.x - fistsTarget.x, e.y - fistsTarget.y);
              if (dist < 150) { // Chain FROM the target, not player
                chainTargets.push(e);
              }
            }
          });
          
          // Apply chain lightning damage with OBVIOUS visuals
          chainTargets.forEach((target, idx) => {
            const chainDmg = Math.floor(coneDmg * (1 - idx * 0.15)); // Slight falloff
            target.hp -= chainDmg;
            target.flash = 15;
            spawnDamageNumber(target.x, target.y - (idx * 10), chainDmg, idx === 0 ? '#ffffff' : '#44ddff');
            
            // Chain lightning visual - MUCH more obvious
            if (idx > 0) {
              const prev = chainTargets[idx - 1];
              // Draw thick lightning bolt between targets
              const segments = 8;
              for (let i = 0; i < segments; i++) {
                const t = i / segments;
                const jitter = (i > 0 && i < segments - 1) ? (Math.random() - 0.5) * 20 : 0;
                addParticle({
                  x: prev.x + (target.x - prev.x) * t + jitter,
                  y: prev.y + (target.y - prev.y) * t + jitter,
                  vx: (Math.random() - 0.5) * 2, 
                  vy: (Math.random() - 0.5) * 2, 
                  life: 15, 
                  color: i % 2 === 0 ? '#ffffff' : '#88ffff', 
                  size: 5
                });
              }
              // Extra bright core particles
              addParticle({
                x: target.x, y: target.y,
                vx: 0, vy: 0, life: 12, color: '#ffffff', size: 8
              });
            }
            checkEnemyDeath(target);
          });
          
          // Big shockwave burst from player
          for (let i = 0; i < 16; i++) {
            const burstAngle = (i / 16) * Math.PI * 2;
            addParticle({
              x: player.x + Math.cos(burstAngle) * 25,
              y: player.y + Math.sin(burstAngle) * 25,
              vx: Math.cos(burstAngle) * 6,
              vy: Math.sin(burstAngle) * 6,
              life: 18, color: i % 2 === 0 ? '#aaffff' : '#ffffff', size: 5
            });
          }
          
          // Log chain count
          if (chainTargets.length > 1) {
            addLog(`CHAIN LIGHTNING! (${chainTargets.length} targets)`, 'skill');
          }
          camera.shake = Math.max(camera.shake, 5);
        }
        
        checkEnemyDeath(fistsTarget);
      }
      break;
      
    case 'wayOfTheGlacier':
      // Monk Cold Primary - Ice strikes with freeze
      player.skillAnimType = 'punch';
      if (!player.glacierComboCount) player.glacierComboCount = 0;
      player.glacierComboCount++;
      
      let glacierTarget = findNearestEnemy(skill.engageRange || 200);
      if (glacierTarget) {
        const distToTarget = Math.hypot(glacierTarget.x - player.x, glacierTarget.y - player.y);
        const meleeRange = skill.radius || 45;
        const minDashDistance = 30;
        if (!player.glacierDashCD) player.glacierDashCD = 0;
        
        // DASH to target - icy trail
        const dashDist = distToTarget - meleeRange * 0.7;
        if (distToTarget > meleeRange && distToTarget <= (skill.engageRange || 200) 
            && dashDist >= minDashDistance && player.glacierDashCD <= 0) {
          const angle = Math.atan2(glacierTarget.y - player.y, glacierTarget.x - player.x);
          const startX = player.x, startY = player.y;
          player.x += Math.cos(angle) * dashDist;
          player.y += Math.sin(angle) * dashDist;
          player.glacierDashCD = 0.3;
          
          // Ice trail effect
          const steps = Math.min(6, Math.floor(dashDist / 20));
          for (let i = 0; i < steps; i++) {
            const t = i / steps;
            addParticle({
              x: startX + (player.x - startX) * t, y: startY + (player.y - startY) * t,
              vx: (Math.random() - 0.5) * 2, vy: (Math.random() - 0.5) * 2,
              life: 15, color: i % 2 ? '#aaeeff' : '#88ccff', size: 4
            });
          }
        }
        
        // Base damage
        const glacierDmg = Math.floor(baseDmg * (skill.damage || 1) * tierMultiplier);
        glacierTarget.hp -= glacierDmg;
        glacierTarget.flash = 8;
        player.facing = glacierTarget.x > player.x ? 1 : -1;
        spawnDamageNumber(glacierTarget.x, glacierTarget.y, glacierDmg, '#88ccff');
        updateBossBarOnHit(glacierTarget);
        
        // Freeze chance on normal hits
        if (Math.random() < (skill.freezeChance || 0.15) && !glacierTarget.isBoss) {
          glacierTarget.frozen = (skill.freezeDuration || 45) / 60;
        }
        
        // Ice particles
        for (let i = 0; i < 4; i++) {
          addParticle({
            x: glacierTarget.x + (Math.random() - 0.5) * 20,
            y: glacierTarget.y + (Math.random() - 0.5) * 20,
            vx: (Math.random() - 0.5) * 4, vy: -2 - Math.random() * 2,
            life: 15, color: i % 2 ? '#ccffff' : '#88ddff', size: 3
          });
        }
        
        // Every 3rd hit: freezing nova
        if (player.glacierComboCount >= 3) {
          player.glacierComboCount = 0;
          const novaDmg = Math.floor(baseDmg * (skill.thirdHitDamage || 1.5) * tierMultiplier);
          
          enemies.forEach(e => {
            if (!e.dead && Math.hypot(e.x - player.x, e.y - player.y) < 80) {
              e.hp -= novaDmg;
              e.flash = 12;
              spawnDamageNumber(e.x, e.y, novaDmg, '#66eeff');
              // High freeze chance on 3rd hit
              if (Math.random() < (skill.thirdHitFreeze || 0.5) && !e.isBoss) {
                e.frozen = (skill.freezeDuration || 45) / 60;
              }
              checkEnemyDeath(e);
            }
          });
          
          // Nova visual
          for (let i = 0; i < 12; i++) {
            const novaAngle = (i / 12) * Math.PI * 2;
            addParticle({
              x: player.x + Math.cos(novaAngle) * 40, y: player.y + Math.sin(novaAngle) * 40,
              vx: Math.cos(novaAngle) * 4, vy: Math.sin(novaAngle) * 4,
              life: 18, color: '#aaffff', size: 5
            });
          }
          camera.shake = Math.max(camera.shake, 4);
        }
        checkEnemyDeath(glacierTarget);
      }
      break;
      
    case 'blazingFists':
      // Monk Fire Primary - Fire strikes with ignite
      player.skillAnimType = 'punch';
      if (!player.blazingComboCount) player.blazingComboCount = 0;
      player.blazingComboCount++;
      
      let blazeTarget = findNearestEnemy(skill.engageRange || 200);
      if (blazeTarget) {
        const distToTarget = Math.hypot(blazeTarget.x - player.x, blazeTarget.y - player.y);
        const meleeRange = skill.radius || 45;
        const minDashDistance = 30;
        if (!player.blazeDashCD) player.blazeDashCD = 0;
        
        // DASH to target - fire trail
        const dashDist = distToTarget - meleeRange * 0.7;
        if (distToTarget > meleeRange && distToTarget <= (skill.engageRange || 200) 
            && dashDist >= minDashDistance && player.blazeDashCD <= 0) {
          const angle = Math.atan2(blazeTarget.y - player.y, blazeTarget.x - player.x);
          const startX = player.x, startY = player.y;
          player.x += Math.cos(angle) * dashDist;
          player.y += Math.sin(angle) * dashDist;
          player.blazeDashCD = 0.3;
          
          // Fire trail effect
          const steps = Math.min(6, Math.floor(dashDist / 20));
          for (let i = 0; i < steps; i++) {
            const t = i / steps;
            addParticle({
              x: startX + (player.x - startX) * t, y: startY + (player.y - startY) * t,
              vx: (Math.random() - 0.5) * 2, vy: -1 - Math.random(),
              life: 12, color: i % 2 ? '#ff8844' : '#ffaa22', size: 4
            });
          }
        }
        
        // Base damage
        const blazeDmg = Math.floor(baseDmg * (skill.damage || 1) * tierMultiplier);
        blazeTarget.hp -= blazeDmg;
        blazeTarget.flash = 8;
        player.facing = blazeTarget.x > player.x ? 1 : -1;
        spawnDamageNumber(blazeTarget.x, blazeTarget.y, blazeDmg, '#ff6622');
        updateBossBarOnHit(blazeTarget);
        
        // Fire particles
        for (let i = 0; i < 5; i++) {
          addParticle({
            x: blazeTarget.x + (Math.random() - 0.5) * 20,
            y: blazeTarget.y + (Math.random() - 0.5) * 20,
            vx: (Math.random() - 0.5) * 4, vy: -2 - Math.random() * 3,
            life: 15, color: i % 2 ? '#ff4400' : '#ffaa00', size: 4
          });
        }
        
        // Every 3rd hit: fire explosion + ignite
        if (player.blazingComboCount >= 3) {
          player.blazingComboCount = 0;
          const explodeDmg = Math.floor(baseDmg * (skill.thirdHitDamage || 1.5) * tierMultiplier);
          const burnRadius = skill.burnRadius || 60;
          
          enemies.forEach(e => {
            if (!e.dead && Math.hypot(e.x - player.x, e.y - player.y) < burnRadius) {
              e.hp -= explodeDmg;
              e.flash = 15;
              spawnDamageNumber(e.x, e.y, explodeDmg, '#ff4400');
              // Apply burn DoT
              e.burning = (skill.burnDuration || 60) / 60;
              e.burnDamage = baseDmg * (skill.burnDamage || 0.3) * tierMultiplier;
              checkEnemyDeath(e);
            }
          });
          
          // Explosion visual
          for (let i = 0; i < 16; i++) {
            const expAngle = (i / 16) * Math.PI * 2;
            addParticle({
              x: player.x + Math.cos(expAngle) * 30, y: player.y + Math.sin(expAngle) * 30,
              vx: Math.cos(expAngle) * 6, vy: Math.sin(expAngle) * 6 - 2,
              life: 20, color: i % 3 === 0 ? '#ffff44' : (i % 3 === 1 ? '#ff8800' : '#ff4400'), size: 5
            });
          }
          camera.shake = Math.max(camera.shake, 5);
        }
        checkEnemyDeath(blazeTarget);
      }
      break;
      
    case 'jadeWindStrike':
      // Monk Nature Primary - Healing strikes
      player.skillAnimType = 'punch';
      if (!player.jadeComboCount) player.jadeComboCount = 0;
      player.jadeComboCount++;
      
      let jadeTarget = findNearestEnemy(skill.engageRange || 200);
      if (jadeTarget) {
        const distToTarget = Math.hypot(jadeTarget.x - player.x, jadeTarget.y - player.y);
        const meleeRange = skill.radius || 45;
        const minDashDistance = 30;
        if (!player.jadeDashCD) player.jadeDashCD = 0;
        
        // DASH to target - nature wind
        const dashDist = distToTarget - meleeRange * 0.7;
        if (distToTarget > meleeRange && distToTarget <= (skill.engageRange || 200) 
            && dashDist >= minDashDistance && player.jadeDashCD <= 0) {
          const angle = Math.atan2(jadeTarget.y - player.y, jadeTarget.x - player.x);
          const startX = player.x, startY = player.y;
          player.x += Math.cos(angle) * dashDist;
          player.y += Math.sin(angle) * dashDist;
          player.jadeDashCD = 0.3;
          
          // Nature wind effect
          const steps = Math.min(6, Math.floor(dashDist / 20));
          for (let i = 0; i < steps; i++) {
            const t = i / steps;
            addParticle({
              x: startX + (player.x - startX) * t, y: startY + (player.y - startY) * t,
              vx: (Math.random() - 0.5) * 2, vy: (Math.random() - 0.5) * 2,
              life: 12, color: i % 2 ? '#88dd88' : '#aaffaa', size: 3
            });
          }
        }
        
        // Base damage + heal on hit
        const jadeDmg = Math.floor(baseDmg * (skill.damage || 1) * tierMultiplier);
        jadeTarget.hp -= jadeDmg;
        jadeTarget.flash = 8;
        player.facing = jadeTarget.x > player.x ? 1 : -1;
        spawnDamageNumber(jadeTarget.x, jadeTarget.y, jadeDmg, '#88dd88');
        updateBossBarOnHit(jadeTarget);
        
        // Heal on hit
        const healAmount = Math.floor(player.maxHp * (skill.healOnHit || 0.01));
        player.hp = Math.min(player.maxHp, player.hp + healAmount);
        
        // Nature particles
        for (let i = 0; i < 4; i++) {
          addParticle({
            x: jadeTarget.x + (Math.random() - 0.5) * 20,
            y: jadeTarget.y + (Math.random() - 0.5) * 20,
            vx: (Math.random() - 0.5) * 3, vy: -1 - Math.random() * 2,
            life: 15, color: i % 2 ? '#66cc66' : '#99ff99', size: 3
          });
        }
        
        // Every 3rd hit: healing burst AoE
        if (player.jadeComboCount >= 3) {
          player.jadeComboCount = 0;
          const burstDmg = Math.floor(baseDmg * (skill.thirdHitDamage || 1.5) * tierMultiplier);
          const burstRadius = skill.thirdHitRadius || 80;
          
          // Big heal on 3rd hit
          const bigHeal = Math.floor(player.maxHp * (skill.thirdHitHeal || 0.05));
          player.hp = Math.min(player.maxHp, player.hp + bigHeal);
          spawnDamageNumber(player.x, player.y - 30, '+' + bigHeal, '#88ff88');
          
          enemies.forEach(e => {
            if (!e.dead && Math.hypot(e.x - player.x, e.y - player.y) < burstRadius) {
              e.hp -= burstDmg;
              e.flash = 12;
              spawnDamageNumber(e.x, e.y, burstDmg, '#66dd66');
              checkEnemyDeath(e);
            }
          });
          
          // Healing wind visual
          for (let i = 0; i < 12; i++) {
            const windAngle = (i / 12) * Math.PI * 2;
            addParticle({
              x: player.x + Math.cos(windAngle) * 40, y: player.y + Math.sin(windAngle) * 40,
              vx: Math.cos(windAngle) * 3, vy: Math.sin(windAngle) * 3 - 1,
              life: 20, color: '#aaffaa', size: 5
            });
          }
          // Healing particles on player
          for (let i = 0; i < 8; i++) {
            addParticle({
              x: player.x + (Math.random() - 0.5) * 30, y: player.y + 10,
              vx: (Math.random() - 0.5) * 2, vy: -2 - Math.random() * 2,
              life: 25, color: '#88ff88', size: 4
            });
          }
          camera.shake = Math.max(camera.shake, 3);
        }
        checkEnemyDeath(jadeTarget);
      }
      break;
      
    case 'basicSlash':
      // Warrior basic melee attack
      player.skillAnimType = 'slash';
      let slashTarget = findNearestEnemy(70);
      if (slashTarget) {
        const dmg = Math.floor((player.minDmg + player.maxDmg) / 2 * (skill.damage || 1) * tierMultiplier);
        slashTarget.hp -= dmg;
        slashTarget.flash = 10;
        spawnDamageNumber(slashTarget.x, slashTarget.y, dmg, '#ffcccc');
        updateBossBarOnHit(slashTarget);  // Show boss bar if hitting boss
        // Slash arc
        const slashAngle = Math.atan2(slashTarget.y - player.y, slashTarget.x - player.x);
        for (let i = 0; i < 4; i++) {
          const a = slashAngle + (i - 1.5) * 0.3;
          addParticle({
            x: player.x + Math.cos(a) * 30, y: player.y + Math.sin(a) * 30,
            vx: Math.cos(a) * 4, vy: Math.sin(a) * 4,
            life: 12, color: '#cc8866', size: 4
          });
        }
        checkEnemyDeath(slashTarget);
      }
      break;
      
    case 'hungryArrow':
      // Ranger Primary - Seeking arrow with 35% pierce chance
      player.skillAnimType = 'shoot';
      if (skillProjectiles.length >= MAX_PROJECTILES) break;
      
      // Find target with LOS preference, slight homing prefers unhit targets
      let hungryTarget = null;
      const potentialTargets = enemies.filter(e => !e.dead && e.active && Math.hypot(e.x - player.x, e.y - player.y) < 400);
      
      // Prefer targets not recently hit (homing behavior)
      const unhitTargets = potentialTargets.filter(e => !e.lastHungryArrowHit || frame - e.lastHungryArrowHit > 60);
      if (unhitTargets.length > 0) {
        unhitTargets.sort((a, b) => Math.hypot(a.x - player.x, a.y - player.y) - Math.hypot(b.x - player.x, b.y - player.y));
        hungryTarget = unhitTargets[0];
      } else if (potentialTargets.length > 0) {
        potentialTargets.sort((a, b) => Math.hypot(a.x - player.x, a.y - player.y) - Math.hypot(b.x - player.x, b.y - player.y));
        hungryTarget = potentialTargets[0];
      }
      
      if (hungryTarget) {
        hungryTarget.lastHungryArrowHit = frame;  // Mark as recently targeted
      }
      
      let hungryAngle = hungryTarget 
        ? Math.atan2(hungryTarget.y - player.y, hungryTarget.x - player.x)
        : player.facing > 0 ? 0 : Math.PI;
      const hungryOffset = TILE * 0.3;
      
      skillProjectiles.push({
        type: 'hungryArrow',
        x: player.x + Math.cos(hungryAngle) * hungryOffset,
        y: player.y + Math.sin(hungryAngle) * hungryOffset,
        vx: Math.cos(hungryAngle) * (skill.speed || 14),
        vy: Math.sin(hungryAngle) * (skill.speed || 14),
        damage: baseDmg * (skill.damage || 1) * tierMultiplier,
        radius: 20,
        life: 80,
        color: '#aaddaa',
        homing: true,
        homingStrength: 0.08,  // Slight homing
        pierceChance: skill.pierceChance || 0.35,
        hasPierced: false
      });
      break;
      
    case 'magicMissile':
      // Mage Primary - force projectile, every 3rd cast fires extra missile
      player.skillAnimType = 'cast';
      player.skillAnimProgress = 1.0;
      if (skillProjectiles.length >= MAX_PROJECTILES) break;
      
      // Track combo counter for 3rd hit bonus
      player.magicMissileCombo = (player.magicMissileCombo || 0) + 1;
      const isThirdCast = player.magicMissileCombo >= 3;
      if (isThirdCast) player.magicMissileCombo = 0;
      
      // Find target
      let mmTarget = findNearestEnemy(skill.range, true);
      if (!mmTarget) mmTarget = findNearestEnemy(TILE * 2, false);
      
      let mmAngle = mmTarget 
        ? Math.atan2(mmTarget.y - player.y, mmTarget.x - player.x)
        : player.facing > 0 ? 0 : Math.PI;
      
      const mmOffset = TILE * 0.3;
      
      // Main missile
      skillProjectiles.push({
        type: 'magicMissile',
        x: player.x + Math.cos(mmAngle) * mmOffset,
        y: player.y + Math.sin(mmAngle) * mmOffset,
        vx: Math.cos(mmAngle) * skill.speed,
        vy: Math.sin(mmAngle) * skill.speed,
        damage: baseDmg * (skill.damage || 1) * tierMultiplier,
        radius: 25,
        life: 80,
        color: '#aa88ff'
      });
      
      // 3rd cast bonus missile at different target
      if (isThirdCast) {
        let secondTarget = null;
        enemies.forEach(e => {
          if (!e.dead && e !== mmTarget && Math.hypot(e.x - player.x, e.y - player.y) < skill.range) {
            if (!secondTarget || Math.hypot(e.x - player.x, e.y - player.y) < Math.hypot(secondTarget.x - player.x, secondTarget.y - player.y)) {
              secondTarget = e;
            }
          }
        });
        
        if (secondTarget || mmTarget) {
          const bonusTarget = secondTarget || mmTarget;
          const bonusAngle = Math.atan2(bonusTarget.y - player.y, bonusTarget.x - player.x);
          skillProjectiles.push({
            type: 'magicMissile',
            x: player.x + Math.cos(bonusAngle) * mmOffset,
            y: player.y + Math.sin(bonusAngle) * mmOffset,
            vx: Math.cos(bonusAngle) * skill.speed,
            vy: Math.sin(bonusAngle) * skill.speed,
            damage: baseDmg * (skill.damage || 1) * tierMultiplier,
            radius: 25,
            life: 80,
            color: '#cc99ff'
          });
          addLog(`MAGIC MISSILE x2!`, 'skill');
        }
      }
      break;

    case 'electrocute':
      // Mage Primary - lightning bolt that chains to 2 additional enemies
      player.skillAnimType = 'cast';
      player.skillAnimProgress = 1.0;
      player.atkAnim = 15;
      
      let elecChainTargets = [];
      let elecLastPos = { x: player.x, y: player.y };
      
      // Find first target
      let elecFirst = findNearestEnemy(300, true);
      if (!elecFirst) elecFirst = findNearestEnemy(TILE * 2, false);
      
      if (elecFirst) {
        elecChainTargets.push(elecFirst);
        
        // Chain to additional targets
        for (let i = 0; i < skill.chains; i++) {
          let nearest = null;
          let nearestDist = skill.chainRange;
          
          const lastTarget = elecChainTargets[elecChainTargets.length - 1];
          enemies.forEach(e => {
            if (!e.dead && !elecChainTargets.includes(e)) {
              const dist = Math.hypot(e.x - lastTarget.x, e.y - lastTarget.y);
              if (dist < nearestDist) {
                nearestDist = dist;
                nearest = e;
              }
            }
          });
          
          if (nearest) elecChainTargets.push(nearest);
        }
        
        // Deal damage to all chained targets
        elecChainTargets.forEach((target, i) => {
          const dmg = Math.floor(baseDmg * (skill.damage || 1) * tierMultiplier);
          target.hp -= dmg;
          target.flash = 12;
          spawnDamageNumber(target.x, target.y, dmg, '#88ddff');
          checkEnemyDeath(target);
          
          // Lightning visual from last position
          const fromPos = i === 0 ? { x: player.x, y: player.y } : { x: elecChainTargets[i-1].x, y: elecChainTargets[i-1].y };
          for (let j = 0; j < 6; j++) {
            const t = j / 6;
            addParticle({
              x: fromPos.x + (target.x - fromPos.x) * t + (Math.random() - 0.5) * 15,
              y: fromPos.y + (target.y - fromPos.y) * t + (Math.random() - 0.5) * 15,
              vx: 0, vy: 0,
              life: 12,
              color: j % 2 ? '#88ddff' : '#ffffff',
              size: 4
            });
          }
        });
        
        addLog(`ELECTROCUTE! (${elecChainTargets.length} chains)`, 'skill');
      }
      break;

    case 'cyclone':
      cycloneActive = true;
      cycloneTimer = skill.duration;
      cycloneTierMultiplier = tierMultiplier;  // Store for use in updateSkills
      player.skillAnimType = 'cyclone';
      player.skillAnimProgress = 1.0;
      addLog(`CYCLONE T${tier}!`, 'skill');
      break;
      
    case 'frostNova':
      // Mage Defensive - freezing burst, bosses slowed instead
      player.skillAnimType = 'nova';
      player.skillAnimProgress = 1.0;
      player.atkAnim = 20;
      
      let frostNovaCount = 0;
      enemies.forEach(e => {
        if (!e.dead && Math.hypot(e.x - player.x, e.y - player.y) < skill.radius) {
          const dmg = Math.floor(baseDmg * (skill.damage || 1) * tierMultiplier);
          e.hp -= dmg;
          e.flash = 15;
          updateBossBarOnHit(e);  // Show boss bar if hitting boss
          
          // Freeze normal enemies, slow bosses (convert frames to seconds)
          if (e.isBoss) {
            e.slowed = skill.slowDuration / 60;  // Convert frames to seconds
            e.slowAmount = 0.5; // 50% slow
          } else {
            e.frozen = skill.freezeDuration / 60;  // Convert frames to seconds
          }
          
          frostNovaCount++;
          spawnDamageNumber(e.x, e.y, dmg, '#88ddff');
          checkEnemyDeath(e);
          
          // Ice particles
          for (let i = 0; i < 4; i++) {
            addParticle({
              x: e.x, y: e.y,
              vx: (Math.random() - 0.5) * 6,
              vy: (Math.random() - 0.5) * 6,
              life: 30,
              color: '#aaeeff',
              size: 5
            });
          }
        }
      });
      
      // Nova visual
      for (let i = 0; i < 24; i++) {
        const angle = (i / 24) * Math.PI * 2;
        addParticle({
          x: player.x, y: player.y,
          vx: Math.cos(angle) * 10,
          vy: Math.sin(angle) * 10,
          life: 30,
          color: i % 2 ? '#66ccff' : '#ffffff',
          size: 6
        });
      }
      
      camera.shake = 4;
      addLog(`FROST NOVA! (${frostNovaCount} frozen)`, 'skill');
      break;
      
    case 'chaosOrb':
      // Mage Secondary - slow projectile that explodes on contact
      player.skillAnimType = 'cast';
      player.skillAnimProgress = 1.0;
      player.atkAnim = 20;
      
      if (skillProjectiles.length >= MAX_PROJECTILES) {
        player.mana += skill.manaCost;
        break;
      }
      
      let orbTarget = findNearestEnemy(400, true);
      let orbAngle = orbTarget 
        ? Math.atan2(orbTarget.y - player.y, orbTarget.x - player.x)
        : player.facing > 0 ? 0 : Math.PI;
      
      const orbOffset = TILE * 0.4;
      skillProjectiles.push({
        type: 'chaosOrb',
        x: player.x + Math.cos(orbAngle) * orbOffset,
        y: player.y + Math.sin(orbAngle) * orbOffset,
        vx: Math.cos(orbAngle) * skill.speed,
        vy: Math.sin(orbAngle) * skill.speed,
        damage: baseDmg * (skill.damage || 1) * tierMultiplier,
        radius: skill.radius,
        life: 180,  // Slow but long range
        color: '#aa88ff'
      });
      
      addLog(`CHAOS ORB!`, 'skill');
      break;
      
    case 'blizzard':
      // Mage Focus - cold DoT area, progressive slow
      player.skillAnimType = 'cast';
      player.skillAnimProgress = 1.0;
      player.atkAnim = 25;
      
      // Find target location (centered on nearest enemy or in front of player)
      let blizzTarget = findNearestEnemy(300, true);
      const blizzX = blizzTarget ? blizzTarget.x : player.x + player.facing * 100;
      const blizzY = blizzTarget ? blizzTarget.y : player.y;
      
      // Create blizzard zone (convert frames to seconds)
      const durationSec = skill.duration / 60;
      const tickRateSec = skill.tickRate / 60;
      player.blizzardZone = {
        x: blizzX,
        y: blizzY,
        radius: skill.radius,
        damage: baseDmg * (skill.damage || 1) * tierMultiplier / (durationSec / tickRateSec),
        duration: durationSec,
        tickRate: tickRateSec,
        tickTimer: 0,
        slowAmount: skill.slowAmount
      };
      
      // Initial visual burst
      for (let i = 0; i < 16; i++) {
        const angle = (i / 16) * Math.PI * 2;
        const dist = Math.random() * skill.radius;
        addParticle({
          x: blizzX + Math.cos(angle) * dist,
          y: blizzY + Math.sin(angle) * dist,
          vx: (Math.random() - 0.5) * 2,
          vy: Math.random() * -3,
          life: 40,
          color: i % 2 ? '#88ccff' : '#ffffff',
          size: 4
        });
      }
      
      addLog(`BLIZZARD! (4s duration)`, 'skill');
      break;
      
    case 'meteor':
      // Mage Ultimate - delayed impact + burning ground
      player.skillAnimType = 'cast';
      player.skillAnimProgress = 1.0;
      player.atkAnim = 30;
      
      // Find target location
      let meteorTarget = findNearestEnemy(350, true);
      const meteorX = meteorTarget ? meteorTarget.x : player.x + player.facing * 150;
      const meteorY = meteorTarget ? meteorTarget.y : player.y;
      
      // Create delayed meteor (convert frames to seconds)
      player.pendingMeteor = {
        x: meteorX,
        y: meteorY,
        delay: skill.delay / 60,  // Convert to seconds
        damage: baseDmg * (skill.damage || 1) * tierMultiplier,
        burnDamage: baseDmg * (skill.burnDamage || 0.2) * tierMultiplier,
        burnDuration: skill.burnDuration / 60,  // Convert to seconds
        radius: skill.radius
      };
      
      // Warning indicator particles
      for (let i = 0; i < 12; i++) {
        const angle = (i / 12) * Math.PI * 2;
        addParticle({
          x: meteorX + Math.cos(angle) * skill.radius * 0.8,
          y: meteorY + Math.sin(angle) * skill.radius * 0.8,
          vx: 0, vy: 0,
          life: skill.delay,
          color: '#ff4400',
          size: 6
        });
      }
      
      addLog(`METEOR INCOMING!`, 'skill');
      break;
      
    case 'energyArmor':
      // Mage Defensive - +30% Shield, 15% DR, no healing
      player.skillAnimType = 'buff';
      player.skillAnimProgress = 1.0;
      player.atkAnim = 20;
      
      // Apply buffs
      player.energyArmorBonus = skill.shieldBonus;
      player.energyArmorDR = skill.damageReduction;
      player.energyArmorDuration = skill.duration;
      
      // Visual effect
      for (let i = 0; i < 16; i++) {
        const angle = (i / 16) * Math.PI * 2;
        addParticle({
          x: player.x + Math.cos(angle) * 30,
          y: player.y + Math.sin(angle) * 30,
          vx: Math.cos(angle) * 2,
          vy: Math.sin(angle) * 2,
          life: 40,
          color: i % 2 ? '#8866ff' : '#aa88ff',
          size: 5
        });
      }
      
      addLog(`ENERGY ARMOR! (+30% Shield, 15% DR)`, 'skill');
      break;
      
    case 'vaalSlam':
      // Screen shake effect
      player.skillAnimType = 'slam';
      player.skillAnimProgress = 1.0;
      player.atkAnim = 30;
      camera.shake = 20;
      
      // Massive damage to all enemies in huge radius
      let slamCount = 0;
      enemies.forEach(e => {
        if (!e.dead && Math.hypot(e.x - player.x, e.y - player.y) < skill.radius) {
          const dmg = Math.floor((player.minDmg + player.maxDmg) / 2 * (skill.damage || 1) * tierMultiplier);
          e.hp -= dmg;
          e.flash = 20;
          slamCount++;
          spawnDamageNumber(e.x, e.y, dmg, '#ff4444');
          
          // Knockback (safe - won't push into walls)
          applyKnockback(e, player.x, player.y, 30);
          
          checkEnemyDeath(e); // Check if enemy died
        }
      });
      
      // Earthquake rings - reduced for performance
      for (let ring = 0; ring < 3; ring++) {
        const ringRadius = 50 + ring * 60;
        for (let i = 0; i < 12; i++) {
          const angle = (i / 12) * Math.PI * 2 + ring * 0.3;
          addParticle({
            x: player.x + Math.cos(angle) * ringRadius,
            y: player.y + Math.sin(angle) * ringRadius,
            vx: Math.cos(angle) * 2,
            vy: Math.sin(angle) * 2,
            life: 40 - ring * 5,
            color: ring % 2 ? '#ff6644' : '#ffaa44',
            size: 8 - ring
          });
        }
      }
      
      // Ground crack blood - limited for performance
      for (let i = 0; i < 5 && blood.length < MAX_BLOOD; i++) {
        blood.push({
          x: player.x + (Math.random() - 0.5) * skill.radius,
          y: player.y + (Math.random() - 0.5) * skill.radius,
          size: 10 + Math.random() * 15,
          alpha: 0.4
        });
      }
      
      addLog(`VAAL EARTHQUAKE! (${slamCount} crushed)`, 'skill');
      break;
      
    case 'blindingFlash':
      // Defensive blind + dodge buff
      player.skillAnimType = 'burst';
      player.skillAnimProgress = 1.0;
      player.atkAnim = 15;
      
      let blindCount = 0;
      enemies.forEach(e => {
        if (!e.dead && Math.hypot(e.x - player.x, e.y - player.y) < skill.radius) {
          // Apply blind debuff (convert frames to seconds)
          e.blinded = skill.blindDuration / 60;
          e.blindMissChance = e.isBoss ? skill.blindMissChance * 0.5 : skill.blindMissChance;
          e.flash = 15;
          blindCount++;
        }
      });
      
      // Grant dodge buff to player (convert frames to seconds)
      player.blindingFlashDodge = skill.dodgeBuff;
      player.blindingFlashDuration = skill.dodgeBuffDuration / 60;
      
      // Bright flash visual
      for (let i = 0; i < 20; i++) {
        const angle = (i / 20) * Math.PI * 2;
        const dist = 30 + Math.random() * 60;
        addParticle({
          x: player.x + Math.cos(angle) * dist,
          y: player.y + Math.sin(angle) * dist,
          vx: Math.cos(angle) * 4,
          vy: Math.sin(angle) * 4,
          life: 20,
          color: i % 2 ? '#ffffff' : '#ffffaa',
          size: 5
        });
      }
      // Central burst
      for (let i = 0; i < 8; i++) {
        addParticle({
          x: player.x + (Math.random() - 0.5) * 30,
          y: player.y + (Math.random() - 0.5) * 30,
          vx: 0, vy: -2,
          life: 25,
          color: '#ffffff',
          size: 8
        });
      }
      
      camera.shake = Math.max(camera.shake, 4);
      addLog(`BLINDING FLASH! (${blindCount} blinded, +15% dodge)`, 'skill');
      break;
      
    case 'breathOfHeaven':
      // Instant heal + speed buffs
      player.skillAnimType = 'channel';
      player.skillAnimProgress = 1.0;
      player.atkAnim = 20;
      
      const breathHeal = Math.floor(player.maxHp * skill.healPercent * tierMultiplier);
      player.hp = Math.min(player.maxHp, player.hp + breathHeal);
      
      // Check for Aspect of Heavenly Grace (doubles attack speed buff and duration)
      const hasHeavenlyGrace = isAspectActive('breath_of_heaven_power');
      const breathAtkSpdBuff = hasHeavenlyGrace ? skill.attackSpeedBuff * 2 : skill.attackSpeedBuff;
      const breathDuration = hasHeavenlyGrace ? skill.buffDuration * 2 : skill.buffDuration;
      
      // Apply buffs (convert duration from frames to seconds)
      player.breathOfHeavenAtkSpd = breathAtkSpdBuff;
      player.breathOfHeavenMoveSpd = skill.moveSpeedBuff;
      player.breathOfHeavenDuration = breathDuration / 60;
      
      // Healing wind visual
      for (let i = 0; i < 15; i++) {
        const angle = (i / 15) * Math.PI * 2;
        addParticle({
          x: player.x + Math.cos(angle) * 20,
          y: player.y + Math.sin(angle) * 20,
          vx: Math.cos(angle) * 2,
          vy: -3 + Math.sin(angle),
          life: 35,
          color: i % 3 === 0 ? '#88ff88' : '#aaffaa',
          size: 4
        });
      }
      const breathAtkPct = Math.floor(breathAtkSpdBuff * 100);
      spawnDamageNumber(player.x, player.y - 20, '+' + breathHeal, '#88ff88');
      addLog(`BREATH OF HEAVEN! (+${breathHeal} HP, +${breathAtkPct}% AS, +10% MS)`, 'skill');
      break;
      
    case 'waveOfLight':
      // Line nuke - pillar + shockwave
      player.skillAnimType = 'slam';
      player.skillAnimProgress = 1.0;
      player.atkAnim = 25;
      camera.shake = 10;
      
      // Find target point
      let wolTarget = findNearestEnemy(skill.range);
      if (!wolTarget) {
        addLog('No target nearby!', 'warning');
        player.mana += skill.manaCost;
        skill.cooldown = 0;
        break;
      }
      
      const wolAngle = Math.atan2(wolTarget.y - player.y, wolTarget.x - player.x);
      const impactX = player.x + Math.cos(wolAngle) * Math.min(skill.range, Math.hypot(wolTarget.x - player.x, wolTarget.y - player.y));
      const impactY = player.y + Math.sin(wolAngle) * Math.min(skill.range, Math.hypot(wolTarget.y - player.y, wolTarget.x - player.x));
      
      let wolHitCount = 0;
      let firstHit = true;
      
      // Check for Aspect of Frozen Light (also scales with cold damage)
      const hasFrozenLight = isAspectActive('wave_of_light_cold');
      let wolBaseDmg = baseDmg;
      if (hasFrozenLight) {
        // Add flat cold damage to base (same as how fire damage would be added)
        const flatCold = ((player.addedColdMin || 0) + (player.addedColdMax || 0)) / 2;
        wolBaseDmg += flatCold;
        // Also apply cold % bonus from passives if any
        const coldPct = (player.passiveBonuses?.coldDamage || 0) / 100;
        wolBaseDmg *= (1 + coldPct);
      }
      
      const waveDmg = Math.floor(wolBaseDmg * (skill.damage || 1) * tierMultiplier);
      const crushDmg = Math.floor(wolBaseDmg * skill.crushDamage * tierMultiplier);
      
      // Check enemies along the line
      enemies.forEach(e => {
        if (e.dead) return;
        
        // Point-to-line distance calculation
        const lineLen = skill.lineLength;
        const endX = impactX + Math.cos(wolAngle) * lineLen;
        const endY = impactY + Math.sin(wolAngle) * lineLen;
        
        // Check if enemy is near the impact point or along the shockwave line
        const distToImpact = Math.hypot(e.x - impactX, e.y - impactY);
        
        // Project enemy onto line
        const dx = endX - impactX;
        const dy = endY - impactY;
        const t = Math.max(0, Math.min(1, ((e.x - impactX) * dx + (e.y - impactY) * dy) / (dx * dx + dy * dy)));
        const projX = impactX + t * dx;
        const projY = impactY + t * dy;
        const distToLine = Math.hypot(e.x - projX, e.y - projY);
        
        if (distToImpact < 50 || (distToLine < skill.lineWidth / 2 && t >= 0 && t <= 1)) {
          let totalDmg = waveDmg;
          if (firstHit) {
            totalDmg += crushDmg;
            firstHit = false;
            spawnDamageNumber(e.x, e.y - 15, crushDmg, '#ffaa44');
          }
          e.hp -= totalDmg;
          e.flash = 15;
          wolHitCount++;
          spawnDamageNumber(e.x, e.y, waveDmg, '#ff6644');
          checkEnemyDeath(e);
        }
      });
      
      // Impact pillar visual
      for (let i = 0; i < 12; i++) {
        addParticle({
          x: impactX + (Math.random() - 0.5) * 40,
          y: impactY + (Math.random() - 0.5) * 40,
          vx: (Math.random() - 0.5) * 3,
          vy: -4 - Math.random() * 3,
          life: 30,
          color: i % 2 ? '#ff8844' : '#ffaa22',
          size: 6
        });
      }
      
      // Shockwave line visual
      for (let i = 0; i < 15; i++) {
        const t = i / 15;
        const lineX = impactX + Math.cos(wolAngle) * skill.lineLength * t;
        const lineY = impactY + Math.sin(wolAngle) * skill.lineLength * t;
        addParticle({
          x: lineX + (Math.random() - 0.5) * 30,
          y: lineY + (Math.random() - 0.5) * 30,
          vx: Math.cos(wolAngle) * 2,
          vy: Math.sin(wolAngle) * 2,
          life: 20 - i,
          color: '#ff6644',
          size: 5
        });
      }
      
      addLog(`WAVE OF LIGHT! (${wolHitCount} scorched)`, 'skill');
      break;
      
    case 'explodingPalm':
      // DoT + chain explosion on death
      player.skillAnimType = 'palm';
      player.skillAnimProgress = 1.0;
      player.atkAnim = 20;
      
      let palmMarkTarget = findNearestEnemy(80);
      if (!palmMarkTarget) {
        addLog('No target nearby!', 'warning');
        player.mana += skill.manaCost;
        skill.cooldown = 0;
        break;
      }
      
      // Remove previous mark if exists
      enemies.forEach(e => {
        if (e.explodingPalmMark) {
          delete e.explodingPalmMark;
          delete e.explodingPalmDamage;
          delete e.explodingPalmExplosion;
          delete e.explodingPalmRadius;
        }
      });
      
      // Check for Aspect of Detonation (100% more damage, larger radius)
      const hasDetonationAspect = isAspectActive('exploding_palm_power');
      const palmExplosionMult = hasDetonationAspect ? 2.0 : 1.0;
      const palmRadiusMult = hasDetonationAspect ? 1.5 : 1.0;
      
      // Apply new mark
      palmMarkTarget.explodingPalmMark = skill.bleedDuration;
      palmMarkTarget.explodingPalmDamage = baseDmg * (skill.bleedDamage || 0.2) * tierMultiplier / ((skill.bleedDuration || 120) / 15);
      palmMarkTarget.explodingPalmExplosion = baseDmg * skill.explosionDamage * tierMultiplier * palmExplosionMult;
      palmMarkTarget.explodingPalmRadius = skill.explosionRadius * palmRadiusMult;
      palmMarkTarget.flash = 20;
      
      // Mark visual - fiery palm strike
      // Impact burst
      for (let i = 0; i < 12; i++) {
        const angle = (i / 12) * Math.PI * 2;
        addParticle({
          x: palmMarkTarget.x,
          y: palmMarkTarget.y,
          vx: Math.cos(angle) * 4,
          vy: Math.sin(angle) * 4,
          life: 20,
          color: '#ff4400',
          size: 6
        });
      }
      // Rising flames on target
      for (let i = 0; i < 8; i++) {
        addParticle({
          x: palmMarkTarget.x + (Math.random() - 0.5) * 25,
          y: palmMarkTarget.y + 10,
          vx: (Math.random() - 0.5) * 2,
          vy: -3 - Math.random() * 3,
          life: 30,
          color: i % 2 ? '#ff6622' : '#ffaa00',
          size: 5
        });
      }
      // Bright center flash
      addParticle({
        x: palmMarkTarget.x,
        y: palmMarkTarget.y,
        vx: 0,
        vy: 0,
        life: 15,
        color: '#ffffff',
        size: 12
      });
      
      camera.shake = Math.max(camera.shake, 5);
      
      player.facing = palmMarkTarget.x > player.x ? 1 : -1;
      addLog('EXPLODING PALM! (Target marked)', 'skill');
      break;
      
    case 'cycloneStrike':
      // Pull enemies in + AoE burst
      player.skillAnimType = 'spin';
      player.skillAnimProgress = 1.0;
      player.atkAnim = 25;
      
      // Check for Aspect of the Vortex
      const hasVortexAspect = isAspectActive('cyclone_pull');
      const pullRadiusMult = hasVortexAspect ? 2.0 : 1.0;  // Double pull range
      const cycloneDmgMult = hasVortexAspect ? 1.2 : 1.0;  // 20% more damage
      
      let pullCount = 0;
      let pullTargets = [];
      
      // Find enemies to pull (with aspect-modified radius)
      const effectivePullRadius = skill.pullRadius * pullRadiusMult;
      enemies.forEach(e => {
        if (!e.dead && pullTargets.length < skill.maxTargets) {
          const dist = Math.hypot(e.x - player.x, e.y - player.y);
          if (dist < effectivePullRadius && dist > 40) {
            pullTargets.push(e);
          }
        }
      });
      
      // Pull enemies toward player
      pullTargets.forEach(e => {
        if (e.isBoss) {
          // Bosses don't move, but get slowed (convert frames to seconds)
          e.slowed = skill.bossSlowDuration / 60;
          e.slowAmount = skill.bossSlowAmount;
        } else {
          // Pull to near player
          const angle = Math.atan2(player.y - e.y, player.x - e.x);
          const dist = Math.hypot(e.x - player.x, e.y - player.y);
          const pullDist = dist - 35;
          e.x += Math.cos(angle) * pullDist;
          e.y += Math.sin(angle) * pullDist;
          pullCount++;
          
          // Pull trail
          for (let i = 0; i < 3; i++) {
            addParticle({
              x: e.x - Math.cos(angle) * i * 15,
              y: e.y - Math.sin(angle) * i * 15,
              vx: Math.cos(angle) * 2, vy: Math.sin(angle) * 2,
              life: 10, color: '#88ddff', size: 3
            });
          }
        }
      });
      
      // Delayed damage burst (with aspect-modified damage)
      const cycloneAspectDmgMult = cycloneDmgMult; // Capture for closure
      setTimeout(() => {
        const burstDmg = Math.floor(baseDmg * (skill.damage || 1) * tierMultiplier * cycloneAspectDmgMult);
        let burstCount = 0;
        enemies.forEach(e => {
          if (!e.dead && Math.hypot(e.x - player.x, e.y - player.y) < 80) {
            e.hp -= burstDmg;
            e.flash = 12;
            burstCount++;
            spawnDamageNumber(e.x, e.y, burstDmg, '#88ffff');
            checkEnemyDeath(e);
          }
        });
        
        // Burst visual
        for (let i = 0; i < 16; i++) {
          const angle = (i / 16) * Math.PI * 2;
          addParticle({
            x: player.x + Math.cos(angle) * 50,
            y: player.y + Math.sin(angle) * 50,
            vx: Math.cos(angle) * 6,
            vy: Math.sin(angle) * 6,
            life: 15, color: '#aaffff', size: 5
          });
        }
        camera.shake = Math.max(camera.shake, 5);
      }, 150);
      
      // Vortex visual
      for (let i = 0; i < 20; i++) {
        const angle = (i / 20) * Math.PI * 2;
        const dist = 80 + Math.random() * 60;
        addParticle({
          x: player.x + Math.cos(angle) * dist,
          y: player.y + Math.sin(angle) * dist,
          vx: -Math.cos(angle) * 4,
          vy: -Math.sin(angle) * 4,
          life: 20, color: '#66ccff', size: 4
        });
      }
      
      addLog(`CYCLONE STRIKE! (${pullCount} pulled)`, 'skill');
      break;
      
    case 'sevenSidedStrike':
      // Rapid teleport strikes - invulnerable during
      player.skillAnimType = 'flurry';
      player.skillAnimProgress = 1.0;
      player.atkAnim = 40;
      
      // Find all targets in range
      let sssTargets = enemies.filter(e => !e.dead && Math.hypot(e.x - player.x, e.y - player.y) < skill.radius);
      
      if (sssTargets.length === 0) {
        player.mana += skill.manaCost;
        skill.cooldown = 0;
        break;
      }
      
      // Store state for the strike sequence
      player.sevenSidedStrikeData = {
        active: true,
        startFloor: player.currentFloor,
        originalX: player.x,
        originalY: player.y,
        damage: Math.floor(baseDmg * skill.damagePerHit * tierMultiplier),
        strikesRemaining: skill.strikes,
        strikeCount: 0,
        nextStrikeTime: Date.now() + 80
      };
      player.invulnerable = true;
      
      addLog(`SEVEN-SIDED STRIKE!`, 'skill');
      break;
      
    case 'innerSanctuary':
      // Create protective zone
      player.skillAnimType = 'cast';
      player.skillAnimProgress = 1.0;
      player.atkAnim = 20;
      
      // Store sanctuary data on player
      player.innerSanctuary = {
        x: player.x,
        y: player.y,
        radius: skill.radius,
        damageReduction: skill.damageReduction,
        healPerSecond: skill.healPerSecond,
        duration: skill.duration / 60 // Convert to seconds
      };
      
      // Visual burst
      for (let i = 0; i < 20; i++) {
        const angle = (i / 20) * Math.PI * 2;
        addParticle({
          x: player.x + Math.cos(angle) * skill.radius,
          y: player.y + Math.sin(angle) * skill.radius,
          vx: 0, vy: -1,
          life: 30, color: '#88ff88', size: 4
        });
      }
      
      addLog(`INNER SANCTUARY!`, 'skill');
      break;
      
    // ============ OLD RANGER SKILLS (kept for compatibility) ============
    case 'powerShot':
      player.skillAnimType = 'shoot';
      player.skillAnimProgress = 1.0;
      player.atkAnim = 20;
      if (skillProjectiles.length >= MAX_PROJECTILES) {
        player.mana += skill.manaCost; skill.cooldown = 0; break;
      }
      let powerTarget = findNearestEnemy(500, true);
      let powerAngle = powerTarget 
        ? Math.atan2(powerTarget.y - player.y, powerTarget.x - player.x)
        : player.facing > 0 ? 0 : Math.PI;
      const powerOffset = TILE * 0.5;
      skillProjectiles.push({
        type: 'powerArrow', 
        x: player.x + Math.cos(powerAngle) * powerOffset, 
        y: player.y + Math.sin(powerAngle) * powerOffset,
        vx: Math.cos(powerAngle) * 15,
        vy: Math.sin(powerAngle) * 15,
        damage: (player.minDmg + player.maxDmg) / 2 * (skill.damage || 1) * tierMultiplier,
        pierce: skill.pierce,
        life: 90
      });
      addLog(`POWER SHOT T${tier}!`, 'skill');
      break;
      
    case 'explosiveArrow':
      player.skillAnimType = 'shoot';
      player.skillAnimProgress = 1.0;
      player.atkAnim = 18;
      if (skillProjectiles.length >= MAX_PROJECTILES) {
        player.mana += skill.manaCost; skill.cooldown = 0; break;
      }
      let explTarget = findNearestEnemy(400, true);
      let explAngle = explTarget 
        ? Math.atan2(explTarget.y - player.y, explTarget.x - player.x)
        : player.facing > 0 ? 0 : Math.PI;
      const explOffset = TILE * 0.5;
      skillProjectiles.push({
        type: 'explosiveArrow', 
        x: player.x + Math.cos(explAngle) * explOffset, 
        y: player.y + Math.sin(explAngle) * explOffset,
        vx: Math.cos(explAngle) * 10,
        vy: Math.sin(explAngle) * 10,
        damage: (player.minDmg + player.maxDmg) / 2 * (skill.damage || 1) * tierMultiplier,
        radius: skill.radius,
        life: 80
      });
      addLog(`EXPLOSIVE ARROW T${tier}!`, 'skill');
      break;
      
    case 'piercingShot':
      player.skillAnimType = 'shoot';
      player.skillAnimProgress = 1.0;
      player.atkAnim = 18;
      if (skillProjectiles.length >= MAX_PROJECTILES) {
        player.mana += skill.manaCost; skill.cooldown = 0; break;
      }
      let pierceTarget = findNearestEnemy(400, true);
      let pierceAngle = pierceTarget 
        ? Math.atan2(pierceTarget.y - player.y, pierceTarget.x - player.x)
        : player.facing > 0 ? 0 : Math.PI;
      const pierceOffset = TILE * 0.5;
      skillProjectiles.push({
        type: 'piercingShot', 
        x: player.x + Math.cos(pierceAngle) * pierceOffset, 
        y: player.y + Math.sin(pierceAngle) * pierceOffset,
        vx: Math.cos(pierceAngle) * 14,
        vy: Math.sin(pierceAngle) * 14,
        damage: (player.minDmg + player.maxDmg) / 2 * (skill.damage || 1) * tierMultiplier,
        pierce: 3, // Can hit up to 3 enemies
        life: 80
      });
      addLog(`PIERCING SHOT T${tier}!`, 'skill');
      break;
      
    case 'evasiveRoll':
      player.skillAnimType = 'roll';
      player.skillAnimProgress = 1.0;
      player.atkAnim = 20;
      const rollDist = skill.distance * tierMultiplier / 100;
      const rollAngle = player.facing > 0 ? Math.PI : 0; // Roll away from facing
      const newX = player.x + Math.cos(rollAngle) * rollDist;
      const newY = player.y;
      if (canMoveTo(newX, newY)) {
        player.x = newX;
        for (let i = 0; i < 5; i++) {
          addParticle({ x: player.x - Math.cos(rollAngle)*i*20, y: player.y, vx: 0, vy: 0, life: 15, color: '#aaa', size: 3 });
        }
      }
      addLog(`EVASIVE ROLL!`, 'skill');
      break;
      
    case 'huntersMark':
      player.skillAnimType = 'cast';
      player.skillAnimProgress = 1.0;
      player.atkAnim = 15;
      let markTarget = findNearestEnemy(300);
      if (markTarget) {
        markTarget.marked = skill.duration;
        markTarget.markBonus = skill.damageBoost * tierMultiplier;
        addParticle({ x: markTarget.x, y: markTarget.y - 30, vx: 0, vy: 0, life: 60, color: '#ff4444', size: 8 });
        addLog(`HUNTER'S MARK! (+${Math.floor(skill.damageBoost*100)}% damage)`, 'skill');
      } else {
        player.mana += skill.manaCost; skill.cooldown = 0;
      }
      break;
      
    case 'barrage':
      player.skillAnimType = 'shoot';
      player.skillAnimProgress = 1.0;
      player.atkAnim = 30;
      let barrageTarget = findNearestEnemy(350, true);
      if (barrageTarget) {
        for (let i = 0; i < skill.arrows; i++) {
          setTimeout(() => {
            if (skillProjectiles.length < MAX_PROJECTILES && barrageTarget && !barrageTarget.dead) {
              const angle = Math.atan2(barrageTarget.y - player.y, barrageTarget.x - player.x) + (Math.random()-0.5)*0.2;
              const barrageOffset = TILE * 0.5;
              skillProjectiles.push({
                type: 'arrow', 
                x: player.x + Math.cos(angle) * barrageOffset, 
                y: player.y + Math.sin(angle) * barrageOffset,
                vx: Math.cos(angle) * 14,
                vy: Math.sin(angle) * 14,
                damage: (player.minDmg + player.maxDmg) / 2 * (skill.damage || 1) * tierMultiplier,
                life: 50
              });
            }
          }, i * 40);
        }
        addLog(`BARRAGE T${tier}!`, 'skill');
      } else {
        player.mana += skill.manaCost; skill.cooldown = 0;
      }
      break;
      
    case 'freezingArrow':
      player.skillAnimType = 'shoot';
      player.skillAnimProgress = 1.0;
      player.atkAnim = 18;
      if (skillProjectiles.length >= MAX_PROJECTILES) {
        player.mana += skill.manaCost; skill.cooldown = 0; break;
      }
      let freezeTarget = findNearestEnemy(400, true);
      let freezeAngle = freezeTarget 
        ? Math.atan2(freezeTarget.y - player.y, freezeTarget.x - player.x)
        : player.facing > 0 ? 0 : Math.PI;
      const freezeOffset = TILE * 0.5;
      skillProjectiles.push({
        type: 'freezingArrow', 
        x: player.x + Math.cos(freezeAngle) * freezeOffset, 
        y: player.y + Math.sin(freezeAngle) * freezeOffset,
        vx: Math.cos(freezeAngle) * 12,
        vy: Math.sin(freezeAngle) * 12,
        damage: (player.minDmg + player.maxDmg) / 2 * (skill.damage || 1) * tierMultiplier,
        slowDuration: skill.slowDuration,
        life: 60
      });
      addLog(`FREEZING ARROW T${tier}!`, 'skill');
      break;
      
    case 'snipe':
      player.skillAnimType = 'shoot';
      player.skillAnimProgress = 1.0;
      player.atkAnim = 25;
      let snipeTarget = findNearestEnemy(600, true);
      if (snipeTarget) {
        const dmg = Math.floor((player.minDmg + player.maxDmg) / 2 * (skill.damage || 1) * tierMultiplier);
        snipeTarget.hp -= dmg;
        snipeTarget.flash = 20;
        spawnDamageNumber(snipeTarget.x, snipeTarget.y, dmg, '#ff8800');
        camera.shake = 8;
        // Tracer line
        for (let i = 0; i < 10; i++) {
          const t = i / 10;
          addParticle({
            x: player.x + (snipeTarget.x - player.x) * t,
            y: player.y + (snipeTarget.y - player.y) * t,
            vx: 0, vy: 0, life: 10, color: '#ffaa00', size: 2
          });
        }
        checkEnemyDeath(snipeTarget);
        addLog(`SNIPE T${tier}! CRITICAL!`, 'skill');
      } else {
        player.mana += skill.manaCost; skill.cooldown = 0;
      }
      break;
      
    // ============ NEW RANGER SKILLS ============
    
    case 'chakram':
      // Chakram - returning disc that hits on way out AND back
      player.skillAnimType = 'shoot';
      player.skillAnimProgress = 1.0;
      player.atkAnim = 15;
      
      if (skillProjectiles.length >= MAX_PROJECTILES) {
        player.mana += skill.manaCost; skill.cooldown = 0; break;
      }
      
      let chakramTarget = findNearestEnemy(350, true);
      const chakramAngle = chakramTarget 
        ? Math.atan2(chakramTarget.y - player.y, chakramTarget.x - player.x)
        : player.facing > 0 ? 0 : Math.PI;
      player.facing = Math.cos(chakramAngle) > 0 ? 1 : -1;
      
      skillProjectiles.push({
        type: 'chakram',
        x: player.x + Math.cos(chakramAngle) * 25,
        y: player.y + Math.sin(chakramAngle) * 25,
        vx: Math.cos(chakramAngle) * (skill.speed || 10),
        vy: Math.sin(chakramAngle) * (skill.speed || 10),
        startX: player.x,
        startY: player.y,
        damage: baseDmg * (skill.damage || 3.8) * tierMultiplier,
        radius: 25,
        maxRange: skill.range || 300,
        returning: false,
        hitEnemies: new Set(),  // Track enemies hit to allow double-hit
        life: 180,
        spin: 0
      });
      
      // Throw effect
      for (let i = 0; i < 8; i++) {
        const sparkAngle = chakramAngle + (Math.random() - 0.5) * 0.5;
        addParticle({
          x: player.x + Math.cos(chakramAngle) * 30,
          y: player.y + Math.sin(chakramAngle) * 30,
          vx: Math.cos(sparkAngle) * 4 + (Math.random() - 0.5) * 2,
          vy: Math.sin(sparkAngle) * 4 + (Math.random() - 0.5) * 2,
          life: 12, color: '#ffdd88', size: 3
        });
      }
      addLog(`CHAKRAM T${tier}!`, 'skill');
      break;
      
    case 'caltrops':
      // Caltrops - ground trap that damages and slows
      player.skillAnimType = 'cast';
      player.skillAnimProgress = 1.0;
      player.atkAnim = 20;
      
      // Deploy at player position or toward nearest enemy
      let caltropTarget = findNearestEnemy(200, true);
      const caltropX = caltropTarget ? (player.x + caltropTarget.x) / 2 : player.x + player.facing * 60;
      const caltropY = caltropTarget ? (player.y + caltropTarget.y) / 2 : player.y;
      
      // Create caltrop zone
      if (!window.caltropZones) window.caltropZones = [];
      window.caltropZones.push({
        x: caltropX,
        y: caltropY,
        radius: skill.radius || 80,
        damage: baseDmg * (skill.damage || 0.5) * tierMultiplier,
        slowAmount: skill.slowAmount || 0.8,
        damageReduction: skill.damageReduction || 0.15,
        duration: (skill.duration || 360) / 60,
        life: (skill.duration || 360) / 60,
        tickTimer: 0,
        tickRate: 0.5  // Damage every 0.5s
      });
      
      // Scatter visual
      for (let i = 0; i < 16; i++) {
        const angle = Math.random() * Math.PI * 2;
        const dist = Math.random() * (skill.radius || 80);
        addParticle({
          x: caltropX + Math.cos(angle) * dist,
          y: caltropY + Math.sin(angle) * dist,
          vx: (Math.random() - 0.5) * 3,
          vy: -Math.random() * 2 - 1,
          life: 20, color: '#888888', size: 4
        });
      }
      addLog(`CALTROPS T${tier}!`, 'skill');
      break;
      
    case 'markedForDeath':
      // Mark for Death - debuff that increases damage taken
      player.skillAnimType = 'cast';
      player.skillAnimProgress = 1.0;
      player.atkAnim = 18;
      
      // Auto-target bosses first, then nearest enemy
      let deathMarkTarget = enemies.find(e => !e.dead && e.active && e.isBoss && !e.markedForDeath);
      if (!deathMarkTarget) {
        deathMarkTarget = findNearestEnemy(400, true);
      }
      
      if (deathMarkTarget && !deathMarkTarget.markedForDeath) {
        // Apply mark
        deathMarkTarget.markedForDeath = true;
        deathMarkTarget.markDuration = (skill.duration || 480) / 60;
        deathMarkTarget.markDamageAmp = skill.damageAmp || 0.25;
        
        // Skull mark visual
        for (let i = 0; i < 12; i++) {
          const angle = (i / 12) * Math.PI * 2;
          addParticle({
            x: deathMarkTarget.x + Math.cos(angle) * 30,
            y: deathMarkTarget.y + Math.sin(angle) * 30,
            vx: Math.cos(angle) * 2,
            vy: Math.sin(angle) * 2,
            life: 25, color: '#ff4444', size: 5
          });
        }
        
        // Rising skull effect
        addParticle({
          x: deathMarkTarget.x, y: deathMarkTarget.y - 20,
          vx: 0, vy: -2,
          life: 40, color: '#ff0000', size: 8, text: '💀'
        });
        
        addLog(`MARKED FOR DEATH on ${deathMarkTarget.name}!`, 'skill');
      } else {
        // No valid target - refund
        player.mana += skill.manaCost; 
        skill.cooldown = 0;
        addLog('No target to mark!', 'warning');
      }
      break;
      
    case 'multiShot':
      // Wide arc volley - AoE clear (classic arrow style)
      player.skillAnimType = 'shoot';
      player.skillAnimProgress = 1.0;
      player.atkAnim = 15;
      
      if (skillProjectiles.length >= MAX_PROJECTILES - 5) {
        player.mana += skill.manaCost; skill.cooldown = 0; break;
      }
      
      let multishotTarget = findNearestEnemy(400, true);
      const multishotAngle = multishotTarget 
        ? Math.atan2(multishotTarget.y - player.y, multishotTarget.x - player.x)
        : player.facing > 0 ? 0 : Math.PI;
      
      // Fire 5 arrows in a spread (classic feel)
      const msOffset = TILE * 0.5;
      const msSpread = 0.4;  // Total spread in radians
      for (let i = 0; i < 5; i++) {
        const arrowAngle = multishotAngle + (i - 2) * msSpread / 4;
        skillProjectiles.push({
          type: 'arrow',  // Use classic arrow rendering
          x: player.x + Math.cos(arrowAngle) * msOffset,
          y: player.y + Math.sin(arrowAngle) * msOffset,
          vx: Math.cos(arrowAngle) * 12,
          vy: Math.sin(arrowAngle) * 12,
          damage: baseDmg * (skill.damage || 1) * tierMultiplier / 5,  // Split damage across arrows
          life: 60
        });
      }
      addLog(`MULTISHOT T${tier}!`, 'skill');
      break;
      
    case 'sentry':
      // Deploy a stationary ballista turret
      player.skillAnimType = 'cast';
      player.skillAnimProgress = 1.0;
      player.atkAnim = 25;
      
      // Initialize sentry array if needed
      if (!window.sentries) window.sentries = [];
      
      // Determine how many sentries to spawn (2 if aspect active)
      const sentryCount = hasSentryX2Aspect() ? 2 : 1;
      const sentryDuration = (skill.duration || 1200) / 60;
      
      for (let s = 0; s < sentryCount; s++) {
        // Check max sentries before each spawn
        if (window.sentries.length >= (skill.maxSentries || 2)) {
          // Remove oldest sentry
          window.sentries.shift();
        }
        
        // Deploy near player (offset second sentry)
        const sentryOffset = s === 0 ? 40 : -40;  // First in front, second behind
        const sentryX = player.x + player.facing * sentryOffset;
        const sentryY = player.y + (s === 1 ? 30 : 0);  // Second slightly below
        
        window.sentries.push({
          x: sentryX,
          y: sentryY,
          damage: baseDmg * (skill.damage || 1) * tierMultiplier,
          fireRate: (skill.fireRate || 72) / 60,  // Convert to seconds
          fireTimer: s * 0.2,  // Stagger fire timing
          duration: sentryDuration,
          life: sentryDuration,
          maxLife: sentryDuration,
          lastTargetAngle: 0
        });
        
        // Deploy particles
        for (let i = 0; i < 12; i++) {
          const angle = (i / 12) * Math.PI * 2;
          addParticle({
            x: sentryX, y: sentryY,
            vx: Math.cos(angle) * 3, vy: Math.sin(angle) * 3,
            life: 20, color: '#8888ff', size: 4
          });
        }
      }
      
      addLog(`SENTRY DEPLOYED${sentryCount > 1 ? ' x2' : ''}! (${window.sentries.length}/${skill.maxSentries || 2})`, 'skill');
      break;
      
    case 'rainOfArrows':
      // Ultimate AoE rain with bleed
      player.skillAnimType = 'cast';
      player.skillAnimProgress = 1.0;
      player.atkAnim = 30;
      
      let roaTarget = findNearestEnemy(400, true);
      const rainX = roaTarget ? roaTarget.x : player.x + player.facing * 150;
      const rainY = roaTarget ? roaTarget.y : player.y;
      const rainRadius = skill.radius || 180;
      
      // Create rain zone that persists (convert frames to seconds)
      if (!window.rainZones) window.rainZones = [];
      window.rainZones.push({
        x: rainX,
        y: rainY,
        radius: rainRadius,
        damage: baseDmg * (skill.damage || 1) * tierMultiplier,
        duration: (skill.duration || 240) / 60,  // Convert to seconds
        life: (skill.duration || 240) / 60,  // Convert to seconds
        bleedDamage: baseDmg * (skill.bleedDamage || 0.2),
        bleedDuration: (skill.bleedDuration || 180) / 60,  // Convert to seconds
        tickTimer: 0,
        tickRate: 15 / 60  // Damage tick every 0.25s (in seconds)
      });
      
      // Initial visual
      for (let i = 0; i < 20; i++) {
        const angle = Math.random() * Math.PI * 2;
        const dist = Math.random() * rainRadius;
        addParticle({
          x: rainX + Math.cos(angle) * dist,
          y: rainY + Math.sin(angle) * dist - 100,
          vx: (Math.random() - 0.5) * 2,
          vy: 8 + Math.random() * 4,
          life: 25, color: '#88aa66', size: 2
        });
      }
      
      camera.shake = Math.max(camera.shake, 5);
      addLog(`RAIN OF ARROWS T${tier}!`, 'skill');
      break;
      
    // ============ WARRIOR SKILLS ============
    case 'shieldBash':
      player.skillAnimType = 'thrust';
      player.skillAnimProgress = 1.0;
      player.atkAnim = 18;
      let bashTarget = findNearestEnemy(skill.radius);
      if (bashTarget) {
        const dmg = Math.floor((player.minDmg + player.maxDmg) / 2 * (skill.damage || 1) * tierMultiplier);
        bashTarget.hp -= dmg; bashTarget.flash = 15;
        bashTarget.stunned = skill.stunDuration;
        spawnDamageNumber(bashTarget.x, bashTarget.y, dmg, '#cccccc');
        for (let i = 0; i < 6; i++) {
          addParticle({ x: bashTarget.x, y: bashTarget.y, vx: (Math.random()-0.5)*8, vy: (Math.random()-0.5)*8, life: 15, color: '#aaaaaa', size: 4 });
        }
        checkEnemyDeath(bashTarget);
        addLog(`SHIELD BASH T${tier}!`, 'skill');
      } else {
        player.mana += skill.manaCost; skill.cooldown = 0;
      }
      break;
      
    case 'cleave':
      player.skillAnimType = 'slash';
      player.skillAnimProgress = 1.0;
      player.atkAnim = 20;
      let cleaveCount = 0;
      const cleaveAngle = player.facing > 0 ? 0 : Math.PI;
      enemies.forEach(e => {
        if (!e.dead) {
          const dist = Math.hypot(e.x - player.x, e.y - player.y);
          const angle = Math.atan2(e.y - player.y, e.x - player.x);
          const angleDiff = Math.abs(angle - cleaveAngle);
          if (dist < skill.radius && angleDiff < Math.PI/2) {
            const dmg = Math.floor((player.minDmg + player.maxDmg) / 2 * (skill.damage || 1) * tierMultiplier);
            e.hp -= dmg; e.flash = 12; cleaveCount++;
            spawnDamageNumber(e.x, e.y, dmg, '#ff8844');
            checkEnemyDeath(e);
          }
        }
      });
      for (let i = 0; i < 8; i++) {
        const a = cleaveAngle + (i-4)*0.2;
        addParticle({ x: player.x, y: player.y, vx: Math.cos(a)*8, vy: Math.sin(a)*8, life: 15, color: '#ffaa44', size: 4 });
      }
      addLog(`CLEAVE! (${cleaveCount} hit)`, 'skill');
      break;
      
    case 'groundSlam':
      player.skillAnimType = 'slam';
      player.skillAnimProgress = 1.0;
      player.atkAnim = 25;
      camera.shake = 15;
      let slamCount2 = 0;
      enemies.forEach(e => {
        if (!e.dead && Math.hypot(e.x - player.x, e.y - player.y) < skill.radius) {
          const dmg = Math.floor((player.minDmg + player.maxDmg) / 2 * (skill.damage || 1) * tierMultiplier);
          e.hp -= dmg; e.flash = 15; slamCount2++;
          spawnDamageNumber(e.x, e.y, dmg, '#ff6644');
          checkEnemyDeath(e);
        }
      });
      for (let i = 0; i < 16; i++) {
        const angle = (i / 16) * Math.PI * 2;
        addParticle({ x: player.x + Math.cos(angle)*50, y: player.y + Math.sin(angle)*50, vx: Math.cos(angle)*3, vy: Math.sin(angle)*3, life: 25, color: '#aa6644', size: 5 });
      }
      addLog(`GROUND SLAM! (${slamCount2} hit)`, 'skill');
      break;
      
    case 'charge':
      player.skillAnimType = 'thrust';
      player.skillAnimProgress = 1.0;
      player.atkAnim = 15;
      const chargeDist = skill.distance;
      const chargeAngle = player.facing > 0 ? 0 : Math.PI;
      let chargeX = player.x;
      for (let d = 20; d <= chargeDist; d += 20) {
        const testX = player.x + Math.cos(chargeAngle) * d;
        if (canMoveTo(testX, player.y)) {
          chargeX = testX;
          // Hit enemies along the way
          enemies.forEach(e => {
            if (!e.dead && Math.hypot(e.x - testX, e.y - player.y) < 40) {
              const dmg = Math.floor((player.minDmg + player.maxDmg) / 2 * (skill.damage || 1) * tierMultiplier);
              e.hp -= dmg; e.flash = 10;
              spawnDamageNumber(e.x, e.y, dmg, '#ff4444');
              checkEnemyDeath(e);
            }
          });
        } else break;
      }
      player.x = chargeX;
      for (let i = 0; i < 6; i++) {
        addParticle({ x: player.x - Math.cos(chargeAngle)*i*15, y: player.y, vx: 0, vy: 0, life: 15, color: '#ffaa44', size: 4 });
      }
      addLog(`CHARGE!`, 'skill');
      break;
      
    case 'warCry':
      player.skillAnimType = 'nova';
      player.skillAnimProgress = 1.0;
      player.atkAnim = 20;
      player.warCryActive = skill.duration;
      player.warCryBoost = skill.damageBoost * tierMultiplier;
      camera.shake = 5;
      for (let i = 0; i < 12; i++) {
        const angle = (i / 12) * Math.PI * 2;
        addParticle({ x: player.x + Math.cos(angle)*40, y: player.y + Math.sin(angle)*40, vx: Math.cos(angle)*5, vy: Math.sin(angle)*5, life: 30, color: '#ff8844', size: 4 });
      }
      addLog(`WAR CRY! (+${Math.floor(skill.damageBoost*100)}% damage)`, 'skill');
      break;
      
    case 'shieldWall':
      player.skillAnimType = 'buff';
      player.skillAnimProgress = 1.0;
      player.atkAnim = 20;
      player.shieldWallActive = skill.duration;
      player.shieldWallReduction = skill.damageReduction * tierMultiplier;
      for (let i = 0; i < 8; i++) {
        addParticle({ x: player.x + (i-4)*8, y: player.y - 10, vx: 0, vy: -1, life: 60, color: '#888888', size: 6 });
      }
      addLog(`SHIELD WALL! (${Math.floor(skill.damageReduction*100)}% reduction)`, 'skill');
      break;
      
    case 'execute':
      player.skillAnimType = 'slam';
      player.skillAnimProgress = 1.0;
      player.atkAnim = 22;
      let execTarget = findNearestEnemy(skill.radius);
      if (execTarget) {
        const dmg = Math.floor((player.minDmg + player.maxDmg) / 2 * (skill.damage || 1) * tierMultiplier);
        execTarget.hp -= dmg; execTarget.flash = 20;
        camera.shake = 10;
        spawnDamageNumber(execTarget.x, execTarget.y, dmg, '#ff0000');
        for (let i = 0; i < 10; i++) {
          addParticle({ x: execTarget.x, y: execTarget.y, vx: (Math.random()-0.5)*10, vy: (Math.random()-0.5)*10, life: 25, color: '#ff4444', size: 5 });
        }
        checkEnemyDeath(execTarget);
        addLog(`EXECUTE T${tier}!`, 'skill');
      } else {
        player.mana += skill.manaCost; skill.cooldown = 0;
      }
      break;
      
    case 'whirlwind':
      player.skillAnimType = 'spin';
      player.skillAnimProgress = 1.0;
      player.atkAnim = 25;
      player.whirlwindActive = skill.duration;
      player.whirlwindDamage = (player.minDmg + player.maxDmg) / 2 * (skill.damage || 1) * tierMultiplier;
      player.whirlwindRadius = skill.radius;
      addLog(`WHIRLWIND T${tier}!`, 'skill');
      break;
      
    case 'revenge':
      player.skillAnimType = 'spin';
      player.skillAnimProgress = 1.0;
      player.atkAnim = 18;
      let revengeCount = 0;
      enemies.forEach(e => {
        if (!e.dead && Math.hypot(e.x - player.x, e.y - player.y) < skill.radius) {
          const dmg = Math.floor((player.minDmg + player.maxDmg) / 2 * (skill.damage || 1) * tierMultiplier);
          e.hp -= dmg; e.flash = 12; revengeCount++;
          spawnDamageNumber(e.x, e.y, dmg, '#ff6644');
          checkEnemyDeath(e);
        }
      });
      for (let i = 0; i < 10; i++) {
        const angle = (i / 10) * Math.PI * 2;
        addParticle({ x: player.x + Math.cos(angle)*35, y: player.y + Math.sin(angle)*35, vx: Math.cos(angle)*4, vy: Math.sin(angle)*4, life: 20, color: '#ff4444', size: 4 });
      }
      addLog(`REVENGE! (${revengeCount} hit)`, 'skill');
      break;
      
    case 'earthquake':
      player.skillAnimType = 'slam';
      player.skillAnimProgress = 1.0;
      player.atkAnim = 35;
      camera.shake = 30;
      for (let wave = 0; wave < skill.waves; wave++) {
        setTimeout(() => {
          enemies.forEach(e => {
            if (!e.dead && Math.hypot(e.x - player.x, e.y - player.y) < skill.radius) {
              const dmg = Math.floor((player.minDmg + player.maxDmg) / 2 * (skill.damage || 1) * tierMultiplier / skill.waves);
              e.hp -= dmg; e.flash = 15;
              spawnDamageNumber(e.x, e.y, dmg, '#aa4400');
              checkEnemyDeath(e);
            }
          });
          for (let i = 0; i < 16; i++) {
            const angle = (i / 16) * Math.PI * 2;
            const dist = 40 + wave * 50;
            addParticle({ x: player.x + Math.cos(angle)*dist, y: player.y + Math.sin(angle)*dist, vx: Math.cos(angle)*2, vy: Math.sin(angle)*2, life: 30, color: wave%2 ? '#ff6644' : '#aa4422', size: 6 });
          }
        }, wave * 200);
      }
      addLog(`EARTHQUAKE T${tier}!`, 'skill');
      break;
  }
  
  updateSkillBar();
}

// Check line of sight between two points (returns true if clear path)
// LOS cache - cleared every 10 frames
let losCache = new Map();
let losCacheFrame = 0;

function hasLineOfSight(x1, y1, x2, y2) {
  // Clear cache every 10 frames
  if (frame - losCacheFrame > 10) {
    losCache.clear();
    losCacheFrame = frame;
  }
  
  // Round positions for cache key (tile-level precision)
  const key = `${Math.floor(x1/TILE)},${Math.floor(y1/TILE)},${Math.floor(x2/TILE)},${Math.floor(y2/TILE)}`;
  if (losCache.has(key)) return losCache.get(key);
  
  const dist = Math.hypot(x2 - x1, y2 - y1);
  const steps = Math.ceil(dist / (TILE * 0.5)); // Check every half tile
  
  for (let i = 1; i < steps; i++) {
    const t = i / steps;
    const x = x1 + (x2 - x1) * t;
    const y = y1 + (y2 - y1) * t;
    
    const tx = Math.floor(x / TILE);
    const ty = Math.floor(y / TILE);
    
    // Check if this tile is a wall
    if (tx < 0 || tx >= map.width || ty < 0 || ty >= map.height || map.tiles[ty]?.[tx] !== 1) {
      losCache.set(key, false);
      return false;
    }
  }
  
  losCache.set(key, true);
  return true;
}

// Apply knockback safely - stops at walls instead of pushing through
function applyKnockback(entity, fromX, fromY, distance) {
  const angle = Math.atan2(entity.y - fromY, entity.x - fromX);
  const steps = Math.ceil(distance / 5); // Check every 5 pixels
  
  let finalX = entity.x;
  let finalY = entity.y;
  
  for (let i = 1; i <= steps; i++) {
    const t = i / steps;
    const testX = entity.x + Math.cos(angle) * distance * t;
    const testY = entity.y + Math.sin(angle) * distance * t;
    
    if (isWalkable(testX, testY)) {
      finalX = testX;
      finalY = testY;
    } else {
      // Hit a wall - stop here
      break;
    }
  }
  
  entity.x = finalX;
  entity.y = finalY;
}

function findNearestEnemy(maxDist, requireLOS = false) {
  let nearest = null;
  let nearestDist = maxDist;
  
  enemies.forEach(e => {
    if (!e.dead && e.active) {
      const dist = Math.hypot(e.x - player.x, e.y - player.y);
      if (dist < nearestDist) {
        // If LOS required, check it
        if (requireLOS && !hasLineOfSight(player.x, player.y, e.x, e.y)) {
          return; // Skip this enemy, no line of sight
        }
        nearestDist = dist;
        nearest = e;
      }
    }
  });
  
  return nearest;
}

// Helper to check if skill can be used
function canUseSkill(skillId) {
  const skill = SKILLS[skillId];
  if (!skill) return false;
  
  // Primary skills use player's attack/cast cooldown, not skill cooldown
  if (skill.isPrimary) {
    if (skill.isSpell) {
      return (player.castCD || 0) <= 0;  // Spell primaries use cast cooldown
    }
    return player.atkCD <= 0;  // Attack primaries use attack cooldown
  }
  
  return skill.cooldown <= 0 && player.mana >= skill.manaCost;
}

// Projectile limit for performance
const MAX_PROJECTILES = 10;
const MAX_PARTICLES = 100;
const MAX_LOOT = 50;
const MAX_ENEMIES = 30;
const MAX_DAMAGE_NUMBERS = 50;
const MAX_BLOOD = 30;

// Safe particle creation with limit
function addParticle(p) {
  if (particles.length < MAX_PARTICLES) {
    particles.push(p);
  }
}

function updateSkills(dt, deltaSeconds) {
  // Update cooldowns for active skills (not primaries) - using real seconds
  for (const [skillId, skill] of Object.entries(SKILLS)) {
    if (skill.cooldown > 0 && !skill.isPrimary) {
      skill.cooldown -= deltaSeconds;  // Cooldowns are now in seconds
    }
  }
  
  // AUTO-CAST SYSTEM - Use abilities automatically when near enemies
  // Disabled in test mode so player can test abilities manually
  if (!testMode) {
    const nearestEnemy = findNearestEnemy(400);
    if (nearestEnemy) {
      const distToNearest = Math.hypot(nearestEnemy.x - player.x, nearestEnemy.y - player.y);
      const hasLOS = hasLineOfSight(player.x, player.y, nearestEnemy.x, nearestEnemy.y);
      const veryClose = distToNearest < TILE * 1.5;
      const isRanged = player.class === 'ranger' || player.class === 'mage';
      
      // Get primary skill's engage range (for dashing skills like Fists of Thunder)
      const primarySkill = SKILLS[equippedSkills[0]];
      const primaryEngageRange = primarySkill?.engageRange || 80;
      
      // For ranged: use 350, for melee: use primary skill's engage range (allows dashing)
      const attackRange = isRanged ? 350 : primaryEngageRange;
      
      // Count nearby enemies at different ranges for smarter decisions
      const enemiesVeryClose = enemies.filter(e => !e.dead && e.active && Math.hypot(e.x - player.x, e.y - player.y) < 80).length;
      const enemiesClose = enemies.filter(e => !e.dead && e.active && Math.hypot(e.x - player.x, e.y - player.y) < 150).length;
      const enemiesNearby = enemies.filter(e => !e.dead && e.active && Math.hypot(e.x - player.x, e.y - player.y) < 250).length;
      
      // Health thresholds for defensive abilities
      const hpPercent = player.hp / player.maxHp;
      const manaPercent = player.mana / player.maxMana;
      const lowHealth = hpPercent < 0.6;
      const criticalHealth = hpPercent < 0.4;
      const needsHealing = hpPercent < 0.7;
      
      // Check if there's a boss nearby
      const bossNearby = enemies.some(e => !e.dead && e.active && e.isBoss && Math.hypot(e.x - player.x, e.y - player.y) < 300);
      
      // Only use abilities when in attack range
      if (distToNearest < attackRange && (hasLOS || veryClose)) {
        // ========== PRIMARY SKILL LOOP (Background DPS) ==========
        // Runs continuously based on attack/cast speed, independent of active skills
        if (canUseSkill(equippedSkills[0])) {
          useSkillSlot(0);
        }
        
        // ========== SMART ACTIVE SKILL AI ==========
        // Class-specific smart skill usage based on situation
        
        const skill1 = SKILLS[equippedSkills[1]];
        const skill2 = SKILLS[equippedSkills[2]];
        const skill3 = SKILLS[equippedSkills[3]];
        const skill4 = SKILLS[equippedSkills[4]];
        
        // Get skill names for smart decisions
        const skill1Name = equippedSkills[1];
        const skill2Name = equippedSkills[2];
        const skill3Name = equippedSkills[3];
        const skill4Name = equippedSkills[4];
        
        // Mana conservation: don't spam abilities when low on mana
        // Exception: emergency heals/defensives when health is critical
        const conserveMana = manaPercent < 0.4 && !criticalHealth;
        
        // Defensive cooldown bias: after using a defensive, deprioritize others for ~1s
        // Prevents panic-casting (Flash → Nova → Armor in same frame)
        // Makes combat look calmer and more readable
        // Uses real time (gameTime) instead of frame count
        if (!player.lastDefensiveTime) player.lastDefensiveTime = 0;
        const defensiveBiasActive = (window.gameTime - player.lastDefensiveTime) < 1.0;  // 1 second bias (real time)
        
        // ========== SLOT 4: PASSIVE SKILLS (NO AI CASTING) ==========
        // Slot 4 is now always a passive skill - no execution needed
        // Passive bonuses are applied through getPassiveBonuses() in recalculateStats()
        
        // ========== SLOT 3: ULTIMATE / AOE SKILLS ==========
        // Context-sensitive: heals when hurt, AoE when swarmed
        // Heals bypass mana conservation when needed
        // Skip entirely if priority is 0 (disabled)
        const slot3Ready = canUseSkill(equippedSkills[3]) && player.mana >= (skill3?.manaCost || 0);
        let useSlot3 = false;
        
        // Apply AI priority to slot 3 (skip if disabled)
        const slot3Conserve = shouldAIConserve(3, conserveMana);
        const slot3Disabled = skillAIPriority[3] === 0;
        
        if (slot3Ready && !slot3Disabled) {
          switch (skill3Name) {
            case 'breathOfHeaven':  // Monk heal - ONLY when hurt (bypasses mana conservation)
              useSlot3 = hpPercent < getAIHealthThreshold(3, 0.7);
              break;
            case 'waveOfLight':  // Monk nuke - use on any enemy, especially bosses
            case 'sevenSidedStrike':  // Monk ultimate - use on any enemy
            case 'meteor':  // Mage nuke - use on any enemy
            case 'earthquake':  // Warrior ultimate - use on any enemy
            case 'rainOfArrows':  // Ranger ultimate - use on any enemy
              useSlot3 = !slot3Conserve && (bossNearby || enemiesClose >= getAIThreshold(3, 1));
              break;
            case 'blizzard':  // Mage AoE DoT - when grouped enemies
              useSlot3 = !slot3Conserve && enemiesClose >= getAIThreshold(3, 2);
              break;
            case 'groundSlam':  // Warrior AoE
              useSlot3 = !slot3Conserve && enemiesClose >= getAIThreshold(3, 2);
              break;
            case 'sentry':  // Ranger turret - deploy when room to fight
              useSlot3 = !slot3Conserve && (!window.sentries || window.sentries.length < 2);
              break;
            default:
              useSlot3 = !slot3Conserve && enemiesClose >= getAIThreshold(3, 2);
          }
        }
        if (useSlot3) useSkillSlot(3);
        
        // ========== SLOT 2: MAIN ACTIVE SKILLS ==========
        // Core damage abilities - use more freely but still smart
        // Skip when conserving mana unless really needed
        // Skip entirely if priority is 0 (disabled)
        const slot2Ready = canUseSkill(equippedSkills[2]) && player.mana >= (skill2?.manaCost || 0);
        let useSlot2 = false;
        
        // Apply AI priority to slot 2 (skip if disabled)
        const slot2Conserve = shouldAIConserve(2, conserveMana);
        const slot2Disabled = skillAIPriority[2] === 0;
        
        if (slot2Ready && !slot2Disabled && skillProjectiles.length < 8 && !slot2Conserve) {
          switch (skill2Name) {
            case 'cycloneStrike':  // Monk pull - only when enemies spread out
              useSlot2 = enemiesNearby >= getAIThreshold(2, 2) && enemiesVeryClose < enemiesNearby;
              break;
            case 'chaosOrb':  // Mage orb - good single target, use freely
              useSlot2 = true;
              break;
            case 'cleave':  // Warrior cleave
              useSlot2 = enemiesClose >= getAIThreshold(2, 1);
              break;
            case 'multiShot':  // Ranger wide arc - use on bosses or multiple targets
              useSlot2 = bossNearby || enemiesNearby >= getAIThreshold(2, 2);
              break;
            default:
              useSlot2 = true;
          }
        }
        if (useSlot2) useSkillSlot(2);
        
        // ========== SLOT 1: UTILITY / DEFENSIVE SKILLS ==========
        // Most situational - buffs, CC, emergency only
        // Defensive abilities bypass mana conservation when in danger
        // Defensive bias: don't stack defensives within 1 second of each other
        // Skip entirely if priority is 0 (disabled)
        const slot1Ready = canUseSkill(equippedSkills[1]) && player.mana >= (skill1?.manaCost || 0);
        let useSlot1 = false;
        let isDefensiveSkill = false;
        
        // Apply AI priority to slot 1 (skip if disabled)
        const slot1Conserve = shouldAIConserve(1, conserveMana);
        const slot1LowHP = hpPercent < getAIHealthThreshold(1, 0.6);
        const slot1Disabled = skillAIPriority[1] === 0;
        
        if (slot1Ready && !slot1Disabled) {
          switch (skill1Name) {
            case 'blindingFlash':  // Monk blind - defensive
              isDefensiveSkill = true;
              // Skip if another defensive was used recently (unless critical)
              if (defensiveBiasActive && !criticalHealth) break;
              useSlot1 = enemiesVeryClose >= getAIThreshold(1, 3) || slot1LowHP;
              break;
            case 'frostNova':  // Mage freeze - defensive
              isDefensiveSkill = true;
              if (defensiveBiasActive && !criticalHealth) break;
              useSlot1 = enemiesVeryClose >= getAIThreshold(1, 2) || (enemiesVeryClose >= 1 && slot1LowHP);
              break;
            case 'shieldBash':  // Warrior stun - defensive
              isDefensiveSkill = true;
              if (defensiveBiasActive && !criticalHealth) break;
              useSlot1 = !slot1Conserve && enemiesVeryClose >= getAIThreshold(1, 1);
              break;
            case 'rapidFire':  // Legacy - keep for compatibility
            case 'chakram':  // Ranger secondary - use frequently for damage
              useSlot1 = !slot1Conserve && (bossNearby || enemiesNearby >= getAIThreshold(1, 1));
              break;
            case 'caltrops':  // Ranger trap - use when enemies closing in or boss fight
              // Use at start of boss fights or when being swarmed
              useSlot1 = !slot1Conserve && (bossNearby || enemiesVeryClose >= getAIThreshold(1, 2));
              break;
            case 'markedForDeath':  // Ranger debuff - prioritize bosses
              // Only mark if boss is nearby and not already marked
              const anyBossMarked = enemies.some(e => e.isBoss && !e.dead && e.markedForDeath);
              useSlot1 = !slot1Conserve && bossNearby && !anyBossMarked;
              break;
            case 'energyArmor':  // Mage shield - defensive
              isDefensiveSkill = true;
              if (defensiveBiasActive && !criticalHealth) break;
              useSlot1 = slot1LowHP || (player.currentShield < player.shield * getAIHealthThreshold(1, 0.5));
              break;
            case 'warCry':  // Warrior buff - only when enough mana
              useSlot1 = !slot1Conserve && (bossNearby || enemiesNearby >= getAIThreshold(1, 2));
              break;
            default:
              // Generic utility - defensive use only when conserving
              useSlot1 = slot1Conserve ? slot1LowHP : (slot1LowHP || enemiesClose >= getAIThreshold(1, 3));
          }
        }
        if (useSlot1) {
          useSkillSlot(1);
          // Track defensive usage for bias system
          if (isDefensiveSkill) player.lastDefensiveTime = window.gameTime;
        }
      }
    }
  } // End of !testMode check
  
  // Cyclone effect
  if (cycloneActive) {
    cycloneTimer -= window.deltaSeconds;  // FIX: Use real seconds for consistency
    if (cycloneTimer <= 0) {
      cycloneActive = false;
    } else {
      // Spin and damage nearby enemies
      enemies.forEach(e => {
        if (!e.dead && Math.hypot(e.x - player.x, e.y - player.y) < SKILLS.cyclone.radius) {
          if (Math.random() < 0.15 * window.deltaSeconds * 60) { // FIX: Frame-rate independent hit chance
            const dmg = Math.floor((player.minDmg + player.maxDmg) / 2 * (SKILLS.cyclone?.damage || 1) * cycloneTierMultiplier);
            e.hp -= dmg;
            e.flash = 5;
            spawnDamageNumber(e.x, e.y, dmg, '#88ff88');
            checkEnemyDeath(e); // Check if enemy died
          }
        }
      });
      
      // Spin particles
      if (frame % 4 === 0) { // Reduced frequency
        const angle = frame * 0.3;
        addParticle({
          x: player.x + Math.cos(angle) * 40,
          y: player.y + Math.sin(angle) * 40,
          vx: Math.cos(angle) * 3,
          vy: Math.sin(angle) * 3,
          life: 15,
          color: '#88ffaa',
          size: 5
        });
      }
    }
  }
  
  // Whirlwind effect (Warrior)
  if (player.whirlwindActive) {
    player.whirlwindActive -= dt;
    if (player.whirlwindActive <= 0) {
      player.whirlwindActive = 0;
    } else {
      enemies.forEach(e => {
        if (!e.dead && Math.hypot(e.x - player.x, e.y - player.y) < player.whirlwindRadius) {
          if (Math.random() < 0.12 * dt) {
            const dmg = Math.floor(player.whirlwindDamage);
            e.hp -= dmg; e.flash = 5;
            spawnDamageNumber(e.x, e.y, dmg, '#ffaa44');
            checkEnemyDeath(e);
          }
        }
      });
      if (frame % 5 === 0) {
        const angle = frame * 0.4;
        addParticle({ x: player.x + Math.cos(angle)*50, y: player.y + Math.sin(angle)*50, vx: Math.cos(angle)*2, vy: Math.sin(angle)*2, life: 12, color: '#ffaa44', size: 4 });
      }
    }
  }
  
  // ============ SENTRY UPDATE (Ranger) ============
  if (window.sentries && window.sentries.length > 0) {
    for (let i = window.sentries.length - 1; i >= 0; i--) {
      const sentry = window.sentries[i];
      sentry.life -= window.deltaSeconds;  // Use real seconds
      
      if (sentry.life <= 0) {
        // Sentry expired - remove with particles
        for (let j = 0; j < 8; j++) {
          addParticle({
            x: sentry.x, y: sentry.y,
            vx: (Math.random() - 0.5) * 4, vy: (Math.random() - 0.5) * 4,
            life: 15, color: '#666688', size: 3
          });
        }
        window.sentries.splice(i, 1);
        continue;
      }
      
      // Fire at enemies
      sentry.fireTimer += window.deltaSeconds;  // Use real seconds
      if (sentry.fireTimer >= sentry.fireRate) {
        // Find nearest enemy
        let sentryTarget = null;
        let closestDist = 300;  // Max range
        enemies.forEach(e => {
          if (!e.dead && e.active) {
            const dist = Math.hypot(e.x - sentry.x, e.y - sentry.y);
            if (dist < closestDist) {
              closestDist = dist;
              sentryTarget = e;
            }
          }
        });
        
        if (sentryTarget && skillProjectiles.length < MAX_PROJECTILES) {
          sentry.fireTimer = 0;  // Only reset when actually firing
          sentry.justFired = true;  // Flag for animation
          const sentryAngle = Math.atan2(sentryTarget.y - sentry.y, sentryTarget.x - sentry.x);
          sentry.lastTargetAngle = sentryAngle;  // Store for animation
          
          skillProjectiles.push({
            type: 'sentryArrow',
            x: sentry.x + Math.cos(sentryAngle) * 20,
            y: sentry.y - 10 + Math.sin(sentryAngle) * 5,
            vx: Math.cos(sentryAngle) * 16,
            vy: Math.sin(sentryAngle) * 16,
            damage: sentry.damage,
            radius: 15,
            life: 60,
            color: '#88aaff'
          });
          
          // Muzzle flash particles
          for (let i = 0; i < 3; i++) {
            addParticle({
              x: sentry.x + Math.cos(sentryAngle) * 22,
              y: sentry.y - 10 + Math.sin(sentryAngle) * 5,
              vx: Math.cos(sentryAngle) * 4 + (Math.random() - 0.5) * 2,
              vy: Math.sin(sentryAngle) * 4 + (Math.random() - 0.5) * 2,
              life: 10, color: i === 0 ? '#ffdd88' : '#aaccff', size: 3
            });
          }
        } else {
          // No target - cap timer at fireRate so it fires immediately when enemy arrives
          sentry.fireTimer = sentry.fireRate;
        }
      }
    }
  }
  
  // ============ RAIN OF ARROWS ZONES (Ranger) ============
  if (window.rainZones && window.rainZones.length > 0) {
    for (let i = window.rainZones.length - 1; i >= 0; i--) {
      const zone = window.rainZones[i];
      zone.life -= window.deltaSeconds;  // Use real seconds
      
      if (zone.life <= 0) {
        window.rainZones.splice(i, 1);
        continue;
      }
      
      // Tick damage
      zone.tickTimer += window.deltaSeconds;  // Use real seconds
      if (zone.tickTimer >= zone.tickRate) {
        zone.tickTimer = 0;
        const tickDmg = Math.floor(zone.damage / (zone.duration / zone.tickRate));
        
        enemies.forEach(e => {
          if (!e.dead && e.active && Math.hypot(e.x - zone.x, e.y - zone.y) < zone.radius) {
            e.hp -= tickDmg;
            e.flash = 5;
            spawnDamageNumber(e.x, e.y, tickDmg, '#88aa66');
            
            // Apply bleed (durations already in seconds)
            if (!e.bleedDamage || e.bleedDamage < zone.bleedDamage) {
              e.bleedDamage = zone.bleedDamage;
              e.bleedDuration = zone.bleedDuration;
            }
            
            checkEnemyDeath(e);
          }
        });
      }
      
      // Visual - falling arrows
      if (frame % 3 === 0) {
        const angle = Math.random() * Math.PI * 2;
        const dist = Math.random() * zone.radius;
        addParticle({
          x: zone.x + Math.cos(angle) * dist,
          y: zone.y + Math.sin(angle) * dist - 80,
          vx: (Math.random() - 0.5) * 1,
          vy: 10 + Math.random() * 5,
          life: 18, color: '#669944', size: 2
        });
      }
    }
  }
  
  // ============ CALTROPS ZONES (Ranger) ============
  if (window.caltropZones && window.caltropZones.length > 0) {
    for (let i = window.caltropZones.length - 1; i >= 0; i--) {
      const zone = window.caltropZones[i];
      zone.life -= window.deltaSeconds;
      
      if (zone.life <= 0) {
        window.caltropZones.splice(i, 1);
        continue;
      }
      
      // Tick damage every 0.5s
      zone.tickTimer += window.deltaSeconds;
      if (zone.tickTimer >= zone.tickRate) {
        zone.tickTimer = 0;
        
        enemies.forEach(e => {
          if (!e.dead && e.active && Math.hypot(e.x - zone.x, e.y - zone.y) < zone.radius) {
            // Damage
            const tickDmg = Math.floor(zone.damage * zone.tickRate);
            e.hp -= tickDmg;
            e.flash = 5;
            spawnDamageNumber(e.x, e.y, tickDmg, '#888888');
            
            // Apply slow
            e.caltropSlowed = true;
            e.caltropSlowAmount = zone.slowAmount;
            e.caltropSlowTimer = 0.5;  // Slow persists briefly after leaving
            
            // Apply damage reduction debuff
            e.caltropWeakened = true;
            e.caltropDamageReduction = zone.damageReduction || 0.15;
            e.caltropWeakenTimer = 0.5;  // Debuff persists briefly after leaving
            
            checkEnemyDeath(e);
          }
        });
      }
      
      // Visual - scattered metal shards
      if (frame % 8 === 0) {
        const angle = Math.random() * Math.PI * 2;
        const dist = Math.random() * zone.radius * 0.8;
        addParticle({
          x: zone.x + Math.cos(angle) * dist,
          y: zone.y + Math.sin(angle) * dist,
          vx: (Math.random() - 0.5) * 0.5,
          vy: (Math.random() - 0.5) * 0.5,
          life: 10, color: '#666666', size: 2
        });
      }
    }
  }
  
  // ============ MARKED FOR DEATH UPDATE ============
  enemies.forEach(e => {
    if (!e.dead && e.markedForDeath) {
      e.markDuration -= window.deltaSeconds;
      
      if (e.markDuration <= 0) {
        e.markedForDeath = false;
        e.markDamageAmp = 0;
      }
      
      // Visual indicator - pulsing skull above head
      if (frame % 20 === 0) {
        addParticle({
          x: e.x, y: e.y - e.size - 15,
          vx: 0, vy: -0.5,
          life: 18, color: '#ff4444', size: 6
        });
      }
    }
    
    // Caltrop slow decay
    if (e.caltropSlowed && e.caltropSlowTimer > 0) {
      e.caltropSlowTimer -= window.deltaSeconds;
      if (e.caltropSlowTimer <= 0) {
        e.caltropSlowed = false;
        e.caltropSlowAmount = 0;
      }
    }
    
    // Caltrop damage reduction decay
    if (e.caltropWeakened && e.caltropWeakenTimer > 0) {
      e.caltropWeakenTimer -= window.deltaSeconds;
      if (e.caltropWeakenTimer <= 0) {
        e.caltropWeakened = false;
        e.caltropDamageReduction = 0;
      }
    }
  });
  
  // ============ BLEED DOT UPDATE ============
  // Use time accumulator for tick timing instead of frame modulo
  if (!window.bleedTickAccum) window.bleedTickAccum = 0;
  window.bleedTickAccum += window.deltaSeconds;
  const bleedShouldTick = window.bleedTickAccum >= 0.5;  // Tick every 0.5 seconds
  if (bleedShouldTick) window.bleedTickAccum = 0;
  
  enemies.forEach(e => {
    if (!e.dead && e.bleedDuration > 0) {
      e.bleedDuration -= window.deltaSeconds;  // Use real seconds
      if (bleedShouldTick) {  // Tick every 0.5s
        const bleedTick = Math.floor(e.bleedDamage);
        e.hp -= bleedTick;
        spawnDamageNumber(e.x, e.y - 10, bleedTick, '#44aa44');
        addParticle({
          x: e.x + (Math.random() - 0.5) * 20, y: e.y,
          vx: 0, vy: -1, life: 15, color: '#227722', size: 2
        });
        checkEnemyDeath(e);
      }
    }
  });
  
  // Buff timers (all in seconds now)
  if (player.ironSkinActive > 0) player.ironSkinActive -= window.deltaSeconds;
  if (player.zenFocusActive > 0) player.zenFocusActive -= window.deltaSeconds;
  if (player.manaShieldActive > 0) player.manaShieldActive -= window.deltaSeconds;
  if (player.warCryActive > 0) player.warCryActive -= window.deltaSeconds;
  if (player.shieldWallActive > 0) player.shieldWallActive -= window.deltaSeconds;
  
  // New Monk buff timers (all in seconds now)
  if (player.blindingFlashDuration > 0) {
    player.blindingFlashDuration -= window.deltaSeconds;
    if (player.blindingFlashDuration <= 0) {
      player.blindingFlashDodge = 0;
    }
  }
  if (player.breathOfHeavenDuration > 0) {
    player.breathOfHeavenDuration -= window.deltaSeconds;
    if (player.breathOfHeavenDuration <= 0) {
      player.breathOfHeavenAtkSpd = 0;
      player.breathOfHeavenMoveSpd = 0;
    }
  }
  
  // Mage buff timers
  if (player.energyArmorDuration > 0) {
    player.energyArmorDuration -= window.deltaSeconds;  // FIX: Use real seconds like other buffs
    if (player.energyArmorDuration <= 0) {
      player.energyArmorBonus = 0;
      player.energyArmorDR = 0;
    }
  }
  
  // Blizzard zone update
  if (player.blizzardZone) {
    const bz = player.blizzardZone;
    bz.duration -= window.deltaSeconds;  // Use real seconds
    bz.tickTimer += window.deltaSeconds;
    
    // Tick damage (tickRate now in seconds)
    if (bz.tickTimer >= bz.tickRate) {
      bz.tickTimer = 0;
      enemies.forEach(e => {
        if (!e.dead && Math.hypot(e.x - bz.x, e.y - bz.y) < bz.radius) {
          const dmg = Math.floor(bz.damage);
          e.hp -= dmg;
          e.flash = 5;
          e.slowed = 1.0; // Apply 1 second slow (real time)
          e.slowAmount = Math.min((e.slowAmount || 0) + bz.slowAmount, 0.7); // Stack up to 70%
          spawnDamageNumber(e.x, e.y, dmg, '#88ccff');
          updateBossBarOnHit(e);  // Show boss bar if hitting boss
          checkEnemyDeath(e);
        }
      });
      
      // Blizzard particles
      for (let i = 0; i < 8; i++) {
        const angle = Math.random() * Math.PI * 2;
        const dist = Math.random() * bz.radius;
        addParticle({
          x: bz.x + Math.cos(angle) * dist,
          y: bz.y + Math.sin(angle) * dist,
          vx: (Math.random() - 0.5) * 2,
          vy: Math.random() * -4,
          life: 25,
          color: Math.random() > 0.5 ? '#88ccff' : '#ffffff',
          size: 3 + Math.random() * 3
        });
      }
    }
    
    // Remove when expired
    if (bz.duration <= 0) {
      player.blizzardZone = null;
    }
  }
  
  // Pending meteor update
  if (player.pendingMeteor) {
    const pm = player.pendingMeteor;
    pm.delay -= window.deltaSeconds;  // Use real seconds
    
    if (pm.delay <= 0) {
      // METEOR IMPACT!
      camera.shake = 15;
      
      // Deal impact damage
      enemies.forEach(e => {
        if (!e.dead && Math.hypot(e.x - pm.x, e.y - pm.y) < pm.radius) {
          const dmg = Math.floor(pm.damage);
          e.hp -= dmg;
          e.flash = 20;
          spawnDamageNumber(e.x, e.y, dmg, '#ff8844');
          updateBossBarOnHit(e);  // Show boss bar if hitting boss
          
          // Apply burn debuff
          e.meteorBurn = pm.burnDuration;
          e.meteorBurnDamage = pm.burnDamage / (pm.burnDuration / 30); // Damage per tick
          
          checkEnemyDeath(e);
        }
      });
      
      // Impact visual - massive explosion
      for (let i = 0; i < 30; i++) {
        const angle = (i / 30) * Math.PI * 2;
        const speed = 8 + Math.random() * 6;
        addParticle({
          x: pm.x, y: pm.y,
          vx: Math.cos(angle) * speed,
          vy: Math.sin(angle) * speed,
          life: 35,
          color: ['#ff4400', '#ff8800', '#ffcc00'][Math.floor(Math.random() * 3)],
          size: 6 + Math.random() * 4
        });
      }
      
      // Central fire
      for (let i = 0; i < 12; i++) {
        addParticle({
          x: pm.x + (Math.random() - 0.5) * 40,
          y: pm.y + (Math.random() - 0.5) * 40,
          vx: (Math.random() - 0.5) * 4,
          vy: -2 - Math.random() * 4,
          life: 40,
          color: '#ffaa22',
          size: 8
        });
      }
      
      addLog(`METEOR IMPACT!`, 'skill');
      player.pendingMeteor = null;
    }
  }
  
  // Shield recharge (POE2 style)
  if (player.shield > 0) {
    if (player.shieldRechargeDelay > 0) {
      // Waiting for recharge to start (using real seconds)
      player.shieldRechargeDelay -= window.deltaSeconds;
    } else if (player.currentShield < player.shield) {
      // Recharging - recover shield over time (rate is per second)
      player.currentShield = Math.min(player.shield, player.currentShield + player.shieldRechargeRate * window.deltaSeconds);
    }
  }
  
  // Inner Sanctuary zone update
  if (player.innerSanctuary) {
    const sanctuary = player.innerSanctuary;
    sanctuary.duration -= window.deltaSeconds;
    
    // Check if player is inside the zone
    const distToSanctuary = Math.hypot(player.x - sanctuary.x, player.y - sanctuary.y);
    player.inSanctuary = distToSanctuary < sanctuary.radius;
    
    // Heal while inside (heal per second)
    if (player.inSanctuary) {
      const healAmount = Math.floor(player.maxHP * sanctuary.healPerSecond * window.deltaSeconds);
      player.hp = Math.min(player.maxHP, player.hp + healAmount);
      
      // Healing particles
      if (frame % 15 === 0) {
        addParticle({
          x: player.x + (Math.random() - 0.5) * 30,
          y: player.y + 10,
          vx: 0, vy: -2,
          life: 20, color: '#88ff88', size: 3
        });
      }
    }
    
    // Zone visual particles
    if (frame % 10 === 0) {
      const angle = Math.random() * Math.PI * 2;
      addParticle({
        x: sanctuary.x + Math.cos(angle) * sanctuary.radius,
        y: sanctuary.y + Math.sin(angle) * sanctuary.radius,
        vx: 0, vy: -1,
        life: 25, color: '#aaffaa', size: 3
      });
    }
    
    // Remove when expired
    if (sanctuary.duration <= 0) {
      player.innerSanctuary = null;
      player.inSanctuary = false;
    }
  }
  
  // Seven-Sided Strike update (frame-based instead of setTimeout)
  if (player.sevenSidedStrikeData && player.sevenSidedStrikeData.active) {
    const sss = player.sevenSidedStrikeData;
    const now = Date.now();
    
    // Failsafe: if skill has been running for more than 2 seconds, force end it
    if (!sss.startTime) sss.startTime = now;
    if (now - sss.startTime > 2000) {
      player.x = sss.originalX;
      player.y = sss.originalY;
      player.invulnerable = false;
      player.sevenSidedStrikeData = null;
      return;
    }
    
    // Abort if floor changed
    if (player.currentFloor !== sss.startFloor) {
      player.x = sss.originalX;
      player.y = sss.originalY;
      player.invulnerable = false;
      player.sevenSidedStrikeData = null;
    } else if (now >= sss.nextStrikeTime && sss.strikesRemaining > 0) {
      // Perform a strike
      const validTargets = enemies.filter(e => !e.dead);
      
      if (validTargets.length > 0) {
        const target = validTargets[Math.floor(Math.random() * validTargets.length)];
        
        // Teleport to target - use fixed bounds (800x600 game area)
        const angle = Math.random() * Math.PI * 2;
        const newX = target.x + Math.cos(angle) * 30;
        const newY = target.y + Math.sin(angle) * 30;
        
        // Clamp to valid bounds (fixed game area)
        player.x = Math.max(60, Math.min(740, newX));
        player.y = Math.max(60, Math.min(540, newY));
        player.facing = target.x > player.x ? 1 : -1;
        
        // Deal damage
        target.hp -= sss.damage;
        target.flash = 8;
        sss.strikeCount++;
        spawnDamageNumber(target.x, target.y - (sss.strikeCount * 5), sss.damage, '#ffffff');
        
        // Strike visual
        for (let j = 0; j < 6; j++) {
          const pAngle = (j / 6) * Math.PI * 2;
          addParticle({
            x: target.x + Math.cos(pAngle) * 20,
            y: target.y + Math.sin(pAngle) * 20,
            vx: Math.cos(pAngle) * 4, vy: Math.sin(pAngle) * 4,
            life: 10, color: '#ffff88', size: 3
          });
        }
        
        // Teleport trail
        addParticle({
          x: player.x, y: player.y,
          vx: 0, vy: 0, life: 15, color: '#aaaaff', size: 8
        });
        
        camera.shake = Math.max(camera.shake, 2);
        checkEnemyDeath(target);
        
        sss.strikesRemaining--;
        sss.nextStrikeTime = now + 80;
      } else {
        // No valid targets left - end sequence early
        sss.strikesRemaining = 0;
        sss.returnTime = now + 50;
      }
      
      // Check if done
      if (sss.strikesRemaining <= 0 && !sss.returnTime) {
        sss.returnTime = now + 100;
      }
    } else if (sss.strikesRemaining <= 0 && sss.returnTime && now >= sss.returnTime) {
      // Return to original position
      player.x = sss.originalX;
      player.y = sss.originalY;
      player.invulnerable = false;
      
      // Return flash
      for (let i = 0; i < 10; i++) {
        const angle = (i / 10) * Math.PI * 2;
        addParticle({
          x: player.x + Math.cos(angle) * 30,
          y: player.y + Math.sin(angle) * 30,
          vx: Math.cos(angle) * 3, vy: Math.sin(angle) * 3,
          life: 15, color: '#8888ff', size: 4
        });
      }
      
      player.sevenSidedStrikeData = null;
    }
  }
  
  // Enemy debuff updates
  enemies.forEach(e => {
    if (e.dead) return;
    // Hunter's Mark timer (using real seconds)
    if (e.marked && e.marked > 0) {
      e.marked -= window.deltaSeconds;
    }
    // Blinding Flash - blind timer decay (duration in seconds)
    if (e.blinded && e.blinded > 0) {
      e.blinded -= window.deltaSeconds;
      if (e.blinded <= 0) {
        e.blindMissChance = 0;
      }
    }
    // Cyclone Strike - slow timer decay (duration in seconds)
    if (e.slowed && e.slowed > 0) {
      e.slowed -= window.deltaSeconds;
      if (e.slowed <= 0) {
        e.slowAmount = 0;
      }
    }
    // Frozen (Frost Nova) - complete inability to act (duration in seconds)
    if (e.frozen && e.frozen > 0) {
      e.frozen -= window.deltaSeconds;
      // Ice particles while frozen
      if (frame % 20 === 0) {
        addParticle({
          x: e.x + (Math.random() - 0.5) * 20,
          y: e.y - 10,
          vx: (Math.random() - 0.5) * 2,
          vy: -1,
          life: 25,
          color: '#aaeeff',
          size: 3
        });
      }
    }
    // Meteor burn - fire DoT
    if (e.meteorBurn && e.meteorBurn > 0) {
      e.meteorBurn -= dt;
      // Tick damage every 30 frames
      if (frame % 30 === 0 && e.meteorBurnDamage) {
        const burnDmg = Math.floor(e.meteorBurnDamage);
        e.hp -= burnDmg;
        e.flash = 5;
        spawnDamageNumber(e.x, e.y, burnDmg, '#ff6622');
        // Fire particles
        addParticle({
          x: e.x + (Math.random() - 0.5) * 15,
          y: e.y + (Math.random() - 0.5) * 15,
          vx: (Math.random() - 0.5) * 3, vy: -2,
          life: 20, color: '#ff8844', size: 4
        });
        checkEnemyDeath(e);
      }
    }
    // Exploding Palm - bleed tick
    if (e.explodingPalmMark && e.explodingPalmMark > 0) {
      e.explodingPalmMark -= dt;
      // Tick damage every 15 frames
      if (frame % 15 === 0 && e.explodingPalmDamage) {
        const bleedDmg = Math.floor(e.explodingPalmDamage);
        e.hp -= bleedDmg;
        e.flash = 3;
        spawnDamageNumber(e.x, e.y, bleedDmg, '#ff6644');
        // Bleed particles
        addParticle({
          x: e.x + (Math.random() - 0.5) * 15,
          y: e.y + (Math.random() - 0.5) * 15,
          vx: (Math.random() - 0.5) * 2, vy: 1,
          life: 15, color: '#ff4444', size: 3
        });
        // Check death (triggers explosion)
        if (e.hp <= 0 && !e.dead) {
          triggerExplodingPalmExplosion(e);
        }
      }
    }
  });
  
  // Update projectiles
  for (let i = skillProjectiles.length - 1; i >= 0; i--) {
    const p = skillProjectiles[i];
    
    // Homing behavior for Hungry Arrow
    if (p.homing && p.homingStrength) {
      const nearestEnemy = enemies.find(e => !e.dead && e.active && Math.hypot(e.x - p.x, e.y - p.y) < 200);
      if (nearestEnemy) {
        const targetAngle = Math.atan2(nearestEnemy.y - p.y, nearestEnemy.x - p.x);
        const currentAngle = Math.atan2(p.vy, p.vx);
        let angleDiff = targetAngle - currentAngle;
        // Normalize angle diff
        while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
        while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
        const newAngle = currentAngle + angleDiff * p.homingStrength;
        const speed = Math.hypot(p.vx, p.vy);
        p.vx = Math.cos(newAngle) * speed;
        p.vy = Math.sin(newAngle) * speed;
      }
    }
    
    p.x += p.vx * dt;
    p.y += p.vy * dt;
    p.life -= dt;
    
    // Hungry Arrow trail - green seeking arrows
    if (p.type === 'hungryArrow' && frame % 4 === 0) {
      addParticle({
        x: p.x, y: p.y,
        vx: -p.vx * 0.05, vy: -p.vy * 0.05,
        life: 12, color: '#88cc88', size: 3
      });
    }
    
    // Chakram - spinning disc that returns
    if (p.type === 'chakram') {
      p.spin = (p.spin || 0) + 0.4;  // Spin animation
      
      // Check if should return
      const distFromStart = Math.hypot(p.x - p.startX, p.y - p.startY);
      if (!p.returning && distFromStart >= p.maxRange) {
        p.returning = true;
        p.hitEnemies.clear();  // Allow hitting enemies again on return
      }
      
      // Return to player
      if (p.returning) {
        const angleToPlayer = Math.atan2(player.y - p.y, player.x - p.x);
        const returnSpeed = 14;
        p.vx = Math.cos(angleToPlayer) * returnSpeed;
        p.vy = Math.sin(angleToPlayer) * returnSpeed;
        
        // Destroy when close to player
        const distToPlayer = Math.hypot(p.x - player.x, p.y - player.y);
        if (distToPlayer < 30) {
          p.life = 0;
        }
      }
      
      // Trail effect
      if (frame % 2 === 0) {
        addParticle({
          x: p.x + (Math.random() - 0.5) * 15,
          y: p.y + (Math.random() - 0.5) * 15,
          vx: (Math.random() - 0.5) * 2,
          vy: (Math.random() - 0.5) * 2,
          life: 10, color: '#ffdd88', size: 3
        });
      }
    }
    
    // Multishot trail - teal spread arrows
    if (p.type === 'multiShot' && frame % 5 === 0) {
      addParticle({
        x: p.x, y: p.y,
        vx: -p.vx * 0.03, vy: -p.vy * 0.03,
        life: 10, color: '#88ddbb', size: 2
      });
    }
    
    // Sentry Arrow trail - blue turret arrows
    if (p.type === 'sentryArrow' && frame % 4 === 0) {
      addParticle({
        x: p.x, y: p.y,
        vx: -p.vx * 0.05, vy: -p.vy * 0.05,
        life: 10, color: '#8888dd', size: 2
      });
    }
    
    // Fireball trail - reduced frequency
    if (p.type === 'fireball' && frame % 4 === 0) {
      addParticle({
        x: p.x + (Math.random() - 0.5) * 10,
        y: p.y + (Math.random() - 0.5) * 10,
        vx: -p.vx * 0.1 + (Math.random() - 0.5) * 2,
        vy: -p.vy * 0.1 + (Math.random() - 0.5) * 2,
        life: 20,
        color: Math.random() > 0.5 ? '#ff6622' : '#ffaa22',
        size: 4 + Math.random() * 3
      });
    }
    
    // Qi Blast trail
    if (p.type === 'qiBlast' && frame % 3 === 0) {
      addParticle({
        x: p.x + (Math.random() - 0.5) * 15,
        y: p.y + (Math.random() - 0.5) * 15,
        vx: -p.vx * 0.05,
        vy: -p.vy * 0.05,
        life: 15,
        color: '#88ddff',
        size: 6
      });
    }
    
    // Explosive arrow trail
    if (p.type === 'explosiveArrow' && frame % 5 === 0) {
      addParticle({ x: p.x, y: p.y, vx: -p.vx*0.1, vy: -p.vy*0.1, life: 15, color: '#ff6644', size: 3 });
    }
    
    // Chaos orb glow
    if (p.type === 'chaosOrb' && frame % 4 === 0) {
      addParticle({ x: p.x + (Math.random()-0.5)*20, y: p.y + (Math.random()-0.5)*20, vx: 0, vy: 0, life: 12, color: '#aa66ff', size: 4 });
    }
    
    // Ice spear trail
    if (p.type === 'iceSpear' && frame % 5 === 0) {
      addParticle({ x: p.x, y: p.y, vx: -p.vx*0.1, vy: -p.vy*0.1, life: 12, color: '#88ddff', size: 3 });
    }
    
    // Piercing shot trail
    if (p.type === 'piercingShot' && frame % 4 === 0) {
      addParticle({ x: p.x, y: p.y, vx: (Math.random()-0.5)*2, vy: (Math.random()-0.5)*2, life: 10, color: '#ffff44', size: 3 });
    }
    
    // Freezing arrow trail
    if (p.type === 'freezingArrow' && frame % 5 === 0) {
      addParticle({ x: p.x, y: p.y, vx: -p.vx*0.1, vy: -p.vy*0.1, life: 12, color: '#aaeeff', size: 3 });
    }
    
    // Arrow trail - minimal
    if (p.type === 'arrow' && frame % 6 === 0) {
      addParticle({
        x: p.x,
        y: p.y,
        vx: -p.vx * 0.02,
        vy: -p.vy * 0.02,
        life: 10,
        color: '#8B7355',
        size: 2
      });
    }
    
    // Magic bolt trail
    if (p.type === 'magicBolt' && frame % 4 === 0) {
      addParticle({
        x: p.x + (Math.random() - 0.5) * 8,
        y: p.y + (Math.random() - 0.5) * 8,
        vx: -p.vx * 0.05,
        vy: -p.vy * 0.05,
        life: 12,
        color: '#9966FF',
        size: 4
      });
    }
    
    // Magic Missile trail (new mage primary)
    if (p.type === 'magicMissile' && frame % 3 === 0) {
      addParticle({
        x: p.x + (Math.random() - 0.5) * 8,
        y: p.y + (Math.random() - 0.5) * 8,
        vx: -p.vx * 0.05,
        vy: -p.vy * 0.05,
        life: 15,
        color: Math.random() > 0.5 ? '#aa88ff' : '#cc99ff',
        size: 4
      });
    }
    
    // Check collision with walls
    let hitWall = !isWalkable(p.x, p.y);
    
    // Check collision with enemies
    let hit = false;
    let hitEnemy = null;
    enemies.forEach(e => {
      if (!e.dead && Math.hypot(e.x - p.x, e.y - p.y) < e.size + 10) {
        hit = true;
        hitEnemy = e;
      }
    });
    
    // Handle piercing projectiles
    if (p.pierce && hit && hitEnemy) {
      if (!p.hitEnemies) p.hitEnemies = [];
      if (!p.hitEnemies.includes(hitEnemy)) {
        p.hitEnemies.push(hitEnemy);
        hitEnemy.hp -= p.damage;
        hitEnemy.flash = 10;
        const color = p.type === 'iceSpear' ? '#88ddff' : '#ffaa44';
        spawnDamageNumber(hitEnemy.x, hitEnemy.y, Math.floor(p.damage), color);
        if (p.type === 'iceSpear') hitEnemy.slowed = 1.0;  // 1 second slow
        checkEnemyDeath(hitEnemy);
        p.pierce--;
        hit = false; // Don't destroy projectile yet
      } else {
        hit = false; // Already hit this enemy
      }
    }
    
    // Handle Hungry Arrow pierce chance (35% to continue)
    if (p.type === 'hungryArrow' && p.pierceChance && hit && hitEnemy && !p.hasPierced) {
      if (!p.hitEnemies) p.hitEnemies = [];
      if (!p.hitEnemies.includes(hitEnemy)) {
        p.hitEnemies.push(hitEnemy);
        hitEnemy.hp -= p.damage;
        hitEnemy.flash = 10;
        spawnDamageNumber(hitEnemy.x, hitEnemy.y, Math.floor(p.damage), '#88cc88');
        updateBossBarOnHit(hitEnemy);
        
        // Life/Mana on hit
        player.hp = Math.min(player.maxHp, player.hp + player.lifeOnHit);
        player.mana = Math.min(player.maxMana, player.mana + player.manaOnHit);
        
        checkEnemyDeath(hitEnemy);
        
        // Roll for pierce
        if (Math.random() < p.pierceChance) {
          p.hasPierced = true;  // Can only pierce once
          hit = false;
          addParticle({ x: hitEnemy.x, y: hitEnemy.y, vx: 0, vy: -2, life: 12, color: '#aaffaa', size: 4 });
        }
      } else {
        hit = false;
      }
    }
    
    // Handle Chakram - hits enemies along path, can hit again on return
    if (p.type === 'chakram' && hitEnemy) {
      if (!p.hitEnemies.has(hitEnemy.id)) {
        p.hitEnemies.add(hitEnemy.id);
        
        // Apply marked for death bonus
        let finalDamage = p.damage;
        if (hitEnemy.markedForDeath && hitEnemy.markDamageAmp) {
          finalDamage = Math.floor(p.damage * (1 + hitEnemy.markDamageAmp));
        }
        
        hitEnemy.hp -= finalDamage;
        hitEnemy.flash = 12;
        spawnDamageNumber(hitEnemy.x, hitEnemy.y, Math.floor(finalDamage), '#ffdd44');
        updateBossBarOnHit(hitEnemy);
        
        // Life/Mana on hit
        player.hp = Math.min(player.maxHp, player.hp + player.lifeOnHit);
        player.mana = Math.min(player.maxMana, player.mana + player.manaOnHit);
        
        checkEnemyDeath(hitEnemy);
        
        // Sparks on hit
        for (let j = 0; j < 6; j++) {
          const sparkAngle = Math.random() * Math.PI * 2;
          addParticle({
            x: hitEnemy.x, y: hitEnemy.y,
            vx: Math.cos(sparkAngle) * 4,
            vy: Math.sin(sparkAngle) * 4,
            life: 12, color: '#ffcc44', size: 3
          });
        }
      }
      hit = false;  // Chakram passes through enemies
    }
    
    // Explode on hit, wall collision, or end of life
    if (hit || hitWall || p.life <= 0) {
      if (p.type === 'arrow' || p.type === 'magicBolt' || p.type === 'magicMissile') {
        // Single-target hit for basic attacks
        if (hitEnemy && !hitEnemy.dead) {
          // Apply marked for death bonus
          let finalDamage = p.damage;
          if (hitEnemy.markedForDeath && hitEnemy.markDamageAmp) {
            finalDamage = Math.floor(p.damage * (1 + hitEnemy.markDamageAmp));
          }
          
          hitEnemy.hp -= finalDamage;
          hitEnemy.flash = 8;
          const color = p.type === 'arrow' ? '#ffcc44' : (p.type === 'magicMissile' ? '#aa88ff' : '#cc88ff');
          spawnDamageNumber(hitEnemy.x, hitEnemy.y, Math.floor(finalDamage), color);
          
          // Life and Mana on Hit for ranged attacks
          player.hp = Math.min(player.maxHp, player.hp + player.lifeOnHit);
          player.mana = Math.min(player.maxMana, player.mana + player.manaOnHit);
          
          // Boss handling
          if (hitEnemy.isBoss) {
            currentBoss = hitEnemy;
            document.getElementById('bossBar').classList.add('visible');
            document.getElementById('bossName').textContent = hitEnemy.name;
            if (Math.random() < 0.3) {
              applyDebuff(hitEnemy);
            }
            updateBossBar();
          }
          
          checkEnemyDeath(hitEnemy);
          
          // Impact particles
          const impactColor = p.type === 'arrow' ? '#8B7355' : (p.type === 'magicMissile' ? '#aa88ff' : '#9966FF');
          for (let j = 0; j < 5; j++) {
            const angle = Math.random() * Math.PI * 2;
            addParticle({
              x: p.x, y: p.y,
              vx: Math.cos(angle) * 2,
              vy: Math.sin(angle) * 2,
              life: 15,
              color: impactColor,
              size: 3
            });
          }
        }
      } else if (p.type === 'fireball' || p.type === 'qiBlast' || p.type === 'explosiveArrow' || p.type === 'chaosOrb') {
        // AOE Explosion!
        const colorMap = { fireball: '#ff8844', qiBlast: '#88ddff', explosiveArrow: '#ff6644', chaosOrb: '#aa88ff' };
        const color = colorMap[p.type] || '#ff8844';
        enemies.forEach(e => {
          if (!e.dead && Math.hypot(e.x - p.x, e.y - p.y) < (p.radius || 60)) {
            e.hp -= p.damage;
            e.flash = 15;
            spawnDamageNumber(e.x, e.y, Math.floor(p.damage), color);
            updateBossBarOnHit(e);  // Show boss bar if hitting boss
            checkEnemyDeath(e);
          }
        });
        
        // Explosion particles - reduced for performance
        const colorSets = {
          fireball: ['#ff4400', '#ff8800', '#ffcc00'],
          qiBlast: ['#44aaff', '#88ddff', '#aaffff'],
          explosiveArrow: ['#ff4400', '#ff6600', '#ffaa00'],
          chaosOrb: ['#8844ff', '#aa66ff', '#cc88ff']
        };
        const colors = colorSets[p.type] || colorSets.fireball;
        for (let j = 0; j < 12; j++) {
          const angle = Math.random() * Math.PI * 2;
          const speed = 3 + Math.random() * 5;
          addParticle({
            x: p.x, y: p.y,
            vx: Math.cos(angle) * speed,
            vy: Math.sin(angle) * speed,
            life: 20,
            color: colors[Math.floor(Math.random() * 3)],
            size: 4 + Math.random() * 3
          });
        }
      } else if (p.type === 'piercingShot' && hitEnemy) {
        // Piercing shot - damages and continues through enemies
        hitEnemy.hp -= p.damage;
        hitEnemy.flash = 8;
        spawnDamageNumber(hitEnemy.x, hitEnemy.y, Math.floor(p.damage), '#ffff44');
        checkEnemyDeath(hitEnemy);
        for (let j = 0; j < 5; j++) {
          addParticle({ x: p.x, y: p.y, vx: (Math.random()-0.5)*4, vy: (Math.random()-0.5)*4, life: 20, color: '#ffff44', size: 3 });
        }
        // Pierce through if we have pierce charges left
        if (p.pierce && p.pierce > 0) {
          p.pierce--;
          p.hitEnemies = p.hitEnemies || [];
          p.hitEnemies.push(hitEnemy);
        } else {
          p.life = 0;
        }
      } else if (p.type === 'freezingArrow' && hitEnemy) {
        // Apply slow
        hitEnemy.hp -= p.damage;
        hitEnemy.flash = 10;
        hitEnemy.slowed = p.slowDuration;
        spawnDamageNumber(hitEnemy.x, hitEnemy.y, Math.floor(p.damage), '#88ddff');
        checkEnemyDeath(hitEnemy);
        for (let j = 0; j < 5; j++) {
          addParticle({ x: p.x, y: p.y, vx: (Math.random()-0.5)*4, vy: (Math.random()-0.5)*4, life: 20, color: '#88ddff', size: 3 });
        }
      } else if ((p.type === 'powerArrow' || p.type === 'iceSpear') && hitEnemy && p.pierce <= 0) {
        // Final hit of piercing projectile
        hitEnemy.hp -= p.damage;
        hitEnemy.flash = 10;
        spawnDamageNumber(hitEnemy.x, hitEnemy.y, Math.floor(p.damage), p.type === 'iceSpear' ? '#88ddff' : '#ffaa44');
        checkEnemyDeath(hitEnemy);
      } else if (p.type === 'rapidFire' && hitEnemy) {
        // Rapid Fire - single target hits
        hitEnemy.hp -= p.damage;
        hitEnemy.flash = 6;
        spawnDamageNumber(hitEnemy.x, hitEnemy.y, Math.floor(p.damage), '#ffaa44');
        player.hp = Math.min(player.maxHp, player.hp + player.lifeOnHit);
        player.mana = Math.min(player.maxMana, player.mana + player.manaOnHit);
        updateBossBarOnHit(hitEnemy);
        checkEnemyDeath(hitEnemy);
        for (let j = 0; j < 3; j++) {
          addParticle({ x: p.x, y: p.y, vx: (Math.random()-0.5)*3, vy: (Math.random()-0.5)*3, life: 10, color: '#ffcc44', size: 2 });
        }
      } else if (p.type === 'multiShot' && hitEnemy) {
        // Multishot - apply falloff based on distance traveled
        const distanceTraveled = 80 - p.life;  // Approximate
        const falloffMult = distanceTraveled > 40 ? (p.falloff || 0.85) : 1.0;
        const finalDmg = Math.floor(p.damage * falloffMult);
        hitEnemy.hp -= finalDmg;
        hitEnemy.flash = 8;
        spawnDamageNumber(hitEnemy.x, hitEnemy.y, finalDmg, '#88ddbb');
        player.hp = Math.min(player.maxHp, player.hp + player.lifeOnHit);
        player.mana = Math.min(player.maxMana, player.mana + player.manaOnHit);
        updateBossBarOnHit(hitEnemy);
        checkEnemyDeath(hitEnemy);
        for (let j = 0; j < 3; j++) {
          addParticle({ x: p.x, y: p.y, vx: (Math.random()-0.5)*3, vy: (Math.random()-0.5)*3, life: 12, color: '#aaddcc', size: 2 });
        }
      } else if (p.type === 'sentryArrow' && hitEnemy) {
        // Sentry Arrow - turret shots
        hitEnemy.hp -= p.damage;
        hitEnemy.flash = 8;
        spawnDamageNumber(hitEnemy.x, hitEnemy.y, Math.floor(p.damage), '#8888dd');
        updateBossBarOnHit(hitEnemy);
        checkEnemyDeath(hitEnemy);
        for (let j = 0; j < 4; j++) {
          addParticle({ x: p.x, y: p.y, vx: (Math.random()-0.5)*3, vy: (Math.random()-0.5)*3, life: 10, color: '#aaaaff', size: 2 });
        }
      }
      skillProjectiles.splice(i, 1);
    }
  }
  
  // Camera shake decay
  if (camera.shake) {
    camera.shake *= 0.9;
    if (camera.shake < 0.5) camera.shake = 0;
  }
}

function updateSkillBar() {
  for (const [id, skill] of Object.entries(SKILLS)) {
    const el = document.getElementById('skill-' + id);
    if (el) {
      const cdPct = skill.cooldown > 0 ? (skill.cooldown / skill.maxCooldown * 100) : 0;
      el.querySelector('.skill-cd').style.height = cdPct + '%';
      el.classList.toggle('on-cooldown', skill.cooldown > 0);
      el.classList.toggle('no-mana', player.mana < skill.manaCost);
    }
  }
}

function spawnDamageNumber(x, y, amount, color = '#fff') {
  // Safety: prevent undefined, NaN, or invalid values from showing
  if (amount === undefined || amount === null || isNaN(amount)) {
    console.warn('Invalid damage number:', amount);
    return;
  }
  
  // Don't show 0 damage numbers (utility skills, etc)
  if (amount === 0) return;
  
  // Limit damage numbers for performance
  if (damageNumbers.length >= MAX_DAMAGE_NUMBERS) {
    damageNumbers.shift();
  }
  damageNumbers.push({
    x: x + (Math.random() - 0.5) * 20,
    y: y - 20,
    amount: Math.round(amount),  // Ensure integer
    color: color,
    life: 45,
    vy: -2
  });
}

function addLootPopup(item, x, y) {
  // Duration based on rarity (in frames at 60fps)
  const durations = {
    unique: 240,  // 4 seconds
    rare: 240,    // 4 seconds (was 3, +1 second)
    magic: 180,   // 3 seconds (was 2, +1 second)
    normal: 90    // 1.5 seconds (was 1, +0.5 second)
  };
  
  // Rarity priority for z-ordering (higher = on top)
  const rarityPriority = {
    unique: 4,
    rare: 3,
    magic: 2,
    normal: 1
  };
  
  // Remove oldest if at limit
  if (lootPopups.length >= MAX_LOOT_POPUPS) {
    lootPopups.shift();
  }
  
  // Rarity colors
  const rarityColors = {
    unique: '#ff8844',
    rare: '#ffff44',
    magic: '#8888ff',
    normal: '#cccccc'
  };
  
  // Rarity border glow
  const rarityGlow = {
    unique: '#ff4400',
    rare: '#cc9900',
    magic: '#4444ff',
    normal: '#666666'
  };
  
  // Build lines for the popup
  const lines = [];
  
  // Item name (will be colored by rarity)
  lines.push({ text: item.name, color: rarityColors[item.rarity], size: 14, bold: true });
  
  // Item type
  const itemType = getItemType ? getItemType(item.name) : 'Item';
  lines.push({ text: itemType, color: '#888888', size: 11, bold: false });
  
  // Separator
  lines.push({ text: '───────────', color: '#444444', size: 10, bold: false });
  
  // Base stats
  if (item.baseDmgMin && item.baseDmgMax) {
    lines.push({ text: `Physical Damage: ${item.baseDmgMin}-${item.baseDmgMax}`, color: '#cccccc', size: 11, bold: false, highlight: true });
  }
  if (item.baseArmor) {
    lines.push({ text: `Armor: ${item.baseArmor}`, color: '#cccccc', size: 11, bold: false });
  }
  if (item.baseDodge) {
    lines.push({ text: `Dodge: ${item.baseDodge}`, color: '#cccccc', size: 11, bold: false });
  }
  
  // Quality (special stat for Rift amulets)
  if (item.quality) {
    lines.push({ text: `Quality: +${item.quality}%`, color: '#88ffff', size: 11, bold: true });
  }
  
  // Required level
  if (item.baseLevel) {
    lines.push({ text: `Requires Level ${item.baseLevel}`, color: '#666666', size: 10, bold: false });
  }
  
  // Sockets
  if (item.sockets && item.sockets.length > 0) {
    lines.push({ text: '───────────', color: '#444444', size: 10, bold: false });
    lines.push({ type: 'sockets', sockets: item.sockets });
  }
  
  // Mods
  const mods = item.mods || {};
  if (mods.implicit || (mods.prefixes && mods.prefixes.length) || (mods.suffixes && mods.suffixes.length)) {
    lines.push({ text: '───────────', color: '#444444', size: 10, bold: false });
  }
  
  // Implicit mod (muted gray - base identity, not a roll)
  if (mods.implicit) {
    lines.push({ text: mods.implicit.text, color: '#666666', size: 11, bold: false, italic: true });
  }
  
  // Prefixes and suffixes with tier indicators
  if (mods.prefixes) {
    mods.prefixes.forEach(m => {
      lines.push({ text: m.text, color: '#8888ff', size: 11, bold: false, tier: m.tier });
    });
  }
  if (mods.suffixes) {
    mods.suffixes.forEach(m => {
      lines.push({ text: m.text, color: '#8888ff', size: 11, bold: false, tier: m.tier });
    });
  }
  
  lootPopups.push({
    name: item.name,
    rarity: item.rarity,
    priority: rarityPriority[item.rarity] || 1,
    lines: lines,
    x: x,
    y: y - 60,
    life: durations[item.rarity] || 60,
    maxLife: durations[item.rarity] || 60,
    color: rarityColors[item.rarity] || '#ccc',
    glow: rarityGlow[item.rarity] || '#666',
    vy: -0.3
  });
}

// Helper to extract stat values from item mods
function getItemStatValues(item) {
  const stats = { armor: 0, life: 0, physDmg: 0, minDmg: 0 };
  if (!item || !item.mods) return stats;
  
  const allMods = [
    ...(item.mods.prefixes || []),
    ...(item.mods.suffixes || []),
    item.mods.implicit
  ].filter(Boolean);
  
  for (const mod of allMods) {
    if (!mod.text) continue;
    const text = mod.text.toLowerCase();
    
    if (text.includes('armor')) {
      const match = text.match(/\+?(\d+)/);
      if (match) stats.armor += parseInt(match[1]);
    }
    if (text.includes('life') || text.includes('health')) {
      const match = text.match(/\+?(\d+)/);
      if (match) stats.life += parseInt(match[1]);
    }
    if (text.includes('physical damage')) {
      const match = text.match(/\+?(\d+)/);
      if (match) stats.physDmg += parseInt(match[1]);
    }
    if (text.includes('minimum') && text.includes('damage')) {
      const match = text.match(/\+?(\d+)/);
      if (match) stats.minDmg += parseInt(match[1]);
    }
  }
  
  return stats;
}

let currentBoss = null; // Currently fighting boss
let bossDebuffs = []; // Active debuffs on boss

let inventoryOpen = false;
let stashOpen = false;
let charPanelOpen = false;
let hotkeyMenuOpen = false;
let inventoryItems = []; // Collected items with positions
let stashItems = []; // Items stored in stash grid
let craftingItem = null; // Item currently in crafting slot
let selectedInvItem = null; // Currently selected inventory item

// Stash tabs system
let stashTabs = [
  { id: 'overflow', name: 'Loot', type: 'overflow' },
  { id: 'currency', name: 'Crafting', type: 'currency' },
  { id: 'stash', name: 'Stash', type: 'items' }
];
let activeStashTab = 'overflow';
let stashTabCounter = 0;

// Loot Tab system - AFK loot collection
let overflowItems = [];
const OVERFLOW_BASE_CAPACITY = 20;
let overflowCapacity = OVERFLOW_BASE_CAPACITY;
let overflowMode = null; // null, 'move', or 'salvage'

// Context menu state
let contextMenuTarget = null; // { type: 'inventory'|'stash', idx: number, item: object }
let tabRenameTarget = null; // Tab being renamed

// ========== GEARING SYSTEM - LOCKED ==========
// This specification is FINAL and should not be modified without explicit approval.
//
// EQUIPMENT SLOTS (8 total):
// - Weapon, Helmet, Amulet, Body, Ring1, Ring2, Gloves, Boots
// - NO belt slot (removed)
// - NO off-hand slot (removed)
// - NO charm slot (never added)
//
// DEFENSE SYSTEM:
// - Armor: Primarily from STR (1 per 10 STR) + gear
// - Dodge: Primarily from DEX (1% per 100 DEX) + gear, capped at 70%
// - Shield: Primarily from GEAR, INT provides minor bonus (1 per 5 INT)
//   (Note: UI displays "Shield" not "Energy Shield")
//
// ARMOR BASE TYPES:
// - All bases MUST explicitly declare their defense type via name pattern
// - Names alone drive logic - no defaults should be relied upon
// - STR bases: Armor only (Iron, Steel, Chain, Plate, etc.)
// - DEX bases: Dodge only (Leather, Hide, Scout, etc.)
// - INT bases: Shield only (Silk, Cloth, Mage, Scholar, etc.)
// - Hybrids: Two defenses at 55% value each (Scale, Assassin, Crusader, etc.)
//
// VALIDATION RULES:
// - getItemSlot() returns null for unmatched items (NO silent defaults)
// - generateMod() returns null and logs warning for invalid slots
// - Unmatched items log console warnings for debugging
// - All LOOT items must have explicit slot patterns
//
// REMOVED MECHANICS (do not add):
// - Regen, Magic Find, Gold Find
// - Conditional damage mods
// - Leech (replaced by on-hit/on-kill sustain)
// - Block (replaced by Dodge)
// - DoT/Poison
// - Belts (removed entirely)
//
// BOOT MOVEMENT SPEED:
// - Movement Speed is a SUFFIX AFFIX on boots (T8: 5% to T1: 40%)
// - Boots do NOT have movement speed implicit
// - Boots get defense implicit from base type (same as helmets/gloves)
//
// RESISTANCE CAPS:
// - Elemental Resistances: 70% (capped)
// - Dodge: 70% (capped)
// - Armor: No cap (diminishing returns)
//
// ITEM VALIDATION CHECKLIST (for new bases):
// 1. LOOT tables - appears in correct rarity entries
// 2. getItemSlot(name) - returns intended slot
// 3. getArmorBaseType(name) - returns correct str/dex/int/hybrid identity (armor only)
// 4. getImplicitCategory(name) - maps to correct implicit bucket
// 5. IMPLICIT_MODS[category] - bucket exists
// 6. SLOT_MODS[slot] - has prefix/suffix pools
// 7. ITEM_SIZES[name] - entry exists for grid layout
// 8. getItemIcon(name) - has entry or sensible fallback
// 9. Defense constraints - helmet/gloves/boots only roll defense mods matching base type
// ==================================================

// Equipment slots
const equipment = {
  weapon: null,
  helmet: null,
  amulet: null,
  body: null,
  ring1: null,
  ring2: null,
  gloves: null,
  boots: null
};

// Slot type mapping for equipping items
const SLOT_TYPE_MAP = {
  weapon: ['Blade', 'Staff', 'Quarterstaff', 'Bow'],
  helmet: ['Helm', 'Hood', 'Cap', 'Crown', 'Circlet', 'Mask', 'Casque', 'Burgonet', 'Hat', 'Coif'],
  amulet: ['Amulet', 'Talisman', 'Pendant'],
  body: ['Robe', 'Vest', 'Shirt', 'Mail', 'Armor', 'Regalia', 'Garb', 'Coat', 'Brigandine', 'Tunic'],
  ring1: ['Ring'],
  ring2: ['Ring'],
  gloves: ['Gloves', 'Gauntlets', 'Mitts', 'Mittens', 'Grips', 'Wraps'],
  boots: ['Boots', 'Greaves', 'Shoes', 'Slippers', 'Sabaton']
};

// Get valid slot for item
function getValidSlotForItem(itemName) {
  const nameLower = itemName.toLowerCase();
  for (const [slot, keywords] of Object.entries(SLOT_TYPE_MAP)) {
    for (const keyword of keywords) {
      if (nameLower.includes(keyword.toLowerCase())) {
        if (slot === 'ring1' && equipment.ring1) {
          return equipment.ring2 ? null : 'ring2';
        }
        return slot;
      }
    }
  }
  return null;
}

// Click equipment slot
// Check if current class can equip a weapon
function canEquipWeapon(weaponName) {
  const weaponCategory = getWeaponCategory(weaponName);
  const allowedWeapons = CLASS_WEAPONS[player.class] || [];
  return allowedWeapons.includes(weaponCategory);
}

function clickEquipSlot(slot) {
  if (selectedInvItem !== null) {
    const item = inventoryItems[selectedInvItem];
    const validSlot = getValidSlotForItem(item.name);
    if (validSlot === slot || (slot.startsWith('ring') && validSlot && validSlot.startsWith('ring'))) {
      // Check weapon class restrictions
      if (slot === 'weapon' && !canEquipWeapon(item.name)) {
        const weaponCategory = getWeaponCategory(item.name);
        const className = CLASS_DATA[player.class]?.name || player.class;
        addLog(`${className} cannot equip ${weaponCategory}s!`, 'warning');
        return;
      }
      
      if (equipment[slot]) {
        const oldItem = equipment[slot];
        // Unregister old item's unique effect
        if (oldItem.isUnique && oldItem.uniqueId && UNIQUE_ITEMS[oldItem.uniqueId]?.onUnequip) {
          UNIQUE_ITEMS[oldItem.uniqueId].onUnequip(player);
        }
        removeItemFromGrid(item);
        inventoryItems.splice(selectedInvItem, 1);
        equipment[slot] = item;
        // Register new item's unique effect
        if (item.isUnique && item.uniqueId && UNIQUE_ITEMS[item.uniqueId]?.onEquip) {
          UNIQUE_ITEMS[item.uniqueId].onEquip(player);
        }
        // Clear grid position from equipped item so it gets fresh placement
        item.gridX = undefined;
        item.gridY = undefined;
        // Clear old item's grid position so it gets fresh placement
        oldItem.gridX = undefined;
        oldItem.gridY = undefined;
        inventoryItems.push(oldItem);
        gridNeedsRebuild = true;
      } else {
        removeItemFromGrid(item);
        inventoryItems.splice(selectedInvItem, 1);
        equipment[slot] = item;
        // Register unique effect
        if (item.isUnique && item.uniqueId && UNIQUE_ITEMS[item.uniqueId]?.onEquip) {
          UNIQUE_ITEMS[item.uniqueId].onEquip(player);
        }
        // Clear grid position from equipped item
        item.gridX = undefined;
        item.gridY = undefined;
      }
      selectedInvItem = null;
      addLog(`Equipped ${item.name}`, 'loot');
      updateEquipmentDisplay();
      updateInventoryDisplay();
      recalculateStats();
      updateStats();
      updateCharPanel(); // Update STR/DEX/INT/Damage display
      
      // Steam integration: item equipped achievement check
      onItemEquipped_Steam();
    } else {
      addLog(`Can't equip ${item.name} there!`, 'warning');
    }
  } else if (equipment[slot]) {
    unequipItem(slot);
  }
}

// Unequip item to inventory
function unequipItem(slot) {
  if (!equipment[slot]) return;
  
  const item = equipment[slot];
  const w = item.width || 1;
  const h = item.height || 1;
  
  const pos = findPositionForItem(w, h);
  if (!pos) {
    addLog('Inventory full!', 'warning');
    return;
  }
  
  // Unregister unique effect before removing
  if (item.isUnique && item.uniqueId && UNIQUE_ITEMS[item.uniqueId]?.onUnequip) {
    UNIQUE_ITEMS[item.uniqueId].onUnequip(player);
  }
  
  equipment[slot] = null;
  inventoryItems.push(item);
  placeItemOnGrid(item, pos.x, pos.y);
  
  addLog(`Unequipped ${item.name}`, 'loot');
  updateEquipmentDisplay();
  updateInventoryDisplay();
  recalculateStats();
  updateStats();
  updateCharPanel(); // Update STR/DEX/INT/Damage display
}

// Update equipment display
function updateEquipmentDisplay() {
  const slots = ['weapon', 'helmet', 'amulet', 'body', 'ring1', 'ring2', 'gloves', 'boots'];
  
  for (const slot of slots) {
    const el = document.getElementById('equip-' + slot);
    if (!el) continue;
    
    const item = equipment[slot];
    if (item) {
      el.className = `equip-slot ${slot} filled ${item.rarity}`;
      
      // Try to assign image if missing
      if (!item.image) {
        item.image = getItemImage(item.name);
      }
      
      // Build content HTML
      let contentHtml = '';
      
      // Use image if available, otherwise use emoji icon
      if (item.image) {
        contentHtml = `<img src="${item.image}" style="width:100%;height:100%;object-fit:contain;" alt="${item.name}" onerror="this.parentElement.innerHTML='${getItemIcon(item.name)}'">`;
      } else {
        contentHtml = `<span class="equip-icon">${getItemIcon(item.name)}</span>`;
      }
      
      // Add socket pips if item has sockets
      if (item.sockets && item.sockets.length > 0) {
        contentHtml += '<div class="equip-sockets">';
        item.sockets.forEach(socket => {
          const gemData = socket.gem ? GEM_DATA[socket.gem] : null;
          if (socket.gem && gemData) {
            contentHtml += `<div class="socket-pip filled" style="font-size:7px;display:flex;align-items:center;justify-content:center;background:transparent;">${gemData.icon}</div>`;
          } else {
            contentHtml += '<div class="socket-pip empty"></div>';
          }
        });
        contentHtml += '</div>';
      }
      
      el.innerHTML = contentHtml;
      
      el.onmouseenter = (e) => showTooltip(item, e);
      el.onmouseleave = hideTooltip;
    } else {
      el.className = `equip-slot ${slot}`;
      el.innerHTML = ''; // Let CSS ::after show the placeholder
      el.onmouseenter = null;
      el.onmouseleave = null;
    }
  }
  
  // Always update character panel stats (inline equipment stats need updating even when panel is closed)
  updateCharPanel();
}

// Recalculate stats from equipment
function recalculateStats() {
  // Get class stat definitions
  const startStats = CLASS_START_STATS[player.class] || CLASS_START_STATS.monk;
  const baseStats = CLASS_BASE_STATS[player.class] || CLASS_BASE_STATS.monk;
  const primaryStat = CLASS_PRIMARY_STAT[player.class] || 'dex';
  
  // Reset elemental resistances (recalculated from gear each time)
  player.fireRes = 0;
  player.coldRes = 0;
  player.lightRes = 0;
  player.natureRes = 0;
  
  // Calculate base attributes from level
  let baseStr = startStats.str + (player.level - 1) * baseStats.str;
  let baseDex = startStats.dex + (player.level - 1) * baseStats.dex;
  let baseInt = startStats.int + (player.level - 1) * baseStats.int;
  
  // Equipment bonuses
  let bonusStr = 0, bonusDex = 0, bonusInt = 0;
  let bonusLife = 0, bonusMana = 0, bonusDamagePercent = 0;
  let bonusAtkSpd = 0, bonusCritChance = 0;
  let flatPhysDmgMin = 0, flatPhysDmgMax = 0;
  let weaponBaseDmgMin = 0, weaponBaseDmgMax = 0;
  let bonusLifeRegen = 0, bonusManaRegen = 0;
  
  // Separate flat and % for armor/dodge/shield (to fix the multiplier bug)
  let flatArmor = 0, percentArmor = 0;
  let flatDodge = 0, percentDodge = 0;
  let flatShield = 0, percentShield = 0;
  let baseArmorFromGear = 0, baseDodgeFromGear = 0, baseShieldFromGear = 0;
  
  for (const item of Object.values(equipment)) {
    if (!item || !item.mods) continue;
    
    // Add base armor/dodge/shield from equipment (body armor base stats)
    if (item.baseArmor) baseArmorFromGear += item.baseArmor;
    if (item.baseDodge) baseDodgeFromGear += item.baseDodge;
    if (item.baseShield) baseShieldFromGear += item.baseShield;
    
    // Add weapon base damage
    if (item.baseDmgMin && item.baseDmgMax) {
      weaponBaseDmgMin = item.baseDmgMin;
      weaponBaseDmgMax = item.baseDmgMax;
    }
    
    const allMods = [
      ...(item.mods.prefixes || []),
      ...(item.mods.suffixes || []),
      item.mods.implicit
    ].filter(Boolean);
    
    for (const mod of allMods) {
      if (!mod.stat) continue;
      const val = mod.value1 || 0;
      const val2 = mod.value2 || 0;
      
      // Attributes
      if (mod.stat.includes('Strength')) bonusStr += val;
      if (mod.stat.includes('Dexterity')) bonusDex += val;
      if (mod.stat.includes('Intelligence')) bonusInt += val;
      if (mod.stat.includes('all Attributes')) {
        bonusStr += val;
        bonusDex += val;
        bonusInt += val;
      }
      
      // Life/Mana
      if (mod.stat.includes('maximum Life')) bonusLife += val;
      if (mod.stat.includes('maximum Mana')) bonusMana += val;
      
      // Damage
      if (mod.stat.includes('Physical Damage') && mod.stat.includes('%')) bonusDamagePercent += val;
      if (mod.stat.includes('Adds') && mod.stat.includes('Physical Damage')) {
        flatPhysDmgMin += val;
        flatPhysDmgMax += val2;
      }
      
      // Defense - Armor (properly separate flat vs %)
      if (mod.stat.includes('increased Armor')) {
        percentArmor += val; // % increased Armor
      } else if (mod.stat.includes('to Armor') || (mod.stat.includes('Armor') && !mod.stat.includes('%'))) {
        flatArmor += val; // Flat armor
      }
      
      // Defense - Dodge Rating (properly separate flat vs %)
      if (mod.stat.includes('increased Dodge') || mod.stat.includes('increased Evasion')) {
        percentDodge += val; // % increased Dodge
      } else if (mod.stat.includes('to Dodge') || mod.stat.includes('Dodge Rating')) {
        flatDodge += val; // Flat dodge rating
      }
      
      // Defense - Shield (properly separate flat vs %)
      if (mod.stat.includes('increased Shield') || mod.stat.includes('increased Energy Shield')) {
        percentShield += val; // % increased Shield
      } else if (mod.stat.includes('to Shield') || mod.stat.includes('to maximum Shield')) {
        flatShield += val; // Flat shield
      }
      
      // Elemental Resistances (from suffixes)
      if (mod.stat.includes('Fire Resistance')) player.fireRes += val;
      if (mod.stat.includes('Cold Resistance')) player.coldRes += val;
      if (mod.stat.includes('Lightning Resistance')) player.lightRes += val;
      if (mod.stat.includes('Nature Resistance')) player.natureRes += val;
      if (mod.stat.includes('all Resistances')) {
        player.fireRes += val;
        player.coldRes += val;
        player.lightRes += val;
        player.natureRes += val;
      }
      
      // Attack speed
      if (mod.stat.includes('Attack Speed')) bonusAtkSpd += val;
      
      // Life/Mana Regeneration
      if (mod.stat.includes('Life Regeneration')) bonusLifeRegen += val;
      if (mod.stat.includes('Mana Regeneration')) bonusManaRegen += val;
    }
    
    // ========== SOCKETED GEM BONUSES ==========
    // Process gems socketed in this item
    if (item.sockets && item.sockets.length > 0) {
      const isWeapon = getItemSlot(item.name) === 'weapon';
      
      for (const socket of item.sockets) {
        if (!socket.gem) continue;
        
        const gemBonus = getGemBonusWithQuality(socket.gem, socket.gemQuality || 0, isWeapon);
        if (!gemBonus) continue;
        
        const stat = gemBonus.stat;
        const val = gemBonus.value;
        
        // Apply gem stat based on type
        if (stat === 'physDmgPct') bonusDamagePercent += val;
        if (stat === 'armorPct') percentArmor += val; // % increased armor from gems
        if (stat === 'atkSpd') bonusAtkSpd += val;
        if (stat === 'dodge') flatDodge += val; // Flat dodge rating from gems
        if (stat === 'fireRes') player.fireRes = (player.fireRes || 0) + val;
        if (stat === 'coldRes') player.coldRes = (player.coldRes || 0) + val;
        if (stat === 'lightRes') player.lightRes = (player.lightRes || 0) + val;
        if (stat === 'natureRes') player.natureRes = (player.natureRes || 0) + val;
        
        // Elemental damage (flat added)
        if (stat === 'fireDmg' && Array.isArray(val)) {
          player.addedFireMin = (player.addedFireMin || 0) + val[0];
          player.addedFireMax = (player.addedFireMax || 0) + val[1];
        }
        if (stat === 'coldDmg' && Array.isArray(val)) {
          player.addedColdMin = (player.addedColdMin || 0) + val[0];
          player.addedColdMax = (player.addedColdMax || 0) + val[1];
        }
        if (stat === 'lightDmg' && Array.isArray(val)) {
          player.addedLightMin = (player.addedLightMin || 0) + val[0];
          player.addedLightMax = (player.addedLightMax || 0) + val[1];
        }
      }
    }
  }
  
  // ========== ECHO RING STAT MIRRORING ==========
  // If player has an Echo Ring, copy stats from the other ring
  const ring1 = equipment.ring1;
  const ring2 = equipment.ring2;
  let echoRing = null;
  let sourceRing = null;
  
  if (ring1 && ring1.isEchoRing && ring2 && !ring2.isEchoRing) {
    echoRing = ring1;
    sourceRing = ring2;
  } else if (ring2 && ring2.isEchoRing && ring1 && !ring1.isEchoRing) {
    echoRing = ring2;
    sourceRing = ring1;
  }
  
  if (echoRing && sourceRing && sourceRing.mods) {
    const echoMult = echoRing.echoPercent / 100;
    const qualityMult = 1 + (sourceRing.quality || 0) / 100;
    
    const sourceMods = [
      ...(sourceRing.mods.prefixes || []),
      ...(sourceRing.mods.suffixes || []),
      sourceRing.mods.implicit
    ].filter(Boolean);
    
    for (const mod of sourceMods) {
      if (!mod.stat) continue;
      // Apply quality FIRST, then Echo %
      const rawVal = mod.value1 || 0;
      const val = Math.round(rawVal * qualityMult * echoMult);
      const rawVal2 = mod.value2 || 0;
      const val2 = Math.round(rawVal2 * qualityMult * echoMult);
      
      // Mirror all stats from source ring
      if (mod.stat.includes('Strength')) bonusStr += val;
      if (mod.stat.includes('Dexterity')) bonusDex += val;
      if (mod.stat.includes('Intelligence')) bonusInt += val;
      if (mod.stat.includes('all Attributes')) {
        bonusStr += val;
        bonusDex += val;
        bonusInt += val;
      }
      if (mod.stat.includes('maximum Life')) bonusLife += val;
      if (mod.stat.includes('maximum Mana')) bonusMana += val;
      if (mod.stat.includes('Physical Damage') && mod.stat.includes('%')) bonusDamagePercent += val;
      if (mod.stat.includes('Adds') && mod.stat.includes('Physical Damage')) {
        flatPhysDmgMin += val;
        flatPhysDmgMax += val2;
      }
      if (mod.stat.includes('increased Armor')) {
        percentArmor += val;
      } else if (mod.stat.includes('Armor') && !mod.stat.includes('%')) {
        flatArmor += val;
      }
      if (mod.stat.includes('Attack Speed')) bonusAtkSpd += val;
      if (mod.stat.includes('Life Regeneration')) bonusLifeRegen += val;
      if (mod.stat.includes('Mana Regeneration')) bonusManaRegen += val;
    }
  }
  
  // ========== PASSIVE TREE BONUSES ==========
  const passives = typeof getPassiveBonuses === 'function' ? getPassiveBonuses() : {};
  flatArmor += passives.armor || 0;
  flatDodge += passives.dodge || 0;
  flatShield += passives.shield || 0;
  bonusLife += passives.life || 0;
  bonusMana += passives.mana || 0;
  bonusAtkSpd += passives.attackSpeed || 0;
  bonusLifeRegen += passives.lifeOnHit || 0; // Life on hit from passives
  
  // Apply All Resist from passive skill to individual resistances
  const allResistBonus = passives.allResist || 0;
  if (allResistBonus > 0) {
    player.fireRes += allResistBonus;
    player.coldRes += allResistBonus;
    player.lightRes += allResistBonus;
    player.natureRes += allResistBonus;
  }
  
  // Final attributes
  player.str = Math.floor(baseStr + bonusStr);
  player.dex = Math.floor(baseDex + bonusDex);
  player.int = Math.floor(baseInt + bonusInt);
  
  // ========== ATTRIBUTE SECONDARY EFFECTS ==========
  // Strength: +1 Armor per 10 STR
  const strArmorBonus = Math.floor(player.str / 10);
  
  // Dexterity: +1.5 Dodge Rating per 1 DEX (feeds into diminishing returns formula)
  // Makes dodge easier to achieve while still requiring investment
  const dexDodgeRating = Math.floor(player.dex * 1.5);
  
  // Calculate total dodge rating: DEX contribution + gear base + flat mods
  // Then apply % increased dodge as a multiplier
  const baseDodgeRating = dexDodgeRating + baseDodgeFromGear + flatDodge;
  const dodgeMultiplier = 1 + (percentDodge / 100) + (passives.dodgePercent || 0) / 100;
  player.dodgeRating = Math.floor(baseDodgeRating * dodgeMultiplier);
  
  // Intelligence: +1 Shield per 5 INT, plus flat shield from gear
  const intShieldBonus = Math.floor(player.int / 5);
  
  // ========== PRIMARY STAT DAMAGE BONUS ==========
  // Primary stat gives +1% damage per 50 points (2% per 100)
  let primaryStatValue = 0;
  if (primaryStat === 'str') primaryStatValue = player.str;
  else if (primaryStat === 'dex') primaryStatValue = player.dex;
  else if (primaryStat === 'int') primaryStatValue = player.int;
  
  const primaryDamageBonus = primaryStatValue / 5000; // 1% per 50 primary stat (2% per 100)
  
  // ========== FINAL STAT CALCULATIONS ==========
  // Base damage comes from equipped weapon (not innate player level scaling)
  // Unarmed base damage is minimal
  player.baseDmgMin = weaponBaseDmgMin > 0 ? weaponBaseDmgMin : 1;
  player.baseDmgMax = weaponBaseDmgMax > 0 ? weaponBaseDmgMax : 2;
  
  // Apply damage bonuses: (base + flat) * (1 + %bonuses + primary stat bonus)
  const totalDamageMultiplier = 1 + (bonusDamagePercent / 100) + primaryDamageBonus;
  player.minDmg = Math.floor((player.baseDmgMin + flatPhysDmgMin) * totalDamageMultiplier);
  player.maxDmg = Math.floor((player.baseDmgMax + flatPhysDmgMax) * totalDamageMultiplier);
  
  // Life: base + level bonus + equipment (no longer from STR)
  // Player HP scaling: 80 + level * 8
  // Level 1:  88 HP
  // Level 10: 160 HP
  // Level 50: 480 HP
  // Level 70: 640 HP (before gear)
  let baseLife = 80 + player.level * 8 + bonusLife;
  // Apply passive life % bonuses and reductions
  const lifeMultiplier = 1 + (passives.lifePercent || 0) / 100 - (passives.lifeReduction || 0) / 100;
  player.maxHp = Math.floor(baseLife * lifeMultiplier);
  
  // Mana: base + level bonus + equipment
  let baseMana = 40 + player.level * 4 + bonusMana;
  const manaMultiplier = 1 + (passives.manaPercent || 0) / 100;
  player.maxMana = Math.floor(baseMana * manaMultiplier);
  
  // Armor: STR bonus + gear base + flat mods, then apply % multipliers
  const baseArmorValue = 3 + strArmorBonus + baseArmorFromGear + flatArmor;
  const armorMultiplier = 1 + (percentArmor / 100) + (passives.armorPercent || 0) / 100;
  player.armor = Math.floor(baseArmorValue * armorMultiplier);
  
  // Shield: INT bonus + gear base + flat mods, then apply % multipliers
  const oldMaxShield = player.shield;
  const baseShieldVal = intShieldBonus + baseShieldFromGear + flatShield;
  const shieldMultiplier = 1 + (percentShield / 100) + (passives.shieldPercent || 0) / 100 + (passives.shieldCapIncrease || 0) / 100;
  player.shield = Math.floor(baseShieldVal * shieldMultiplier);
  
  // Shield recharge rate: ~12% of max shield per second
  let shieldRechargeRate = player.shield * 0.12; // 12% per second = full recharge in ~8 seconds
  if (passives.shieldRechargeBonus) shieldRechargeRate *= (1 + passives.shieldRechargeBonus / 100);
  player.shieldRechargeRate = shieldRechargeRate;
  
  // If max shield increased, proportionally increase current shield
  if (player.shield > oldMaxShield && oldMaxShield > 0) {
    player.currentShield = Math.min(player.shield, player.currentShield + (player.shield - oldMaxShield));
  }
  // If this is first time getting shield, fill it
  if (oldMaxShield === 0 && player.shield > 0) {
    player.currentShield = player.shield;
  }
  // Cap current shield
  if (player.currentShield > player.shield) player.currentShield = player.shield;
  
  // Apply keystone: Dodge Rating is set to 0 (Juggernaut)
  if (passives.dodgeZero) {
    player.dodgeRating = 0;
  }
  // Apply keystone: Dodge Rating reduction (simulate cap by reducing effectiveness)
  if (passives.dodgeCap40) {
    player.dodgeRating = Math.floor(player.dodgeRating * 0.6); // 60% effectiveness
  } else if (passives.dodgeCap50) {
    player.dodgeRating = Math.floor(player.dodgeRating * 0.75); // 75% effectiveness
  }
  
  // Attack speed bonus
  player.atkSpd = 0.8 * (1 + bonusAtkSpd / 100);
  
  // Cast speed (for spell primaries) - base 1.0, modified by cast speed bonuses
  // INT also provides cast speed: +1% per 100 INT
  const intCastSpeedBonus = player.int / 100;
  let castSpeedBonus = (passives.castSpeed || 0);
  player.castSpd = 1.0 * (1 + (intCastSpeedBonus + castSpeedBonus) / 100);
  
  // Spell damage: scales with INT (base 10 + 0.5 per INT + level bonus)
  // This provides a base for spell primaries to scale from
  let spellDmgBonus = (passives.spellDamage || 0);
  player.spellDmg = (10 + player.int * 0.5 + player.level * 2) * (1 + spellDmgBonus / 100);
  
  // Life/Mana Regeneration (per second)
  // Life regen can come from gear
  // Mana regen is DISABLED by design - mana sustain from on-hit, on-kill, leech, potions only
  player.lifeRegen = bonusLifeRegen;
  player.manaRegen = 0; // No passive mana regen - intentional design decision
  
  // Store passive bonuses for use elsewhere
  player.passiveBonuses = passives;
  
  // ========== ECHO DOMAIN BUFFS/DEBUFFS ==========
  if (echoDomainActive) {
    // Apply buffs (stack additively/multiplicatively as appropriate)
    for (const buff of echoDomainBuffs) {
      if (buff.effect.dmgMult) {
        player.minDmg = Math.floor(player.minDmg * buff.effect.dmgMult);
        player.maxDmg = Math.floor(player.maxDmg * buff.effect.dmgMult);
      }
      if (buff.effect.speedMult) player.speed = Math.floor(player.speed * buff.effect.speedMult);
      if (buff.effect.maxHp) player.maxHp += buff.effect.maxHp;
      if (buff.effect.armor) player.armor += buff.effect.armor;
      if (buff.effect.shieldRecharge) player.shieldRechargeRate = (player.shieldRechargeRate || 0) + buff.effect.shieldRecharge;
      if (buff.effect.critChance) player.critChance = (player.critChance || 0) + buff.effect.critChance;
      if (buff.effect.lifeOnHit) player.lifeOnHit += buff.effect.lifeOnHit;
      if (buff.effect.atkSpeedMult) player.atkSpd = Math.floor(player.atkSpd * buff.effect.atkSpeedMult);
    }
    
    // Apply debuffs
    for (const debuff of echoDomainDebuffs) {
      if (debuff.effect.dmgMult) {
        player.minDmg = Math.floor(player.minDmg * debuff.effect.dmgMult);
        player.maxDmg = Math.floor(player.maxDmg * debuff.effect.dmgMult);
      }
      if (debuff.effect.speedMult) player.speed = Math.floor(player.speed * debuff.effect.speedMult);
      if (debuff.effect.maxHp) player.maxHp = Math.max(1, player.maxHp + debuff.effect.maxHp);
      if (debuff.effect.armor) player.armor = Math.max(0, player.armor + debuff.effect.armor);
      if (debuff.effect.atkSpeedMult) player.atkSpd = Math.floor(player.atkSpd * debuff.effect.atkSpeedMult);
      if (debuff.effect.dodgePenalty) player.dodgeRating = Math.max(0, (player.dodgeRating || 0) - debuff.effect.dodgePenalty);
    }
  }
  
  // Cap HP
  if (player.hp > player.maxHp) player.hp = player.maxHp;
  if (player.mana > player.maxMana) player.mana = player.maxMana;
}

// ========== CROSS-SCALING DAMAGE SYSTEM ==========
// Physical damage: 100% to physical, 50% to elemental portions
// Elemental damage: 100% to matching element, 50% to physical
// All/Increased damage: 100% to everything
//
// This ensures NO DEAD AFFIXES - every damage stat contributes something
//
// Usage: calculateSkillDamage(baseDmg, skillElement)
// - baseDmg: base damage from weapon/skill
// - skillElement: 'physical', 'fire', 'cold', 'lightning', 'nature'

function calculateSkillDamage(baseDmg, skillElement) {
  const passives = player.passiveBonuses || {};
  
  // % damage bonuses from gear and passives
  const physPct = (passives.physicalDamage || 0) / 100;
  const firePct = (passives.fireDamage || 0) / 100;
  const coldPct = (passives.coldDamage || 0) / 100;
  const lightPct = (passives.lightningDamage || 0) / 100;
  const naturePct = (passives.natureDamage || 0) / 100;
  const allPct = (passives.damageIncreaseAll || 0) / 100;
  
  // Flat elemental damage additions (from gems)
  const flatFire = ((player.addedFireMin || 0) + (player.addedFireMax || 0)) / 2;
  const flatCold = ((player.addedColdMin || 0) + (player.addedColdMax || 0)) / 2;
  const flatLight = ((player.addedLightMin || 0) + (player.addedLightMax || 0)) / 2;
  
  // Calculate each damage portion with cross-scaling
  let physicalPortion = baseDmg;
  let firePortion = flatFire;
  let coldPortion = flatCold;
  let lightPortion = flatLight;
  
  // Apply % physical damage: 100% to physical, 50% to elemental
  physicalPortion *= (1 + physPct + allPct);
  firePortion *= (1 + 0.5 * physPct + allPct);
  coldPortion *= (1 + 0.5 * physPct + allPct);
  lightPortion *= (1 + 0.5 * physPct + allPct);
  
  // Apply elemental % bonuses: 100% to matching, 50% to physical
  // Fire %
  firePortion *= (1 + firePct);
  physicalPortion *= (1 + 0.5 * firePct);
  // Cold %
  coldPortion *= (1 + coldPct);
  physicalPortion *= (1 + 0.5 * coldPct);
  // Lightning %
  lightPortion *= (1 + lightPct);
  physicalPortion *= (1 + 0.5 * lightPct);
  // Nature %
  // (nature damage portion would need flat nature additions, but we don't have those yet)
  physicalPortion *= (1 + 0.5 * naturePct);
  
  // If skill has a specific element, that portion gets a bonus
  // (this makes skills "feel" like their element even with cross-scaling)
  const elementalBoost = 1.0; // No additional boost for now, cross-scaling handles it
  
  // Sum all portions for total damage
  const totalDamage = physicalPortion + firePortion + coldPortion + lightPortion;
  
  return Math.floor(totalDamage);
}

// Get the dominant element for damage coloring/effects
function getDominantElement(baseDmg, skillElement) {
  const flatFire = ((player.addedFireMin || 0) + (player.addedFireMax || 0)) / 2;
  const flatCold = ((player.addedColdMin || 0) + (player.addedColdMax || 0)) / 2;
  const flatLight = ((player.addedLightMin || 0) + (player.addedLightMax || 0)) / 2;
  
  // If skill has an element, prioritize that
  if (skillElement && skillElement !== 'physical') return skillElement;
  
  // Otherwise return highest flat elemental
  const max = Math.max(flatFire, flatCold, flatLight, baseDmg);
  if (max === flatFire && flatFire > 0) return 'fire';
  if (max === flatCold && flatCold > 0) return 'cold';
  if (max === flatLight && flatLight > 0) return 'lightning';
  return 'physical';
}

// Extract stat values from item mods
function extractItemStats(item) {
  const stats = { 
    life: 0, mana: 0, damage: 0, armor: 0, 
    fireRes: 0, coldRes: 0, lightRes: 0, natureRes: 0,
    str: 0, dex: 0, int: 0, allStats: 0,
    attackSpeed: 0, critChance: 0, critDamage: 0,
    lifeOnHit: 0, manaOnHit: 0,
    flatPhysDmgMin: 0, flatPhysDmgMax: 0,
    moveSpeed: 0
  };
  if (!item || !item.mods) return stats;
  
  const allMods = [
    ...(item.mods.prefixes || []),
    ...(item.mods.suffixes || []),
    item.mods.implicit
  ].filter(Boolean);
  
  for (const mod of allMods) {
    if (!mod.stat) continue;
    const val = mod.value1 || 0;
    const val2 = mod.value2 || 0;
    
    if (mod.stat.includes('maximum Life')) stats.life += val;
    if (mod.stat.includes('maximum Mana')) stats.mana += val;
    if (mod.stat.includes('Physical Damage') && mod.stat.includes('%')) stats.damage += val;
    if (mod.stat.includes('Armor') || mod.stat.includes('Armor') || mod.stat.includes('increased Armor')) stats.armor += val;
    if (mod.stat.includes('Fire Resistance')) stats.fireRes += val;
    if (mod.stat.includes('Cold Resistance')) stats.coldRes += val;
    if (mod.stat.includes('Lightning Resistance')) stats.lightRes += val;
    if (mod.stat.includes('Nature Resistance')) stats.natureRes += val;
    if (mod.stat.includes('Strength')) stats.str += val;
    if (mod.stat.includes('Dexterity')) stats.dex += val;
    if (mod.stat.includes('Intelligence')) stats.int += val;
    if (mod.stat.includes('all Attributes')) stats.allStats += val;
    if (mod.stat.includes('Attack Speed')) stats.attackSpeed += val;
    if (mod.stat.includes('Critical Strike Chance')) stats.critChance += val;
    if (mod.stat.includes('Critical Strike Multiplier') || mod.stat.includes('Critical Damage')) stats.critDamage += val;
    if (mod.stat.includes('Life gained on Hit') || mod.stat.includes('Life on Hit')) stats.lifeOnHit += val;
    if (mod.stat.includes('Mana gained on Hit') || mod.stat.includes('Mana on Hit')) stats.manaOnHit += val;
    if (mod.stat.includes('Adds') && mod.stat.includes('Physical Damage')) {
      stats.flatPhysDmgMin += val;
      stats.flatPhysDmgMax += val2;
    }
    if (mod.stat.includes('Movement Speed')) stats.moveSpeed += val;
  }
  
  return stats;
}

// Extract all mods from an item as a list for comparison
function extractItemMods(item) {
  if (!item || !item.mods) return [];
  
  const result = [];
  const allMods = [
    ...(item.mods.prefixes || []),
    ...(item.mods.suffixes || []),
    item.mods.implicit
  ].filter(Boolean);
  
  for (const mod of allMods) {
    if (!mod.stat) continue;
    result.push({
      stat: mod.stat,
      text: mod.text,
      value1: mod.value1 || 0,
      value2: mod.value2 || 0
    });
  }
  
  return result;
}

// ============ TOOLTIP SYSTEM ============

// Helper to format mod for tooltip
function formatModLine(m, showTier = false) {
  // Base text with just the rolled value
  let displayText = m.text;
  
  if (altPressed && m.value1 !== undefined && m.min !== undefined && m.max !== undefined) {
    // When Alt is held, show value with range in parentheses
    if (m.value2 !== undefined && m.min2 !== undefined && m.max2 !== undefined) {
      // For mods with two values like "Adds X to Y Fire Damage"
      const range1 = `${m.value1}(${m.min}-${m.max})`;
      const range2 = `${m.value2}(${m.min2}-${m.max2})`;
      displayText = m.stat.replace('#', range1).replace('#', range2);
    } else {
      // Single value mod
      const range = `${m.value1}(${m.min}-${m.max})`;
      displayText = m.stat.replace('#', range);
    }
  }
  
  // Only show tier when Alt is pressed
  const tierStr = (altPressed && m.tier) ? ` <span class="tooltip-tier-small">T${m.tier}</span>` : '';
  return `<div class="tooltip-mod"><span class="tooltip-mod-text">${displayText}</span>${tierStr}</div>`;
}

// Check if mod is a flat elemental/physical damage mod (for grouping)
function isFlatDamageMod(mod) {
  if (!mod || !mod.stat) return false;
  const s = mod.stat.toLowerCase();
  return s.includes('adds') && s.includes('damage') && 
         (s.includes('fire') || s.includes('cold') || s.includes('lightning') || s.includes('physical'));
}

// Get element type from damage mod
function getDamageElement(mod) {
  if (!mod || !mod.stat) return null;
  const s = mod.stat.toLowerCase();
  if (s.includes('fire')) return 'fire';
  if (s.includes('cold')) return 'cold';
  if (s.includes('lightning')) return 'lightning';
  if (s.includes('physical')) return 'physical';
  return null;
}

// Format grouped elemental damage mods
function formatGroupedDamageMods(mods) {
  if (!mods || mods.length === 0) return '';
  
  // If only ONE damage mod, display it like a regular mod (no grouping box)
  if (mods.length === 1) {
    const m = mods[0];
    const element = getDamageElement(m);
    const elementName = element ? element.charAt(0).toUpperCase() + element.slice(1) : '';
    
    let dmgText = `${m.value1}-${m.value2}`;
    if (altPressed && m.min !== undefined && m.max !== undefined && m.min2 !== undefined && m.max2 !== undefined) {
      dmgText = `${m.value1}(${m.min}-${m.max}) - ${m.value2}(${m.min2}-${m.max2})`;
    }
    
    const tierStr = (altPressed && m.tier) ? ` <span class="tooltip-tier-small">T${m.tier}</span>` : '';
    const statText = `Adds ${dmgText} ${elementName} Damage to Attacks`;
    
    return `<div class="tooltip-mod"><span class="tooltip-mod-text">${statText}</span>${tierStr}</div>`;
  }
  
  // Multiple damage mods - use grouped format
  // Determine if these are "to Attacks" or "to Spells" or generic
  const firstMod = mods[0];
  const statLower = firstMod.stat.toLowerCase();
  let header = 'Adds Elemental Damage';
  if (statLower.includes('to attacks')) header = 'Adds Damage to Attacks';
  else if (statLower.includes('to spells')) header = 'Adds Damage to Spells';
  
  let html = '<div class="tooltip-ele-group">';
  html += `<div class="tooltip-ele-header">${header}:</div>`;
  
  mods.forEach(m => {
    const element = getDamageElement(m);
    const elementClass = element || '';
    const elementName = element ? element.charAt(0).toUpperCase() + element.slice(1) : 'Damage';
    
    let dmgText = `${m.value1}-${m.value2}`;
    if (altPressed && m.min !== undefined && m.max !== undefined && m.min2 !== undefined && m.max2 !== undefined) {
      dmgText = `${m.value1}(${m.min}-${m.max}) - ${m.value2}(${m.min2}-${m.max2})`;
    }
    
    const tierStr = (altPressed && m.tier) ? ` <span class="tooltip-tier-small">T${m.tier}</span>` : '';
    html += `<div class="tooltip-ele-line ${elementClass}">${elementName}: ${dmgText}${tierStr}</div>`;
  });
  
  html += '</div>';
  return html;
}

// Separate mods into grouped damage and regular mods
function separateDamageMods(mods) {
  const damageMods = [];
  const regularMods = [];
  
  mods.forEach(m => {
    if (isFlatDamageMod(m)) {
      damageMods.push(m);
    } else {
      regularMods.push(m);
    }
  });
  
  return { damageMods, regularMods };
}

// Categorize a mod for grouping
function getModCategory(mod) {
  if (!mod || !mod.stat) return 'other';
  const s = mod.stat.toLowerCase();
  
  // Damage mods
  if (s.includes('damage') || s.includes('attack speed') || s.includes('critical')) return 'damage';
  
  // Resource mods
  if (s.includes('life') || s.includes('mana') || s.includes('on hit') || s.includes('on kill')) return 'resources';
  
  // Defense mods
  if (s.includes('armour') || s.includes('armor') || s.includes('dodge') || s.includes('shield') || 
      s.includes('resistance') || s.includes('block')) return 'defense';
  
  // Attribute mods
  if (s.includes('strength') || s.includes('dexterity') || s.includes('intelligence') || s.includes('attributes')) return 'attributes';
  
  // Utility
  if (s.includes('movement') || s.includes('speed')) return 'utility';
  
  return 'other';
}

// Shared tooltip content builder - PoE2 style clean layout
function showTooltipContent(item) {
  const header = document.getElementById('tooltipHeader');
  const name = document.getElementById('tooltipName');
  const type = document.getElementById('tooltipType');
  const body = document.getElementById('tooltipBody');
  
  header.className = 'tooltip-header ' + item.rarity;
  name.className = 'tooltip-name ' + item.rarity;
  name.textContent = item.name;
  type.textContent = getItemType(item.name);
  
  // Use shared tooltip builder
  body.innerHTML = buildItemTooltipHTML(item);
}

function showTooltipWithComparison(item, event) {
  currentTooltipItem = item;
  currentTooltipEvent = event;
  
  // Show the main tooltip for the hovered item
  const tooltip = document.getElementById('itemTooltip');
  const header = document.getElementById('tooltipHeader');
  const name = document.getElementById('tooltipName');
  const type = document.getElementById('tooltipType');
  const body = document.getElementById('tooltipBody');
  
  header.className = 'tooltip-header ' + item.rarity;
  name.className = 'tooltip-name ' + item.rarity;
  name.textContent = item.name;
  type.textContent = getItemType(item.name);
  
  let html = buildItemTooltipHTML(item);
  body.innerHTML = html;
  tooltip.classList.add('visible');
  tooltip.dataset.active = 'true';
  
  // Check if there's an equipped item to compare
  const validSlot = getValidSlotForItem(item.name);
  const equippedItem = validSlot ? equipment[validSlot] : null;
  const equippedTooltip = document.getElementById('equippedTooltip');
  
  if (equippedItem) {
    // Show the equipped item tooltip
    const eqHeader = document.getElementById('equippedTooltipHeader');
    const eqName = document.getElementById('equippedTooltipName');
    const eqType = document.getElementById('equippedTooltipType');
    const eqBody = document.getElementById('equippedTooltipBody');
    
    eqHeader.className = 'tooltip-header ' + equippedItem.rarity;
    eqName.className = 'tooltip-name ' + equippedItem.rarity;
    eqName.textContent = equippedItem.name;
    eqType.textContent = getItemType(equippedItem.name);
    
    let eqHtml = buildItemTooltipHTML(equippedItem);
    eqBody.innerHTML = eqHtml;
    equippedTooltip.classList.add('visible');
  } else {
    equippedTooltip.classList.remove('visible');
  }
  
  positionTooltipWithComparison(event, equippedItem !== null);
}

// Build HTML content for an item tooltip (used by both main and equipped tooltips)
function buildItemTooltipHTML(item) {
  let html = '';
  
  // UNIQUE ITEM TOOLTIP (from UNIQUE_ITEMS registry)
  if (item.isUnique && item.tooltipLines) {
    const levelColor = (player.level >= (item.levelReq || 1)) ? '#8f8' : '#f88';
    html = `
      <div class="tooltip-section" style="text-align: center; padding: 10px;">
        <div style="font-size: 16px; color: #ff8833; margin-bottom: 3px;">${item.name}</div>
        <div style="font-size: 11px; color: #a86; margin-bottom: 8px;">Unique ${item.slot.charAt(0).toUpperCase() + item.slot.slice(1)}</div>
        <div style="border-top: 1px solid #443; padding-top: 8px;">
    `;
    if (item.mods && item.mods.implicit) {
      html += `<div style="color: #88f; font-size: 12px; margin-bottom: 5px;">${item.mods.implicit.text}</div>`;
    }
    html += `<div style="border-top: 1px solid #332; margin-top: 8px; padding-top: 8px;">`;
    for (const line of item.tooltipLines) {
      html += `<div style="color: #af6; font-size: 11px; margin-bottom: 4px; line-height: 1.3;">${line}</div>`;
    }
    html += `</div></div>
        <div style="border-top: 1px solid #332; margin-top: 8px; padding-top: 6px; font-size: 10px; color: ${levelColor};">
          Requires Level ${item.levelReq || 1}
        </div>
      </div>
    `;
    return html;
  }
  
  // SPECIAL CASE: Echo Ring (old stat-copy version) - unique tooltip
  if (item.isEchoRing) {
    const echoColor = item.echoPercent >= 100 ? '#4af' : item.echoPercent >= 80 ? '#fa4' : '#aaa';
    html = `
      <div class="tooltip-section" style="text-align: center; padding: 10px;">
        <div style="font-size: 16px; color: #af6; margin-bottom: 5px;">Echo Ring</div>
        <div style="font-size: 11px; color: #a86; margin-bottom: 10px;">Unique Ring</div>
        <div style="border-top: 1px solid #333; padding-top: 10px;">
          <div style="font-size: 14px; color: ${echoColor}; margin-bottom: 5px;">
            Echo: ${item.echoPercent}%
          </div>
          <div style="font-size: 11px; color: #888; line-height: 1.4;">
            Mirrors <span style="color: ${echoColor}">${item.echoPercent}%</span> of your other ring's stats
          </div>
          <div style="font-size: 10px; color: #666; margin-top: 8px; font-style: italic;">
            Quality is applied to source ring first, then Echo %
          </div>
        </div>
        <div style="border-top: 1px solid #333; margin-top: 10px; padding-top: 8px; font-size: 10px; color: #666;">
          Use Echo Cores to reroll Echo %
        </div>
      </div>
    `;
    return html;
  }
  
  const mods = item.mods || {};
  const slot = getItemSlot(item.name);
  const baseLevel = item.baseLevel || Math.max(1, Math.floor(player.level * 0.8));
  
  // === BASE STATS SECTION (wrapped in distinct styling) ===
  let baseStatsHtml = '';
  
  if (slot === 'weapon') {
    const weaponDmg = getWeaponBaseDamage(item.name, baseLevel);
    let totalMin = item.baseDmgMin || weaponDmg.min;
    let totalMax = item.baseDmgMax || weaponDmg.max;
    // Prevent 0 DPS display
    if (totalMin <= 0) totalMin = 1;
    if (totalMax <= 0) totalMax = 2;
    baseStatsHtml += `<div class="tooltip-base-stat"><span>Physical Damage</span><span class="base-value">${totalMin}-${totalMax}</span></div>`;
  } else if (slot === 'body' || slot === 'helmet' || slot === 'gloves' || slot === 'boots') {
    // Calculate base defenses
    const armorBaseType = getArmorBaseType(item.name);
    let baseArmorVal = 0, baseDodgeVal = 0, baseShieldVal = 0;
    const baseArmor = item.baseArmor || (20 + baseLevel * 3);
    const baseDodge = item.baseDodge || (15 + baseLevel * 2);
    const baseShield = item.baseShield || (12 + baseLevel * 2);
    
    let isHybrid = false;
    let hybridTypes = [];
    
    if (armorBaseType === 'str') baseArmorVal = baseArmor;
    else if (armorBaseType === 'dex') baseDodgeVal = baseDodge;
    else if (armorBaseType === 'int') baseShieldVal = baseShield;
    else if (armorBaseType === 'str_dex') { 
      baseArmorVal = Math.floor(baseArmor * 0.55); 
      baseDodgeVal = Math.floor(baseDodge * 0.55); 
      isHybrid = true;
      hybridTypes = ['Armor', 'Dodge'];
    }
    else if (armorBaseType === 'str_int') { 
      baseArmorVal = Math.floor(baseArmor * 0.55); 
      baseShieldVal = Math.floor(baseShield * 0.55); 
      isHybrid = true;
      hybridTypes = ['Armor', 'Shield'];
    }
    else if (armorBaseType === 'dex_int') { 
      baseDodgeVal = Math.floor(baseDodge * 0.55); 
      baseShieldVal = Math.floor(baseShield * 0.55); 
      isHybrid = true;
      hybridTypes = ['Dodge', 'Shield'];
    }
    
    // Calculate % increases from mods
    let armorPctIncrease = 0, dodgePctIncrease = 0, shieldPctIncrease = 0;
    const allMods = [...(mods.prefixes || []), ...(mods.suffixes || [])].filter(Boolean);
    allMods.forEach(mod => {
      if (!mod || !mod.stat) return;
      const val = mod.value || Math.floor((mod.min + mod.max) / 2);
      if (mod.stat.includes('% increased Armor') || mod.stat.includes('% increased Armor')) {
        armorPctIncrease += val;
      }
      if (mod.stat.includes('% increased Dodge') || mod.stat.includes('% increased Evasion')) {
        dodgePctIncrease += val;
      }
      if (mod.stat.includes('% increased Energy Shield') || mod.stat.includes('% increased Shield')) {
        shieldPctIncrease += val;
      }
    });
    
    // Apply quality bonus (quality increases base defense)
    const qualityBonus = (item.quality || 0) / 100;
    
    // Calculate final values: base * (1 + quality) * (1 + %increase)
    const finalArmorVal = Math.floor(baseArmorVal * (1 + qualityBonus) * (1 + armorPctIncrease / 100));
    const finalDodgeVal = Math.floor(baseDodgeVal * (1 + qualityBonus) * (1 + dodgePctIncrease / 100));
    const finalShieldVal = Math.floor(baseShieldVal * (1 + qualityBonus) * (1 + shieldPctIncrease / 100));
    
    // Show defense values with base in parentheses when modified
    if (baseArmorVal > 0) {
      const isModified = finalArmorVal !== baseArmorVal;
      if (isModified) {
        baseStatsHtml += `<div class="tooltip-base-stat"><span>Armor</span><span class="base-value modified">${finalArmorVal}</span></div>`;
        baseStatsHtml += `<div class="tooltip-base-detail">Base: ${baseArmorVal}</div>`;
      } else {
        baseStatsHtml += `<div class="tooltip-base-stat"><span>Armor</span><span class="base-value">${baseArmorVal}</span></div>`;
      }
    }
    if (baseDodgeVal > 0) {
      const isModified = finalDodgeVal !== baseDodgeVal;
      if (isModified) {
        baseStatsHtml += `<div class="tooltip-base-stat"><span>Dodge Rating</span><span class="base-value modified">${finalDodgeVal}</span></div>`;
        baseStatsHtml += `<div class="tooltip-base-detail">Base: ${baseDodgeVal}</div>`;
      } else {
        baseStatsHtml += `<div class="tooltip-base-stat"><span>Dodge Rating</span><span class="base-value">${baseDodgeVal}</span></div>`;
      }
    }
    if (baseShieldVal > 0) {
      const isModified = finalShieldVal !== baseShieldVal;
      if (isModified) {
        baseStatsHtml += `<div class="tooltip-base-stat"><span>Energy Shield</span><span class="base-value modified">${finalShieldVal}</span></div>`;
        baseStatsHtml += `<div class="tooltip-base-detail">Base: ${baseShieldVal}</div>`;
      } else {
        baseStatsHtml += `<div class="tooltip-base-stat"><span>Energy Shield</span><span class="base-value">${baseShieldVal}</span></div>`;
      }
    }
    
    // Add hybrid hint
    if (isHybrid) {
      baseStatsHtml += `<div class="tooltip-hybrid-hint">Hybrid: ${hybridTypes.join(' + ')}</div>`;
    }
  }
  
  // Quality (if present)
  if (item.quality && item.quality > 0) {
    baseStatsHtml += `<div class="tooltip-base-stat"><span>Quality</span><span class="base-value quality">+${item.quality}%</span></div>`;
  }
  
  // Wrap base stats in section if we have any
  if (baseStatsHtml) {
    html += `<div class="tooltip-base-stats-section">${baseStatsHtml}</div>`;
  }
  
  // Requirements
  html += `<div class="tooltip-req">Requires Level ${baseLevel}</div>`;
  
  // === SOCKETS ===
  if (item.sockets && item.sockets.length > 0) {
    html += '<div class="tooltip-sep"></div>';
    html += '<div class="tooltip-sockets-section">';
    html += '<div class="tooltip-section-header">Socketed Gems</div>';
    item.sockets.forEach((socket, i) => {
      const colorMap = { red: '#f44', green: '#4f4', blue: '#44f', white: '#fff' };
      const gemData = socket.gem ? GEM_DATA[socket.gem] : null;
      
      if (socket.gem && gemData) {
        // Determine if weapon or armor for effect display
        const isWeapon = slot === 'weapon';
        const quality = socket.gemQuality || 0;
        const qualityMult = 1 + (quality / 100);
        const effectText = getGemEffectText(gemData, isWeapon, quality);
        const effectClass = getEffectClass(isWeapon ? gemData.bonus.stat : (gemData.bonus.armorStat || gemData.bonus.stat));
        const qualityText = quality > 0 ? `<span style="color: #8f8; font-size: 10px;"> (${quality}%)</span>` : '';
        
        // Add onclick for unsocketing when in crafting context
        const unsocketAttr = `onclick="unsocketGemFromItem(${i})" style="cursor: pointer;" title="Click to unsocket gem"`;
        
        html += `<div class="tooltip-socket-row" ${unsocketAttr}>`;
        html += `<span class="socket-icon" style="color:${colorMap[socket.color] || '#888'}">${gemData.icon || '●'}</span>`;
        html += `<span class="socket-gem-info">`;
        html += `<span class="socket-gem-name">${gemData.name}${qualityText}</span>`;
        html += `<span class="socket-gem-effect ${effectClass}">${effectText}</span>`;
        html += `</span></div>`;
      } else {
        // Empty socket
        html += `<div class="tooltip-socket-row empty">`;
        html += `<span class="socket-icon" style="color:${colorMap[socket.color] || '#888'}">○</span>`;
        html += `<span class="socket-empty-text">Empty Socket</span>`;
        html += `</div>`;
      }
    });
    html += '</div>';
  }
  
  // === IMPLICIT (shown BEFORE affixes with isolated styling) ===
  if (mods.implicit && mods.implicit.stat && mods.implicit.text) {
    html += '<div class="tooltip-sep"></div>';
    html += '<div class="tooltip-implicit-section">';
    html += '<div class="tooltip-section-header implicit">Implicit</div>';
    html += `<div class="tooltip-implicit">${mods.implicit.text}</div>`;
    html += '</div>';
  }
  
  // === AFFIXES (separated by prefix/suffix like POE2) ===
  const prefixes = (mods.prefixes || []).filter(Boolean);
  const suffixes = (mods.suffixes || []).filter(Boolean);
  const totalMods = prefixes.length + suffixes.length;
  
  if (prefixes.length > 0 || suffixes.length > 0) {
    html += '<div class="tooltip-sep"></div>';
    
    // Separate damage mods from regular mods for grouping
    const prefixSplit = separateDamageMods(prefixes);
    const suffixSplit = separateDamageMods(suffixes);
    
    // Combine all damage mods for grouped display (usually all prefixes)
    const allDamageMods = [...prefixSplit.damageMods, ...suffixSplit.damageMods];
    
    // Show prefixes section (regular mods + grouped damage)
    const hasPrefixContent = prefixSplit.regularMods.length > 0 || allDamageMods.length > 0;
    if (hasPrefixContent) {
      html += '<div class="tooltip-section-header">Prefixes</div>';
      prefixSplit.regularMods.forEach(m => { html += formatModLine(m); });
      if (allDamageMods.length > 0) {
        html += formatGroupedDamageMods(allDamageMods);
      }
    }
    
    // Show suffixes section (only regular mods, damage mods were grouped above)
    if (suffixSplit.regularMods.length > 0) {
      html += '<div class="tooltip-section-header">Suffixes</div>';
      suffixSplit.regularMods.forEach(m => { html += formatModLine(m); });
    }
  }
  
  if (mods.isImmutable) {
    html += '<div class="tooltip-immutable">Immutable</div>';
  }
  
  if (!altPressed && totalMods > 0) {
    html += `<div class="tooltip-hint">Hold Alt for details</div>`;
  }
  
  return html;
}

// Position tooltips side by side
function positionTooltipWithComparison(event, hasEquipped) {
  const tooltip = document.getElementById('itemTooltip');
  const equippedTooltip = document.getElementById('equippedTooltip');
  
  if (!tooltip.classList.contains('visible')) return;
  
  const rect = tooltip.getBoundingClientRect();
  const gap = 10;
  const margin = 15;
  const screenPadding = 10;
  
  // If equipped tooltip is visible, position them side by side
  if (hasEquipped && equippedTooltip.classList.contains('visible')) {
    const eqRect = equippedTooltip.getBoundingClientRect();
    const totalWidth = rect.width + gap + eqRect.width;
    const maxHeight = Math.max(rect.height, eqRect.height);
    
    // Calculate starting position (center them horizontally on cursor)
    let startX = event.clientX - totalWidth / 2;
    let y = event.clientY + margin;
    
    // Clamp X to screen bounds
    startX = Math.max(screenPadding, Math.min(startX, window.innerWidth - totalWidth - screenPadding));
    
    // Check if fits below cursor, otherwise flip above
    if (y + maxHeight > window.innerHeight - screenPadding) {
      y = event.clientY - maxHeight - margin;
    }
    
    // Final Y clamp
    y = Math.max(screenPadding, Math.min(y, window.innerHeight - maxHeight - screenPadding));
    
    // Position equipped tooltip (left)
    equippedTooltip.style.left = startX + 'px';
    equippedTooltip.style.top = y + 'px';
    
    // Position main tooltip (right)
    tooltip.style.left = (startX + eqRect.width + gap) + 'px';
    tooltip.style.top = y + 'px';
  } else {
    // No equipped item, just position main tooltip normally
    let x = event.clientX + margin;
    let y = event.clientY + margin;
    
    // Check right edge
    if (x + rect.width > window.innerWidth - screenPadding) {
      x = event.clientX - rect.width - margin;
    }
    
    // Check bottom edge
    if (y + rect.height > window.innerHeight - screenPadding) {
      y = event.clientY - rect.height - margin;
    }
    
    // Final clamp
    x = Math.max(screenPadding, Math.min(x, window.innerWidth - rect.width - screenPadding));
    y = Math.max(screenPadding, Math.min(y, window.innerHeight - rect.height - screenPadding));
    
    tooltip.style.left = x + 'px';
    tooltip.style.top = y + 'px';
  }
}

// Get the difference for a specific mod compared to equipped item
function getModDiffFromEquipped(mod, equippedMods) {
  if (!mod.stat || equippedMods.length === 0) return null;
  
  // Try to find matching mod by stat type
  const match = equippedMods.find(em => {
    if (!em.stat) return false;
    // Match by stat type (the # placeholder part)
    return em.stat === mod.stat;
  });
  
  if (match) {
    return {
      value1Diff: (mod.value1 || 0) - (match.value1 || 0),
      value2Diff: (mod.value2 || 0) - (match.value2 || 0),
      isNew: false
    };
  }
  
  // This is a new mod not on equipped item
  return { isNew: true };
}

// Format mod line with diff indicator
function formatModLineWithDiff(m, diff) {
  let displayText = m.text;
  let diffHtml = '';
  
  if (altPressed && m.value1 !== undefined && m.min !== undefined && m.max !== undefined) {
    if (m.value2 !== undefined && m.min2 !== undefined && m.max2 !== undefined) {
      const range1 = `${m.value1}(${m.min}-${m.max})`;
      const range2 = `${m.value2}(${m.min2}-${m.max2})`;
      displayText = m.stat.replace('#', range1).replace('#', range2);
    } else {
      const range = `${m.value1}(${m.min}-${m.max})`;
      displayText = m.stat.replace('#', range);
    }
  }
  
  // Add diff indicator - show both absolute and percentage where relevant
  if (diff) {
    if (diff.isNew) {
      diffHtml = ' <span class="stat-diff positive">(NEW)</span>';
    } else if (diff.value1Diff !== 0) {
      const cls = diff.value1Diff > 0 ? 'positive' : 'negative';
      const sign = diff.value1Diff > 0 ? '+' : '';
      
      // Check if this is a percentage-based stat
      const isPercent = m.stat && (m.stat.includes('%') || m.stat.includes('increased') || m.stat.includes('Resistance'));
      const suffix = isPercent ? '%' : '';
      
      diffHtml = ` <span class="stat-diff ${cls}">(${sign}${diff.value1Diff}${suffix})</span>`;
    }
  }
  
  return `<div class="tooltip-stat-line">${displayText}${diffHtml}</div>`;
}

// Find mods that exist in equipped but not in new item
function findLostMods(equippedMods, newMods) {
  const lost = [];
  
  for (const em of equippedMods) {
    if (!em.stat) continue;
    
    const hasMatch = newMods.some(nm => nm.stat === em.stat);
    if (!hasMatch) {
      lost.push(em);
    }
  }
  
  return lost;
}

function showTooltip(item, event) {
  currentTooltipItem = item;
  currentTooltipEvent = event;
  
  const tooltip = document.getElementById('itemTooltip');
  const header = document.getElementById('tooltipHeader');
  const name = document.getElementById('tooltipName');
  const type = document.getElementById('tooltipType');
  const body = document.getElementById('tooltipBody');
  
  header.className = 'tooltip-header ' + item.rarity;
  name.className = 'tooltip-name ' + item.rarity;
  name.textContent = item.name;
  type.textContent = getItemType(item.name);
  
  body.innerHTML = buildItemTooltipHTML(item);
  tooltip.classList.add('visible');
  
  // Store item for mouse move updates
  tooltip.dataset.active = 'true';
  positionTooltip(event);
}

function positionTooltip(event) {
  const tooltip = document.getElementById('itemTooltip');
  if (!tooltip.classList.contains('visible')) return;
  
  const rect = tooltip.getBoundingClientRect();
  const margin = 15;
  const screenPadding = 10;
  
  // Start with cursor position + offset
  let x = event.clientX + margin;
  let y = event.clientY + margin;
  
  // Check right edge - flip to left of cursor if needed
  if (x + rect.width > window.innerWidth - screenPadding) {
    x = event.clientX - rect.width - margin;
  }
  
  // Check bottom edge - flip above cursor if needed
  if (y + rect.height > window.innerHeight - screenPadding) {
    y = event.clientY - rect.height - margin;
  }
  
  // Final clamp to ensure always on screen
  x = Math.max(screenPadding, Math.min(x, window.innerWidth - rect.width - screenPadding));
  y = Math.max(screenPadding, Math.min(y, window.innerHeight - rect.height - screenPadding));
  
  tooltip.style.left = x + 'px';
  tooltip.style.top = y + 'px';
}

function hideTooltip() {
  const tooltip = document.getElementById('itemTooltip');
  tooltip.classList.remove('visible');
  tooltip.dataset.active = 'false';
  
  // Also hide the equipped comparison tooltip
  const equippedTooltip = document.getElementById('equippedTooltip');
  if (equippedTooltip) {
    equippedTooltip.classList.remove('visible');
  }
  
  currentTooltipItem = null;
  currentTooltipEvent = null;
}

// ========== CURRENCY/GEM TOOLTIP SYSTEM ==========
// Currency data for tooltips
const CURRENCY_DATA = {
  transmute: { 
    name: 'Common Core', 
    rarity: 'basic', 
    desc: 'Upgrades a Normal item to Magic quality, adding one random modifier.',
    useOn: '⚪ Normal (white) items only',
    tip: '💡 Start here! Use on white items you want to improve.'
  },
  augment: { 
    name: 'Magic Core', 
    rarity: 'basic', 
    desc: 'Adds a second modifier to a Magic item that only has one mod.',
    useOn: '🔵 Magic (blue) items with 1 mod',
    tip: '💡 Magic items can have up to 2 mods total.'
  },
  upgrade: { 
    name: 'Upgrade Core', 
    rarity: 'rare', 
    desc: 'Upgrades a Magic item to Rare quality. Keeps existing mods and adds one more.',
    useOn: '🔵 Magic (blue) items only',
    tip: '💡 Best used on Magic items with 2 good mods you want to keep.'
  },
  rare: { 
    name: 'Rare Core', 
    rarity: 'rare', 
    desc: 'Adds one random modifier to a Rare item.',
    useOn: '🟡 Rare (yellow) items with <6 mods',
    tip: '💡 Rare items can have up to 6 mods (3 prefix + 3 suffix).'
  },
  wild: { 
    name: 'Wild Core', 
    rarity: 'rare', 
    desc: 'Completely rerolls ALL modifiers on a Rare item with new random mods.',
    useOn: '🟡 Rare (yellow) items only',
    tip: '⚠️ Risky! Destroys existing mods. Use on bad rares.'
  },
  echo: { 
    name: 'Echo Core', 
    rarity: 'rare', 
    desc: 'Rerolls the numerical values of all mods. Keeps the same mod types but changes the numbers.',
    useOn: '🔵 Magic or 🟡 Rare items',
    tip: '💡 Safe to use! Great for improving rolls on good mod types.'
  },
  annul: { 
    name: 'Void Core', 
    rarity: 'rare', 
    desc: 'Removes one RANDOM modifier from an item permanently.',
    useOn: '🔵 Magic or 🟡 Rare items',
    tip: '⚠️ Dangerous! Can remove your best mod. Use to remove bad mods.'
  },
  vaal: { 
    name: 'Uncontrolled Core', 
    rarity: 'unique', 
    desc: 'Corrupts an item with unpredictable results. Can add powerful implicits, extra sockets, transform it, or BRICK it completely.',
    useOn: 'Any non-corrupted item',
    tip: '☠️ DANGER! Item becomes IMMUTABLE (unchangeable forever).'
  },
  armorer: { 
    name: 'Armor Shard', 
    rarity: 'basic', 
    desc: 'Adds +5% quality to armor. Quality increases the base defense values.',
    useOn: '🛡️ Armor pieces (helm, chest, gloves, boots)',
    tip: '💡 Quality boosts base stats. Max 20% quality.'
  },
  whetstone: { 
    name: 'Weapon Shard', 
    rarity: 'basic', 
    desc: 'Adds +5% quality to weapons. Quality increases base physical damage.',
    useOn: '⚔️ Weapons only',
    tip: '💡 Quality boosts base damage. Max 20% quality.'
  },
  jeweller: { 
    name: 'Socket Core', 
    rarity: 'basic', 
    desc: 'Adds one socket to an item. Sockets let you insert gems for bonus stats.',
    useOn: 'Any socketable gear',
    tip: '💡 Max sockets: Weapons & Chest = 2, Other gear = 1'
  }
};

function showCurrencyTooltip(currencyId, event) {
  const tooltip = document.getElementById('currencyTooltip');
  const nameEl = document.getElementById('currencyTooltipName');
  const stackEl = document.getElementById('currencyTooltipStack');
  const bodyEl = document.getElementById('currencyTooltipBody');
  
  // Check if it's a gem
  const gemData = GEM_DATA[currencyId];
  const currencyData = CURRENCY_DATA[currencyId];
  
  if (gemData) {
    // It's a gem - show gem tooltip
    nameEl.textContent = gemData.name;
    nameEl.className = 'currency-tooltip-name magic';
    stackEl.textContent = `Stack: ${stash[currencyId] || 0}`;
    
    let bodyHtml = '';
    
    // Show the simple tip that explains both weapon and armor effects
    if (gemData.tip) {
      bodyHtml += `<div class="currency-tooltip-tip" style="font-style: normal; color: #ccbb99; padding: 0 0 6px 0;">${gemData.tip}</div>`;
    }
    
    bodyHtml += '<div class="currency-tooltip-useon">💎 Socket into gear with empty sockets</div>';
    
    bodyEl.innerHTML = bodyHtml;
  } else if (currencyData) {
    // It's a crafting currency
    nameEl.textContent = currencyData.name;
    nameEl.className = `currency-tooltip-name ${currencyData.rarity}`;
    stackEl.textContent = `Stack: ${stash[currencyId] || 0}`;
    
    let bodyHtml = `<div class="currency-tooltip-desc">${currencyData.desc}</div>`;
    if (currencyData.useOn) {
      bodyHtml += `<div class="currency-tooltip-useon">${currencyData.useOn}</div>`;
    }
    if (currencyData.tip) {
      bodyHtml += `<div class="currency-tooltip-tip">${currencyData.tip}</div>`;
    }
    bodyEl.innerHTML = bodyHtml;
  } else {
    return; // Unknown currency
  }
  
  // Position and show
  tooltip.classList.add('visible');
  positionCurrencyTooltip(event);
}

function hideCurrencyTooltip() {
  const tooltip = document.getElementById('currencyTooltip');
  if (tooltip) {
    tooltip.classList.remove('visible');
  }
}

function positionCurrencyTooltip(event) {
  const tooltip = document.getElementById('currencyTooltip');
  if (!tooltip) return;
  
  const padding = 15;
  let x = event.clientX + padding;
  let y = event.clientY + padding;
  
  // Get tooltip dimensions
  const rect = tooltip.getBoundingClientRect();
  
  // Adjust if going off screen
  if (x + rect.width > window.innerWidth - padding) {
    x = event.clientX - rect.width - padding;
  }
  if (y + rect.height > window.innerHeight - padding) {
    y = event.clientY - rect.height - padding;
  }
  
  tooltip.style.left = x + 'px';
  tooltip.style.top = y + 'px';
}

function getEffectClass(stat) {
  if (stat.includes('fire') || stat === 'fireRes') return 'fire';
  if (stat.includes('cold') || stat === 'coldRes') return 'cold';
  if (stat.includes('light') || stat === 'lightRes') return 'lightning';
  if (stat.includes('life') || stat === 'maxHp' || stat === 'lifeLeech' || stat === 'lifeOnKill' || stat === 'lifeRegen') return 'life';
  if (stat.includes('mana')) return 'mana';
  if (stat.includes('phys') || stat === 'armorPct') return 'physical';
  return '';
}

function formatGemEffect(stat, value) {
  const isRange = Array.isArray(value);
  const valStr = isRange ? `${value[0]} to ${value[1]}` : value;
  
  switch(stat) {
    case 'physDmgPct': return `+${valStr}% Physical Damage`;
    case 'armorPct': return `+${valStr}% Armor`;
    case 'fireDmg': return `Adds ${valStr} Fire Damage`;
    case 'coldDmg': return `Adds ${valStr} Cold Damage`;
    case 'lightDmg': return `Adds ${valStr} Lightning Damage`;
    case 'fireRes': return `+${valStr}% Fire Resistance`;
    case 'coldRes': return `+${valStr}% Cold Resistance`;
    case 'lightRes': return `+${valStr}% Lightning Resistance`;
    case 'dodge': return `+${valStr} Dodge Rating`;
    case 'lifeLeech': return `${valStr}% of Damage Leeched as Life`;
    case 'maxHp': return `+${valStr} to Maximum Life`;
    case 'lifeOnKill': return `+${valStr} Life on Kill`;
    case 'lifeRegen': return `+${valStr}% Life Regeneration`;
    case 'atkSpd': return `+${valStr}% Attack Speed`;
    case 'strength': return `+${valStr} Strength`;
    case 'allRes': return `+${valStr}% to All Elemental Resistances`;
    default: return `+${valStr} ${stat}`;
  }
}

// Get the effect text for a gem based on item type and quality
function getGemEffectText(gemData, isWeapon, quality = 0) {
  const bonus = gemData.bonus;
  const qualityMult = 1 + (quality / 100);
  
  // Helper to apply quality to a value
  const applyQuality = (val) => {
    if (Array.isArray(val)) {
      return [Math.round(val[0] * qualityMult), Math.round(val[1] * qualityMult)];
    }
    return Math.round(val * qualityMult * 10) / 10;
  };
  
  // Universal gems (same effect on all items)
  if (!bonus.armorStat || bonus.armorStat === bonus.stat) {
    return formatGemEffect(bonus.stat, applyQuality(bonus.value));
  }
  
  // Dual-effect gems
  if (isWeapon) {
    return formatGemEffect(bonus.stat, applyQuality(bonus.value));
  } else {
    return formatGemEffect(bonus.armorStat, applyQuality(bonus.armorValue));
  }
}

// Track mouse for currency tooltip positioning
document.addEventListener('mousemove', (e) => {
  const currencyTooltip = document.getElementById('currencyTooltip');
  if (currencyTooltip && currencyTooltip.classList.contains('visible')) {
    positionCurrencyTooltip(e);
  }
});

// Track mouse for tooltip positioning
document.addEventListener('mousemove', (e) => {
  const tooltip = document.getElementById('itemTooltip');
  if (tooltip && tooltip.dataset.active === 'true') {
    positionTooltip(e);
  }
  const skillTooltip = document.getElementById('skillTooltip');
  if (skillTooltip && skillTooltip.dataset.active === 'true') {
    positionSkillTooltip(e);
  }
  
  // Enemy tooltip handling for canvas
  handleEnemyTooltip(e);
});

// Track mouse position for enemy tooltips
let canvasMouseX = 0;
let canvasMouseY = 0;

function handleEnemyTooltip(e) {
  const canvas = document.getElementById('gameCanvas');
  if (!canvas || gameState !== 'playing') {
    hideEnemyTooltip();
    return;
  }
  
  // Hide tooltip when any UI panel is open
  if (inventoryOpen || stashOpen || shopOpen || charPanelOpen || passiveTreeOpen) {
    hideEnemyTooltip();
    return;
  }
  
  const rect = canvas.getBoundingClientRect();
  const mouseX = e.clientX;
  const mouseY = e.clientY;
  
  // Check if mouse is over canvas
  if (mouseX < rect.left || mouseX > rect.right || mouseY < rect.top || mouseY > rect.bottom) {
    hideEnemyTooltip();
    return;
  }
  
  // Convert screen coords to canvas pixel coords
  const scaleX = canvas.width / rect.width;
  const scaleY = canvas.height / rect.height;
  const canvasX = (mouseX - rect.left) * scaleX;
  const canvasY = (mouseY - rect.top) * scaleY;
  
  // Convert canvas coords to world coords (reverse the render transform)
  // Render does: translate(W/2, H/2) -> scale(zoom) -> translate(-camera.x, -camera.y)
  // So reverse: subtract W/2, H/2 -> divide by zoom -> add camera.x, camera.y
  const W = canvas.width;
  const H = canvas.height;
  const zoom = camera.zoom || 1;
  const worldX = (canvasX - W / 2) / zoom + camera.x;
  const worldY = (canvasY - H / 2) / zoom + camera.y;
  
  // Check if hovering over any enemy
  let hoveredEnemy = null;
  for (const enemy of enemies) {
    if (enemy.dead) continue;
    const dist = Math.hypot(enemy.x - worldX, enemy.y - worldY);
    const hitRadius = enemy.size || 16;
    if (dist < hitRadius + 10) {
      hoveredEnemy = enemy;
      break;
    }
  }
  
  if (hoveredEnemy) {
    showEnemyTooltip(hoveredEnemy, e);
  } else {
    hideEnemyTooltip();
  }
}

function showEnemyTooltip(enemy, event) {
  const tooltip = document.getElementById('enemyTooltip');
  if (!tooltip) return;
  
  const nameEl = document.getElementById('enemyTooltipName');
  const typeEl = document.getElementById('enemyTooltipType');
  const hpEl = document.getElementById('enemyTooltipHp');
  const hpFill = document.getElementById('enemyTooltipHpFill');
  const dmgEl = document.getElementById('enemyTooltipDmg');
  const spdEl = document.getElementById('enemyTooltipSpd');
  
  // Determine if this is a Greater Rift Guardian (must be BOTH isGuardian AND isGreaterRift)
  const isGuardian = enemy.isGuardian === true && enemy.isGreaterRift === true;
  
  // Clear both classes first, then add the appropriate one
  tooltip.classList.remove('boss-tooltip', 'guardian-tooltip');
  if (isGuardian) {
    tooltip.classList.add('guardian-tooltip');
  } else if (enemy.isBoss) {
    tooltip.classList.add('boss-tooltip');
  }
  
  // Set name with boss/guardian styling
  nameEl.textContent = enemy.name;
  nameEl.className = 'enemy-tooltip-name' + (enemy.isBoss || isGuardian ? ' boss' : '');
  
  // Set type with boss/guardian styling
  let typeText = 'Monster';
  if (isGuardian) typeText = '⚔ RIFT GUARDIAN ⚔';
  else if (enemy.isBoss) typeText = '★ BOSS ★';
  typeEl.textContent = typeText;
  typeEl.className = 'enemy-tooltip-type' + (enemy.isBoss || isGuardian ? ' boss-type' : '');
  
  // Set HP with appropriate color
  const hpPercent = Math.max(0, (enemy.hp / enemy.maxHp) * 100);
  const hpColor = isGuardian ? '#c080ff' : (enemy.isBoss ? '#ffc000' : '#ff6644');
  hpEl.innerHTML = `HP: <span style="color: ${hpColor}">${Math.ceil(enemy.hp)}</span> / ${enemy.maxHp}`;
  hpFill.style.width = hpPercent + '%';
  
  // Set damage
  dmgEl.textContent = `${enemy.dmg[0]}-${enemy.dmg[1]}`;
  
  // Set speed
  spdEl.textContent = enemy.spd.toFixed(1);
  
  // Position tooltip
  tooltip.classList.add('visible');
  
  const tooltipRect = tooltip.getBoundingClientRect();
  let x = event.clientX + 15;
  let y = event.clientY - tooltipRect.height - 10;
  
  if (x + tooltipRect.width > window.innerWidth - 10) {
    x = event.clientX - tooltipRect.width - 15;
  }
  if (y < 10) {
    y = event.clientY + 20;
  }
  
  tooltip.style.left = x + 'px';
  tooltip.style.top = y + 'px';
}

function hideEnemyTooltip() {
  const tooltip = document.getElementById('enemyTooltip');
  if (tooltip) {
    tooltip.classList.remove('visible');
    tooltip.classList.remove('boss-tooltip');
    tooltip.classList.remove('guardian-tooltip');
  }
}

// Skill tooltip data
const SKILL_TOOLTIPS = {
  // ============ PRIMARY SKILLS ============
  // Primary skills scale with attack/cast speed - no cooldown displayed
  fistsOfThunderPrimary: {
    name: 'Fists of Thunder',
    type: 'Primary · Lightning',
    desc: 'Teleport to the target and unleash rapid lightning punches. Every third hit erupts in a crackling shockwave that chains between nearby enemies.',
    stats: ['Damage: 90% weapon damage', 'Every 3rd Hit: 150% AoE + chains to 3', 'Dash Range: 200 units', 'Element: Lightning'],
    cost: 0,
    cooldown: 'atkspd'
  },
  wayOfTheGlacier: {
    name: 'Way of the Glacier',
    type: 'Primary · Cold',
    desc: 'Glacial fists crash into foes with bone-chilling force. Each strike may freeze, and every third hit shatters the air in a freezing nova.',
    stats: ['Damage: 85% weapon damage', '15% freeze chance per hit', 'Every 3rd Hit: 180% nova + 50% freeze', 'Element: Cold'],
    cost: 0,
    cooldown: 'atkspd'
  },
  blazingFists: {
    name: 'Blazing Fists',
    type: 'Primary · Fire',
    desc: 'Fists wreathed in flames scorch all they touch. Every third strike erupts in a fiery explosion that ignites nearby enemies.',
    stats: ['Damage: 95% weapon damage', 'Every 3rd Hit: 200% explosion + ignite', 'Burn: 30% dmg/sec for 1s', 'Element: Fire'],
    cost: 0,
    cooldown: 'atkspd'
  },
  jadeWindStrike: {
    name: 'Jade Wind Strike',
    type: 'Primary · Nature',
    desc: 'Channel the vital energy of nature through each strike. Every blow mends your wounds, and every third strike releases a burst of rejuvenating force.',
    stats: ['Damage: 85% weapon damage', 'Heal 1% max HP per hit', 'Every 3rd Hit: 160% AoE + heal 5%', 'Element: Nature'],
    cost: 0,
    cooldown: 'atkspd'
  },
  basicSlash: {
    name: 'Basic Slash',
    type: 'Primary Attack',
    desc: 'A powerful sword slash with melee cleave. No mana cost - always available.',
    stats: ['Damage: 120% of weapon damage', 'Melee Range: 50 units'],
    cost: 0,
    cooldown: 'atkspd'
  },
  hungryArrowPrimary: {
    name: 'Hungry Arrow',
    type: 'Primary Attack',
    desc: 'Fire a seeking arrow that homes toward nearby enemies. 35% chance to pierce through to the next target.',
    stats: ['Damage: 90% of weapon damage', '35% Pierce Chance', 'Slight Homing'],
    cost: 0,
    cooldown: 'atkspd'
  },
  // ============ MONK SKILLS (D3-Converted) ============
  blindingFlash: {
    name: 'Blinding Flash',
    type: 'Defensive Utility',
    desc: 'Unleash a burst of blinding radiance, causing enemies to whiff their attacks while you slip between blows with heightened agility.',
    stats: ['Blinds enemies for 1s (40% miss chance)', '+15% Dodge for 1.5s', 'Radius: 120 units', 'Bosses: 20% miss chance'],
    cost: 12,
    cooldown: 1.5
  },
  breathOfHeaven: {
    name: 'Breath of Heaven',
    type: 'Heal + Buff',
    desc: 'Channel a surge of vital energy, mending your wounds in a flash and surging forward with renewed speed and focus.',
    stats: ['Heals 30% of max HP', '+15% Attack Speed for 2s', '+10% Movement Speed for 2s'],
    cost: 20,
    cooldown: 3.0
  },
  waveOfLight: {
    name: 'Wave of Light',
    type: 'Line Nuke',
    desc: 'Drop a blazing idol of flame that explodes into a scorching shockwave, obliterating anything caught in its path.',
    stats: ['Damage: 350% along the line', 'First target: +150% crush (500% total)', 'Line length: 200 units', 'Element: Fire'],
    cost: 30,
    cooldown: 2.5
  },
  explodingPalm: {
    name: 'Exploding Palm',
    type: 'DoT + Explosion',
    desc: 'Mark an enemy with a lethal strike. When they fall, their body detonates in a violent blast that rips through surrounding foes.',
    stats: ['Bleed: 180% over 1.5s', 'On death: 300% explosion (120 radius)', 'Only 1 mark active at a time', 'Element: Physical + Fire'],
    cost: 25,
    cooldown: 2.0
  },
  cycloneStrike: {
    name: 'Cyclone Strike',
    type: 'Pull + Burst',
    desc: 'Summon a raging wind that drags enemies into striking distance, then detonate the swirling storm in a crackling burst of lightning.',
    stats: ['Pulls up to 12 enemies (180 radius)', 'Damage: 200% burst', 'Bosses: 20% slow for 1s (no pull)', 'Element: Lightning'],
    cost: 20,
    cooldown: 1.5
  },
  sevenSidedStrike: {
    name: 'Seven-Sided Strike',
    type: 'Ultimate · Teleport',
    desc: 'Become a blur of motion, teleporting between enemies and striking 7 times in rapid succession. Completely invulnerable while attacking.',
    stats: ['Damage: 100% × 7 strikes (700% total)', 'INVULNERABLE during strikes', 'Random target selection', 'Element: Physical'],
    cost: 35,
    cooldown: 15.0
  },
  innerSanctuary: {
    name: 'Inner Sanctuary',
    type: 'Defensive · Zone',
    desc: 'Create a sacred zone of protection around your current position. While inside, take greatly reduced damage and regenerate health.',
    stats: ['50% Damage Reduction inside', 'Heal 3% max HP per second', 'Duration: 5 seconds', 'Radius: 100 units'],
    cost: 25,
    cooldown: 12.0
  },

  // ============ PASSIVE SKILLS (Class-Specific) ============
  // MONK PASSIVES
  monkPower: {
    name: 'Monk Power',
    type: 'Passive · Offensive',
    desc: 'Channel inner strength into devastating strikes.',
    stats: ['+5% Damage', '+10% with Aspect', 'Always Active'],
    cost: 0,
    cooldown: 'Passive'
  },
  monkVitality: {
    name: 'Monk Vitality',
    type: 'Passive · Defensive',
    desc: 'Harden your body through meditation.',
    stats: ['+5% Maximum HP', '+10% with Aspect', 'Always Active'],
    cost: 0,
    cooldown: 'Passive'
  },
  monkResistance: {
    name: 'Monk Resistance',
    type: 'Passive · Utility',
    desc: 'Spiritual protection against the elements.',
    stats: ['+5% All Elemental Resist', '+10% with Aspect', 'Always Active'],
    cost: 0,
    cooldown: 'Passive'
  },
  // WARRIOR PASSIVES
  warriorPower: {
    name: 'Warrior Power',
    type: 'Passive · Offensive',
    desc: 'Raw strength from years of combat training.',
    stats: ['+5% Damage', '+10% with Aspect', 'Always Active'],
    cost: 0,
    cooldown: 'Passive'
  },
  warriorVitality: {
    name: 'Warrior Vitality',
    type: 'Passive · Defensive',
    desc: 'Battle-hardened constitution.',
    stats: ['+5% Maximum HP', '+10% with Aspect', 'Always Active'],
    cost: 0,
    cooldown: 'Passive'
  },
  warriorResistance: {
    name: 'Warrior Resistance',
    type: 'Passive · Utility',
    desc: 'Endure elemental punishment.',
    stats: ['+5% All Elemental Resist', '+10% with Aspect', 'Always Active'],
    cost: 0,
    cooldown: 'Passive'
  },
  // RANGER PASSIVES
  rangerPower: {
    name: 'Ranger Power',
    type: 'Passive · Offensive',
    desc: 'Precision strikes with deadly accuracy.',
    stats: ['+5% Damage', '+10% with Aspect', 'Always Active'],
    cost: 0,
    cooldown: 'Passive'
  },
  rangerVitality: {
    name: 'Ranger Vitality',
    type: 'Passive · Defensive',
    desc: 'Survival instincts honed in the wild.',
    stats: ['+5% Maximum HP', '+10% with Aspect', 'Always Active'],
    cost: 0,
    cooldown: 'Passive'
  },
  rangerResistance: {
    name: 'Ranger Resistance',
    type: 'Passive · Utility',
    desc: 'Natural resilience against harsh elements.',
    stats: ['+5% All Elemental Resist', '+10% with Aspect', 'Always Active'],
    cost: 0,
    cooldown: 'Passive'
  },
  // MAGE PASSIVES
  magePower: {
    name: 'Mage Power',
    type: 'Passive · Offensive',
    desc: 'Amplified magical potency.',
    stats: ['+5% Damage', '+10% with Aspect', 'Always Active'],
    cost: 0,
    cooldown: 'Passive'
  },
  mageVitality: {
    name: 'Mage Vitality',
    type: 'Passive · Defensive',
    desc: 'Life force reinforced by arcane energy.',
    stats: ['+5% Maximum HP', '+10% with Aspect', 'Always Active'],
    cost: 0,
    cooldown: 'Passive'
  },
  mageResistance: {
    name: 'Mage Resistance',
    type: 'Passive · Utility',
    desc: 'Magical wards against elemental harm.',
    stats: ['+5% All Elemental Resist', '+10% with Aspect', 'Always Active'],
    cost: 0,
    cooldown: 'Passive'
  },

  // ============ RANGER SKILLS (D4-Converted) ============
  hungryArrow: {
    name: 'Hungry Arrow',
    type: 'Primary · Physical',
    desc: 'Fire a seeking arrow that homes toward unhit enemies. Has a 35% chance to pierce and continue to another target.',
    stats: ['Damage: 90% Physical', '35% Pierce Chance', 'Slight Homing', 'Prefers Unhit Targets'],
    cost: 0,
    cooldown: 'atkspd'
  },
  chakram: {
    name: 'Chakram',
    type: 'Secondary · Physical',
    desc: 'Fire a swirling Chakram that deals damage to enemies along its path. Returns to you, hitting enemies again on the way back.',
    stats: ['Damage: 180% Physical', 'Hits on outward path', 'Hits again on return', 'Slow projectile'],
    cost: 10,
    cooldown: 5.0
  },
  caltrops: {
    name: 'Caltrops',
    type: 'Utility · Trap',
    desc: 'Scatter sharp caltrops on the ground. Enemies who walk through take damage, are massively slowed, and deal reduced damage.',
    stats: ['Damage: 50%/sec Physical', '80% Slow', '-15% Enemy Damage', 'Duration: 6 seconds'],
    cost: 15,
    cooldown: 5.0
  },
  markedForDeath: {
    name: 'Marked for Death',
    type: 'Utility · Debuff',
    desc: 'Mark an enemy for death. The marked target takes increased damage from all sources. Automatically prioritizes bosses.',
    stats: ['+25% Damage Taken', 'Duration: 8 seconds', 'Auto-targets Bosses', 'One mark at a time'],
    cost: 20,
    cooldown: 8.0
  },
  multiShot: {
    name: 'Multishot',
    type: 'Core Active · AoE',
    desc: 'Fire a volley of arrows in a spread pattern, hitting multiple enemies in front of you.',
    stats: ['Damage: 280% total (5 arrows)', '5 arrows in spread', 'Classic brown arrows', 'Wave Clear'],
    cost: 25,
    cooldown: 1.0
  },
  sentry: {
    name: 'Sentry',
    type: 'Utility · Summon',
    desc: 'Deploy a stationary ballista that fires automatically at nearby enemies. Scales with your weapon and stats, NOT attack speed.',
    stats: ['Damage: 90% per shot', 'Fires every 1.2s', 'Max 2 Sentries', 'Duration: 20s'],
    cost: 20,
    cooldown: 12.0
  },
  rainOfArrows: {
    name: 'Rain of Arrows',
    type: 'Ultimate · AoE',
    desc: 'Call down a devastating rain of arrows over a large area. Applies a Nature bleed that continues dealing damage after the rain ends.',
    stats: ['Damage: 420% over 4s', 'Large radius AoE', 'Bleed: 20%/sec for 3s', 'Element: Physical + Nature'],
    cost: 40,
    cooldown: 30.0
  },

  // ============ MAGE SKILLS ============
  // ============ MAGE SKILLS (D3/D4-Converted) ============
  magicMissile: {
    name: 'Magic Missile',
    type: 'Primary · Physical',
    desc: 'Fire a fast force projectile that seeks enemies. Every third cast fires an additional missile at a nearby enemy.',
    stats: ['Damage: 90% Physical', 'Range: 350 units', '3rd cast: bonus missile', 'No mana cost'],
    cost: 0,
    cooldown: 'castspd'
  },
  electrocute: {
    name: 'Electrocute',
    type: 'Primary · Lightning',
    desc: 'Unleash a bolt of lightning that chains to additional enemies. Lower damage per hit but excellent clear.',
    stats: ['Damage: 70% per hit as Lightning', 'Chains to 2 additional enemies', 'Chain range: 120 units', 'No mana cost'],
    cost: 0,
    cooldown: 'castspd'
  },
  frostNova: {
    name: 'Frost Nova',
    type: 'Defensive · Cold',
    desc: 'Release a burst of freezing energy around you, freezing enemies in place. Bosses are slowed instead of frozen.',
    stats: ['Damage: 120% as Cold', 'Freezes enemies for 1.5s', 'Radius: 140 units', 'Bosses: slowed 3s instead'],
    cost: 18,
    cooldown: 10
  },
  chaosOrb: {
    name: 'Chaos Orb',
    type: 'Secondary · Physical',
    desc: 'Launch a slow-moving orb that explodes on contact. High damage rewards positioning.',
    stats: ['Damage: 240% Physical', 'Explosion radius: 80 units', 'Slow projectile speed'],
    cost: 25,
    cooldown: 1.0
  },
  blizzard: {
    name: 'Blizzard',
    type: 'Focus · Cold',
    desc: 'Call down freezing shards over an area for 4 seconds. Enemies inside are progressively slowed.',
    stats: ['Total Damage: 300% as Cold over 4s', 'Radius: 120 units', '8 hits over duration', 'Progressive slow effect'],
    cost: 30,
    cooldown: 6
  },
  meteor: {
    name: 'Meteor',
    type: 'Ultimate · Fire',
    desc: 'Summon a massive meteor that crashes down after a short delay. Impact followed by burning ground.',
    stats: ['Impact: 400% as Fire', 'Burn: 150% Fire over 3s', 'Radius: 140 units', '0.75s delay before impact'],
    cost: 40,
    cooldown: 10
  },
  energyArmor: {
    name: 'Energy Armor',
    type: 'Defensive · Physical',
    desc: 'Surround yourself with protective energy for 6 seconds. Pure mitigation - no healing.',
    stats: ['+30% Shield', '-15% damage taken', 'Duration: 6 seconds', 'No regeneration effect'],
    cost: 25,
    cooldown: 20
  },

  // ============ WARRIOR SKILLS ============
  shieldBash: {
    name: 'Shield Bash',
    type: 'Melee Stun',
    desc: 'Bash enemies with your shield, stunning them.',
    stats: ['Damage: 150% of weapon damage', 'Stun: 1 second', 'Radius: 50 units'],
    cost: 8,
    cooldown: 0.5
  },
  cleave: {
    name: 'Cleave',
    type: 'Melee AoE',
    desc: 'A wide sweeping sword attack hitting all enemies in front.',
    stats: ['Damage: 180% of weapon damage', 'Radius: 90 units', 'Arc: 180°'],
    cost: 10,
    cooldown: 0.6
  },
  groundSlam: {
    name: 'Ground Slam',
    type: 'Shockwave',
    desc: 'Slam the ground, sending a shockwave that damages nearby enemies.',
    stats: ['Damage: 215% of weapon damage', 'Radius: 120 units'],
    cost: 15,
    cooldown: 1.0
  },
  charge: {
    name: 'Charge',
    type: 'Movement Attack',
    desc: 'Charge forward, damaging enemies in your path.',
    stats: ['Damage: 200% of weapon damage', 'Distance: 200 units'],
    cost: 12,
    cooldown: 0.75
  },
  warCry: {
    name: 'War Cry',
    type: 'Attack Buff',
    desc: 'Let out a mighty war cry, increasing your damage.',
    stats: ['+25% damage', 'Duration: 4 seconds'],
    cost: 15,
    cooldown: 2.0
  },
  shieldWall: {
    name: 'Shield Wall',
    type: 'Defensive Buff',
    desc: 'Raise your guard to reduce incoming damage.',
    stats: ['Reduces damage by 70%', 'Duration: 3 seconds'],
    cost: 20,
    cooldown: 3.0
  },
  execute: {
    name: 'Execute',
    type: 'Finisher',
    desc: 'A devastating finisher attack against a single target.',
    stats: ['Damage: 300% of weapon damage', 'Radius: 60 units'],
    cost: 20,
    cooldown: 1.5
  },
  whirlwind: {
    name: 'Whirlwind',
    type: 'Channeled AoE',
    desc: 'Spin with your weapon, hitting all enemies around you.',
    stats: ['Damage: 100% of weapon damage', 'Radius: 100 units', 'Duration: 1 second'],
    cost: 12,
    cooldown: 0.8
  },
  revenge: {
    name: 'Revenge',
    type: 'Counter Attack',
    desc: 'Strike back at nearby enemies with fury.',
    stats: ['Damage: 220% of weapon damage', 'Radius: 70 units', 'Fast cooldown'],
    cost: 8,
    cooldown: 0.4
  },
  earthquake: {
    name: 'Earthquake',
    type: 'Ultimate AoE',
    desc: 'Create a massive earthquake that damages all enemies in a huge area.',
    stats: ['Damage: 110% per wave', '3 waves (330% total)', 'Radius: 180 units'],
    cost: 35,
    cooldown: 4.0
  }
};

function showSkillTooltip(skillId, event) {
  const data = SKILL_TOOLTIPS[skillId];
  if (!data) return;
  
  const skill = SKILLS[skillId];
  const tooltip = document.getElementById('skillTooltip');
  document.getElementById('skillTooltipName').textContent = data.name;
  document.getElementById('skillTooltipType').textContent = data.type;
  document.getElementById('skillTooltipDesc').textContent = data.desc;
  
  // Get tier multiplier
  const equippedGem = equippedSkillGems.find(g => g.skill === skillId);
  const tier = equippedGem ? equippedGem.tier : 1;
  const tierMult = SKILL_GEM_DATA[skillId]?.tiers?.[tier] || 1;
  
  // Calculate base damage with safety checks
  const minDmg = player.minDmg || 1;
  const maxDmg = player.maxDmg || 2;
  const avgDmg = (minDmg + maxDmg) / 2;
  const skillDmgMult = skill?.damage || 1;
  const estimatedDmg = Math.floor(avgDmg * skillDmgMult * tierMult);
  const minEstDmg = Math.floor(minDmg * skillDmgMult * tierMult);
  const maxEstDmg = Math.floor(maxDmg * skillDmgMult * tierMult);
  
  // Build stats with actual damage numbers
  let statsHtml = '';
  data.stats.forEach(stat => {
    let displayStat = stat;
    
    // Replace "X% of weapon damage" with actual damage
    if (stat.includes('% of weapon damage') || stat.includes('weapon damage')) {
      const percentMatch = stat.match(/(\d+)%/);
      if (percentMatch) {
        const percent = parseInt(percentMatch[1]) / 100;
        const dmgMin = Math.floor(player.minDmg * percent * tierMult);
        const dmgMax = Math.floor(player.maxDmg * percent * tierMult);
        displayStat = `Damage: <span style="color:#ff8866">${dmgMin}-${dmgMax}</span> <span style="color:#666">(${percentMatch[1]}%)</span>`;
      }
    }
    // Replace "Damage:" stats that have multipliers in skill data
    else if (stat.startsWith('Damage:') && skill?.damage) {
      displayStat = `Damage: <span style="color:#ff8866">${minEstDmg}-${maxEstDmg}</span>`;
    }
    
    statsHtml += `<div class="skill-tooltip-stat">${displayStat}</div>`;
  });
  
  // Add estimated DPS for primary skills (only if we have damage)
  if (skill?.isPrimary && estimatedDmg > 0) {
    const speedPerSec = skill.isSpell ? (player.castSpd || 1) / 60 : player.atkSpd / 60;
    const dps = Math.floor(estimatedDmg * speedPerSec);
    if (dps > 0) {
      statsHtml += `<div class="skill-tooltip-stat">Est. DPS: <span style="color:#ffcc44">${dps}</span></div>`;
    }
  }
  
  document.getElementById('skillTooltipStats').innerHTML = statsHtml;
  
  // Primary skills show attack/cast speed info instead of mana/cooldown
  if (skill && skill.isPrimary) {
    if (skill.isSpell) {
      // Spell primary - scales with cast speed
      document.getElementById('skillTooltipCost').innerHTML = `
        <span style="color: #88ff88;">No Mana Cost</span>
        <span class="skill-tooltip-cooldown" style="margin-left: 15px; color: #cc88ff;">Scales with Cast Speed</span>
      `;
    } else {
      // Attack primary - scales with attack speed
      document.getElementById('skillTooltipCost').innerHTML = `
        <span style="color: #88ff88;">No Mana Cost</span>
        <span class="skill-tooltip-cooldown" style="margin-left: 15px; color: #ffcc44;">Scales with Attack Speed</span>
      `;
    }
  } else {
    // Format cooldown - don't show sub-0.1s values
    let cdDisplay = data.cooldown;
    if (typeof cdDisplay === 'number') {
      cdDisplay = cdDisplay >= 1 ? cdDisplay.toFixed(1) : cdDisplay.toFixed(1);
      if (cdDisplay < 0.1) cdDisplay = '0.1';
    }
    document.getElementById('skillTooltipCost').innerHTML = `
      <span style="color: #6688ff;">Mana Cost: ${data.cost}</span>
      <span class="skill-tooltip-cooldown" style="margin-left: 15px;">Cooldown: ${cdDisplay}s</span>
    `;
  }
  
  tooltip.classList.add('visible');
  tooltip.dataset.active = 'true';
  positionSkillTooltip(event);
}

function hideSkillTooltip(event) {
  // Don't hide if we're moving to a child element of the skill slot
  if (event && event.relatedTarget) {
    const skillSlot = event.currentTarget;
    if (skillSlot && skillSlot.contains(event.relatedTarget)) {
      return; // Still within the skill slot, don't hide
    }
  }
  const tooltip = document.getElementById('skillTooltip');
  tooltip.classList.remove('visible');
  tooltip.dataset.active = 'false';
}

function positionSkillTooltip(event) {
  const tooltip = document.getElementById('skillTooltip');
  if (!tooltip.classList.contains('visible')) return;
  
  const rect = tooltip.getBoundingClientRect();
  const margin = 15;
  const screenPadding = 10;
  
  // Start above cursor (skill tooltips prefer above)
  let x = event.clientX + margin;
  let y = event.clientY - rect.height - margin;
  
  // Check right edge
  if (x + rect.width > window.innerWidth - screenPadding) {
    x = event.clientX - rect.width - margin;
  }
  
  // Check top edge - flip below if needed
  if (y < screenPadding) {
    y = event.clientY + margin;
  }
  
  // Check bottom edge after flip
  if (y + rect.height > window.innerHeight - screenPadding) {
    y = window.innerHeight - rect.height - screenPadding;
  }
  
  // Final clamp
  x = Math.max(screenPadding, Math.min(x, window.innerWidth - rect.width - screenPadding));
  y = Math.max(screenPadding, y);
  
  tooltip.style.left = x + 'px';
  tooltip.style.top = y + 'px';
}

// ═══════════════════════════════════════════════════════════════════════════════
// POTION TOOLTIPS - Styled like skill tooltips
// ═══════════════════════════════════════════════════════════════════════════════

const POTION_DATA = {
  life: {
    name: 'Life Potion',
    type: 'INSTANT RECOVERY',
    desc: 'Instantly restores a portion of your maximum health. Essential for surviving tough encounters.',
    icon: '❤️',
    key: 'Q',
    stats: [
      { text: 'Restores 30% of max HP', positive: true },
      { text: 'Auto-triggers below 50% HP', positive: true },
      { text: '8 second cooldown', positive: false },
      { text: 'Unlimited uses', positive: true }
    ],
    color: 'life'
  },
  mana: {
    name: 'Mana Potion',
    type: 'INSTANT RECOVERY',
    desc: 'Instantly restores a large portion of your mana pool. Use to keep your skills ready.',
    icon: '💧',
    key: 'W',
    stats: [
      { text: 'Restores 80% of max Mana', positive: true },
      { text: 'Auto-triggers below 50% Mana', positive: true },
      { text: '8 second cooldown', positive: false },
      { text: 'Unlimited uses', positive: true }
    ],
    color: 'mana'
  }
};

function showPotionTooltip(type, event) {
  const data = POTION_DATA[type];
  if (!data) return;
  
  const tooltip = document.getElementById('potionTooltip');
  const nameEl = document.getElementById('potionTooltipName');
  const typeEl = document.getElementById('potionTooltipType');
  const descEl = document.getElementById('potionTooltipDesc');
  const statsEl = document.getElementById('potionTooltipStats');
  const footerEl = document.getElementById('potionTooltipFooter');
  
  // Set name with proper class
  nameEl.textContent = data.name;
  nameEl.className = 'potion-tooltip-name ' + data.color;
  
  // Set type
  typeEl.textContent = data.type;
  
  // Set description
  descEl.textContent = data.desc;
  
  // Build stats HTML
  let statsHtml = '';
  data.stats.forEach(stat => {
    const colorClass = stat.positive ? '' : 'warning';
    statsHtml += `<div class="potion-tooltip-stat ${colorClass}">${stat.text}</div>`;
  });
  statsEl.innerHTML = statsHtml;
  
  // Set footer with cooldown info and hotkey
  const potion = type === 'life' ? potions.life : potions.mana;
  const cdRemaining = potion.cooldown > 0 ? ` (${potion.cooldown.toFixed(1)}s remaining)` : '';
  footerEl.innerHTML = `Cooldown: 8s${cdRemaining}<span class="potion-tooltip-key">${data.key}</span>`;
  
  // Set tooltip border color
  tooltip.className = 'potion-tooltip visible ' + data.color;
  
  positionPotionTooltip(tooltip, event);
}

function hidePotionTooltip() {
  const tooltip = document.getElementById('potionTooltip');
  if (tooltip) tooltip.classList.remove('visible');
}

// Experience Bar Tooltip
function showExpTooltip() {
  const tooltip = document.getElementById('expTooltip');
  if (!tooltip) return;
  
  const percent = Math.floor((player.exp / player.expToLevel) * 100);
  const currentExp = formatNumber(player.exp);
  const maxExp = formatNumber(player.expToLevel);
  
  document.getElementById('expTooltipLevel').textContent = player.level;
  document.getElementById('expTooltipBarFill').style.width = percent + '%';
  document.getElementById('expTooltipPercent').textContent = percent + '%';
  document.getElementById('expTooltipCurrent').textContent = currentExp;
  document.getElementById('expTooltipMax').textContent = maxExp;
  
  tooltip.classList.add('visible');
}

function hideExpTooltip() {
  const tooltip = document.getElementById('expTooltip');
  if (tooltip) tooltip.classList.remove('visible');
}

function positionPotionTooltip(tooltip, event) {
  const rect = tooltip.getBoundingClientRect();
  const margin = 15;
  const screenPadding = 10;
  
  // Position above the potion button
  let x = event.clientX + margin;
  let y = event.clientY - rect.height - margin;
  
  // Check right edge
  if (x + rect.width > window.innerWidth - screenPadding) {
    x = event.clientX - rect.width - margin;
  }
  
  // Check left edge
  if (x < screenPadding) {
    x = screenPadding;
  }
  
  // Check top edge - flip below if needed
  if (y < screenPadding) {
    y = event.clientY + margin;
  }
  
  // Check bottom edge
  if (y + rect.height > window.innerHeight - screenPadding) {
    y = window.innerHeight - rect.height - screenPadding;
  }
  
  tooltip.style.left = x + 'px';
  tooltip.style.top = y + 'px';
}

function getItemType(name) {
  // Weapons (4 types only)
  if (name.includes('Sword') || name.includes('Blade') || name.includes('Edge')) return 'Sword';
  if (/Quarterstaff/i.test(name)) return 'Quarterstaff';
  if (/Staff|Stave/i.test(name)) return 'Staff';
  if (name.includes('Bow')) return 'Bow';
  // Armor - check Gloves/Boots BEFORE Body Armor (to avoid 'Plate' matching Plate Gauntlets/Greaves)
  if (name.includes('Helm') || name.includes('Hood') || name.includes('Crown') || name.includes('Cap') || name.includes('Circlet') || name.includes('Hat') || name.includes('Mask')) return 'Helmet';
  if (name.includes('Gloves') || name.includes('Gauntlets') || name.includes('Mittens') || name.includes('Wraps')) return 'Gloves';
  if (name.includes('Boots') || name.includes('Greaves') || name.includes('Slippers') || name.includes('Shoes')) return 'Boots';
  if (name.includes('Plate') || name.includes('Mail') || name.includes('Robe') || name.includes('Vest') || name.includes('Shirt') || name.includes('Vestment') || name.includes('Armor') || name.includes('Tunic') || name.includes('Garb')) return 'Body Armor';
  // Accessories
  if (name.includes('Ring')) return 'Ring';
  if (name.includes('Amulet')) return 'Amulet';
  // Fallback to slot-based type
  const slot = getItemSlot(name);
  if (slot === 'weapon') return 'Weapon';
  if (slot === 'body') return 'Body Armor';
  if (slot === 'helmet') return 'Helmet';
  if (slot === 'gloves') return 'Gloves';
  if (slot === 'boots') return 'Boots';
  if (slot === 'ring1' || slot === 'ring2') return 'Ring';
  if (slot === 'amulet') return 'Amulet';
  return 'Equipment';
}

// Item size definitions (width x height in grid cells)
const ITEM_SIZES = {
  // Weapons - 2x3 (8 types: 2 per class)
  // Sword type (STR)
  'Viper Blade': [2, 3], 'War Blade': [2, 3],
  // Quarterstaff type (STR/DEX)
  'Windspire Quarterstaff': [2, 3], 'Ironbark Quarterstaff': [2, 3],
  // Bow type (DEX)
  'Windrunner Bow': [2, 3], 'Ironwood Bow': [2, 3],
  // Staff type (INT)
  'Mystic Staff': [2, 3], 'Elder Staff': [2, 3],
  
  // ═══════════════════════════════════════════════════════════════════════
  // BODY ARMOR - 2x3 (6 bases: 3 pure + 3 hybrid)
  // ═══════════════════════════════════════════════════════════════════════
  'Plate Armor': [2, 3],      // STR (Armor)
  'Leather Tunic': [2, 3],    // DEX (Dodge)
  'Silk Robe': [2, 3],        // INT (Shield)
  'Scale Armor': [2, 3],      // STR/DEX (Armor + Dodge)
  'Crusader Armor': [2, 3],   // STR/INT (Armor + Shield)
  'Assassin Garb': [2, 3],    // DEX/INT (Dodge + Shield)
  
  // ═══════════════════════════════════════════════════════════════════════
  // HELMETS - 2x2 (6 bases: 3 pure + 3 hybrid)
  // ═══════════════════════════════════════════════════════════════════════
  'Iron Helm': [2, 2],       // STR (Armor)
  'Leather Cap': [2, 2],      // DEX (Dodge)
  'Mage Hat': [2, 2],        // INT (Shield)
  'Scale Helm': [2, 2],       // STR/DEX (Armor + Dodge)
  'Crusader Helm': [2, 2],    // STR/INT (Armor + Shield)
  'Bone Circlet': [2, 2],    // DEX/INT (Dodge + Shield)
  
  // ═══════════════════════════════════════════════════════════════════════
  // GLOVES - 2x2 (6 bases: 3 pure + 3 hybrid)
  // ═══════════════════════════════════════════════════════════════════════
  'Plate Gauntlets': [2, 2],     // STR (Armor)
  'Leather Gloves': [2, 2],     // DEX (Dodge)
  'Silk Gloves': [2, 2],        // INT (Shield)
  'Scale Gauntlets': [2, 2],    // STR/DEX (Armor + Dodge)
  'Crusader Gauntlets': [2, 2], // STR/INT (Armor + Shield)
  'Assassin Gloves': [2, 2],    // DEX/INT (Dodge + Shield)
  
  // ═══════════════════════════════════════════════════════════════════════
  // BOOTS - 2x2 (6 bases: 3 pure + 3 hybrid)
  // ═══════════════════════════════════════════════════════════════════════
  'Plate Greaves': [2, 2],     // STR (Armor)
  'Leather Boots': [2, 2],     // DEX (Dodge)
  'Silk Slippers': [2, 2],     // INT (Shield)
  'Scale Boots': [2, 2],       // STR/DEX (Armor + Dodge)
  'Crusader Greaves': [2, 2],  // STR/INT (Armor + Shield)
  'Assassin Boots': [2, 2],    // DEX/INT (Dodge + Shield)
  
  // ═══════════════════════════════════════════════════════════════════════
  // ACCESSORIES & OTHER
  // ═══════════════════════════════════════════════════════════════════════
  // Rings - 1x1 (renamed to match implicits)
  'Nature Ring': [1, 1], 'Vitality Ring': [1, 1], 'Arcane Ring': [1, 1],
  'Flame Ring': [1, 1], 'Frost Ring': [1, 1], 'Storm Ring': [1, 1], 'Prismatic Ring': [1, 1],
  // Amulets - 1x1 (renamed to match implicits)
  'Might Amulet': [1, 1], 'Grace Amulet': [1, 1], 'Wisdom Amulet': [1, 1], 'Harmony Amulet': [1, 1],
  // Flasks - 1x2
  'Life Flask': [1, 2], 'Mana Flask': [1, 2], 'Quicksilver Flask': [1, 2], 'Granite Flask': [1, 2],
  // Jewels - 1x1
  'Crimson Jewel': [1, 1], 'Viridian Jewel': [1, 1], 'Cobalt Jewel': [1, 1],
};

// Get item size, default to 1x1
function getItemSize(name) {
  return ITEM_SIZES[name] || [1, 1];
}

// ============ SLOT-BASED POE2 MODIFIER SYSTEM ============
// SPEC-COMPLIANT ITEMIZATION - DO NOT MODIFY WITHOUT SPEC REFERENCE

// ========== TIER VALUE TABLES (FROM SPEC) ==========

// Large percentage modifiers (% Physical Damage, % Elemental Damage, etc.)
const LARGE_PCT_TIERS = {
  1: [26, 30], 2: [22, 25], 3: [18, 21], 4: [14, 17],
  5: [10, 13], 6: [7, 9], 7: [4, 6], 8: [2, 3]
};

// Small utility percentage modifiers (Movement Speed, Attack Speed, Cast Speed)
const SMALL_PCT_TIERS = {
  1: [9, 10], 2: [7, 8], 3: [5, 6], 4: [3, 4],
  5: [1, 2], 6: [1, 2], 7: [1, 2], 8: [1, 2]
};

// Flat value modifiers (Life, Mana, Attributes, On-Hit, On-Kill)
const FLAT_TIERS = {
  1: [26, 30], 2: [22, 25], 3: [18, 21], 4: [14, 17],
  5: [10, 13], 6: [7, 9], 7: [4, 6], 8: [2, 3]
};

// General resistance tiers
const RESIST_TIERS = {
  1: [21, 25], 2: [18, 21], 3: [16, 18], 4: [12, 15],
  5: [8, 11], 6: [6, 8], 7: [4, 6], 8: [2, 4]
};

// Amulet resistance tiers (weaker - also used for "All Resistances")
const AMULET_RESIST_TIERS = {
  1: [9, 10], 2: [7, 8], 3: [5, 6], 4: [3, 4],
  5: [1, 2], 6: [1, 2], 7: [1, 2], 8: [1, 2]
};

// Skill level tiers (weapons and amulets only)
const SKILL_LEVEL_TIERS = {
  1: [5, 5], 2: [4, 4], 3: [3, 3], 4: [2, 2],
  5: [1, 1], 6: [1, 1], 7: [1, 1], 8: [1, 1]
};

// Boot movement speed tiers (spec section 5)
const MOVE_SPEED_TIERS = {
  1: [40, 40], 2: [35, 35], 3: [30, 30], 4: [25, 25],
  5: [20, 20], 6: [15, 15], 7: [10, 10], 8: [5, 5]
};

// Critical strike chance tiers (small utility)
const CRIT_CHANCE_TIERS = SMALL_PCT_TIERS;

// Critical strike multiplier tiers (larger values)
const CRIT_MULTI_TIERS = {
  1: [26, 30], 2: [22, 25], 3: [18, 21], 4: [14, 17],
  5: [10, 13], 6: [7, 9], 7: [4, 6], 8: [2, 3]
};

// Life regeneration per second tiers (Mana regen REMOVED from game)
const REGEN_TIERS = {
  1: [8, 10], 2: [6, 7], 3: [4, 5], 4: [3, 3],
  5: [2, 2], 6: [1, 2], 7: [1, 1], 8: [1, 1]
};

// ========== ITEM LEVEL TIER UNLOCKS ==========
function getMinTierForItemLevel(ilvl) {
  // Per spec Section 6:
  // ilvl 70+: T1-T8
  // ilvl 51-69: T2-T8 (spec says "60 or lower: T2-T8", 70+ is T1)
  // ilvl 41-50: T3-T8
  // ilvl 31-40: T4-T8
  // ilvl 21-30: T5-T8
  // ilvl 1-20: T6-T8
  if (ilvl >= 70) return 1;
  if (ilvl > 50) return 2;   // 51-69
  if (ilvl > 40) return 3;   // 41-50
  if (ilvl > 30) return 4;   // 31-40
  if (ilvl > 20) return 5;   // 21-30
  return 6;                   // 1-20
}

// Select a random tier based on item level (higher tiers more rare)
function selectTier(ilvl) {
  const minTier = getMinTierForItemLevel(ilvl);
  // Weight distribution: higher tiers are rarer
  const weights = { 1: 5, 2: 10, 3: 15, 4: 20, 5: 20, 6: 15, 7: 10, 8: 5 };
  let validTiers = [];
  let totalWeight = 0;
  for (let t = minTier; t <= 8; t++) {
    validTiers.push({ tier: t, weight: weights[t] });
    totalWeight += weights[t];
  }
  let roll = Math.random() * totalWeight;
  for (const t of validTiers) {
    roll -= t.weight;
    if (roll <= 0) return t.tier;
  }
  return 8;
}

// Generate tiered mod helper
function tieredMod(name, stat, tiers, tier) {
  const [min, max] = tiers[tier];
  return { name, stat, min, max, tier };
}

// ════════════════════════════════════════════════════════════════════════════════
// ARMOR BASE TYPE DETECTION
// Maps item names to defense combinations for implicit stat calculation
// See ARMOR BASE SYSTEM documentation above for the complete specification
// ════════════════════════════════════════════════════════════════════════════════

function getArmorBaseType(name) {
  // HYBRID bases checked FIRST (more specific patterns)
  // Hybrids provide BOTH defense types with split base values (55% each)
  
  // STR/DEX hybrid: Armor and Dodge with reduced base values
  if (/^Scale /i.test(name)) return 'str_dex';
  // STR/INT hybrid: Armor and Shield with reduced base values
  if (/^Crusader /i.test(name)) return 'str_int';
  // DEX/INT hybrid: Dodge and Shield with reduced base values
  if (/^Assassin |Bone Circlet/i.test(name)) return 'dex_int';
  
  // PURE bases (checked after hybrids) - full base values for single defense
  // STR bases (Armor only)
  if (/^Plate |Iron Helm/i.test(name)) return 'str';
  // DEX bases (Dodge only)
  if (/^Leather /i.test(name)) return 'dex';
  // INT bases (Shield only)
  if (/^Silk |Mage Hat/i.test(name)) return 'int';
  
  // Default to STR (should not happen with proper item names)
  console.warn('getArmorBaseType: Unmatched item name: ' + name);
  return 'str';
}

// ========== WEAPON TYPE SYSTEM ==========
// WEAPON VALIDATION RULES - LOCKED DOWN
// Only 4 weapon types supported: Sword, Bow, Staff, Quarterstaff
// 
// | Type        | Attribute | Implicit                  | Allowed Affixes                    | Forbidden Affixes        |
// |-------------|-----------|---------------------------|------------------------------------|--------------------------| 
// | Sword       | STR/DEX   | % Attack Speed            | Phys Dmg, Ele Dmg, Atk Spd, Crit   | Spell Dmg, Cast Speed    |
// | Quarterstaff| STR/DEX   | % Critical Strike Chance  | Phys Dmg, Ele Dmg, Atk Spd, Crit   | Spell Dmg, Cast Speed    |
// | Bow         | DEX       | % Projectile Damage       | Phys Dmg, Ele Dmg, Atk Spd, Crit   | Spell Dmg, Cast Speed    |
// | Staff       | INT       | % Spell Damage            | Spell Dmg, Cast Speed, Ele to Spell| Phys Dmg, Attack Speed   |
//
// Base Damage Bounds (ilvl 1 -> ilvl 70):
// | Type        | Early Min-Max | Late Min-Max |
// |-------------|---------------|--------------|
// | Sword       | 3-5           | 18-28        |
// | Quarterstaff| 4-6           | 20-30        |
// | Bow         | 4-7           | 22-34        |
// | Staff       | 2-4           | 14-22        |

function getWeaponType(name) {
  // Staff type (INT spell weapons)
  if (/Elder Staff/i.test(name)) return 'elder_staff';
  if (/Mystic Staff/i.test(name)) return 'mystic_staff';
  
  // Quarterstaff type (STR/DEX melee)
  if (/Windspire Quarterstaff/i.test(name)) return 'windspire_quarterstaff';
  if (/Ironbark Quarterstaff|Quarterstaff/i.test(name)) return 'ironbark_quarterstaff';
  
  // Bow type (DEX ranged)
  if (/Windrunner Bow/i.test(name)) return 'windrunner_bow';
  if (/Ironwood Bow|Bow/i.test(name)) return 'ironwood_bow';
  
  // Sword type (STR melee)
  if (/War Blade/i.test(name)) return 'war_blade';
  // Default to Viper Blade for any blade/sword
  return 'viper_blade';
}

// Get weapon category (for base damage, affixes)
function getWeaponCategory(name) {
  const type = getWeaponType(name);
  if (type === 'viper_blade' || type === 'war_blade') return 'sword';
  if (type === 'windspire_quarterstaff' || type === 'ironbark_quarterstaff') return 'quarterstaff';
  if (type === 'windrunner_bow' || type === 'ironwood_bow') return 'bow';
  if (type === 'mystic_staff' || type === 'elder_staff') return 'staff';
  return 'sword';
}

// Check if weapon is spell-based (INT weapons)
function isSpellWeapon(name) {
  const cat = getWeaponCategory(name);
  return cat === 'staff';
}

// Check if weapon is attack-based (STR/DEX weapons)
function isAttackWeapon(name) {
  return !isSpellWeapon(name);
}

// ========== WEAPON BASE DAMAGE ==========
// White (no affixes) base damage targets
// Early game (ilvl 1-10) -> Late game (ilvl 70)

const WEAPON_BASE_DAMAGE = {
  sword:       { earlyMin: 3,  earlyMax: 5,  lateMin: 18, lateMax: 28 },  // Balanced melee
  quarterstaff:{ earlyMin: 4,  earlyMax: 6,  lateMin: 20, lateMax: 30 },  // 2H melee, crit focus
  bow:         { earlyMin: 4,  earlyMax: 7,  lateMin: 22, lateMax: 34 },  // Ranged attack
  staff:       { earlyMin: 2,  earlyMax: 4,  lateMin: 14, lateMax: 22 },  // Spell focus (low phys)
};

function getWeaponBaseDamage(weaponName, ilvl) {
  const wepCat = getWeaponCategory(weaponName);
  const base = WEAPON_BASE_DAMAGE[wepCat] || WEAPON_BASE_DAMAGE.sword;
  
  // Two-phase scaling:
  // Phase 1: Normal scaling from ilvl 1-70 (linear)
  // Phase 2: Diminishing returns from ilvl 70-80 (~10% more damage total)
  
  let minDmg, maxDmg;
  
  if (ilvl <= 70) {
    // Normal linear scaling 1-70
    const t = Math.max(0, (ilvl - 1) / 69); // 0 at ilvl 1, 1 at ilvl 70
    minDmg = Math.round(base.earlyMin + t * (base.lateMin - base.earlyMin));
    maxDmg = Math.round(base.earlyMax + t * (base.lateMax - base.earlyMax));
  } else {
    // Diminishing returns 70-80: adds ~10% more damage over 10 levels
    // Each level from 70-80 adds 1% of the ilvl 70 value
    const base70Min = base.lateMin;
    const base70Max = base.lateMax;
    const bonusLevels = Math.min(ilvl - 70, 10); // Cap at +10 levels
    const bonusMult = 1 + (bonusLevels * 0.01); // 1% per level, max 10%
    
    minDmg = Math.round(base70Min * bonusMult);
    maxDmg = Math.round(base70Max * bonusMult);
  }
  
  return { min: minDmg, max: maxDmg };
}

// ========== HELMET MODS ==========
const HELMET_PREFIXES = [
  // Life
  ...Array.from({length: 8}, (_, i) => tieredMod('Hale', '+# to maximum Life', FLAT_TIERS, i+1)),
  // Mana
  ...Array.from({length: 8}, (_, i) => tieredMod('Sapient', '+# to maximum Mana', FLAT_TIERS, i+1)),
  // % Armor (STR bases only)
  ...Array.from({length: 8}, (_, i) => tieredMod('Shielding', '#% increased Armor', LARGE_PCT_TIERS, i+1)),
  // % Dodge (DEX bases only)
  ...Array.from({length: 8}, (_, i) => tieredMod('Vaporous', '#% increased Dodge', LARGE_PCT_TIERS, i+1)),
  // % Shield (INT bases only) - filtered by base type in generateMod
  ...Array.from({length: 8}, (_, i) => tieredMod('Glowing', '#% increased Shield', LARGE_PCT_TIERS, i+1)),
];

const HELMET_SUFFIXES = [
  // Attributes
  ...Array.from({length: 8}, (_, i) => tieredMod('of the Titan', '+# to Strength', FLAT_TIERS, i+1)),
  ...Array.from({length: 8}, (_, i) => tieredMod('of the Falcon', '+# to Dexterity', FLAT_TIERS, i+1)),
  ...Array.from({length: 8}, (_, i) => tieredMod('of the Sage', '+# to Intelligence', FLAT_TIERS, i+1)),
  // Single resistances
  ...Array.from({length: 8}, (_, i) => tieredMod('of the Salamander', '+#% to Fire Resistance', RESIST_TIERS, i+1)),
  ...Array.from({length: 8}, (_, i) => tieredMod('of the Yeti', '+#% to Cold Resistance', RESIST_TIERS, i+1)),
  ...Array.from({length: 8}, (_, i) => tieredMod('of the Storm', '+#% to Lightning Resistance', RESIST_TIERS, i+1)),
  ...Array.from({length: 8}, (_, i) => tieredMod('of the Grove', '+#% to Nature Resistance', RESIST_TIERS, i+1)),
  // Life/Mana Regen (helmets have insight/regeneration theme)
  ...Array.from({length: 8}, (_, i) => tieredMod('of Regeneration', '+# Life Regeneration per second', REGEN_TIERS, i+1)),
  // NOTE: Mana Regen REMOVED - mana sustain comes from on-hit, on-kill, leech, potions only
];

// ========== GLOVES MODS ==========
// Special rules: Physical Damage to Attacks only on STR/DEX bases
// Elemental Damage to Attacks on ALL bases
// NO Attack Speed, Cast Speed, Spell Damage, Regen, Leech

const GLOVES_PREFIXES = [
  // Life
  ...Array.from({length: 8}, (_, i) => tieredMod('Hale', '+# to maximum Life', FLAT_TIERS, i+1)),
  // Mana
  ...Array.from({length: 8}, (_, i) => tieredMod('Sapient', '+# to maximum Mana', FLAT_TIERS, i+1)),
  // % Armor
  ...Array.from({length: 8}, (_, i) => tieredMod('Shielding', '#% increased Armor', LARGE_PCT_TIERS, i+1)),
  // % Dodge
  ...Array.from({length: 8}, (_, i) => tieredMod('Vaporous', '#% increased Dodge', LARGE_PCT_TIERS, i+1)),
  // % Shield
  ...Array.from({length: 8}, (_, i) => tieredMod('Glowing', '#% increased Shield', LARGE_PCT_TIERS, i+1)),
  // Adds Elemental Damage to Attacks (all base types)
  { name: 'Heated', stat: 'Adds # to # Fire Damage to Attacks', min: 2, max: 3, min2: 4, max2: 6, tier: 5 },
  { name: 'Chilled', stat: 'Adds # to # Cold Damage to Attacks', min: 2, max: 3, min2: 4, max2: 5, tier: 5 },
  { name: 'Charged', stat: 'Adds # to # Lightning Damage to Attacks', min: 1, max: 2, min2: 6, max2: 8, tier: 5 },
];

// Physical damage to attacks - only for STR/DEX gloves (added dynamically)
const GLOVES_PHYS_PREFIX = { name: 'Martial', stat: 'Adds # to # Physical Damage to Attacks', min: 2, max: 3, min2: 4, max2: 5, tier: 5 };

const GLOVES_SUFFIXES = [
  // Attributes
  ...Array.from({length: 8}, (_, i) => tieredMod('of the Titan', '+# to Strength', FLAT_TIERS, i+1)),
  ...Array.from({length: 8}, (_, i) => tieredMod('of the Falcon', '+# to Dexterity', FLAT_TIERS, i+1)),
  ...Array.from({length: 8}, (_, i) => tieredMod('of the Sage', '+# to Intelligence', FLAT_TIERS, i+1)),
  // Single resistance only
  ...Array.from({length: 8}, (_, i) => tieredMod('of the Salamander', '+#% to Fire Resistance', RESIST_TIERS, i+1)),
  ...Array.from({length: 8}, (_, i) => tieredMod('of the Yeti', '+#% to Cold Resistance', RESIST_TIERS, i+1)),
  ...Array.from({length: 8}, (_, i) => tieredMod('of the Storm', '+#% to Lightning Resistance', RESIST_TIERS, i+1)),
  ...Array.from({length: 8}, (_, i) => tieredMod('of the Grove', '+#% to Nature Resistance', RESIST_TIERS, i+1)),
];

// ========== BOOTS MODS ==========
// BOOTS SYSTEM - LOCKED DOWN (PoE2 Model)
//
// NO IMPLICITS: Base defense IS the identity
// - "Base = what the item IS, Implicit = what the item DOES"
// - Defense comes from base stats which scale with ilvl
//
// MOVEMENT SPEED: Normal suffix affix (competes with resistances/attributes)
// - T8: 5%, T7: 10%, T6: 15%, T5: 20%, T4: 25%, T3: 30%, T2: 35%, T1: 40%
//
// ALLOWED PREFIXES: +Life, +Mana, % Defense (matching base type only)
// ALLOWED SUFFIXES: Attributes, Resistances, Movement Speed
// NOT ALLOWED: Offensive mods, sustain mods (on Hit/Kill)
//
// BOOT BASES:
// | Name                                     | Type     | Base Defense   |
// |------------------------------------------|----------|----------------|
// | Iron/Chain/Steel/Titan Greaves           | str      | Armor          |
// | Rawhide/Leather/Scout Boots              | dex      | Dodge          |
// | Silk Slippers/Cloth Shoes/Scholar Boots  | int      | Shield         |
// | Scale Boots                              | str_dex  | 55% Armor/Dodge|
// | Assassin Boots                           | dex_int  | 55% Dodge/Shield|
// | Crusader Greaves                         | str_int  | 55% Armor/Shield|
//
// DESIGN INTENT: MS is desirable but competes with resistances/attributes.
// Best boots prioritize MS + survivability; depth from affix competition.

const BOOTS_PREFIXES = [
  // Life
  ...Array.from({length: 8}, (_, i) => tieredMod('Hale', '+# to maximum Life', FLAT_TIERS, i+1)),
  // Mana
  ...Array.from({length: 8}, (_, i) => tieredMod('Sapient', '+# to maximum Mana', FLAT_TIERS, i+1)),
  // % Armor
  ...Array.from({length: 8}, (_, i) => tieredMod('Shielding', '#% increased Armor', LARGE_PCT_TIERS, i+1)),
  // % Dodge
  ...Array.from({length: 8}, (_, i) => tieredMod('Vaporous', '#% increased Dodge', LARGE_PCT_TIERS, i+1)),
  // % Shield
  ...Array.from({length: 8}, (_, i) => tieredMod('Glowing', '#% increased Shield', LARGE_PCT_TIERS, i+1)),
];

const BOOTS_SUFFIXES = [
  // Attributes
  ...Array.from({length: 8}, (_, i) => tieredMod('of the Titan', '+# to Strength', FLAT_TIERS, i+1)),
  ...Array.from({length: 8}, (_, i) => tieredMod('of the Falcon', '+# to Dexterity', FLAT_TIERS, i+1)),
  ...Array.from({length: 8}, (_, i) => tieredMod('of the Sage', '+# to Intelligence', FLAT_TIERS, i+1)),
  // Single resistances
  ...Array.from({length: 8}, (_, i) => tieredMod('of the Salamander', '+#% to Fire Resistance', RESIST_TIERS, i+1)),
  ...Array.from({length: 8}, (_, i) => tieredMod('of the Yeti', '+#% to Cold Resistance', RESIST_TIERS, i+1)),
  ...Array.from({length: 8}, (_, i) => tieredMod('of the Storm', '+#% to Lightning Resistance', RESIST_TIERS, i+1)),
  ...Array.from({length: 8}, (_, i) => tieredMod('of the Grove', '+#% to Nature Resistance', RESIST_TIERS, i+1)),
  // Movement Speed (boots only) - competes with resistances/attributes
  ...Array.from({length: 8}, (_, i) => tieredMod('of Speed', '#% increased Movement Speed', MOVE_SPEED_TIERS, i+1)),
];

// ========== BODY ARMOUR MODS ==========
// ONLY slot with hybrid defense mods and defense behavior mods

const BODY_PREFIXES = [
  // Life
  ...Array.from({length: 8}, (_, i) => tieredMod('Hale', '+# to maximum Life', FLAT_TIERS, i+1)),
  // Mana
  ...Array.from({length: 8}, (_, i) => tieredMod('Sapient', '+# to maximum Mana', FLAT_TIERS, i+1)),
  // % Armor
  ...Array.from({length: 8}, (_, i) => tieredMod('Shielding', '#% increased Armor', LARGE_PCT_TIERS, i+1)),
  // % Dodge
  ...Array.from({length: 8}, (_, i) => tieredMod('Vaporous', '#% increased Dodge', LARGE_PCT_TIERS, i+1)),
  // % Shield
  ...Array.from({length: 8}, (_, i) => tieredMod('Glowing', '#% increased Shield', LARGE_PCT_TIERS, i+1)),
  // HYBRID DEFENSE MODS (Body only)
  { name: 'Stalwart', stat: '+# to Armor, +# to maximum Life', min: 10, max: 15, min2: 10, max2: 15, tier: 3 },
  { name: 'Agile', stat: '+# to Dodge Rating, +# to maximum Life', min: 10, max: 15, min2: 10, max2: 15, tier: 3 },
  { name: 'Warded', stat: '+# to Shield, +# to maximum Life', min: 10, max: 15, min2: 10, max2: 15, tier: 3 },
];

const BODY_SUFFIXES = [
  // Attributes
  ...Array.from({length: 8}, (_, i) => tieredMod('of the Titan', '+# to Strength', FLAT_TIERS, i+1)),
  ...Array.from({length: 8}, (_, i) => tieredMod('of the Falcon', '+# to Dexterity', FLAT_TIERS, i+1)),
  ...Array.from({length: 8}, (_, i) => tieredMod('of the Sage', '+# to Intelligence', FLAT_TIERS, i+1)),
  // Resistances
  ...Array.from({length: 8}, (_, i) => tieredMod('of the Salamander', '+#% to Fire Resistance', RESIST_TIERS, i+1)),
  ...Array.from({length: 8}, (_, i) => tieredMod('of the Yeti', '+#% to Cold Resistance', RESIST_TIERS, i+1)),
  ...Array.from({length: 8}, (_, i) => tieredMod('of the Storm', '+#% to Lightning Resistance', RESIST_TIERS, i+1)),
  ...Array.from({length: 8}, (_, i) => tieredMod('of the Grove', '+#% to Nature Resistance', RESIST_TIERS, i+1)),
  // DEFENSE BEHAVIOR MODS (Body only)
  { name: 'of Recharging', stat: '#% faster Shield Recharge', min: 10, max: 15, tier: 3 },
  { name: 'of Fortitude', stat: 'Armor is #% more effective against large hits', min: 10, max: 15, tier: 3 },
  { name: 'of Reflexes', stat: '#% increased Dodge after being hit', min: 5, max: 8, tier: 3 },
];

// ========== WEAPON MODS ==========
// Weapon prefixes - ALL weapons
const WEAPON_PREFIXES_ALL = [
  // Adds Physical Damage
  { name: 'Flaring', stat: 'Adds # to # Physical Damage', min: 5, max: 7, min2: 10, max2: 14, tier: 1 },
  { name: 'Tempered', stat: 'Adds # to # Physical Damage', min: 4, max: 5, min2: 8, max2: 10, tier: 2 },
  { name: 'Razor-sharp', stat: 'Adds # to # Physical Damage', min: 3, max: 4, min2: 6, max2: 8, tier: 3 },
  { name: 'Honed', stat: 'Adds # to # Physical Damage', min: 2, max: 3, min2: 4, max2: 6, tier: 4 },
  { name: 'Sharpened', stat: 'Adds # to # Physical Damage', min: 1, max: 2, min2: 3, max2: 4, tier: 5 },
  // Adds Fire Damage
  { name: 'Incinerating', stat: 'Adds # to # Fire Damage', min: 6, max: 8, min2: 12, max2: 16, tier: 1 },
  { name: 'Cremating', stat: 'Adds # to # Fire Damage', min: 4, max: 6, min2: 8, max2: 12, tier: 2 },
  { name: 'Burning', stat: 'Adds # to # Fire Damage', min: 2, max: 4, min2: 5, max2: 8, tier: 3 },
  // Adds Cold Damage
  { name: 'Glaciated', stat: 'Adds # to # Cold Damage', min: 5, max: 7, min2: 10, max2: 14, tier: 1 },
  { name: 'Polar', stat: 'Adds # to # Cold Damage', min: 3, max: 5, min2: 7, max2: 10, tier: 2 },
  { name: 'Frosted', stat: 'Adds # to # Cold Damage', min: 2, max: 3, min2: 4, max2: 7, tier: 3 },
  // Adds Lightning Damage
  { name: 'Electrocuting', stat: 'Adds # to # Lightning Damage', min: 1, max: 3, min2: 14, max2: 18, tier: 1 },
  { name: 'Discharging', stat: 'Adds # to # Lightning Damage', min: 1, max: 2, min2: 10, max2: 14, tier: 2 },
  { name: 'Sparking', stat: 'Adds # to # Lightning Damage', min: 1, max: 1, min2: 6, max2: 10, tier: 3 },
  // % Physical Damage
  ...Array.from({length: 8}, (_, i) => tieredMod('Tyrannical', '#% increased Physical Damage', LARGE_PCT_TIERS, i+1)),
  // % Elemental Damage
  ...Array.from({length: 8}, (_, i) => tieredMod('Elemental', '#% increased Elemental Damage', LARGE_PCT_TIERS, i+1)),
  // % Global Damage (low values)
  ...Array.from({length: 8}, (_, i) => tieredMod('Ruinous', '#% increased Damage', SMALL_PCT_TIERS, i+1)),
  // % Critical Strike Chance
  ...Array.from({length: 8}, (_, i) => tieredMod('Precise', '#% increased Critical Strike Chance', SMALL_PCT_TIERS, i+1)),
  // % Critical Strike Multiplier
  ...Array.from({length: 8}, (_, i) => tieredMod('Cruel', '+#% to Critical Strike Multiplier', CRIT_MULTI_TIERS, i+1)),
];

// Staff/mage-only prefixes
const WEAPON_PREFIXES_STAFF = [
  // % Spell Damage
  ...Array.from({length: 8}, (_, i) => tieredMod('Infused', '#% increased Spell Damage', LARGE_PCT_TIERS, i+1)),
  // Adds Elemental Damage to Spells
  { name: 'Sorcerous', stat: 'Adds # to # Fire Damage to Spells', min: 4, max: 6, min2: 8, max2: 12, tier: 2 },
  { name: 'Frigid', stat: 'Adds # to # Cold Damage to Spells', min: 3, max: 5, min2: 7, max2: 10, tier: 2 },
  { name: 'Voltaic', stat: 'Adds # to # Lightning Damage to Spells', min: 1, max: 2, min2: 10, max2: 14, tier: 2 },
];

// Skill level prefixes (weapons only)
const WEAPON_PREFIXES_SKILLS = [
  ...Array.from({length: 8}, (_, i) => tieredMod('Warrior\'s', '+# to Level of Strength Skills', SKILL_LEVEL_TIERS, i+1)),
  ...Array.from({length: 8}, (_, i) => tieredMod('Hunter\'s', '+# to Level of Dexterity Skills', SKILL_LEVEL_TIERS, i+1)),
  ...Array.from({length: 8}, (_, i) => tieredMod('Wizard\'s', '+# to Level of Intelligence Skills', SKILL_LEVEL_TIERS, i+1)),
];

// Weapon suffixes
const WEAPON_SUFFIXES = [
  // Attack Speed (Sword, Bow, Quarterstaff only - not Staff)
  ...Array.from({length: 8}, (_, i) => tieredMod('of the Leopard', '#% increased Attack Speed', SMALL_PCT_TIERS, i+1)),
  // Sustain mods
  ...Array.from({length: 8}, (_, i) => tieredMod('of Leeching', '+# Life on Hit', FLAT_TIERS, i+1)),
  ...Array.from({length: 8}, (_, i) => tieredMod('of Siphoning', '+# Mana on Hit', FLAT_TIERS, i+1)),
  ...Array.from({length: 8}, (_, i) => tieredMod('of Slaughter', '+# Life on Kill', FLAT_TIERS, i+1)),
  ...Array.from({length: 8}, (_, i) => tieredMod('of Absorption', '+# Mana on Kill', FLAT_TIERS, i+1)),
  // Attributes
  ...Array.from({length: 8}, (_, i) => tieredMod('of the Titan', '+# to Strength', FLAT_TIERS, i+1)),
  ...Array.from({length: 8}, (_, i) => tieredMod('of the Falcon', '+# to Dexterity', FLAT_TIERS, i+1)),
  ...Array.from({length: 8}, (_, i) => tieredMod('of the Sage', '+# to Intelligence', FLAT_TIERS, i+1)),
];

// Staff-only suffix (Cast Speed instead of Attack Speed)
const WEAPON_SUFFIXES_STAFF = [
  ...Array.from({length: 8}, (_, i) => tieredMod('of Casting', '#% increased Cast Speed', SMALL_PCT_TIERS, i+1)),
];

// ========== RING MODS ==========
const RING_PREFIXES = [
  // Life
  ...Array.from({length: 8}, (_, i) => tieredMod('Hale', '+# to maximum Life', FLAT_TIERS, i+1)),
  // Mana
  ...Array.from({length: 8}, (_, i) => tieredMod('Sapient', '+# to maximum Mana', FLAT_TIERS, i+1)),
  // Adds elemental damage to attacks
  { name: 'Heated', stat: 'Adds # to # Fire Damage to Attacks', min: 2, max: 3, min2: 4, max2: 6, tier: 5 },
  { name: 'Chilled', stat: 'Adds # to # Cold Damage to Attacks', min: 2, max: 3, min2: 4, max2: 5, tier: 5 },
  { name: 'Charged', stat: 'Adds # to # Lightning Damage to Attacks', min: 1, max: 2, min2: 6, max2: 8, tier: 5 },
  // Adds elemental damage to spells
  { name: 'Searing', stat: 'Adds # to # Fire Damage to Spells', min: 2, max: 3, min2: 4, max2: 6, tier: 5 },
  { name: 'Freezing', stat: 'Adds # to # Cold Damage to Spells', min: 2, max: 3, min2: 4, max2: 5, tier: 5 },
  { name: 'Shocking', stat: 'Adds # to # Lightning Damage to Spells', min: 1, max: 2, min2: 6, max2: 8, tier: 5 },
  // % Elemental Damage
  ...Array.from({length: 8}, (_, i) => tieredMod('Elemental', '#% increased Elemental Damage', LARGE_PCT_TIERS, i+1)),
  // % Global Damage (low)
  ...Array.from({length: 8}, (_, i) => tieredMod('Ruinous', '#% increased Damage', SMALL_PCT_TIERS, i+1)),
  // Sustain mods
  ...Array.from({length: 8}, (_, i) => tieredMod('of Leeching', '+# Life on Hit', FLAT_TIERS, i+1)),
  ...Array.from({length: 8}, (_, i) => tieredMod('of Siphoning', '+# Mana on Hit', FLAT_TIERS, i+1)),
  ...Array.from({length: 8}, (_, i) => tieredMod('of Slaughter', '+# Life on Kill', FLAT_TIERS, i+1)),
  ...Array.from({length: 8}, (_, i) => tieredMod('of Absorption', '+# Mana on Kill', FLAT_TIERS, i+1)),
  // % Defense
  ...Array.from({length: 8}, (_, i) => tieredMod('Shielding', '#% increased Armor', LARGE_PCT_TIERS, i+1)),
  ...Array.from({length: 8}, (_, i) => tieredMod('Vaporous', '#% increased Dodge', LARGE_PCT_TIERS, i+1)),
  ...Array.from({length: 8}, (_, i) => tieredMod('Glowing', '#% increased Shield', LARGE_PCT_TIERS, i+1)),
];

const RING_SUFFIXES = [
  // Attributes
  ...Array.from({length: 8}, (_, i) => tieredMod('of the Titan', '+# to Strength', FLAT_TIERS, i+1)),
  ...Array.from({length: 8}, (_, i) => tieredMod('of the Falcon', '+# to Dexterity', FLAT_TIERS, i+1)),
  ...Array.from({length: 8}, (_, i) => tieredMod('of the Sage', '+# to Intelligence', FLAT_TIERS, i+1)),
  ...Array.from({length: 8}, (_, i) => tieredMod('of the Gods', '+# to all Attributes', FLAT_TIERS, i+1)),
  // Resistances
  ...Array.from({length: 8}, (_, i) => tieredMod('of the Salamander', '+#% to Fire Resistance', RESIST_TIERS, i+1)),
  ...Array.from({length: 8}, (_, i) => tieredMod('of the Yeti', '+#% to Cold Resistance', RESIST_TIERS, i+1)),
  ...Array.from({length: 8}, (_, i) => tieredMod('of the Storm', '+#% to Lightning Resistance', RESIST_TIERS, i+1)),
  ...Array.from({length: 8}, (_, i) => tieredMod('of the Grove', '+#% to Nature Resistance', RESIST_TIERS, i+1)),
  // All Resistances (uses amulet/weak table)
  ...Array.from({length: 8}, (_, i) => tieredMod('of the Rainbow', '+#% to all Resistances', AMULET_RESIST_TIERS, i+1)),
  // Crit
  ...Array.from({length: 8}, (_, i) => tieredMod('of Precision', '#% increased Critical Strike Chance', SMALL_PCT_TIERS, i+1)),
  ...Array.from({length: 8}, (_, i) => tieredMod('of Destruction', '+#% to Critical Strike Multiplier', CRIT_MULTI_TIERS, i+1)),
  // Life Regen (Mana Regen REMOVED - mana sustain comes from on-hit, on-kill, leech, potions only)
  ...Array.from({length: 8}, (_, i) => tieredMod('of Regeneration', '+# Life Regeneration per second', REGEN_TIERS, i+1)),
];

// ========== AMULET MODS ==========
const AMULET_PREFIXES = [
  // Life
  ...Array.from({length: 8}, (_, i) => tieredMod('Hale', '+# to maximum Life', FLAT_TIERS, i+1)),
  // Mana
  ...Array.from({length: 8}, (_, i) => tieredMod('Sapient', '+# to maximum Mana', FLAT_TIERS, i+1)),
  // % Elemental Damage
  ...Array.from({length: 8}, (_, i) => tieredMod('Elemental', '#% increased Elemental Damage', LARGE_PCT_TIERS, i+1)),
  // Skill levels (+1 to +4 per spec)
  { name: 'Warrior\'s', stat: '+# to Level of Strength Skills', min: 1, max: 1, tier: 8 },
  { name: 'Veteran\'s', stat: '+# to Level of Strength Skills', min: 2, max: 2, tier: 5 },
  { name: 'Champion\'s', stat: '+# to Level of Strength Skills', min: 3, max: 3, tier: 3 },
  { name: 'Warlord\'s', stat: '+# to Level of Strength Skills', min: 4, max: 4, tier: 1 },
  { name: 'Hunter\'s', stat: '+# to Level of Dexterity Skills', min: 1, max: 1, tier: 8 },
  { name: 'Tracker\'s', stat: '+# to Level of Dexterity Skills', min: 2, max: 2, tier: 5 },
  { name: 'Assassin\'s', stat: '+# to Level of Dexterity Skills', min: 3, max: 3, tier: 3 },
  { name: 'Deadeye\'s', stat: '+# to Level of Dexterity Skills', min: 4, max: 4, tier: 1 },
  { name: 'Wizard\'s', stat: '+# to Level of Intelligence Skills', min: 1, max: 1, tier: 8 },
  { name: 'Arcanist\'s', stat: '+# to Level of Intelligence Skills', min: 2, max: 2, tier: 5 },
  { name: 'Sorcerer\'s', stat: '+# to Level of Intelligence Skills', min: 3, max: 3, tier: 3 },
  { name: 'Archmage\'s', stat: '+# to Level of Intelligence Skills', min: 4, max: 4, tier: 1 },
];

const AMULET_SUFFIXES = [
  // Attributes
  ...Array.from({length: 8}, (_, i) => tieredMod('of the Titan', '+# to Strength', FLAT_TIERS, i+1)),
  ...Array.from({length: 8}, (_, i) => tieredMod('of the Falcon', '+# to Dexterity', FLAT_TIERS, i+1)),
  ...Array.from({length: 8}, (_, i) => tieredMod('of the Sage', '+# to Intelligence', FLAT_TIERS, i+1)),
  // Resistances (amulet tiers - lower values)
  ...Array.from({length: 8}, (_, i) => tieredMod('of the Salamander', '+#% to Fire Resistance', AMULET_RESIST_TIERS, i+1)),
  ...Array.from({length: 8}, (_, i) => tieredMod('of the Yeti', '+#% to Cold Resistance', AMULET_RESIST_TIERS, i+1)),
  ...Array.from({length: 8}, (_, i) => tieredMod('of the Storm', '+#% to Lightning Resistance', AMULET_RESIST_TIERS, i+1)),
  ...Array.from({length: 8}, (_, i) => tieredMod('of the Grove', '+#% to Nature Resistance', AMULET_RESIST_TIERS, i+1)),
  // Crit
  ...Array.from({length: 8}, (_, i) => tieredMod('of Precision', '#% increased Critical Strike Chance', SMALL_PCT_TIERS, i+1)),
  ...Array.from({length: 8}, (_, i) => tieredMod('of Destruction', '+#% to Critical Strike Multiplier', CRIT_MULTI_TIERS, i+1)),
  // Sustain mods
  ...Array.from({length: 8}, (_, i) => tieredMod('of Leeching', '+# Life on Hit', FLAT_TIERS, i+1)),
  ...Array.from({length: 8}, (_, i) => tieredMod('of Siphoning', '+# Mana on Hit', FLAT_TIERS, i+1)),
  ...Array.from({length: 8}, (_, i) => tieredMod('of Slaughter', '+# Life on Kill', FLAT_TIERS, i+1)),
  ...Array.from({length: 8}, (_, i) => tieredMod('of Absorption', '+# Mana on Kill', FLAT_TIERS, i+1)),
];

// ========== SLOT MODIFIER POOLS ==========
const SLOT_MODS = {
  helmet: { prefixes: HELMET_PREFIXES, suffixes: HELMET_SUFFIXES },
  gloves: { prefixes: GLOVES_PREFIXES, suffixes: GLOVES_SUFFIXES },
  boots: { prefixes: BOOTS_PREFIXES, suffixes: BOOTS_SUFFIXES },
  body: { prefixes: BODY_PREFIXES, suffixes: BODY_SUFFIXES },
  weapon: { prefixes: WEAPON_PREFIXES_ALL, suffixes: WEAPON_SUFFIXES },
  ring: { prefixes: RING_PREFIXES, suffixes: RING_SUFFIXES },
  amulet: { prefixes: AMULET_PREFIXES, suffixes: AMULET_SUFFIXES },
};

// ========== IMPLICIT MODS BY ITEM TYPE ==========
const IMPLICIT_MODS = {
  // Ring implicits - IDENTITY-BASED (ring base determines implicit)
  // Each ring type has a unique, thematic implicit - ALWAYS rolls
  nature_ring: [{ stat: '+#% to Nature Resistance', min: 5, max: 10 }],
  vitality_ring: [{ stat: '+# to maximum Life', min: 20, max: 35 }],
  arcane_ring: [{ stat: '+# to maximum Mana', min: 20, max: 30 }],
  flame_ring: [{ stat: '+#% to Fire Resistance', min: 5, max: 10 }],
  frost_ring: [{ stat: '+#% to Cold Resistance', min: 5, max: 10 }],
  storm_ring: [{ stat: '+#% to Lightning Resistance', min: 5, max: 10 }],
  prismatic_ring: [{ stat: '+#% to all Elemental Resistances', min: 3, max: 5 }],
  // Default ring (fallback)
  ring: [{ stat: '+# to maximum Life', min: 10, max: 15 }],
  
  // Amulet implicits - IDENTITY-BASED (amulet base determines implicit)
  // Each amulet type has ONE fixed implicit - ALWAYS rolls
  might_amulet: [{ stat: '+# to Strength', min: 10, max: 15 }],
  grace_amulet: [{ stat: '+# to Dexterity', min: 10, max: 15 }],
  wisdom_amulet: [{ stat: '+# to Intelligence', min: 10, max: 15 }],
  harmony_amulet: [{ stat: '+# to all Attributes', min: 5, max: 8 }],
  // Default amulet (fallback)
  amulet: [{ stat: '+# to all Attributes', min: 3, max: 5 }],
  
  // Weapon implicits (8 types - 2 per class)
  // Sword type (STR) - Viper Blade vs War Blade
  viper_blade: [{ stat: '#% increased Attack Speed', min: 5, max: 10 }],
  war_blade: [{ stat: '#% increased Physical Damage', min: 5, max: 10 }],
  // Quarterstaff type (STR/DEX) - Windspire vs Ironbark
  windspire_quarterstaff: [{ stat: '#% increased Attack Speed', min: 5, max: 10 }],
  ironbark_quarterstaff: [{ stat: '#% increased Critical Strike Chance', min: 8, max: 12 }],
  // Bow type (DEX) - Windrunner vs Ironwood
  windrunner_bow: [{ stat: '#% increased Attack Speed', min: 5, max: 10 }],
  ironwood_bow: [{ stat: '#% increased Projectile Damage', min: 10, max: 15 }],
  // Staff type (INT) - Mystic vs Elder
  mystic_staff: [{ stat: '#% increased Cast Speed', min: 5, max: 10 }],
  elder_staff: [{ stat: '#% increased Spell Damage', min: 12, max: 18 }],
  // ARMOR HAS NO IMPLICITS - Base defense IS the identity
  // "Base = what the item IS, Implicit = what the item DOES" - they must never be the same
  // Armor pieces get: Base defense from ilvl + Prefixes + Suffixes only
};

// ARMOR IMPLICIT RULES (FINAL):
// - Armor pieces have NO implicits - base defense IS the identity
// - Base = what the item IS (Armor/Dodge/Shield from ilvl)
// - Implicit = what the item DOES (must be different from base)
// - Movement Speed on boots is a SUFFIX AFFIX (competes with other mods)

// Get slot type from item name
function getItemSlot(name) {
  // Weapons (8 types: 2 per class)
  if (/Blade|Quarterstaff|Bow|Staff/i.test(name)) return 'weapon';
  // Helmet
  if (/Helm|Hood|Cap|Crown|Circlet|Mask|Casque|Burgonet|Bascinet|Hat/i.test(name)) return 'helmet';
  // Gloves - check BEFORE body (to avoid 'Plate Gauntlets' matching body)
  if (/Gloves|Gauntlets|Mitts|Mittens|Grips|Wraps|Bracers/i.test(name)) return 'gloves';
  // Boots - check BEFORE body (to avoid 'Plate Greaves' matching body)
  if (/Boots|Greaves|Shoes|Slippers|Sabaton|Treads/i.test(name)) return 'boots';
  // Body armor
  if (/Robe|Vest|Shirt|Mail|Armor|Regalia|Garb|Coat|Jacket|Brigandine|Tunic/i.test(name)) return 'body';
  // Rings
  if (/Ring/i.test(name)) return 'ring';
  // Amulets
  if (/Amulet|Talisman|Pendant|Choker/i.test(name)) return 'amulet';
  // Flasks (not equippable, but valid items)
  if (/Flask/i.test(name)) return 'flask';
  // Jewels (not equippable in standard slots)
  if (/Jewel/i.test(name)) return 'jewel';
  // NO DEFAULT - unmatched items return null
  console.warn('getItemSlot: Unmatched item name: ' + name);
  return null;
}

function getImplicitCategory(name) {
  // Identity-based ring implicits
  if (name.includes('Ring')) {
    const ringName = name.toLowerCase();
    if (ringName.includes('nature')) return 'nature_ring';
    if (ringName.includes('vitality')) return 'vitality_ring';
    if (ringName.includes('arcane')) return 'arcane_ring';
    if (ringName.includes('flame')) return 'flame_ring';
    if (ringName.includes('frost')) return 'frost_ring';
    if (ringName.includes('storm')) return 'storm_ring';
    if (ringName.includes('prismatic')) return 'prismatic_ring';
    return 'ring'; // fallback
  }
  if (name.includes('Amulet') || name.includes('Talisman')) {
    const amuletName = name.toLowerCase();
    if (amuletName.includes('might')) return 'might_amulet';
    if (amuletName.includes('grace')) return 'grace_amulet';
    if (amuletName.includes('wisdom')) return 'wisdom_amulet';
    if (amuletName.includes('harmony')) return 'harmony_amulet';
    return 'amulet'; // fallback
  }
  
  // Weapon types - use getWeaponType for consistency
  const slot = getItemSlot(name);
  if (slot === 'weapon') {
    return getWeaponType(name);
  }
  
  // ARMOR HAS NO IMPLICITS - base defense IS the identity
  // Return null for helmet, gloves, boots, body
  if (['helmet', 'gloves', 'boots', 'body'].includes(slot)) {
    return null;
  }
  
  return null;
}

// Generate random modifier from slot-specific pool
function generateMod(isPrefix, slot, itemName, ilvl = 1) {
  // Handle null/undefined slot explicitly
  if (!slot || !SLOT_MODS[slot]) {
    console.warn('generateMod: Invalid slot "' + slot + '" for item "' + itemName + '"');
    return null;
  }
  let pool = SLOT_MODS[slot];
  let mods = isPrefix ? [...pool.prefixes] : [...pool.suffixes];
  
  // Add weapon-type specific mods and filter by weapon identity
  if (slot === 'weapon') {
    const wepType = getWeaponType(itemName);
    const isSpell = isSpellWeapon(itemName);
    
    // Spell weapons (staff only): Add spell mods, remove attack mods
    if (isSpell) {
      if (isPrefix) {
        mods = [...mods, ...WEAPON_PREFIXES_STAFF];
        // Remove physical damage mods from spell weapons
        mods = mods.filter(m => {
          const stat = m.stat || '';
          if (stat.includes('Physical Damage') && !stat.includes('to Spells')) return false;
          if (stat.includes('Projectile Damage')) return false;
          return true;
        });
      } else {
        // Remove Attack Speed, add Cast Speed
        mods = mods.filter(m => !m.stat.includes('Attack Speed'));
        mods = [...mods, ...WEAPON_SUFFIXES_STAFF];
      }
    } else {
      // Attack weapons: Remove spell mods
      mods = mods.filter(m => {
        const stat = m.stat || '';
        if (stat.includes('Spell Damage')) return false;
        if (stat.includes('to Spells')) return false;
        if (stat.includes('Cast Speed')) return false;
        return true;
      });
    }
    
    // All weapons can roll skill level mods
    if (isPrefix) mods = [...mods, ...WEAPON_PREFIXES_SKILLS];
  }
  
  // Add physical damage to attacks for STR/DEX gloves
  if (slot === 'gloves' && isPrefix) {
    const baseType = getArmorBaseType(itemName);
    if (['str', 'dex', 'str_dex'].includes(baseType)) {
      mods = [...mods, GLOVES_PHYS_PREFIX];
    }
  }
  
  // Filter defense mods by base type - can only enhance existing defenses, not add new ones
  // NOTE: Body armor is EXEMPT - it keeps special hybrid/behavior mods regardless of base type
  if (['helmet', 'gloves', 'boots'].includes(slot)) {
    const baseType = getArmorBaseType(itemName);
    mods = mods.filter(m => {
      const stat = m.stat || '';
      const isArmorMod = stat.includes('Armor') || stat.includes('Armor');
      const isDodgeMod = stat.includes('Dodge');
      const isShieldMod = stat.includes('Shield') && !stat.includes('Shield Wall'); // Don't filter Shield Wall skill
      
      // If not a defense mod, allow it (Life, Mana, Attributes, Resistances, utility all pass through)
      if (!isArmorMod && !isDodgeMod && !isShieldMod) return true;
      
      // Filter based on base type
      if (baseType === 'str') {
        return isArmorMod; // STR bases only get Armor mods
      } else if (baseType === 'dex') {
        return isDodgeMod; // DEX bases only get Dodge mods
      } else if (baseType === 'int') {
        return isShieldMod; // INT bases only get Shield mods
      } else if (baseType === 'str_dex') {
        return isArmorMod || isDodgeMod; // Hybrid: Armor + Dodge
      } else if (baseType === 'str_int') {
        return isArmorMod || isShieldMod; // Hybrid: Armor + Shield
      } else if (baseType === 'dex_int') {
        return isDodgeMod || isShieldMod; // Hybrid: Dodge + Shield
      }
      return true;
    });
  }
  
  // Filter by tier availability based on item level
  const minTier = getMinTierForItemLevel(ilvl);
  mods = mods.filter(m => m.tier >= minTier);
  
  if (mods.length === 0) mods = isPrefix ? pool.prefixes : pool.suffixes;
  
  const mod = mods[Math.floor(Math.random() * mods.length)];
  const value1 = Math.floor(Math.random() * (mod.max - mod.min + 1)) + mod.min;
  let value2 = null;
  if (mod.min2 !== undefined) {
    value2 = Math.floor(Math.random() * (mod.max2 - mod.min2 + 1)) + mod.min2;
  }
  return {
    ...mod,
    value1,
    value2,
    text: mod.stat.replace('#', value1).replace('#', value2 || '')
  };
}

// Generate a mod that doesn't duplicate existing mods on an item
function generateUniqueModForItem(isPrefix, slot, itemName, ilvl, existingMods) {
  // Build set of existing mod base stats
  const usedStats = new Set();
  if (existingMods) {
    if (existingMods.prefixes) {
      existingMods.prefixes.forEach(m => {
        if (m.stat) usedStats.add(m.stat.replace(/#/g, '').trim());
      });
    }
    if (existingMods.suffixes) {
      existingMods.suffixes.forEach(m => {
        if (m.stat) usedStats.add(m.stat.replace(/#/g, '').trim());
      });
    }
  }
  
  // Try to generate a unique mod
  let attempts = 0;
  while (attempts < 20) {
    const mod = generateMod(isPrefix, slot, itemName, ilvl);
    const baseStat = mod.stat.replace(/#/g, '').trim();
    if (!usedStats.has(baseStat)) {
      return mod;
    }
    attempts++;
  }
  // Fallback - return any mod if we can't find unique one
  return generateMod(isPrefix, slot, itemName, ilvl);
}

// Generate implicit
function generateImplicit(itemName) {
  const category = getImplicitCategory(itemName);
  
  // No implicit for armor pieces or unknown categories
  if (!category) return null;
  
  // Get pool for this category
  let pool = IMPLICIT_MODS[category];
  if (!pool) return null;
  
  // If pool is an array of stats, pick randomly
  if (Array.isArray(pool) && pool.length > 0) {
    const mod = pool[Math.floor(Math.random() * pool.length)];
    const value1 = Math.floor(Math.random() * (mod.max - mod.min + 1)) + mod.min;
    return { ...mod, value1, text: mod.stat.replace('#', value1) };
  }
  
  return null;
}

// ============ SOCKET SYSTEM (LOCKED) ============
// Max sockets per slot (before corruption):
// Weapon: 2, Chest: 2, Helmet/Gloves/Boots: 1, Jewelry: 0 (NEVER)
// Uncontrolled Core can add +1 socket above max (not on jewelry)
const SOCKET_LIMITS = {
  weapon: 2,
  body: 2,
  helmet: 1,
  gloves: 1,
  boots: 1,
  amulet: 0,  // NEVER gets sockets
  ring: 0     // NEVER gets sockets
};

function canHaveSockets(itemName) {
  const slot = getItemSlot(itemName);
  return SOCKET_LIMITS[slot] > 0;
}

function getMaxSockets(itemName, isImmutable = false) {
  const slot = getItemSlot(itemName);
  const base = SOCKET_LIMITS[slot] || 0;
  // Jewelry (rings/amulets) can NEVER have sockets, even via corruption
  if (base === 0) return 0;
  // Uncontrolled Core can add +1 socket above normal max (capped at 3)
  return isImmutable ? Math.min(base + 1, 3) : base;
}

function getRandomSocketColor() {
  const colors = ['red', 'green', 'blue'];
  return colors[Math.floor(Math.random() * colors.length)];
}

// ============ SUPPORT GEM SYSTEM (LOCKED) ============
// Only these 5 gems exist. No life/mana/leech/CDR/all-res gems.
// Quality: 0-100%, doubles effect at 100% (linear scaling)
// Gems ALWAYS drop at 0% quality - only Prism adds quality (+5% per use)
// If any gem becomes "mandatory", its numbers are too high.
const GEM_DATA = {
  // Base values are intentionally low - quality makes them powerful
  'gem-haste': { 
    name: 'Haste Gem', 
    icon: '🟢', 
    bonus: { stat: 'atkSpd', value: 3, armorStat: 'dodge', armorValue: 3 }, 
    desc: '+3% Atk Spd/Dodge', 
    tip: '⚔️ Weapons: +3% Attack Speed | 🛡️ Armor: +3% Dodge' 
  },
  'gem-iron': { 
    name: 'Iron Gem', 
    icon: '⚫', 
    bonus: { stat: 'physDmgPct', value: 7, armorStat: 'armorPct', armorValue: 6 }, 
    desc: '+7% Phys/+6% Armor', 
    tip: '⚔️ Weapons: +7% Physical Damage | 🛡️ Armor: +6% Armor' 
  },
  'gem-flame': { 
    name: 'Flame Gem', 
    icon: '🔴', 
    bonus: { stat: 'fireDmg', value: [2, 4], armorStat: 'fireRes', armorValue: 6 }, 
    desc: 'Fire Dmg/Res', 
    tip: '⚔️ Weapons: Adds 2-4 Fire Damage | 🛡️ Armor: +6% Fire Resist' 
  },
  'gem-frost': { 
    name: 'Frost Gem', 
    icon: '🔵', 
    bonus: { stat: 'coldDmg', value: [2, 4], armorStat: 'coldRes', armorValue: 6 }, 
    desc: 'Cold Dmg/Res', 
    tip: '⚔️ Weapons: Adds 2-4 Cold Damage | 🛡️ Armor: +6% Cold Resist' 
  },
  'gem-storm': { 
    name: 'Storm Gem', 
    icon: '🟡', 
    bonus: { stat: 'lightDmg', value: [2, 4], armorStat: 'lightRes', armorValue: 6 }, 
    desc: 'Light Dmg/Res', 
    tip: '⚔️ Weapons: Adds 2-4 Lightning Damage | 🛡️ Armor: +6% Lightning Resist' 
  }
};

// Gem inventory - stores gems with their quality
// Format: { gemId: { quality: 0-100 } }
let gemInventory = [];

function addGemToInventory(gemId, quality = 0) {
  gemInventory.push({ id: gemId, quality: quality || 0 });
  addLog(`Obtained ${GEM_DATA[gemId].name}${quality > 0 ? ` (${quality}% quality)` : ''}`, 'loot');
}

function removeGemFromInventory(index) {
  if (index >= 0 && index < gemInventory.length) {
    return gemInventory.splice(index, 1)[0];
  }
  return null;
}

// Calculate gem bonus with quality (quality doubles the effect at 100%)
function getGemBonusWithQuality(gemId, quality, isWeapon) {
  const gem = GEM_DATA[gemId];
  if (!gem) return null;
  
  const qualityMult = 1 + (quality / 100); // 0% = 1x, 100% = 2x
  
  if (isWeapon) {
    const baseValue = gem.bonus.value;
    if (Array.isArray(baseValue)) {
      return {
        stat: gem.bonus.stat,
        value: [Math.round(baseValue[0] * qualityMult), Math.round(baseValue[1] * qualityMult)]
      };
    }
    return {
      stat: gem.bonus.stat,
      value: Math.round(baseValue * qualityMult * 10) / 10
    };
  } else {
    return {
      stat: gem.bonus.armorStat,
      value: Math.round(gem.bonus.armorValue * qualityMult * 10) / 10
    };
  }
}

// Gemcutter's Prism - ALWAYS adds exactly +5% quality (LOCKED)
// This is the ONLY way gems gain quality - gems never drop with quality
function useGemcuttersPrism(gemIndex) {
  if (gemIndex < 0 || gemIndex >= gemInventory.length) return false;
  
  const prismCount = player.currency?.gemcuttersPrism || 0;
  if (prismCount <= 0) {
    showToast('❌', 'No Prisms', 'You need a Gemcutter\'s Prism', 'warning');
    return false;
  }
  
  const gem = gemInventory[gemIndex];
  if (gem.quality >= 100) {
    showToast('❌', 'Max Quality', 'This gem is already at 100% quality', 'warning');
    return false;
  }
  
  // LOCKED: Always adds exactly +5% quality
  const qualityGain = 5;
  gem.quality = Math.min(100, gem.quality + qualityGain);
  
  player.currency.gemcuttersPrism--;
  
  showToast('💎', 'Gem Improved!', `+${qualityGain}% quality (now ${gem.quality}%)`, 'info');
  addLog(`Used Gemcutter's Prism: ${GEM_DATA[gem.id].name} now ${gem.quality}% quality`, 'craft');
  
  return true;
}

// Skill Gems - T1-T5 tiers with MODEST scaling (20% total T1→T5)
// Tiers improve reliability and modestly boost damage - NOT double it
// Each skill has a 'band' property for validation
const SKILL_GEM_DATA = {
  // ============ PRIMARY SKILLS (Band: PRIMARY, 0.8x-1.2x) ============
  'fistsOfThunderPrimary': { name: 'Fists of Thunder', icon: '⚡', desc: 'Lightning punches with dash, every 3rd hit chains', band: 'PRIMARY', baseDmg: 0.9, hits: 1, tiers: { 1: 1.0, 2: 1.03, 3: 1.06, 4: 1.10, 5: 1.15 } },
  'wayOfTheGlacier': { name: 'Way of the Glacier', icon: '❄️', desc: 'Cold strikes with freeze chance, 3rd hit freezing nova', band: 'PRIMARY', baseDmg: 0.85, hits: 1, tiers: { 1: 1.0, 2: 1.03, 3: 1.06, 4: 1.10, 5: 1.15 } },
  'blazingFists': { name: 'Blazing Fists', icon: '🔥', desc: 'Fire punches, 3rd hit ignites in AoE', band: 'PRIMARY', baseDmg: 0.95, hits: 1, tiers: { 1: 1.0, 2: 1.03, 3: 1.06, 4: 1.10, 5: 1.15 } },
  'jadeWindStrike': { name: 'Jade Wind Strike', icon: '🌿', desc: 'Nature strikes that heal on hit', band: 'PRIMARY', baseDmg: 0.85, hits: 1, tiers: { 1: 1.0, 2: 1.03, 3: 1.06, 4: 1.10, 5: 1.15 } },
  'basicSlash': { name: 'Basic Slash', icon: '⚔️', desc: 'Simple sword slash (No Mana)', band: 'PRIMARY', baseDmg: 1.0, hits: 1, tiers: { 1: 1.0, 2: 1.03, 3: 1.06, 4: 1.10, 5: 1.15 } },
  'magicMissile': { name: 'Magic Missile', icon: '🔮', desc: 'Force bolt, 3rd fires extra', band: 'PRIMARY', baseDmg: 0.9, hits: 1, tiers: { 1: 1.0, 2: 1.03, 3: 1.06, 4: 1.10, 5: 1.15 } },
  'electrocute': { name: 'Electrocute', icon: '⚡', desc: 'Lightning chains to 2 enemies', band: 'PRIMARY', baseDmg: 0.7, hits: 3, tiers: { 1: 1.0, 2: 1.03, 3: 1.06, 4: 1.10, 5: 1.15 } },
  
  // ============ MONK SKILLS (D3-Converted) ============
  'blindingFlash': { name: 'Blinding Flash', icon: '✨', desc: 'Blind enemies + gain dodge', band: 'UTILITY', baseDmg: 0, hits: 0, tiers: { 1: 1.0, 2: 1.03, 3: 1.06, 4: 1.10, 5: 1.15 } },
  'breathOfHeaven': { name: 'Breath of Heaven', icon: '💨', desc: 'Instant heal 30% + speed buffs', band: 'UTILITY', baseDmg: 0, hits: 0, tiers: { 1: 1.0, 2: 1.03, 3: 1.06, 4: 1.10, 5: 1.15 } },
  'waveOfLight': { name: 'Wave of Light', icon: '🔔', desc: 'Line nuke (3.5x + 1.5x crush)', band: 'ULTIMATE', baseDmg: 3.5, hits: 1, tiers: { 1: 1.0, 2: 1.03, 3: 1.06, 4: 1.10, 5: 1.15 } },
  'explodingPalm': { name: 'Exploding Palm', icon: '💥', desc: 'DoT + explosion on death (3.0x)', band: 'ULTIMATE', baseDmg: 1.8, hits: 1, tiers: { 1: 1.0, 2: 1.03, 3: 1.06, 4: 1.10, 5: 1.15 } },
  'cycloneStrike': { name: 'Cyclone Strike', icon: '🌪️', desc: 'Pull enemies + AoE burst (2.0x)', band: 'CORE_ACTIVE', baseDmg: 2.0, hits: 1, tiers: { 1: 1.0, 2: 1.03, 3: 1.06, 4: 1.10, 5: 1.15 } },
  'sevenSidedStrike': { name: 'Seven-Sided Strike', icon: '⚔️', desc: 'Teleport 7 strikes, invulnerable (7.0x)', band: 'ULTIMATE', baseDmg: 1.0, hits: 7, tiers: { 1: 1.0, 2: 1.03, 3: 1.06, 4: 1.10, 5: 1.15 } },
  'innerSanctuary': { name: 'Inner Sanctuary', icon: '🛡️', desc: '50% DR zone + 3% heal/sec', band: 'UTILITY', baseDmg: 0, hits: 0, tiers: { 1: 1.0, 2: 1.03, 3: 1.06, 4: 1.10, 5: 1.15 } },
  
  // ============ PASSIVE SKILLS (Class-Specific) ============
  // MONK
  'monkPower': { name: 'Monk Power', icon: '⚔️', desc: 'PASSIVE: +5% Damage', band: 'PASSIVE', baseDmg: 0, hits: 0, tiers: { 1: 1.0, 2: 1.0, 3: 1.0, 4: 1.0, 5: 1.0 }, isPassive: true },
  'monkVitality': { name: 'Monk Vitality', icon: '❤️', desc: 'PASSIVE: +5% Max HP', band: 'PASSIVE', baseDmg: 0, hits: 0, tiers: { 1: 1.0, 2: 1.0, 3: 1.0, 4: 1.0, 5: 1.0 }, isPassive: true },
  'monkResistance': { name: 'Monk Resistance', icon: '🛡️', desc: 'PASSIVE: +5% All Resist', band: 'PASSIVE', baseDmg: 0, hits: 0, tiers: { 1: 1.0, 2: 1.0, 3: 1.0, 4: 1.0, 5: 1.0 }, isPassive: true },
  // WARRIOR
  'warriorPower': { name: 'Warrior Power', icon: '⚔️', desc: 'PASSIVE: +5% Damage', band: 'PASSIVE', baseDmg: 0, hits: 0, tiers: { 1: 1.0, 2: 1.0, 3: 1.0, 4: 1.0, 5: 1.0 }, isPassive: true },
  'warriorVitality': { name: 'Warrior Vitality', icon: '❤️', desc: 'PASSIVE: +5% Max HP', band: 'PASSIVE', baseDmg: 0, hits: 0, tiers: { 1: 1.0, 2: 1.0, 3: 1.0, 4: 1.0, 5: 1.0 }, isPassive: true },
  'warriorResistance': { name: 'Warrior Resistance', icon: '🛡️', desc: 'PASSIVE: +5% All Resist', band: 'PASSIVE', baseDmg: 0, hits: 0, tiers: { 1: 1.0, 2: 1.0, 3: 1.0, 4: 1.0, 5: 1.0 }, isPassive: true },
  // RANGER
  'rangerPower': { name: 'Ranger Power', icon: '⚔️', desc: 'PASSIVE: +5% Damage', band: 'PASSIVE', baseDmg: 0, hits: 0, tiers: { 1: 1.0, 2: 1.0, 3: 1.0, 4: 1.0, 5: 1.0 }, isPassive: true },
  'rangerVitality': { name: 'Ranger Vitality', icon: '❤️', desc: 'PASSIVE: +5% Max HP', band: 'PASSIVE', baseDmg: 0, hits: 0, tiers: { 1: 1.0, 2: 1.0, 3: 1.0, 4: 1.0, 5: 1.0 }, isPassive: true },
  'rangerResistance': { name: 'Ranger Resistance', icon: '🛡️', desc: 'PASSIVE: +5% All Resist', band: 'PASSIVE', baseDmg: 0, hits: 0, tiers: { 1: 1.0, 2: 1.0, 3: 1.0, 4: 1.0, 5: 1.0 }, isPassive: true },
  // MAGE
  'magePower': { name: 'Mage Power', icon: '⚔️', desc: 'PASSIVE: +5% Damage', band: 'PASSIVE', baseDmg: 0, hits: 0, tiers: { 1: 1.0, 2: 1.0, 3: 1.0, 4: 1.0, 5: 1.0 }, isPassive: true },
  'mageVitality': { name: 'Mage Vitality', icon: '❤️', desc: 'PASSIVE: +5% Max HP', band: 'PASSIVE', baseDmg: 0, hits: 0, tiers: { 1: 1.0, 2: 1.0, 3: 1.0, 4: 1.0, 5: 1.0 }, isPassive: true },
  'mageResistance': { name: 'Mage Resistance', icon: '🛡️', desc: 'PASSIVE: +5% All Resist', band: 'PASSIVE', baseDmg: 0, hits: 0, tiers: { 1: 1.0, 2: 1.0, 3: 1.0, 4: 1.0, 5: 1.0 }, isPassive: true },
  
  // ============ MAGE SKILLS (D3/D4-Converted) ============
  'frostNova': { name: 'Frost Nova', icon: '❄️', desc: 'Freeze enemies, bosses slowed', band: 'CORE_ACTIVE', baseDmg: 1.2, hits: 1, tiers: { 1: 1.0, 2: 1.03, 3: 1.06, 4: 1.10, 5: 1.15 } },
  'chaosOrb': { name: 'Chaos Orb', icon: '🌀', desc: 'Slow orb explodes for 2.4x', band: 'CORE_ACTIVE', baseDmg: 2.4, hits: 1, tiers: { 1: 1.0, 2: 1.03, 3: 1.06, 4: 1.10, 5: 1.15 } },
  'blizzard': { name: 'Blizzard', icon: '🌨️', desc: 'Cold DoT 3.0x over 4s', band: 'ULTIMATE', baseDmg: 3.0, hits: 8, tiers: { 1: 1.0, 2: 1.03, 3: 1.06, 4: 1.10, 5: 1.15 } },
  'meteor': { name: 'Meteor', icon: '☄️', desc: 'Delayed 4.0x + 1.5x burn', band: 'ULTIMATE', baseDmg: 4.0, hits: 1, tiers: { 1: 1.0, 2: 1.03, 3: 1.06, 4: 1.10, 5: 1.15 } },
  'energyArmor': { name: 'Energy Armor', icon: '💠', desc: '+30% Shield, 15% DR for 6s', band: 'UTILITY', baseDmg: 0, hits: 0, tiers: { 1: 1.0, 2: 1.03, 3: 1.06, 4: 1.10, 5: 1.15 } },
  
  // ============ RANGER SKILLS ============
  'hungryArrow': { name: 'Hungry Arrow', icon: '🏹', desc: 'Seeking arrow, 35% pierce chance', band: 'PRIMARY', baseDmg: 0.9, hits: 1, tiers: { 1: 1.0, 2: 1.03, 3: 1.06, 4: 1.10, 5: 1.15 } },
  'chakram': { name: 'Chakram', icon: '💫', desc: 'Returning disc, 180% damage', band: 'CORE_ACTIVE', baseDmg: 1.8, hits: 2, tiers: { 1: 1.0, 2: 1.03, 3: 1.06, 4: 1.10, 5: 1.15 } },
  'caltrops': { name: 'Caltrops', icon: '🔺', desc: 'Ground trap, 50%/sec + 40% slow', band: 'UTILITY', baseDmg: 0.5, hits: 0, tiers: { 1: 1.0, 2: 1.03, 3: 1.06, 4: 1.10, 5: 1.15 } },
  'markedForDeath': { name: 'Marked for Death', icon: '💀', desc: 'Target takes +25% damage for 8s', band: 'UTILITY', baseDmg: 0, hits: 0, tiers: { 1: 1.0, 2: 1.03, 3: 1.06, 4: 1.10, 5: 1.15 } },
  'multiShot': { name: 'Multishot', icon: '🏹', desc: '5 arrows spread, 2.8x total', band: 'CORE_ACTIVE', baseDmg: 2.8, hits: 1, tiers: { 1: 1.0, 2: 1.03, 3: 1.06, 4: 1.10, 5: 1.15 } },
  'sentry': { name: 'Sentry', icon: '🗼', desc: 'Deploy ballista (max 2)', band: 'UTILITY', baseDmg: 0.9, hits: 1, tiers: { 1: 1.0, 2: 1.03, 3: 1.06, 4: 1.10, 5: 1.15 } },
  'rainOfArrows': { name: 'Rain of Arrows', icon: '🌧️', desc: '4.2x over 4s + bleed', band: 'ULTIMATE', baseDmg: 4.2, hits: 1, tiers: { 1: 1.0, 2: 1.03, 3: 1.06, 4: 1.10, 5: 1.15 } },
  
  // ============ WARRIOR SKILLS ============
  'shieldBash': { name: 'Shield Bash', icon: '🛡️', desc: 'Bash enemies with shield', band: 'CORE_ACTIVE', baseDmg: 1.5, hits: 1, tiers: { 1: 1.0, 2: 1.03, 3: 1.06, 4: 1.10, 5: 1.15 } },
  'cleave': { name: 'Cleave', icon: '⚔️', desc: 'Wide sweeping sword attack', band: 'CORE_ACTIVE', baseDmg: 1.8, hits: 1, tiers: { 1: 1.0, 2: 1.03, 3: 1.06, 4: 1.10, 5: 1.15 } },
  'groundSlam': { name: 'Ground Slam', icon: '💥', desc: 'Slam ground damaging nearby', band: 'CORE_ACTIVE', baseDmg: 2.15, hits: 1, tiers: { 1: 1.0, 2: 1.03, 3: 1.06, 4: 1.10, 5: 1.15 } },
  'charge': { name: 'Charge', icon: '🏃', desc: 'Charge forward damaging foes', band: 'CORE_ACTIVE', baseDmg: 2.0, hits: 1, tiers: { 1: 1.0, 2: 1.03, 3: 1.06, 4: 1.10, 5: 1.15 } },
  'warCry': { name: 'War Cry', icon: '📢', desc: 'Boost damage by 25%', band: 'UTILITY', baseDmg: 0, hits: 0, tiers: { 1: 1.0, 2: 1.03, 3: 1.06, 4: 1.10, 5: 1.15 } },
  'shieldWall': { name: 'Shield Wall', icon: '🏰', desc: 'Reduce damage by 70% for 3s', band: 'UTILITY', baseDmg: 0, hits: 0, tiers: { 1: 1.0, 2: 1.03, 3: 1.06, 4: 1.10, 5: 1.15 } },
  'execute': { name: 'Execute', icon: '💀', desc: 'Powerful finisher attack', band: 'ULTIMATE', baseDmg: 3.0, hits: 1, tiers: { 1: 1.0, 2: 1.03, 3: 1.06, 4: 1.10, 5: 1.15 } },
  'whirlwind': { name: 'Whirlwind', icon: '🌀', desc: 'Spin with sword hitting all', band: 'CORE_ACTIVE', baseDmg: 1.0, hits: 1, tiers: { 1: 1.0, 2: 1.03, 3: 1.06, 4: 1.10, 5: 1.15 } },
  'revenge': { name: 'Revenge', icon: '💢', desc: 'Counter-attack nearby enemies', band: 'CORE_ACTIVE', baseDmg: 2.2, hits: 1, tiers: { 1: 1.0, 2: 1.03, 3: 1.06, 4: 1.10, 5: 1.15 } },
  'earthquake': { name: 'Earthquake', icon: '🌋', desc: 'Massive quake in 3 waves', band: 'ULTIMATE', baseDmg: 1.1, hits: 3, tiers: { 1: 1.0, 2: 1.03, 3: 1.06, 4: 1.10, 5: 1.15 } }
};

// Validate all skills on load
function validateAllSkillBands() {
  console.log('🎯 Validating skill damage bands...');
  let violations = 0;
  
  for (const [skillId, data] of Object.entries(SKILL_GEM_DATA)) {
    if (data.band === 'UTILITY') continue; // Skip utility skills
    
    const effectiveDamage = data.baseDmg * (data.hits || 1);
    const maxTierDamage = effectiveDamage * data.tiers[5];
    const bandLimits = DAMAGE_BANDS[data.band];
    
    if (!bandLimits) {
      console.warn(`⚠️ Unknown band "${data.band}" for skill ${skillId}`);
      continue;
    }
    
    if (maxTierDamage > bandLimits.max * 1.1) { // 10% tolerance
      console.warn(`❌ BAND VIOLATION: ${skillId} (${data.band})`);
      console.warn(`   Base: ${data.baseDmg}x × ${data.hits} hits = ${effectiveDamage.toFixed(2)}x effective`);
      console.warn(`   At T5: ${maxTierDamage.toFixed(2)}x exceeds ${data.band} max of ${bandLimits.max}x`);
      violations++;
    } else {
      console.log(`✅ ${skillId}: ${effectiveDamage.toFixed(2)}x → T5: ${maxTierDamage.toFixed(2)}x (${data.band})`);
    }
  }
  
  if (violations === 0) {
    console.log('✅ All skills within damage bands!');
  } else {
    console.warn(`⚠️ ${violations} skill(s) exceed damage bands!`);
  }
  
  return violations === 0;
}

// Class-specific skill lists (primary skills first)
const CLASS_SKILLS = {
  monk: ['fistsOfThunderPrimary', 'wayOfTheGlacier', 'blazingFists', 'jadeWindStrike', 'blindingFlash', 'breathOfHeaven', 'waveOfLight', 'explodingPalm', 'cycloneStrike', 'sevenSidedStrike', 'innerSanctuary'],
  ranger: ['hungryArrow', 'chakram', 'multiShot', 'caltrops', 'markedForDeath', 'sentry', 'rainOfArrows'],
  mage: ['magicMissile', 'electrocute', 'frostNova', 'chaosOrb', 'blizzard', 'meteor', 'energyArmor'],
  warrior: ['basicSlash', 'shieldBash', 'cleave', 'groundSlam', 'charge', 'warCry', 'shieldWall', 'execute', 'whirlwind', 'revenge', 'earthquake']
};

// Class-specific passive skills (slot 5)
const CLASS_PASSIVES = {
  monk: ['monkPower', 'monkVitality', 'monkResistance'],
  warrior: ['warriorPower', 'warriorVitality', 'warriorResistance'],
  ranger: ['rangerPower', 'rangerVitality', 'rangerResistance'],
  mage: ['magePower', 'mageVitality', 'mageResistance']
};

// Default equipped skills per class
// Slot 0 = PRIMARY (must be a primary skill)
// Slots 1-3 = other skills (non-primary)
// Slot 4 = PASSIVE (must be a passive skill)
const DEFAULT_EQUIPPED_SKILLS = {
  monk: ['fistsOfThunderPrimary', 'blindingFlash', 'cycloneStrike', 'waveOfLight', 'monkPower'],
  ranger: ['hungryArrow', null, null, null, null],  // Only primary at start, others unlock later
  mage: ['magicMissile', 'frostNova', 'chaosOrb', 'meteor', 'magePower'],
  warrior: ['basicSlash', 'shieldBash', 'cleave', 'earthquake', 'warriorVitality']
};

// Currently equipped skills in each slot
let equippedSkills = ['fistsOfThunderPrimary', 'blindingFlash', 'cycloneStrike', 'waveOfLight', 'monkPower'];

// AI Priority for each skill slot (1=Conservative, 2=Normal, 3=Aggressive)
// Slot 0 (primary) always fires, but stored for consistency
let skillAIPriority = [2, 2, 2, 2, 2];

// Cycle AI priority when clicking pips
function cycleAIPriority(slot, event) {
  event.stopPropagation();  // Don't open skill selector
  
  // Cycle 0 -> 1 -> 2 -> 3 -> 0
  skillAIPriority[slot] = (skillAIPriority[slot] + 1) % 4;
  
  // Update pip visuals
  updateAIPipDisplay(slot);
  
  // Update tooltip if visible
  const tooltip = document.getElementById('aiPriorityTooltip');
  if (tooltip && tooltip.classList.contains('visible')) {
    showAIPriorityTooltip(slot, event);
  }
  
  // Show brief floating feedback
  const priorityNames = ['Disabled', 'Conservative', 'Normal', 'Aggressive'];
  const priorityColors = ['#666', '#888', '#4a9', '#c84'];
  showAIPriorityFeedback(event.clientX, event.clientY, priorityNames[skillAIPriority[slot]], priorityColors[skillAIPriority[slot]]);
}

// Show AI Priority tooltip on hover
function showAIPriorityTooltip(slot, event) {
  event.stopPropagation();
  
  // Hide skill tooltip first
  hideSkillTooltip();
  
  const tooltip = document.getElementById('aiPriorityTooltip');
  if (!tooltip) return;
  
  const priority = skillAIPriority[slot];
  const priorityNames = ['Disabled', 'Conservative', 'Normal', 'Aggressive'];
  const priorityClasses = ['disabled', 'conservative', 'normal', 'aggressive'];
  
  // Set level text and color
  const levelEl = document.getElementById('aiTooltipLevel');
  levelEl.textContent = priorityNames[priority];
  levelEl.className = 'ai-tooltip-level ' + priorityClasses[priority];
  
  // Set description
  const descriptions = [
    'AI will never use this skill automatically.',
    'Save this skill for emergencies and high-value targets.',
    'Use intelligently based on combat situation.',
    'Use as often as possible when conditions allow.'
  ];
  document.getElementById('aiTooltipDesc').textContent = descriptions[priority];
  
  // Set detailed effects
  const details = {
    0: [
      '• AI completely ignores this skill',
      '• Manual activation only',
      '• Click skill button to use',
      '• Best for: Testing, specific builds'
    ],
    1: [
      '• Needs 50% more enemies to trigger',
      '• Waits until health is 10% lower',
      '• Always respects mana conservation',
      '• Best for: Defensives, ultimates'
    ],
    2: [
      '• Standard enemy thresholds',
      '• Balanced health triggers',
      '• Respects mana conservation',
      '• Best for: Most situations'
    ],
    3: [
      '• Triggers with 50% fewer enemies',
      '• Uses 15% earlier on health skills',
      '• Ignores mana conservation',
      '• Best for: Farming, AoE clear'
    ]
  };
  
  document.getElementById('aiTooltipDetails').innerHTML = details[priority].map(d => `<div>${d}</div>`).join('');
  
  // Show tooltip first so we can measure it
  tooltip.style.visibility = 'hidden';
  tooltip.classList.add('visible');
  
  // Position tooltip ABOVE the skill bar (bottom HUD is at bottom of screen)
  const rect = event.target.closest('.ai-pips').getBoundingClientRect();
  const tooltipHeight = tooltip.offsetHeight;
  
  // Position above the skill slot with padding
  let topPos = rect.top - tooltipHeight - 60;  // Extra space above skill bar
  let leftPos = rect.left - 80;
  
  // Keep on screen
  if (topPos < 10) topPos = 10;
  if (leftPos < 10) leftPos = 10;
  if (leftPos + tooltip.offsetWidth > window.innerWidth - 10) {
    leftPos = window.innerWidth - tooltip.offsetWidth - 10;
  }
  
  tooltip.style.left = leftPos + 'px';
  tooltip.style.top = topPos + 'px';
  tooltip.style.visibility = 'visible';
}

// Hide AI Priority tooltip
function hideAIPriorityTooltip() {
  const tooltip = document.getElementById('aiPriorityTooltip');
  if (tooltip) {
    tooltip.classList.remove('visible');
  }
}

// Show brief floating text feedback for AI priority change
function showAIPriorityFeedback(x, y, text, color) {
  const feedback = document.createElement('div');
  feedback.textContent = text;
  feedback.style.cssText = `
    position: fixed;
    left: ${x}px;
    top: ${y - 20}px;
    color: ${color};
    font-size: 11px;
    font-weight: bold;
    text-shadow: 0 1px 3px rgba(0,0,0,0.8);
    pointer-events: none;
    z-index: 9999;
    animation: aiFeedbackFloat 0.8s ease-out forwards;
  `;
  document.body.appendChild(feedback);
  
  // Remove after animation
  setTimeout(() => feedback.remove(), 800);
}

// Update pip display for a slot
function updateAIPipDisplay(slot) {
  const pipsContainer = document.querySelector(`.ai-pips[data-slot="${slot}"]`);
  if (!pipsContainer) return;
  
  const priority = skillAIPriority[slot];
  pipsContainer.dataset.priority = priority;
  
  const pips = pipsContainer.querySelectorAll('.ai-pip');
  pips.forEach((pip, i) => {
    pip.classList.toggle('active', i < priority);
  });
}

// Update all pip displays
function updateAllAIPipDisplays() {
  for (let i = 0; i < 5; i++) {
    updateAIPipDisplay(i);
  }
}

// Get adjusted enemy threshold based on AI priority
// Priority 1 (Conservative): Higher thresholds (needs more enemies)
// Priority 2 (Normal): Lower thresholds - use more freely on single targets
// Priority 3 (Aggressive): Lowest thresholds (use on any enemy)
function getAIThreshold(slot, baseThreshold) {
  const priority = skillAIPriority[slot] || 2;
  switch (priority) {
    case 1: return Math.ceil(baseThreshold * 1.5);  // 50% higher
    case 2: return Math.max(1, baseThreshold - 1);  // Lower by 1, min 1
    case 3: return 1;  // Always use if any enemy
    default: return baseThreshold;
  }
}

// Get adjusted health threshold based on AI priority
// Priority 1 (Conservative): Lower health threshold (wait until more hurt)
// Priority 2 (Normal): Base threshold
// Priority 3 (Aggressive): Higher health threshold (use earlier)
function getAIHealthThreshold(slot, baseThreshold) {
  const priority = skillAIPriority[slot] || 2;
  switch (priority) {
    case 1: return baseThreshold - 0.1;  // Use 10% later
    case 3: return Math.min(0.9, baseThreshold + 0.15);  // Use 15% earlier
    default: return baseThreshold;
  }
}

// Check if AI should skip skill based on priority (for mana conservation)
// Priority 1: Always respects mana conservation
// Priority 2: Respects mana conservation
// Priority 3: Ignores mana conservation (still respects 0 mana)
function shouldAIConserve(slot, conserveMana) {
  const priority = skillAIPriority[slot] || 2;
  if (priority === 3) return false;  // Aggressive ignores conservation
  return conserveMana;
}

// Currently equipped skill gems (slot -> { skill: string, tier: number })
const equippedSkillGems = [
  { skill: 'fistsOfThunderPrimary', tier: 1 },
  { skill: 'blindingFlash', tier: 1 },
  { skill: 'cycloneStrike', tier: 1 },
  { skill: 'breathOfHeaven', tier: 1 },
  { skill: 'waveOfLight', tier: 1 }
];

// Skill gem inventory (what player has found)
const skillGemInventory = {
  'fistsOfThunderPrimary': { 1: 1, 2: 0, 3: 0, 4: 0, 5: 0 },
  'wayOfTheGlacier': { 1: 1, 2: 0, 3: 0, 4: 0, 5: 0 },
  'blazingFists': { 1: 1, 2: 0, 3: 0, 4: 0, 5: 0 },
  'jadeWindStrike': { 1: 1, 2: 0, 3: 0, 4: 0, 5: 0 },
  'blindingFlash': { 1: 1, 2: 1, 3: 1, 4: 1, 5: 1 },
  'breathOfHeaven': { 1: 1, 2: 0, 3: 0, 4: 0, 5: 0 },
  'waveOfLight': { 1: 1, 2: 0, 3: 0, 4: 0, 5: 0 },
  'explodingPalm': { 1: 1, 2: 0, 3: 0, 4: 0, 5: 0 },
  'cycloneStrike': { 1: 1, 2: 0, 3: 0, 4: 0, 5: 0 },
  'sevenSidedStrike': { 1: 1, 2: 0, 3: 0, 4: 0, 5: 0 },
  'innerSanctuary': { 1: 1, 2: 0, 3: 0, 4: 0, 5: 0 },
  // Class-specific passive skills (always available at T1)
  'monkPower': { 1: 1, 2: 0, 3: 0, 4: 0, 5: 0 },
  'monkVitality': { 1: 1, 2: 0, 3: 0, 4: 0, 5: 0 },
  'monkResistance': { 1: 1, 2: 0, 3: 0, 4: 0, 5: 0 },
  'warriorPower': { 1: 1, 2: 0, 3: 0, 4: 0, 5: 0 },
  'warriorVitality': { 1: 1, 2: 0, 3: 0, 4: 0, 5: 0 },
  'warriorResistance': { 1: 1, 2: 0, 3: 0, 4: 0, 5: 0 },
  'rangerPower': { 1: 1, 2: 0, 3: 0, 4: 0, 5: 0 },
  'rangerVitality': { 1: 1, 2: 0, 3: 0, 4: 0, 5: 0 },
  'rangerResistance': { 1: 1, 2: 0, 3: 0, 4: 0, 5: 0 },
  'magePower': { 1: 1, 2: 0, 3: 0, 4: 0, 5: 0 },
  'mageVitality': { 1: 1, 2: 0, 3: 0, 4: 0, 5: 0 },
  'mageResistance': { 1: 1, 2: 0, 3: 0, 4: 0, 5: 0 },
  'innerPeace': { 1: 1, 2: 0, 3: 0, 4: 0, 5: 0 },
  'thunderPalm': { 1: 1, 2: 0, 3: 0, 4: 0, 5: 0 },
  'ironSkin': { 1: 1, 2: 0, 3: 0, 4: 0, 5: 0 }
};

// ════════════════════════════════════════════════════════════════════════════════
// PASSIVE SKILL TREE SYSTEM
// ════════════════════════════════════════════════════════════════════════════════
// One massive shared tree. All classes start at different edges.
// Small nodes: minor stackable bonuses
// Notables: strong theme-defining bonuses
// Keystones: transformational, often with a downside
// ════════════════════════════════════════════════════════════════════════════════

// Passive tree state
let passiveTreeOpen = false;
let allocatedPassives = new Set(); // Set of node IDs
let passivePoints = 0;
let passivePointsSpent = 0;

// Tree view state
let treeZoom = 1.0;
let treeOffsetX = 0;
let treeOffsetY = 0;
let treeDragging = false;
let treeDragStart = { x: 0, y: 0 };
let hoveredNode = null;

// Class starting node positions - ALL CLASSES START AT CENTER
// ═══════════════════════════════════════════════════════════════════════════════
// PASSIVE SKILL TREE — CONSTRAINT-BASED SECTOR LAYOUT
// ═══════════════════════════════════════════════════════════════════════════════
// LAYOUT RULES (ENFORCED):
// 1. Classes on CARDINAL positions (N/E/S/W) - eliminates diagonal crossings
// 2. Each class owns a 90° sector - nodes stay in their sector
// 3. Connections only between ADJACENT sectors - no cross-map paths
// 4. Minimum 60px between all nodes
// 5. Paths are monotonic - no backtracking/zig-zag
// 6. Clusters own exclusive circular space
//
// STRUCTURE:
//                 MONK (North, 0,-480)
//                      |
//            NW        |        NE
//          Quadrant    |      Quadrant
//                \     |     /
//   RANGER ------  HUB CENTER  ------ MAGE
//   (West,-480,0)      |         (East, 480,0)
//                /     |     \
//          SW        |        SE
//          Quadrant    |      Quadrant
//                      |
//                WARRIOR (South, 0,480)
// ═══════════════════════════════════════════════════════════════════════════════

const CLASS_START_NODES = {
  monk: 'monk_start',
  ranger: 'ranger_start',
  mage: 'mage_start',
  warrior: 'warrior_start'
};

const PASSIVE_NODES = {

  // ═══════════════════════════════════════════════════════════════════════════
  // LAYER 0: CENTRAL HUB (radius 0-80)
  // Single notable at center, 4 spokes to cardinal directions
  // ═══════════════════════════════════════════════════════════════════════════
  
  hub: { name: 'Nexus', type: 'notable', x: 0, y: 0, stats: ['+5% All Damage', '+5% All Defense'], connections: ['spoke_n1', 'spoke_e1', 'spoke_s1', 'spoke_w1'] },

  // ═══════════════════════════════════════════════════════════════════════════
  // LAYER 1: CARDINAL SPOKES (radius 80-240)
  // Straight paths from hub to each class - NO CROSSINGS (perpendicular)
  // ═══════════════════════════════════════════════════════════════════════════
  
  // NORTH SPOKE (to Monk)
  spoke_n1: { name: 'Vigor', type: 'small', x: 0, y: -70, stats: ['+5% Life'], connections: ['hub', 'spoke_n2'] },
  spoke_n2: { name: 'Fortitude', type: 'small', x: 0, y: -140, stats: ['+6% Life'], connections: ['spoke_n1', 'spoke_n3'] },
  spoke_n3: { name: 'Resilience', type: 'notable', x: 0, y: -210, stats: ['+10% Life', '+5% Attack Speed'], connections: ['spoke_n2', 'monk_gate'] },
  
  // EAST SPOKE (to Mage)
  spoke_e1: { name: 'Clarity', type: 'small', x: 70, y: 0, stats: ['+5% Mana'], connections: ['hub', 'spoke_e2'] },
  spoke_e2: { name: 'Wisdom', type: 'small', x: 140, y: 0, stats: ['+6% Mana'], connections: ['spoke_e1', 'spoke_e3'] },
  spoke_e3: { name: 'Brilliance', type: 'notable', x: 210, y: 0, stats: ['+10% Mana', '+5% Spell Damage'], connections: ['spoke_e2', 'mage_gate'] },
  
  // SOUTH SPOKE (to Warrior)
  spoke_s1: { name: 'Might', type: 'small', x: 0, y: 70, stats: ['+5% Phys Damage'], connections: ['hub', 'spoke_s2'] },
  spoke_s2: { name: 'Power', type: 'small', x: 0, y: 140, stats: ['+6% Phys Damage'], connections: ['spoke_s1', 'spoke_s3'] },
  spoke_s3: { name: 'Dominance', type: 'notable', x: 0, y: 210, stats: ['+10% Phys Damage', '+5% Armor'], connections: ['spoke_s2', 'warrior_gate'] },
  
  // WEST SPOKE (to Ranger)
  spoke_w1: { name: 'Precision', type: 'small', x: -70, y: 0, stats: ['+5% Crit Chance'], connections: ['hub', 'spoke_w2'] },
  spoke_w2: { name: 'Accuracy', type: 'small', x: -140, y: 0, stats: ['+6% Crit Chance'], connections: ['spoke_w1', 'spoke_w3'] },
  spoke_w3: { name: 'Lethality', type: 'notable', x: -210, y: 0, stats: ['+10% Crit Chance', '+5% Proj Damage'], connections: ['spoke_w2', 'ranger_gate'] },

  // ═══════════════════════════════════════════════════════════════════════════
  // LAYER 2: CLASS GATES (radius 280-320)
  // Entry points to each class sector
  // ═══════════════════════════════════════════════════════════════════════════
  
  monk_gate: { name: 'Monk\'s Path', type: 'notable', x: 0, y: -290, stats: ['+8% Attack Speed', '+4% Melee Damage'], connections: ['spoke_n3', 'monk_inner1', 'arc_ne_1', 'arc_nw_1'] },
  mage_gate: { name: 'Mage\'s Path', type: 'notable', x: 290, y: 0, stats: ['+8% Spell Damage', '+4% Cast Speed'], connections: ['spoke_e3', 'mage_inner1', 'arc_ne_5', 'arc_se_1'] },
  warrior_gate: { name: 'Warrior\'s Path', type: 'notable', x: 0, y: 290, stats: ['+8% Armor', '+4% Phys Damage'], connections: ['spoke_s3', 'warrior_inner1', 'arc_se_5', 'arc_sw_1'] },
  ranger_gate: { name: 'Ranger\'s Path', type: 'notable', x: -290, y: 0, stats: ['+8% Proj Damage', '+4% Crit Chance'], connections: ['spoke_w3', 'ranger_inner1', 'arc_sw_5', 'arc_nw_5'] },

  // ═══════════════════════════════════════════════════════════════════════════
  // LAYER 3: QUADRANT ARCS (Between adjacent classes)
  // These curve around the outside - NEVER cross center
  // Each arc stays in its quadrant (NE, SE, SW, NW)
  // ═══════════════════════════════════════════════════════════════════════════
  
  // NE ARC (Monk to Mage) - stays in x>0, y<0 quadrant
  arc_ne_1: { name: 'Battle Mage', type: 'small', x: 80, y: -270, stats: ['+4% Attack Speed'], connections: ['monk_gate', 'arc_ne_2'] },
  arc_ne_2: { name: 'Spell Strike', type: 'small', x: 150, y: -230, stats: ['+4% Spell Damage'], connections: ['arc_ne_1', 'arc_ne_3'] },
  arc_ne_3: { name: 'Arcane Warrior', type: 'notable', x: 200, y: -170, stats: ['+6% Attack Speed', '+6% Cast Speed'], connections: ['arc_ne_2', 'arc_ne_4'] },
  arc_ne_4: { name: 'Mind Blade', type: 'small', x: 230, y: -100, stats: ['+4% Melee Damage'], connections: ['arc_ne_3', 'arc_ne_5'] },
  arc_ne_5: { name: 'Mystic Force', type: 'small', x: 250, y: -40, stats: ['+4% Mana'], connections: ['arc_ne_4', 'mage_gate'] },
  
  // SE ARC (Mage to Warrior) - stays in x>0, y>0 quadrant
  arc_se_1: { name: 'War Mage', type: 'small', x: 270, y: 80, stats: ['+4% Spell Damage'], connections: ['mage_gate', 'arc_se_2'] },
  arc_se_2: { name: 'Arcane Armor', type: 'small', x: 230, y: 150, stats: ['+4% Shield'], connections: ['arc_se_1', 'arc_se_3'] },
  arc_se_3: { name: 'Battle Scholar', type: 'notable', x: 170, y: 200, stats: ['+6% Armor', '+6% Shield'], connections: ['arc_se_2', 'arc_se_4'] },
  arc_se_4: { name: 'Iron Mind', type: 'small', x: 100, y: 230, stats: ['+4% Phys Damage'], connections: ['arc_se_3', 'arc_se_5'] },
  arc_se_5: { name: 'Fortress', type: 'small', x: 40, y: 250, stats: ['+4% Armor'], connections: ['arc_se_4', 'warrior_gate'] },
  
  // SW ARC (Warrior to Ranger) - stays in x<0, y>0 quadrant
  arc_sw_1: { name: 'Iron Hunter', type: 'small', x: -80, y: 270, stats: ['+4% Armor'], connections: ['warrior_gate', 'arc_sw_2'] },
  arc_sw_2: { name: 'Heavy Shot', type: 'small', x: -150, y: 230, stats: ['+4% Proj Damage'], connections: ['arc_sw_1', 'arc_sw_3'] },
  arc_sw_3: { name: 'Gladiator', type: 'notable', x: -200, y: 170, stats: ['+6% Phys Damage', '+6% Crit Damage'], connections: ['arc_sw_2', 'arc_sw_4'] },
  arc_sw_4: { name: 'Brutal Aim', type: 'small', x: -230, y: 100, stats: ['+4% Crit Chance'], connections: ['arc_sw_3', 'arc_sw_5'] },
  arc_sw_5: { name: 'Predator', type: 'small', x: -250, y: 40, stats: ['+4% Proj Damage'], connections: ['arc_sw_4', 'ranger_gate'] },
  
  // NW ARC (Ranger to Monk) - stays in x<0, y<0 quadrant
  arc_nw_1: { name: 'Swift Hunter', type: 'small', x: -80, y: -270, stats: ['+4% Move Speed'], connections: ['monk_gate', 'arc_nw_2'] },
  arc_nw_2: { name: 'Shadow Strike', type: 'small', x: -150, y: -230, stats: ['+4% Dodge'], connections: ['arc_nw_1', 'arc_nw_3'] },
  arc_nw_3: { name: 'Wind Dancer', type: 'notable', x: -200, y: -170, stats: ['+6% Dodge', '+6% Attack Speed'], connections: ['arc_nw_2', 'arc_nw_4'] },
  arc_nw_4: { name: 'Phantom Step', type: 'small', x: -230, y: -100, stats: ['+4% Move Speed'], connections: ['arc_nw_3', 'arc_nw_5'] },
  arc_nw_5: { name: 'Ghost Arrow', type: 'small', x: -250, y: -40, stats: ['+4% Proj Damage'], connections: ['arc_nw_4', 'ranger_gate'] },

  // ═══════════════════════════════════════════════════════════════════════════
  // LAYER 4: CLASS INNER RINGS (radius 320-400)
  // Each class has nodes that stay within their sector
  // ═══════════════════════════════════════════════════════════════════════════
  
  // MONK INNER (North sector, y < -280)
  monk_inner1: { name: 'Swift Fist', type: 'small', x: 0, y: -360, stats: ['+6% Attack Speed'], connections: ['monk_gate', 'monk_inner2', 'monk_inner3'] },
  monk_inner2: { name: 'Flurry', type: 'small', x: -60, y: -390, stats: ['+5% Attack Speed'], connections: ['monk_inner1', 'monk_branch_l1'] },
  monk_inner3: { name: 'Rapid Strikes', type: 'small', x: 60, y: -390, stats: ['+5% Attack Speed'], connections: ['monk_inner1', 'monk_branch_r1'] },
  
  // MAGE INNER (East sector, x > 280)
  mage_inner1: { name: 'Arcane Flow', type: 'small', x: 360, y: 0, stats: ['+6% Spell Damage'], connections: ['mage_gate', 'mage_inner2', 'mage_inner3'] },
  mage_inner2: { name: 'Fire Affinity', type: 'small', x: 390, y: -60, stats: ['+5% Fire Damage'], connections: ['mage_inner1', 'mage_branch_u1'] },
  mage_inner3: { name: 'Cold Affinity', type: 'small', x: 390, y: 60, stats: ['+5% Cold Damage'], connections: ['mage_inner1', 'mage_branch_d1'] },
  
  // WARRIOR INNER (South sector, y > 280)
  warrior_inner1: { name: 'Iron Will', type: 'small', x: 0, y: 360, stats: ['+6% Armor'], connections: ['warrior_gate', 'warrior_inner2', 'warrior_inner3'] },
  warrior_inner2: { name: 'Heavy Armor', type: 'small', x: 60, y: 390, stats: ['+5% Armor'], connections: ['warrior_inner1', 'warrior_branch_r1'] },
  warrior_inner3: { name: 'Thick Skin', type: 'small', x: -60, y: 390, stats: ['+5% Life'], connections: ['warrior_inner1', 'warrior_branch_l1'] },
  
  // RANGER INNER (West sector, x < -280)
  ranger_inner1: { name: 'Eagle Eye', type: 'small', x: -360, y: 0, stats: ['+6% Proj Damage'], connections: ['ranger_gate', 'ranger_inner2', 'ranger_inner3'] },
  ranger_inner2: { name: 'Deadly Aim', type: 'small', x: -390, y: -60, stats: ['+5% Crit Chance'], connections: ['ranger_inner1', 'ranger_branch_u1'] },
  ranger_inner3: { name: 'Pierce', type: 'small', x: -390, y: 60, stats: ['+1 Pierce'], connections: ['ranger_inner1', 'ranger_branch_d1'] },

  // ═══════════════════════════════════════════════════════════════════════════
  // LAYER 5: CLASS BRANCHES (radius 400-520)
  // Each class has 2 main branches leading to keystones
  // Branches stay strictly within sector bounds
  // ═══════════════════════════════════════════════════════════════════════════
  
  // MONK LEFT BRANCH (Attack Speed → Way of Thunder keystone)
  monk_branch_l1: { name: 'Lightning Hands', type: 'small', x: -100, y: -440, stats: ['+6% Attack Speed'], connections: ['monk_inner2', 'monk_branch_l2'] },
  monk_branch_l2: { name: 'Storm Fist', type: 'small', x: -130, y: -490, stats: ['+7% Attack Speed'], connections: ['monk_branch_l1', 'monk_branch_l3'] },
  monk_branch_l3: { name: 'Blur of Steel', type: 'notable', x: -150, y: -540, stats: ['+12% Attack Speed'], connections: ['monk_branch_l2', 'monk_key_l'] },
  monk_key_l: { name: 'Way of Thunder', type: 'keystone', x: -160, y: -600, stats: ['Every 3rd hit deals 2x damage', 'Cannot Crit'], connections: ['monk_branch_l3'] },
  
  // MONK RIGHT BRANCH (Melee → Iron Fist keystone)
  monk_branch_r1: { name: 'Heavy Blow', type: 'small', x: 100, y: -440, stats: ['+6% Melee Damage'], connections: ['monk_inner3', 'monk_branch_r2'] },
  monk_branch_r2: { name: 'Crushing Palm', type: 'small', x: 130, y: -490, stats: ['+7% Melee Damage'], connections: ['monk_branch_r1', 'monk_branch_r3'] },
  monk_branch_r3: { name: 'Devastating Strike', type: 'notable', x: 150, y: -540, stats: ['+12% Melee Damage'], connections: ['monk_branch_r2', 'monk_key_r'] },
  monk_key_r: { name: 'Infinite Combo', type: 'keystone', x: 160, y: -600, stats: ['Combo never resets', '+20% Damage at max'], connections: ['monk_branch_r3'] },
  
  // MAGE UPPER BRANCH (Fire → Avatar of Flame keystone)
  mage_branch_u1: { name: 'Burning Soul', type: 'small', x: 440, y: -100, stats: ['+6% Fire Damage'], connections: ['mage_inner2', 'mage_branch_u2'] },
  mage_branch_u2: { name: 'Immolation', type: 'small', x: 490, y: -130, stats: ['+7% Fire Damage'], connections: ['mage_branch_u1', 'mage_branch_u3'] },
  mage_branch_u3: { name: 'Inferno', type: 'notable', x: 540, y: -150, stats: ['+12% Fire Damage'], connections: ['mage_branch_u2', 'mage_key_u'] },
  mage_key_u: { name: 'Avatar of Flame', type: 'keystone', x: 600, y: -160, stats: ['All damage is Fire', '+25% Fire, -10% other'], connections: ['mage_branch_u3'] },
  
  // MAGE LOWER BRANCH (Cold/Mana → Arcane Supremacy keystone)
  mage_branch_d1: { name: 'Frozen Heart', type: 'small', x: 440, y: 100, stats: ['+6% Cold Damage'], connections: ['mage_inner3', 'mage_branch_d2'] },
  mage_branch_d2: { name: 'Deep Freeze', type: 'small', x: 490, y: 130, stats: ['+7% Cold Damage'], connections: ['mage_branch_d1', 'mage_branch_d3'] },
  mage_branch_d3: { name: 'Glacial Power', type: 'notable', x: 540, y: 150, stats: ['+12% Cold Damage'], connections: ['mage_branch_d2', 'mage_key_d'] },
  mage_key_d: { name: 'Arcane Supremacy', type: 'keystone', x: 600, y: 160, stats: ['Mana = Life for costs', '+30% Spell Damage'], connections: ['mage_branch_d3'] },
  
  // WARRIOR RIGHT BRANCH (Armor → Juggernaut keystone)
  warrior_branch_r1: { name: 'Iron Skin', type: 'small', x: 100, y: 440, stats: ['+6% Armor'], connections: ['warrior_inner2', 'warrior_branch_r2'] },
  warrior_branch_r2: { name: 'Steel Plating', type: 'small', x: 130, y: 490, stats: ['+7% Armor'], connections: ['warrior_branch_r1', 'warrior_branch_r3'] },
  warrior_branch_r3: { name: 'Living Fortress', type: 'notable', x: 150, y: 540, stats: ['+12% Armor'], connections: ['warrior_branch_r2', 'warrior_key_r'] },
  warrior_key_r: { name: 'Juggernaut', type: 'keystone', x: 160, y: 600, stats: ['Cannot Dodge', 'Armor x2'], connections: ['warrior_branch_r3'] },
  
  // WARRIOR LEFT BRANCH (Life → Blood Artist keystone)
  warrior_branch_l1: { name: 'Vitality', type: 'small', x: -100, y: 440, stats: ['+6% Life'], connections: ['warrior_inner3', 'warrior_branch_l2'] },
  warrior_branch_l2: { name: 'Constitution', type: 'small', x: -130, y: 490, stats: ['+7% Life'], connections: ['warrior_branch_l1', 'warrior_branch_l3'] },
  warrior_branch_l3: { name: 'Fortified', type: 'notable', x: -150, y: 540, stats: ['+12% Life'], connections: ['warrior_branch_l2', 'warrior_key_l'] },
  warrior_key_l: { name: 'Blood Artist', type: 'keystone', x: -160, y: 600, stats: ['Bleeds instant', '-50% Bleed duration'], connections: ['warrior_branch_l3'] },
  
  // RANGER UPPER BRANCH (Crit → Endless Arrows keystone)
  ranger_branch_u1: { name: 'Sharpshooter', type: 'small', x: -440, y: -100, stats: ['+6% Crit Chance'], connections: ['ranger_inner2', 'ranger_branch_u2'] },
  ranger_branch_u2: { name: 'Lethal Aim', type: 'small', x: -490, y: -130, stats: ['+7% Crit Chance'], connections: ['ranger_branch_u1', 'ranger_branch_u3'] },
  ranger_branch_u3: { name: 'Assassin', type: 'notable', x: -540, y: -150, stats: ['+12% Crit Chance'], connections: ['ranger_branch_u2', 'ranger_key_u'] },
  ranger_key_u: { name: 'Endless Arrows', type: 'keystone', x: -600, y: -160, stats: ['Proj +30% more Damage', 'Cannot shotgun'], connections: ['ranger_branch_u3'] },
  
  // RANGER LOWER BRANCH (Proj → Master Trapper keystone)
  ranger_branch_d1: { name: 'Multi Shot', type: 'small', x: -440, y: 100, stats: ['+1 Projectile'], connections: ['ranger_inner3', 'ranger_branch_d2'] },
  ranger_branch_d2: { name: 'Barrage', type: 'small', x: -490, y: 130, stats: ['+6% Proj Damage'], connections: ['ranger_branch_d1', 'ranger_branch_d3'] },
  ranger_branch_d3: { name: 'Rain of Arrows', type: 'notable', x: -540, y: 150, stats: ['+2 Projectiles'], connections: ['ranger_branch_d2', 'ranger_key_d'] },
  ranger_key_d: { name: 'Master Trapper', type: 'keystone', x: -600, y: 160, stats: ['Traps arm instantly', 'No skills while active'], connections: ['ranger_branch_d3'] },

  // ═══════════════════════════════════════════════════════════════════════════
  // LAYER 6: CLASS START NODES (radius 480-520)
  // Connect to inner rings and branch notables
  // ═══════════════════════════════════════════════════════════════════════════
  
  monk_start: { name: 'Way of the Fist', type: 'start', x: 0, y: -480, stats: [], connections: ['monk_inner1', 'monk_start_l', 'monk_start_r'] },
  monk_start_l: { name: 'Swift Hand', type: 'small', x: -50, y: -500, stats: ['+4% Attack Speed'], connections: ['monk_start', 'monk_branch_l1'] },
  monk_start_r: { name: 'Iron Palm', type: 'small', x: 50, y: -500, stats: ['+4% Melee Damage'], connections: ['monk_start', 'monk_branch_r1'] },
  
  mage_start: { name: 'Arcane Origin', type: 'start', x: 480, y: 0, stats: [], connections: ['mage_inner1', 'mage_start_u', 'mage_start_d'] },
  mage_start_u: { name: 'Flame Weaver', type: 'small', x: 500, y: -50, stats: ['+4% Fire Damage'], connections: ['mage_start', 'mage_branch_u1'] },
  mage_start_d: { name: 'Frost Weaver', type: 'small', x: 500, y: 50, stats: ['+4% Cold Damage'], connections: ['mage_start', 'mage_branch_d1'] },
  
  warrior_start: { name: 'Path of War', type: 'start', x: 0, y: 480, stats: [], connections: ['warrior_inner1', 'warrior_start_l', 'warrior_start_r'] },
  warrior_start_l: { name: 'Thick Skin', type: 'small', x: -50, y: 500, stats: ['+4% Life'], connections: ['warrior_start', 'warrior_branch_l1'] },
  warrior_start_r: { name: 'Heavy Armor', type: 'small', x: 50, y: 500, stats: ['+4% Armor'], connections: ['warrior_start', 'warrior_branch_r1'] },
  
  ranger_start: { name: 'Hunter\'s Mark', type: 'start', x: -480, y: 0, stats: [], connections: ['ranger_inner1', 'ranger_start_u', 'ranger_start_d'] },
  ranger_start_u: { name: 'Deadly Shot', type: 'small', x: -500, y: -50, stats: ['+4% Crit Chance'], connections: ['ranger_start', 'ranger_branch_u1'] },
  ranger_start_d: { name: 'Pierce Shot', type: 'small', x: -500, y: 50, stats: ['+4% Proj Damage'], connections: ['ranger_start', 'ranger_branch_d1'] },

  // ═══════════════════════════════════════════════════════════════════════════
  // LAYER 7: QUADRANT DEFENSE NOTABLES (on the arcs, radius ~250)
  // These are the "hybrid" nodes accessible from two adjacent classes
  // ═══════════════════════════════════════════════════════════════════════════
  
  // NE Defense (Monk-Mage hybrid) - Spell/Attack speed synergy
  defense_ne: { name: 'Martial Sorcery', type: 'notable', x: 180, y: -180, stats: ['Attack Speed = Cast Speed 50%'], connections: ['arc_ne_3'] },
  
  // SE Defense (Mage-Warrior hybrid) - Shield/Armor synergy  
  defense_se: { name: 'Living Bulwark', type: 'notable', x: 180, y: 180, stats: ['Shield never depletes', '+20% Shield'], connections: ['arc_se_3'] },
  
  // SW Defense (Warrior-Ranger hybrid) - Crit/Phys synergy
  defense_sw: { name: 'Slayer', type: 'notable', x: -180, y: 180, stats: ['Kill <10% instantly', '-10% vs Full Life'], connections: ['arc_sw_3'] },
  
  // NW Defense (Ranger-Monk hybrid) - Dodge/Speed synergy
  defense_nw: { name: 'Ethereal', type: 'notable', x: -180, y: -180, stats: ['+15% Dodge', 'Dodge to Spells 30%'], connections: ['arc_nw_3'] }
};




// PASSIVE TREE FUNCTIONS
// ═══════════════════════════════════════════════════════════════════════════════

function togglePassiveTree() {
  passiveTreeOpen = !passiveTreeOpen;
  const panel = document.getElementById('passiveTreePanel');
  
  if (passiveTreeOpen) {
    panel.style.display = '';  // Clear any inline display:none from returnToMainMenu
  }
  panel.classList.toggle('visible', passiveTreeOpen);
  
  if (passiveTreeOpen) {
    initPassiveTreeCanvas();
    centerPassiveTree();
    renderPassiveTree();
    updatePassivePointsUI();
  }
}

function initPassiveTreeCanvas() {
  const canvas = document.getElementById('passiveTreeCanvas');
  const container = canvas.parentElement;
  canvas.width = container.clientWidth;
  canvas.height = container.clientHeight;
  
  // Add event listeners
  canvas.onmousedown = startTreeDrag;
  canvas.onmousemove = handleTreeMouseMove;
  canvas.onmouseup = endTreeDrag;
  canvas.onmouseleave = endTreeDrag;
  canvas.onclick = handleTreeClick;
  canvas.onwheel = handleTreeWheel;
}

function centerPassiveTree() {
  const canvas = document.getElementById('passiveTreeCanvas');
  // Center on class starting node
  const startNode = PASSIVE_NODES[CLASS_START_NODES[player.class]];
  if (startNode) {
    treeOffsetX = canvas.width / 2 - startNode.x * treeZoom;
    treeOffsetY = canvas.height / 2 - startNode.y * treeZoom;
  } else {
    treeOffsetX = canvas.width / 2;
    treeOffsetY = canvas.height / 2;
  }
  renderPassiveTree();
}

function zoomPassiveTree(factor) {
  const canvas = document.getElementById('passiveTreeCanvas');
  const centerX = canvas.width / 2;
  const centerY = canvas.height / 2;
  
  // Zoom toward center
  const oldZoom = treeZoom;
  treeZoom = Math.max(0.3, Math.min(2.0, treeZoom * factor));
  
  // Adjust offset to keep center point
  const zoomRatio = treeZoom / oldZoom;
  treeOffsetX = centerX - (centerX - treeOffsetX) * zoomRatio;
  treeOffsetY = centerY - (centerY - treeOffsetY) * zoomRatio;
  
  renderPassiveTree();
}

function startTreeDrag(e) {
  treeDragging = true;
  treeDragStart = { x: e.clientX - treeOffsetX, y: e.clientY - treeOffsetY };
}

function handleTreeMouseMove(e) {
  const canvas = document.getElementById('passiveTreeCanvas');
  const rect = canvas.getBoundingClientRect();
  const mouseX = e.clientX - rect.left;
  const mouseY = e.clientY - rect.top;
  
  if (treeDragging) {
    treeOffsetX = e.clientX - treeDragStart.x;
    treeOffsetY = e.clientY - treeDragStart.y;
    renderPassiveTree();
  }
  
  // Check for node hover
  const worldX = (mouseX - treeOffsetX) / treeZoom;
  const worldY = (mouseY - treeOffsetY) / treeZoom;
  
  let foundNode = null;
  for (const [id, node] of Object.entries(PASSIVE_NODES)) {
    const radius = getNodeRadius(node.type);
    const dist = Math.hypot(worldX - node.x, worldY - node.y);
    if (dist < radius) {
      foundNode = id;
      break;
    }
  }
  
  if (foundNode !== hoveredNode) {
    hoveredNode = foundNode;
    renderPassiveTree();
    
    if (foundNode) {
      showNodeTooltip(foundNode, e);
    } else {
      hideNodeTooltip();
    }
  } else if (foundNode) {
    positionNodeTooltip(e);
  }
}

function endTreeDrag() {
  treeDragging = false;
}

function handleTreeWheel(e) {
  e.preventDefault();
  zoomPassiveTree(e.deltaY < 0 ? 1.1 : 0.9);
}

function handleTreeClick(e) {
  if (!hoveredNode) return;
  
  const node = PASSIVE_NODES[hoveredNode];
  if (!node) return;
  
  // Check if already allocated
  if (allocatedPassives.has(hoveredNode)) {
    // Could implement unallocating here (refund points)
    return;
  }
  
  // Check if can allocate (has points and connected to allocated node)
  if (canAllocateNode(hoveredNode)) {
    allocateNode(hoveredNode);
  }
}

function getNodeRadius(type) {
  switch(type) {
    case 'keystone': return 28;
    case 'notable': return 22;
    case 'start': return 20;
    default: return 14;
  }
}

function canAllocateNode(nodeId) {
  const node = PASSIVE_NODES[nodeId];
  if (!node) return false;
  
  // Already allocated
  if (allocatedPassives.has(nodeId)) return false;
  
  // No points available
  if (passivePoints <= 0) return false;
  
  // Must be connected to an allocated node
  const isConnected = node.connections.some(connId => allocatedPassives.has(connId));
  return isConnected;
}

function allocateNode(nodeId) {
  const node = PASSIVE_NODES[nodeId];
  if (!node) return;
  
  allocatedPassives.add(nodeId);
  passivePoints--;
  passivePointsSpent++;
  
  updatePassivePointsUI();
  renderPassiveTree();
  recalculateStats();
  updateStats();
  updateCharPanel(); // Update stat display
  
  // Play sound/effect here if desired
  addLog(`Allocated: ${node.name}`, 'skill');
}

function updatePassivePointsUI() {
  document.getElementById('passivePointsAvailable').textContent = passivePoints;
  document.getElementById('passivePointsAllocated').textContent = passivePointsSpent;
}

function showRespecConfirm() {
  if (passivePointsSpent === 0) {
    addLog('No points to refund!', 'warning');
    return;
  }
  
  if (player.gold < 500) {
    addLog('Not enough gold! (500g required)', 'warning');
    return;
  }
  
  if (confirm(`Respec all ${passivePointsSpent} passive points for 500 gold?`)) {
    player.gold -= 500;
    respecAllPassives();
  }
}

function respecAllPassives() {
  // Refund all non-start nodes
  passivePoints += passivePointsSpent;
  passivePointsSpent = 0;
  
  // Keep only start nodes allocated
  const startNodeId = CLASS_START_NODES[player.class];
  allocatedPassives.clear();
  allocatedPassives.add(startNodeId);
  
  updatePassivePointsUI();
  renderPassiveTree();
  recalculateStats();
  updateStats();
  updateCharPanel(); // Update stat display
  
  addLog('All passive points refunded!', 'skill');
}

function initClassStartNode() {
  const startNodeId = CLASS_START_NODES[player.class];
  if (startNodeId && !allocatedPassives.has(startNodeId)) {
    allocatedPassives.add(startNodeId);
  }
}

// Called when player levels up
function grantPassivePoint() {
  passivePoints++;
  addLog('+1 Passive Point!', 'exp');
}

// ═══════════════════════════════════════════════════════════════════════════════
// PASSIVE TREE RENDERING
// ═══════════════════════════════════════════════════════════════════════════════

function renderPassiveTree() {
  const canvas = document.getElementById('passiveTreeCanvas');
  if (!canvas) return;
  const ctx = canvas.getContext('2d');
  
  // Clear
  ctx.fillStyle = '#0a0a0c';
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  
  // Draw background grid
  drawTreeGrid(ctx);
  
  ctx.save();
  ctx.translate(treeOffsetX, treeOffsetY);
  ctx.scale(treeZoom, treeZoom);
  
  // Draw connections first
  for (const [id, node] of Object.entries(PASSIVE_NODES)) {
    for (const connId of node.connections) {
      const connNode = PASSIVE_NODES[connId];
      if (connNode) {
        drawConnection(ctx, node, connNode, id, connId);
      }
    }
  }
  
  // Draw nodes
  for (const [id, node] of Object.entries(PASSIVE_NODES)) {
    drawNode(ctx, id, node);
  }
  
  ctx.restore();
}

function drawTreeGrid(ctx) {
  ctx.strokeStyle = '#151515';
  ctx.lineWidth = 1;
  
  const gridSize = 100 * treeZoom;
  const startX = treeOffsetX % gridSize;
  const startY = treeOffsetY % gridSize;
  
  for (let x = startX; x < ctx.canvas.width; x += gridSize) {
    ctx.beginPath();
    ctx.moveTo(x, 0);
    ctx.lineTo(x, ctx.canvas.height);
    ctx.stroke();
  }
  
  for (let y = startY; y < ctx.canvas.height; y += gridSize) {
    ctx.beginPath();
    ctx.moveTo(0, y);
    ctx.lineTo(ctx.canvas.width, y);
    ctx.stroke();
  }
}

function drawConnection(ctx, nodeA, nodeB, idA, idB) {
  const isAllocatedA = allocatedPassives.has(idA);
  const isAllocatedB = allocatedPassives.has(idB);
  const bothAllocated = isAllocatedA && isAllocatedB;
  const oneAllocated = isAllocatedA || isAllocatedB;
  
  ctx.beginPath();
  ctx.moveTo(nodeA.x, nodeA.y);
  ctx.lineTo(nodeB.x, nodeB.y);
  
  if (bothAllocated) {
    ctx.strokeStyle = '#d4af37';
    ctx.lineWidth = 4;
  } else if (oneAllocated) {
    ctx.strokeStyle = '#5a5540';
    ctx.lineWidth = 3;
  } else {
    ctx.strokeStyle = '#2a2520';
    ctx.lineWidth = 2;
  }
  
  ctx.stroke();
}

function drawNode(ctx, id, node) {
  const isAllocated = allocatedPassives.has(id);
  const isHovered = hoveredNode === id;
  const canAllocate = canAllocateNode(id);
  const radius = getNodeRadius(node.type);
  
  // Node shape
  ctx.beginPath();
  
  if (node.type === 'keystone') {
    // Diamond shape
    ctx.save();
    ctx.translate(node.x, node.y);
    ctx.rotate(Math.PI / 4);
    ctx.rect(-radius * 0.7, -radius * 0.7, radius * 1.4, radius * 1.4);
    ctx.restore();
  } else {
    ctx.arc(node.x, node.y, radius, 0, Math.PI * 2);
  }
  
  // Fill
  if (isAllocated) {
    if (node.type === 'keystone') {
      ctx.fillStyle = '#6a2020';
    } else if (node.type === 'notable') {
      ctx.fillStyle = '#4a4020';
    } else if (node.type === 'start') {
      ctx.fillStyle = '#204060';
    } else {
      ctx.fillStyle = '#3a3530';
    }
  } else if (canAllocate) {
    ctx.fillStyle = '#2a3530';
  } else {
    ctx.fillStyle = '#1a1815';
  }
  ctx.fill();
  
  // Border
  if (isAllocated) {
    if (node.type === 'keystone') {
      ctx.strokeStyle = '#ff6644';
    } else if (node.type === 'notable') {
      ctx.strokeStyle = '#d4af37';
    } else if (node.type === 'start') {
      ctx.strokeStyle = '#4488cc';
    } else {
      ctx.strokeStyle = '#888';
    }
    ctx.lineWidth = 3;
  } else if (canAllocate) {
    ctx.strokeStyle = '#88aa88';
    ctx.lineWidth = 2;
  } else if (isHovered) {
    ctx.strokeStyle = '#666';
    ctx.lineWidth = 2;
  } else {
    ctx.strokeStyle = '#3a3530';
    ctx.lineWidth = 1;
  }
  
  ctx.beginPath();
  if (node.type === 'keystone') {
    ctx.save();
    ctx.translate(node.x, node.y);
    ctx.rotate(Math.PI / 4);
    ctx.rect(-radius * 0.7, -radius * 0.7, radius * 1.4, radius * 1.4);
    ctx.restore();
  } else {
    ctx.arc(node.x, node.y, radius, 0, Math.PI * 2);
  }
  ctx.stroke();
  
  // Glow for notables/keystones
  if ((node.type === 'notable' || node.type === 'keystone') && isAllocated) {
    ctx.beginPath();
    if (node.type === 'keystone') {
      ctx.save();
      ctx.translate(node.x, node.y);
      ctx.rotate(Math.PI / 4);
      ctx.rect(-radius * 0.7, -radius * 0.7, radius * 1.4, radius * 1.4);
      ctx.restore();
    } else {
      ctx.arc(node.x, node.y, radius, 0, Math.PI * 2);
    }
    ctx.shadowColor = node.type === 'keystone' ? '#ff4422' : '#d4af37';
    ctx.shadowBlur = 15;
    ctx.stroke();
    ctx.shadowBlur = 0;
  }
}

// ═══════════════════════════════════════════════════════════════════════════════
// PASSIVE NODE TOOLTIP
// ═══════════════════════════════════════════════════════════════════════════════

function showNodeTooltip(nodeId, e) {
  const node = PASSIVE_NODES[nodeId];
  if (!node) return;
  
  const tooltip = document.getElementById('passiveNodeTooltip');
  const nameEl = document.getElementById('nodeTooltipName');
  const typeEl = document.getElementById('nodeTooltipType');
  const statsEl = document.getElementById('nodeTooltipStats');
  const hintEl = document.getElementById('nodeTooltipHint');
  
  nameEl.textContent = node.name;
  nameEl.className = 'node-tooltip-name ' + node.type;
  
  typeEl.textContent = node.type === 'start' ? 'Starting Node' : 
                       node.type.charAt(0).toUpperCase() + node.type.slice(1) + ' Node';
  
  statsEl.innerHTML = node.stats.map(stat => {
    const isNegative = stat.includes('-') || stat.includes('disabled') || stat.includes('reduced') || stat.includes('set to 0') || stat.includes('capped');
    return `<div class="node-tooltip-stat ${isNegative ? 'negative' : ''}">${stat}</div>`;
  }).join('');
  
  if (allocatedPassives.has(nodeId)) {
    hintEl.textContent = 'Allocated';
    hintEl.style.color = '#88ff88';
  } else if (canAllocateNode(nodeId)) {
    hintEl.textContent = 'Click to allocate';
    hintEl.style.color = '#88aaff';
  } else if (passivePoints <= 0) {
    hintEl.textContent = 'No points available';
    hintEl.style.color = '#ff6666';
  } else {
    hintEl.textContent = 'Not connected to allocated node';
    hintEl.style.color = '#888';
  }
  
  tooltip.classList.add('visible');
  positionNodeTooltip(e);
}

function hideNodeTooltip() {
  document.getElementById('passiveNodeTooltip').classList.remove('visible');
}

function positionNodeTooltip(e) {
  const tooltip = document.getElementById('passiveNodeTooltip');
  const rect = tooltip.getBoundingClientRect();
  
  let x = e.clientX + 15;
  let y = e.clientY + 15;
  
  if (x + rect.width > window.innerWidth - 10) {
    x = e.clientX - rect.width - 15;
  }
  if (y + rect.height > window.innerHeight - 10) {
    y = e.clientY - rect.height - 15;
  }
  
  tooltip.style.left = x + 'px';
  tooltip.style.top = y + 'px';
}

// ═══════════════════════════════════════════════════════════════════════════════
// PASSIVE STATS INTEGRATION
// ═══════════════════════════════════════════════════════════════════════════════

function getPassiveBonuses() {
  const bonuses = {
    armor: 0, armorPercent: 0,
    dodge: 0, dodgePercent: 0,
    shield: 0, shieldPercent: 0,
    life: 0, lifePercent: 0,
    mana: 0, manaPercent: 0,
    lifeOnHit: 0, manaOnHit: 0,
    lifeOnKill: 0, manaOnKill: 0,
    attackSpeed: 0, castSpeed: 0,
    spellDamage: 0, physicalDamage: 0,
    // Elemental damage % bonuses (for cross-scaling system)
    fireDamage: 0, coldDamage: 0, lightningDamage: 0, natureDamage: 0,
    cooldownRecovery: 0, areaOfEffect: 0,
    movementSpeed: 0, projectiles: 0,
    // Keystones (boolean flags)
    armorNodiminishing: false,
    dodgeZero: false,
    lifeOnHitDouble: false,
    manaOnHitDisabled: false,
    dodgeCap50: false,
    dodgeCap40: false,
    momentumBonus: false,
    shieldBeforeMana: false,
    manaRegenDisabled: false,
    shieldCapIncrease: 0,
    shieldDelayIncrease: 0,
    armorFromDodge: false,
    dodgeFromArmor: false,
    damageIncreaseAll: 0,
    damageReductionZero: false,
    skillLimit: 0,
    skillDamageBonus: 0,
    hybridDefenseBonus: 0,
    lifeReduction: 0,
    spectralImmunity: false,
    battleRhythm: false,
    armorElemental: 0, // % of armor that applies to elemental
    projectileDamageReduction: 0,
    // Universal passive bonuses
    allResist: 0
  };
  
  // Apply bonuses from allocated passive tree nodes
  for (const nodeId of allocatedPassives) {
    const node = PASSIVE_NODES[nodeId];
    if (!node || node.type === 'start') continue;
    
    for (const stat of node.stats) {
      parsePassiveStat(stat, bonuses);
    }
  }
  
  // Apply bonuses from equipped passive skill (slot 5, index 4)
  if (equippedSkills && equippedSkills[4]) {
    const passiveSkillId = equippedSkills[4];
    const passiveSkill = SKILLS[passiveSkillId];
    
    if (passiveSkill && passiveSkill.isPassive && passiveSkill.bonuses) {
      const b = passiveSkill.bonuses;
      
      // Check if corresponding aspect is active (doubles the effect)
      // Map passive skill to its matching aspect
      let aspectMultiplier = 1;
      const aspectMap = {
        'monkPower': 'aspect_monk_power',
        'monkVitality': 'aspect_monk_vitality',
        'monkResistance': 'aspect_monk_resistance',
        'warriorPower': 'aspect_warrior_power',
        'warriorVitality': 'aspect_warrior_vitality',
        'warriorResistance': 'aspect_warrior_resistance',
        'rangerPower': 'aspect_ranger_power',
        'rangerVitality': 'aspect_ranger_vitality',
        'rangerResistance': 'aspect_ranger_resistance',
        'magePower': 'aspect_mage_power',
        'mageVitality': 'aspect_mage_vitality',
        'mageResistance': 'aspect_mage_resistance'
      };
      
      const matchingAspect = aspectMap[passiveSkillId];
      if (matchingAspect && activeAspects.includes(matchingAspect)) {
        aspectMultiplier = 2;
      }
      
      // Apply bonuses with aspect multiplier
      if (b.damageMult) bonuses.damageIncreaseAll += b.damageMult * 100 * aspectMultiplier;
      if (b.maxHpMult) bonuses.lifePercent += b.maxHpMult * 100 * aspectMultiplier;
      if (b.allResist) bonuses.allResist += b.allResist * 100 * aspectMultiplier;
    }
  }
  
  return bonuses;
}

function parsePassiveStat(stat, bonuses) {
  // Flat bonuses
  if (/\+(\d+) Armor/.test(stat)) bonuses.armor += parseInt(RegExp.$1);
  if (/\+(\d+)% increased Armor/.test(stat)) bonuses.armorPercent += parseInt(RegExp.$1);
  if (/\+(\d+)% Dodge/.test(stat)) bonuses.dodge += parseInt(RegExp.$1);
  if (/\+(\d+) Shield/.test(stat)) bonuses.shield += parseInt(RegExp.$1);
  if (/\+(\d+)% increased Shield/.test(stat)) bonuses.shieldPercent += parseInt(RegExp.$1);
  if (/\+(\d+) Life/.test(stat)) bonuses.life += parseInt(RegExp.$1);
  if (/\+(\d+)% Life/.test(stat) && !stat.includes('reduced')) bonuses.lifePercent += parseInt(RegExp.$1);
  if (/\+(\d+) Mana/.test(stat)) bonuses.mana += parseInt(RegExp.$1);
  if (/\+(\d+)% Mana/.test(stat)) bonuses.manaPercent += parseInt(RegExp.$1);
  if (/\+(\d+) Life on Hit/.test(stat)) bonuses.lifeOnHit += parseInt(RegExp.$1);
  if (/\+(\d+) Mana on Hit/.test(stat)) bonuses.manaOnHit += parseInt(RegExp.$1);
  if (/\+(\d+) Life on Kill/.test(stat)) bonuses.lifeOnKill += parseInt(RegExp.$1);
  if (/\+(\d+) Mana on Kill/.test(stat)) bonuses.manaOnKill += parseInt(RegExp.$1);
  if (/\+(\d+)% Attack Speed/.test(stat)) bonuses.attackSpeed += parseInt(RegExp.$1);
  if (/\+(\d+)% Cast Speed/.test(stat)) bonuses.castSpeed += parseInt(RegExp.$1);
  if (/\+(\d+)% Spell Damage/.test(stat)) bonuses.spellDamage += parseInt(RegExp.$1);
  if (/\+(\d+)% Cooldown Recovery/.test(stat)) bonuses.cooldownRecovery += parseInt(RegExp.$1);
  if (/\+(\d+)% Area of Effect/.test(stat)) bonuses.areaOfEffect += parseInt(RegExp.$1);
  if (/\+(\d+)% Movement Speed/.test(stat)) bonuses.movementSpeed += parseInt(RegExp.$1);
  if (/\+(\d+) Projectile/.test(stat)) bonuses.projectiles += parseInt(RegExp.$1);
  
  // Negative modifiers
  if (/-(\d+)% Dodge/.test(stat)) bonuses.dodge -= parseInt(RegExp.$1);
  if (/-(\d+)% Projectile Damage/.test(stat)) bonuses.projectileDamageReduction += parseInt(RegExp.$1);
  if (/-(\d+)% Life/.test(stat)) bonuses.lifeReduction += parseInt(RegExp.$1);
  
  // Special keystones
  if (stat.includes('Armor has no diminishing returns')) bonuses.armorNodiminishing = true;
  if (stat.includes('Dodge is set to 0')) bonuses.dodgeZero = true;
  if (stat.includes('Life on Hit doubled')) bonuses.lifeOnHitDouble = true;
  if (stat.includes('Mana on Hit disabled')) bonuses.manaOnHitDisabled = true;
  if (stat.includes('Dodge capped at 50%')) bonuses.dodgeCap50 = true;
  if (stat.includes('Dodge capped at 40%')) bonuses.dodgeCap40 = true;
  if (stat.includes('Gain +2% Move Speed each second')) bonuses.momentumBonus = true;
  if (stat.includes('Shield is consumed before Mana')) bonuses.shieldBeforeMana = true;
  if (stat.includes('Mana regeneration disabled')) bonuses.manaRegenDisabled = true;
  if (/\+(\d+)% Shield capacity/.test(stat)) bonuses.shieldCapIncrease += parseInt(RegExp.$1);
  if (/Shield recharge delay \+(\d+)%/.test(stat)) bonuses.shieldDelayIncrease += parseInt(RegExp.$1);
  if (stat.includes('Gain Armor equal to your Dodge')) bonuses.armorFromDodge = true;
  if (stat.includes('Gain Dodge equal to')) bonuses.dodgeFromArmor = true;
  if (/All damage increased by (\d+)%/.test(stat)) bonuses.damageIncreaseAll += parseInt(RegExp.$1);
  if (stat.includes('Damage Reduction set to 0')) bonuses.damageReductionZero = true;
  if (stat.includes('Can only equip 2 active skills')) bonuses.skillLimit = 2;
  if (/Active skills deal (\d+)% more damage/.test(stat)) bonuses.skillDamageBonus += parseInt(RegExp.$1);
  if (/Hybrid armor bases gain \+(\d+)%/.test(stat)) bonuses.hybridDefenseBonus += parseInt(RegExp.$1);
  if (stat.includes('After dodging, immune')) bonuses.spectralImmunity = true;
  if (stat.includes('boosts primary skill')) bonuses.battleRhythm = true;
  if (/Armor applies at (\d+)% effectiveness to elemental/.test(stat)) bonuses.armorElemental += parseInt(RegExp.$1);
  if (/Armor and Shield increased by (\d+)%/.test(stat)) {
    bonuses.armorPercent += parseInt(RegExp.$1);
    bonuses.shieldPercent += parseInt(RegExp.$1);
  }
  if (/Life reduced by (\d+)%/.test(stat)) bonuses.lifeReduction += parseInt(RegExp.$1);
  if (stat.includes('Shield recharges 20% faster')) bonuses.shieldRechargeBonus = 20;
  if (/\+(\d+)% Shield from Armor/.test(stat)) bonuses.shieldFromArmor = parseInt(RegExp.$1);
}

// Generate item modifiers based on rarity using slot-specific pools
function generateItemMods(rarity, itemName, modCount = null, ilvl = 1) {
  // Legacy function - uses default constraints
  return generateItemModsWithTier(rarity, itemName, ilvl, null);
}

// Generate item mods with drop tier constraints
function generateItemModsWithTier(rarity, itemName, ilvl, dropTier) {
  const mods = { implicit: null, prefixes: [], suffixes: [] };
  const slot = getItemSlot(itemName);
  
  // If slot is invalid (null), return empty mods with warning
  if (!slot) {
    console.warn('generateItemMods: Cannot generate mods for invalid item: ' + itemName);
    return mods;
  }
  
  // Flasks and jewels don't have standard affixes
  if (slot === 'flask' || slot === 'jewel') {
    return mods;
  }
  
  // Get constraints from drop tier (or use defaults)
  const constraints = dropTier !== null ? getDropTierConstraints(dropTier) : 
    { worstAffix: 8, minMods: 1, maxMods: 6, tierBias: 1.0 };
  
  // Track used mod stat types to prevent duplicates
  const usedModStats = new Set();
  
  // Helper to generate a unique mod with tier constraints
  function generateUniqueMod(isPrefix) {
    let attempts = 0;
    while (attempts < 20) {
      const mod = generateModWithConstraints(isPrefix, slot, itemName, ilvl, constraints);
      if (!mod) return null;
      const baseStat = mod.stat.replace(/#/g, '').trim();
      if (!usedModStats.has(baseStat)) {
        usedModStats.add(baseStat);
        return mod;
      }
      attempts++;
    }
    return generateModWithConstraints(isPrefix, slot, itemName, ilvl, constraints);
  }
  
  // Normal items ALWAYS have implicit, others 40% chance
  if (rarity === 'normal' || Math.random() < 0.4) {
    mods.implicit = generateImplicit(itemName);
  }
  
  // Determine mod count based on drop tier constraints
  if (rarity === 'normal') {
    // Normal items have no affixes
    return mods;
  } else if (rarity === 'magic') {
    // Magic: 1-2 mods, constrained by drop tier
    const minMods = Math.min(constraints.minMods, 2);
    const maxMods = Math.min(constraints.maxMods, 2);
    const targetMods = Math.max(1, Math.floor(Math.random() * (maxMods - minMods + 1)) + minMods);
    
    if (targetMods === 1) {
      if (Math.random() < 0.5) mods.prefixes.push(generateUniqueMod(true));
      else mods.suffixes.push(generateUniqueMod(false));
    } else {
      mods.prefixes.push(generateUniqueMod(true));
      mods.suffixes.push(generateUniqueMod(false));
    }
  } else if (rarity === 'rare') {
    // Rare: 2-6 mods total, constrained by drop tier
    const minMods = Math.max(2, constraints.minMods);
    const maxMods = Math.min(6, constraints.maxMods);
    const totalMods = Math.floor(Math.random() * (maxMods - minMods + 1)) + minMods;
    
    // Split between prefixes and suffixes (max 3 each)
    let numPrefixes = Math.floor(Math.random() * Math.min(3, totalMods)) + 1;
    let numSuffixes = totalMods - numPrefixes;
    
    // Ensure suffix count is valid
    if (numSuffixes > 3) {
      numPrefixes += numSuffixes - 3;
      numSuffixes = 3;
    }
    if (numSuffixes < 1) {
      numSuffixes = 1;
      numPrefixes = totalMods - 1;
    }
    
    for (let i = 0; i < numPrefixes; i++) mods.prefixes.push(generateUniqueMod(true));
    for (let i = 0; i < numSuffixes; i++) mods.suffixes.push(generateUniqueMod(false));
  }
  
  // Filter out any null mods
  mods.prefixes = mods.prefixes.filter(m => m !== null);
  mods.suffixes = mods.suffixes.filter(m => m !== null);
  
  return mods;
}

// Generate a mod with tier constraints from drop tier
function generateModWithConstraints(isPrefix, slot, itemName, ilvl, constraints) {
  if (!slot || !SLOT_MODS[slot]) {
    return null;
  }
  
  let pool = SLOT_MODS[slot];
  let mods = isPrefix ? [...pool.prefixes] : [...pool.suffixes];
  
  // Add weapon-type specific mods
  if (slot === 'weapon') {
    const wepType = getWeaponType(itemName);
    const isSpell = isSpellWeapon(itemName);
    
    if (isSpell) {
      if (isPrefix) {
        mods = [...mods, ...WEAPON_PREFIXES_STAFF];
        mods = mods.filter(m => {
          const stat = m.stat || '';
          if (stat.includes('Physical Damage') && !stat.includes('to Spells')) return false;
          if (stat.includes('Projectile Damage')) return false;
          return true;
        });
      } else {
        mods = mods.filter(m => !m.stat.includes('Attack Speed'));
        mods = [...mods, ...WEAPON_SUFFIXES_STAFF];
      }
    } else {
      mods = mods.filter(m => {
        const stat = m.stat || '';
        if (stat.includes('Spell Damage')) return false;
        if (stat.includes('to Spells')) return false;
        if (stat.includes('Cast Speed')) return false;
        return true;
      });
    }
    
    if (isPrefix) mods = [...mods, ...WEAPON_PREFIXES_SKILLS];
  }
  
  // Add physical damage to attacks for STR/DEX gloves
  if (slot === 'gloves' && isPrefix) {
    const baseType = getArmorBaseType(itemName);
    if (['str', 'dex', 'str_dex'].includes(baseType)) {
      mods = [...mods, GLOVES_PHYS_PREFIX];
    }
  }
  
  // Filter defense mods by base type
  if (['helmet', 'gloves', 'boots'].includes(slot)) {
    const baseType = getArmorBaseType(itemName);
    mods = mods.filter(m => {
      const stat = m.stat || '';
      const isArmorMod = stat.includes('Armor');
      const isDodgeMod = stat.includes('Dodge');
      const isShieldMod = stat.includes('Shield') && !stat.includes('Shield Wall');
      
      if (!isArmorMod && !isDodgeMod && !isShieldMod) return true;
      
      if (baseType === 'str') return isArmorMod;
      if (baseType === 'dex') return isDodgeMod;
      if (baseType === 'int') return isShieldMod;
      if (baseType === 'str_dex') return isArmorMod || isDodgeMod;
      if (baseType === 'str_int') return isArmorMod || isShieldMod;
      if (baseType === 'dex_int') return isDodgeMod || isShieldMod;
      return true;
    });
  }
  
  // Filter by item level (minimum tier allowed)
  const minTierByIlvl = getMinTierForItemLevel(ilvl);
  mods = mods.filter(m => m.tier >= minTierByIlvl);
  
  // Filter by drop tier constraints (worst affix allowed)
  // E.g., T5 drop tier means worst affix is T2, so filter out T3+
  mods = mods.filter(m => m.tier <= constraints.worstAffix);
  
  if (mods.length === 0) {
    // Fallback if no valid mods
    mods = isPrefix ? pool.prefixes : pool.suffixes;
    mods = mods.filter(m => m.tier >= minTierByIlvl);
  }
  
  if (mods.length === 0) return null;
  
  // Apply tier bias - weight toward better (lower) tiers
  // Higher bias = more likely to get better tiers
  const tierBias = constraints.tierBias || 1.0;
  
  // Weight mods: lower tier = higher weight when bias > 1
  const weightedMods = mods.map(mod => {
    // Tier 1 = best, Tier 8 = worst
    // With bias 2.0: T1 gets weight 16, T8 gets weight 2
    const weight = Math.pow(9 - mod.tier, tierBias);
    return { mod, weight };
  });
  
  const totalWeight = weightedMods.reduce((sum, w) => sum + w.weight, 0);
  let roll = Math.random() * totalWeight;
  
  let selectedMod = weightedMods[0].mod;
  for (const w of weightedMods) {
    roll -= w.weight;
    if (roll <= 0) {
      selectedMod = w.mod;
      break;
    }
  }
  
  const value1 = Math.floor(Math.random() * (selectedMod.max - selectedMod.min + 1)) + selectedMod.min;
  let value2 = null;
  if (selectedMod.min2 !== undefined) {
    value2 = Math.floor(Math.random() * (selectedMod.max2 - selectedMod.min2 + 1)) + selectedMod.min2;
  }
  
  return {
    ...selectedMod,
    value1,
    value2,
    text: selectedMod.stat.replace('#', value1).replace('#', value2 || '')
  };
}

// Stash currency data - 10 of each for testing
const stash = {
  // DEMO: Start with 1 of each basic core only
  // Basic currency
  transmute: 1, augment: 1, upgrade: 0,
  // Advanced currency  
  wild: 0, rare: 0, echo: 0, annul: 0, vaal: 0,
  // Quality
  armorer: 1, whetstone: 1,
  // Sockets
  jeweller: 1
};

// Gem drops - these go to gemInventory, not stash
const GEM_DROP_TABLE = ['gem-haste', 'gem-iron', 'gem-flame', 'gem-frost', 'gem-storm'];

// Currency drop tables by enemy type
const CURRENCY_DROPS = {
  common: ['transmute', 'augment', 'armorer', 'whetstone', 'jeweller'],
  uncommon: ['upgrade'],
  rare: ['wild', 'upgrade', 'annul'],
  boss: ['rare', 'echo', 'vaal', 'annul'],
  unique: ['echo', 'rare']
};

// Gemcutter's Prism drop chance by enemy type
// Gems are purchased from shop with gold, prisms drop from enemies
const PRISM_DROP_CHANCES = {
  common: 0.002,   // 0.2%
  uncommon: 0.005, // 0.5%
  rare: 0.01,      // 1%
  boss: 0.05,      // 5%
  unique: 0.10     // 10%
};

// Alt key tracking for advanced tooltip info
let altPressed = false;

// Keyboard handler
// Helper function to simulate keypress from button clicks
function pressKey(code) {
  switch(code) {
    case 'KeyI': toggleInventory(); break;
    case 'KeyC': toggleCharPanel(); break;
    case 'KeyS': toggleShop(); break;
    case 'Tab': toggleStash(); break;
    case 'Escape': togglePauseMenu(); break;
  }
}

// Toggle pause/hotkey menu
function togglePauseMenu() {
  toggleHotkeyMenu();
}

document.addEventListener('keydown', (e) => {
  // Ignore hotkeys when typing in input fields
  if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA' || e.target.isContentEditable) {
    return;
  }
  
  if (e.key === 'Alt') {
    altPressed = true;
    // Refresh any visible tooltip
    refreshTooltipIfVisible();
  } else if (e.key === 'i' || e.key === 'I') {
    toggleInventory();
  } else if (e.key === 'a' || e.key === 'A') {
    // DEMO: Aspects disabled
    e.preventDefault();
    showToast('🔒', 'Coming Soon!', 'Aspects will be available in the full version', 'info');
  } else if (e.key === 'c' || e.key === 'C') {
    toggleCharPanel();
  } else if (e.key === 'p' || e.key === 'P') {
    // DEMO: Passives disabled
    showToast('🔒', 'Coming Soon!', 'Passive Tree will be available in the full version', 'info');
  } else if (e.key === 's' || e.key === 'S') {
    toggleShop();
  } else if (e.key === 'd' || e.key === 'D') {
    toggleDungeonSelector();
  } else if (e.key === 'r' || e.key === 'R') {
    // Disengage from Rift Surge or Echo Domain
    if (riftSurgeActive) {
      endRiftSurge(true);  // voluntary disengage
    } else if (echoDomainActive) {
      leaveEchoDomain();  // Leave with rewards
    }
  } else if (e.key === 'g' || e.key === 'G') {
    // Debug mode moved to G key
    debugMode = !debugMode;
    addLog(`Debug mode: ${debugMode ? 'ON' : 'OFF'}`, 'skill');
  } else if (e.key === 'l' || e.key === 'L') {
    toggleLeaderboard();
  } else if (e.key === 'F1') {
    e.preventDefault();
    toggleStatsDashboard();
  } else if (e.key === 't' || e.key === 'T') {
    testMode = !testMode;
    if (testMode) {
      // Store original stats and set test mode stats
      player._origLevel = player.level;
      player._origMinDmg = player.minDmg;
      player._origMaxDmg = player.maxDmg;
      player.level = 1;
      player.minDmg = 0;
      player.maxDmg = 0;
      player.mana = player.maxMana;
      addLog(`TEST MODE ON - Invincible, No Dmg, ∞ Mana, No Auto-Attack/Skills`, 'skill');
    } else {
      // Restore original stats
      if (player._origLevel) player.level = player._origLevel;
      if (player._origMinDmg) player.minDmg = player._origMinDmg;
      if (player._origMaxDmg) player.maxDmg = player._origMaxDmg;
      addLog(`TEST MODE OFF - Stats restored`, 'skill');
    }
  } else if (e.key === 'e' || e.key === 'E') {
    // Force enter portal (for debugging/testing)
    if (exitPos && !enteringPortal) {
      const exitDist = Math.hypot(exitPos.x - player.x, exitPos.y - player.y);
      const allCleared = map.rooms.every(r => r.cleared);
      if (allCleared && exitDist < TILE * 10) {  // Very generous range for manual entry
        enteringPortal = true;
        if (!greaterRiftActive) {
          dungeon.level++;
          addLog(`Manually entering level ${dungeon.level}...`, 'skill');
          
          // Steam integration: dungeon cleared achievement
          onDungeonCleared_Steam(currentDifficulty);
        } else {
          addLog(`Entering next rift floor...`, 'skill');
        }
        path = [];
        particles = [];
        skillProjectiles = [];
        damageNumbers = [];
        cycloneActive = false;
        cycloneTimer = 0;
        player.state = 'idle';
        setTimeout(() => {
          generateDungeon();
          camera.x = player.x;
          camera.y = player.y;
          camera.shake = 0;
          enteringPortal = false;
          // Greater Rifts don't spawn new enemies on floor transitions - fixed enemy pool
        }, 100);
      } else if (!allCleared) {
        addLog('Clear all rooms first!', 'warning');
      } else {
        addLog('Get closer to the exit portal!', 'warning');
      }
    }
  } else if (e.key === 'k' || e.key === 'K') {
    // Kill all enemies in current room (debug tool)
    const killed = enemies.filter(e => e.active && !e.dead);
    killed.forEach(e => {
      e.dead = true;
      e.hp = 0;
    });
    addLog(`Killed ${killed.length} enemies`, 'skill');
    // Clear path to find new target
    path = [];
    pathTarget = null;
  } else if (e.key === 'Tab') {
    e.preventDefault();
    toggleStash();
  } else if (e.key === 'Escape') {
    // If skill upgrade modal is open, don't close it with escape (must click button)
    const skillModal = document.getElementById('skillUpgradeModal');
    if (skillModal && skillModal.style.display === 'flex') {
      // Don't allow escape to close this - must click a button
      return;
    }
    // If Greater Rift modal is open, close it
    const grModal = document.getElementById('greaterRiftModal');
    if (grModal && grModal.style.display === 'flex') {
      closeGreaterRiftModal();
    }
    // If skill selector is open, close it
    else if (skillSelectorOpen) {
      closeSkillSelector();
    }
    // If dungeon selector is open, close it
    else if (dungeonSelectorOpen) {
      closeDungeonSelector();
    }
    // If hotkey menu is open, close it
    else if (hotkeyMenuOpen) {
      toggleHotkeyMenu();
    }
    // If passive tree is open, close it
    else if (passiveTreeOpen) {
      togglePassiveTree();
    }
    // If any panel is open, close them
    else if (inventoryOpen || stashOpen || charPanelOpen || shopOpen) {
      if (inventoryOpen) toggleInventory();
      if (stashOpen) toggleStash();
      if (charPanelOpen) toggleCharPanel();
      if (shopOpen) toggleShop();
    }
    // Otherwise, open the hotkey menu
    else {
      toggleHotkeyMenu();
    }
  } else if (e.key === '1') {
    useSkillSlot(0);
  } else if (e.key === '2') {
    useSkillSlot(1);
  } else if (e.key === '3') {
    useSkillSlot(2);
  } else if (e.key === '4') {
    useSkillSlot(3);
  } else if (e.key === '5') {
    useSkillSlot(4);
  } else if (e.key === 'q' || e.key === 'Q') {
    useLifePotion();
  } else if (e.key === 'w' || e.key === 'W') {
    useManaPotion();
  }
});

document.addEventListener('keyup', (e) => {
  if (e.key === 'Alt') {
    altPressed = false;
    refreshTooltipIfVisible();
  }
});

// Store current tooltip item for refresh
let currentTooltipItem = null;
let currentTooltipEvent = null;

function refreshTooltipIfVisible() {
  const tooltip = document.getElementById('itemTooltip');
  if (tooltip.classList.contains('visible') && currentTooltipItem) {
    // Re-render tooltip with same item
    showTooltipContent(currentTooltipItem);
  }
}

// Stash tab switching
document.querySelectorAll('.stash-tab').forEach(tab => {
  tab.addEventListener('click', () => {
    const tabName = tab.dataset.tab;
    document.querySelectorAll('.stash-tab').forEach(t => t.classList.remove('active'));
    document.querySelectorAll('.stash-tab-content').forEach(c => c.classList.remove('active'));
    tab.classList.add('active');
    document.getElementById('tab-' + tabName).classList.add('active');
  });
});

function toggleStash() {
  stashOpen = !stashOpen;
  const panel = document.getElementById('stashPanel');
  
  if (stashOpen) {
    // Always switch to Loot tab when opening stash
    activeStashTab = 'overflow';
    panel.style.display = '';  // Clear any inline display:none from returnToMainMenu
    panel.classList.add('visible');
    renderStashTabs();
    switchStashTab('overflow'); // Force loot tab
    updateCurrencyDisplay();
    updateCurrencyStates(craftingItem);
  } else {
    panel.classList.remove('visible');
    hideTooltip();  // Hide tooltip when closing stash
    // Clear overflow mode when closing stash
    if (overflowMode) {
      overflowMode = null;
      const moveModeBtn = document.getElementById('overflowMoveMode');
      const salvageModeBtn = document.getElementById('overflowSalvageMode');
      const indicator = document.getElementById('overflowModeIndicator');
      if (moveModeBtn) moveModeBtn.classList.remove('active');
      if (salvageModeBtn) salvageModeBtn.classList.remove('active', 'salvage');
      if (indicator) indicator.classList.remove('visible', 'salvage');
    }
  }
  updateHotkeyLegend();
}

function toggleCharPanel() {
  charPanelOpen = !charPanelOpen;
  const panel = document.getElementById('charPanel');
  
  if (charPanelOpen) {
    panel.style.display = '';  // Clear any inline display:none from returnToMainMenu
    panel.classList.add('visible');
    updateCharPanel();
  } else {
    panel.classList.remove('visible');
  }
  updateHotkeyLegend();
}

// ============ LEADERBOARD SYSTEM ============
let leaderboardOpen = false;
let leaderboardFilter = 'all';

// Leaderboard data (populated from Steam)
let leaderboardData = [];

function toggleLeaderboard() {
  leaderboardOpen = !leaderboardOpen;
  const panel = document.getElementById('leaderboardPanel');
  
  if (leaderboardOpen) {
    panel.classList.add('visible');
    
    // Load from Steam if available
    loadSteamLeaderboard();
  } else {
    panel.classList.remove('visible');
  }
}

// Load Steam leaderboard
async function loadSteamLeaderboard() {
  const status = document.getElementById('leaderboardStatus');
  const tbody = document.getElementById('leaderboardTableBody');
  
  if (window.steamapi) {
    try {
      const isLoaded = await window.steamapi.isLoaded();
      if (isLoaded) {
        // Update status
        if (status) {
          status.textContent = '⏳ Loading leaderboard...';
          status.style.color = '#8af';
        }
        
        // Get global leaderboard from Steam
        const result = await window.steam.getLeaderboardScores(
          window.STEAM_LEADERBOARDS.HIGHEST_LEVEL, 
          0, 100, 'Global'
        );
        
        if (result && result.success && result.entries && result.entries.length > 0) {
          // Convert Steam entries to our format
          leaderboardData = result.entries.map((entry, idx) => ({
            rank: entry.rank || (idx + 1),
            name: entry.name || `Player`,
            playerClass: 'unknown',
            level: entry.score,
            isSelf: entry.isCurrentUser || false
          }));
          
          updateLeaderboardDisplay();
          
          if (status) {
            status.textContent = '✅ Connected to Steam Leaderboard';
            status.style.color = '#8f8';
          }
          return;
        } else {
          // No entries yet
          leaderboardData = [];
          updateLeaderboardDisplay();
          if (status) {
            status.textContent = '📊 No leaderboard entries yet - be the first!';
            status.style.color = '#c9a050';
          }
          return;
        }
      }
    } catch (e) {
      console.error('Steam leaderboard error:', e);
    }
  }
  
  // Steam not available
  leaderboardData = [];
  if (tbody) {
    tbody.innerHTML = `
      <div style="text-align:center; padding: 40px 20px; color: #888;">
        <div style="font-size: 48px; margin-bottom: 15px;">🎮</div>
        <div style="font-size: 14px; color: #aaa; margin-bottom: 10px;">Steam Integration Required</div>
        <div style="font-size: 12px; color: #666;">Launch through Steam to view and submit to leaderboards</div>
      </div>
    `;
  }
  if (status) {
    status.textContent = '⚠️ Requires Steam to view leaderboards';
    status.style.color = '#c88';
  }
}

function setLeaderboardFilter(filter) {
  leaderboardFilter = filter;
  
  // Update button states
  document.querySelectorAll('.leaderboard-filter').forEach(btn => {
    btn.classList.toggle('active', btn.dataset.filter === filter);
  });
  
  updateLeaderboardDisplay();
}

function updateLeaderboardDisplay() {
  const tbody = document.getElementById('leaderboardTableBody');
  if (!tbody) return;
  
  // Filter data
  let filtered = leaderboardData;
  if (leaderboardFilter !== 'all') {
    filtered = leaderboardData.filter(e => e.playerClass === leaderboardFilter);
    // Recalculate ranks for filtered view
    filtered.forEach((entry, idx) => {
      entry.filteredRank = idx + 1;
    });
  }
  
  const classIcons = {
    warrior: '⚔️',
    monk: '🥋',
    ranger: '🏹',
    mage: '🔮'
  };
  
  const classNames = {
    warrior: 'Warrior',
    monk: 'Monk',
    ranger: 'Ranger',
    mage: 'Mage'
  };
  
  let html = '';
  const displayData = filtered.slice(0, 50); // Show top 50
  
  displayData.forEach((entry) => {
    const rank = leaderboardFilter === 'all' ? entry.rank : entry.filteredRank;
    const rankClass = rank === 1 ? 'gold' : rank === 2 ? 'silver' : rank === 3 ? 'bronze' : '';
    const rowClass = entry.isSelf ? 'self' : (rank <= 3 ? 'top-3' : '');
    
    html += `
      <div class="leaderboard-row ${rowClass}">
        <span class="lb-rank ${rankClass}">${rank}.</span>
        <div class="lb-name">
          <div class="lb-avatar">${classIcons[entry.playerClass] || '👤'}</div>
          <span class="lb-player-name">${entry.name}${entry.isSelf ? ' (You)' : ''}</span>
        </div>
        <span class="lb-class">${classNames[entry.playerClass] || 'Unknown'}</span>
        <span class="lb-level">${entry.level}</span>
      </div>
    `;
  });
  
  tbody.innerHTML = html;
  
  // Update status
  const status = document.getElementById('leaderboardStatus');
  if (status) {
    status.textContent = '⚠️ Steam integration required for online leaderboards';
  }
  
  const lastUpdate = document.getElementById('leaderboardLastUpdate');
  if (lastUpdate) {
    lastUpdate.textContent = `Showing: ${filtered.length} entries (Mock Data)`;
  }
}

function updateSkillsPanel() {
  // Skills panel removed - function kept for compatibility
}

// Update skill cooldown visual displays
function updateSkillCooldownDisplays() {
  for (let i = 0; i < 5; i++) {
    const skillId = equippedSkills[i];
    const skill = SKILLS[skillId];
    const slot = document.getElementById(`skill-slot-${i}`);
    const cdOverlay = slot?.querySelector('.skill-cd');
    const cdText = document.getElementById(`skill-cd-text-${i}`);
    
    if (!slot || !skill) continue;
    
    let cdPercent = 0;
    let cdSeconds = 0;
    let onCooldown = false;
    
    // Primary skills (slot 0) use player attack/cast cooldown
    if (skill.isPrimary) {
      if (skill.isSpell) {
        // Spell primaries use cast cooldown (now in seconds)
        if ((player.castCD || 0) > 0) {
          const maxCastCD = 1.0 / (player.castSpd || 1);  // Max cooldown in seconds
          cdPercent = (player.castCD / maxCastCD) * 100;
          cdSeconds = player.castCD;  // Already in seconds
          onCooldown = true;
        }
      } else {
        // Attack primaries use attack cooldown (now in seconds)
        if (player.atkCD > 0) {
          const maxAtkCD = 1.0 / player.atkSpd;  // Max cooldown in seconds
          cdPercent = (player.atkCD / maxAtkCD) * 100;
          cdSeconds = player.atkCD;  // Already in seconds
          onCooldown = true;
        }
      }
    } else {
      // Regular skills use their own cooldown (now in seconds)
      if (skill.cooldown > 0) {
        const maxCDSeconds = skill.maxCooldown / 60;  // Convert maxCooldown from frames to seconds
        cdPercent = (skill.cooldown / maxCDSeconds) * 100;
        cdSeconds = skill.cooldown;  // Already in seconds
        onCooldown = true;
      }
    }
    
    // Update visual overlay
    if (cdOverlay) {
      cdOverlay.style.height = cdPercent + '%';
    }
    
    // Update cooldown text
    if (cdText) {
      if (onCooldown && cdSeconds > 0.1) {
        cdText.textContent = cdSeconds.toFixed(1);
      } else {
        cdText.textContent = '';
      }
    }
    
    // Update slot class
    if (onCooldown) {
      slot.classList.add('on-cooldown');
    } else {
      slot.classList.remove('on-cooldown');
    }
    
    // Check mana for non-primary skills
    if (!skill.isPrimary && player.mana < skill.manaCost) {
      slot.classList.add('no-mana');
    } else {
      slot.classList.remove('no-mana');
    }
  }
}

function getTierColor(tier) {
  const colors = { 1: '#888', 2: '#5a5', 3: '#55f', 4: '#a5a', 5: '#fa5' };
  return colors[tier] || '#888';
}

function equipSkillGem(skillId, tier) {
  // Find an empty slot or the slot with same skill
  let targetSlot = -1;
  
  // First check if we have this skill already equipped
  for (let i = 0; i < 5; i++) {
    if (equippedSkillGems[i].skill === skillId) {
      targetSlot = i;
      break;
    }
  }
  
  if (targetSlot === -1) {
    // Find first slot to replace (just use slot 0 for now)
    targetSlot = 0;
  }
  
  // Return old gem to inventory
  const oldGem = equippedSkillGems[targetSlot];
  if (skillGemInventory[oldGem.skill]) {
    skillGemInventory[oldGem.skill][oldGem.tier] = (skillGemInventory[oldGem.skill][oldGem.tier] || 0) + 1;
  }
  
  // Remove new gem from inventory
  skillGemInventory[skillId][tier]--;
  
  // Equip new gem
  equippedSkillGems[targetSlot] = { skill: skillId, tier: tier };
  
  addLog(`Equipped ${SKILL_GEM_DATA[skillId].name} T${tier}!`, 'loot');
  updateSkillsPanel();
}

function cycleSkillGem(slotIndex) {
  // Cycle through available gems for this slot
  const currentGem = equippedSkillGems[slotIndex];
  const skillId = currentGem.skill;
  
  // Check if we have a higher tier gem available
  for (let tier = currentGem.tier + 1; tier <= 5; tier++) {
    if (skillGemInventory[skillId]?.[tier] > 0) {
      // Swap
      skillGemInventory[skillId][currentGem.tier]++;
      skillGemInventory[skillId][tier]--;
      equippedSkillGems[slotIndex] = { skill: skillId, tier: tier };
      addLog(`Upgraded ${SKILL_GEM_DATA[skillId].name} to T${tier}!`, 'loot');
      updateSkillsPanel();
      return;
    }
  }
  
  // Loop back to tier 1 if we have it
  for (let tier = 1; tier < currentGem.tier; tier++) {
    if (skillGemInventory[skillId]?.[tier] > 0) {
      skillGemInventory[skillId][currentGem.tier]++;
      skillGemInventory[skillId][tier]--;
      equippedSkillGems[slotIndex] = { skill: skillId, tier: tier };
      addLog(`Changed ${SKILL_GEM_DATA[skillId].name} to T${tier}`, 'loot');
      updateSkillsPanel();
      return;
    }
  }
  
  addLog(`No other ${SKILL_GEM_DATA[skillId].name} gems available`, 'warning');
}

function updateCharPanel() {
  // Calculate total stats from equipped items
  let fireRes = 0, coldRes = 0, lightRes = 0, natureRes = 0;
  let bonusLifeOnHit = 0, bonusManaOnHit = 0;
  let bonusShield = 0, bonusDodge = 0;
  let bonusCritChance = 0, bonusCritDmg = 0;
  let bonusPhysDmgPct = 0, bonusEleDmgPct = 0;
  let bonusMoveSpeed = 0, bonusCastSpeed = 0;
  let bonusCDR = 0, bonusFlaskCharges = 0;
  let bonusAtkSpeed = 0;
  
  // Sum up stats from all equipped items
  Object.values(equipment).forEach(item => {
    if (!item || !item.mods) return;
    const allMods = [
      ...(item.mods.prefixes || []),
      ...(item.mods.suffixes || []),
      item.mods.implicit
    ].filter(Boolean);
    
    for (const mod of allMods) {
      if (!mod.stat) continue;
      const val = mod.value1 || 0;
      // Resistances
      if (mod.stat.includes('Fire Resistance')) fireRes += val;
      if (mod.stat.includes('Cold Resistance')) coldRes += val;
      if (mod.stat.includes('Lightning Resistance')) lightRes += val;
      if (mod.stat.includes('Nature Resistance')) natureRes += val;
      // On-hit
      if (mod.stat.includes('Life gained on Hit')) bonusLifeOnHit += val;
      if (mod.stat.includes('Mana gained on Hit')) bonusManaOnHit += val;
      // Defense
      if (mod.stat.includes('Shield')) bonusShield += val;
      if (mod.stat.includes('Dodge')) bonusDodge += val;
      // Crit
      if (mod.stat.includes('Critical Strike Chance')) bonusCritChance += val;
      if (mod.stat.includes('Critical Strike Damage') || mod.stat.includes('Critical Damage')) bonusCritDmg += val;
      // Damage
      if (mod.stat.includes('Physical Damage')) bonusPhysDmgPct += val;
      if (mod.stat.includes('Elemental Damage')) bonusEleDmgPct += val;
      // Utility
      if (mod.stat.includes('Movement Speed')) bonusMoveSpeed += val;
      if (mod.stat.includes('Cast Speed')) bonusCastSpeed += val;
      if (mod.stat.includes('Cooldown Recovery')) bonusCDR += val;
      if (mod.stat.includes('Flask Charges')) bonusFlaskCharges += val;
      if (mod.stat.includes('Attack Speed')) bonusAtkSpeed += val;
    }
  });
  
  // Calculate capped resistances (70% cap per spec)
  const capRes = (val) => Math.min(70, val);
  
  // Update UI - Character name and level
  const charName = (selectedCharacter !== null && characters[selectedCharacter]) 
    ? characters[selectedCharacter].name 
    : 'Exile';
  document.getElementById('charName').textContent = charName;
  document.getElementById('charLevelNum').textContent = player.level;
  
  // Attributes - show actual values and highlight primary stat
  const primaryStat = CLASS_PRIMARY_STAT[player.class] || 'dex';
  
  const charStrEl = document.getElementById('charStr');
  const charDexEl = document.getElementById('charDex');
  const charIntEl = document.getElementById('charInt');
  
  charStrEl.textContent = player.str;
  charDexEl.textContent = player.dex;
  charIntEl.textContent = player.int;
  
  // Highlight primary stat
  charStrEl.style.color = primaryStat === 'str' ? '#ffd700' : '';
  charDexEl.style.color = primaryStat === 'dex' ? '#ffd700' : '';
  charIntEl.style.color = primaryStat === 'int' ? '#ffd700' : '';
  
  // Core stats
  document.getElementById('charLife').textContent = player.maxHp;
  document.getElementById('charMana').textContent = player.maxMana;
  document.getElementById('charArmor').textContent = player.armor;
  document.getElementById('charDamage').textContent = `${player.minDmg}-${player.maxDmg}`;
  
  // Defense stats - use actual player dodge rating and shield
  document.getElementById('charShield').textContent = player.shield;
  const estimatedDodge = Math.floor(getEstimatedDodgeChance());
  document.getElementById('charDodge').textContent = `${estimatedDodge}%`;
  document.getElementById('charAtkSpd').textContent = player.atkSpd.toFixed(2);
  
  // Resistances (show capped and uncapped)
  document.getElementById('charFireRes').textContent = capRes(fireRes) + '%';
  document.getElementById('charFireResUncapped').textContent = `(${fireRes}%)`;
  document.getElementById('charColdRes').textContent = capRes(coldRes) + '%';
  document.getElementById('charColdResUncapped').textContent = `(${coldRes}%)`;
  document.getElementById('charLightRes').textContent = capRes(lightRes) + '%';
  document.getElementById('charLightResUncapped').textContent = `(${lightRes}%)`;
  document.getElementById('charNatureRes').textContent = capRes(natureRes) + '%';
  document.getElementById('charNatureResUncapped').textContent = `(${natureRes}%)`;
  
  // On-hit stats
  document.getElementById('charLifeOnHit').textContent = '+' + (player.lifeOnHit + bonusLifeOnHit);
  document.getElementById('charManaOnHit').textContent = '+' + (player.manaOnHit + bonusManaOnHit);
  
  // Offense stats
  document.getElementById('charCritChance').textContent = (5 + bonusCritChance) + '%';
  document.getElementById('charCritDmg').textContent = (150 + bonusCritDmg) + '%';
  document.getElementById('charPhysDmgPct').textContent = bonusPhysDmgPct + '%';
  document.getElementById('charEleDmgPct').textContent = bonusEleDmgPct + '%';
  
  // Utility stats
  document.getElementById('charMoveSpeed').textContent = (100 + bonusMoveSpeed) + '%';
  document.getElementById('charCastSpeed').textContent = bonusCastSpeed + '%';
  document.getElementById('charCDR').textContent = bonusCDR + '%';
  document.getElementById('charFlaskCharges').textContent = bonusFlaskCharges + '%';
  
  // Level badge
  document.getElementById('charLevelBadge').textContent = `Level ${player.level} Exile`;
  
  // Update inline equipment panel stats
  const eqStr = document.getElementById('eqStr');
  const eqDex = document.getElementById('eqDex');
  const eqInt = document.getElementById('eqInt');
  const eqDamage = document.getElementById('eqDamage');
  const eqAtkSpd = document.getElementById('eqAtkSpd');
  const eqCritChance = document.getElementById('eqCritChance');
  const eqCritDmg = document.getElementById('eqCritDmg');
  const eqArmor = document.getElementById('eqArmor');
  const eqDodge = document.getElementById('eqDodge');
  const eqShield = document.getElementById('eqShield');
  const eqLife = document.getElementById('eqLife');
  const eqMana = document.getElementById('eqMana');
  const eqLifeOnHit = document.getElementById('eqLifeOnHit');
  const eqManaOnHit = document.getElementById('eqManaOnHit');
  const eqMoveSpd = document.getElementById('eqMoveSpd');
  const eqFireRes = document.getElementById('eqFireRes');
  const eqColdRes = document.getElementById('eqColdRes');
  const eqLightRes = document.getElementById('eqLightRes');
  const eqNatureRes = document.getElementById('eqNatureRes');
  
  if (eqStr) {
    eqStr.textContent = player.str;
    eqStr.style.color = primaryStat === 'str' ? '#ffd700' : '#d4c4a0';
  }
  if (eqDex) {
    eqDex.textContent = player.dex;
    eqDex.style.color = primaryStat === 'dex' ? '#ffd700' : '#d4c4a0';
  }
  if (eqInt) {
    eqInt.textContent = player.int;
    eqInt.style.color = primaryStat === 'int' ? '#ffd700' : '#d4c4a0';
  }
  if (eqDamage) eqDamage.textContent = `${player.minDmg}-${player.maxDmg}`;
  if (eqAtkSpd) eqAtkSpd.textContent = player.atkSpd.toFixed(2);
  if (eqCritChance) eqCritChance.textContent = (5 + bonusCritChance) + '%';
  if (eqCritDmg) eqCritDmg.textContent = (150 + bonusCritDmg) + '%';
  if (eqArmor) eqArmor.textContent = player.armor;
  if (eqDodge) eqDodge.textContent = `${estimatedDodge}%`;
  if (eqShield) eqShield.textContent = player.shield;
  if (eqLife) eqLife.textContent = player.maxHp;
  if (eqMana) eqMana.textContent = player.maxMana;
  if (eqLifeOnHit) eqLifeOnHit.textContent = player.lifeOnHit;
  if (eqManaOnHit) eqManaOnHit.textContent = player.manaOnHit;
  if (eqMoveSpd) eqMoveSpd.textContent = (100 + bonusMoveSpeed) + '%';
  if (eqFireRes) eqFireRes.textContent = capRes(fireRes) + '%';
  if (eqColdRes) eqColdRes.textContent = capRes(coldRes) + '%';
  if (eqLightRes) eqLightRes.textContent = capRes(lightRes) + '%';
  if (eqNatureRes) eqNatureRes.textContent = capRes(natureRes) + '%';
}

// Resistance tooltip functions
const RES_TOOLTIP_DATA = {
  fire: {
    title: 'Fire Resistance',
    desc: 'Reduces the Fire portion of enemy damage. Cap: 75%. Most enemies deal mixed damage - Cultists, Demons, and Bandits all deal Fire damage alongside physical.'
  },
  cold: {
    title: 'Cold Resistance', 
    desc: 'Reduces the Cold portion of enemy damage. Cap: 75%. Undead like Skeletons, Specters, and Wraiths deal Cold damage alongside physical.'
  },
  lightning: {
    title: 'Lightning Resistance',
    desc: 'Reduces the Lightning portion of enemy damage. Cap: 75%. Dark Mages and Golems deal Lightning damage alongside physical.'
  },
  nature: {
    title: 'Nature Resistance',
    desc: 'Reduces the Nature portion of enemy damage. Cap: 75%. Beasts like Spiders, Slimes, and Zombies deal Nature (poison) damage alongside physical.'
  }
};

function showResTooltip(type, event) {
  const tooltip = document.getElementById('resTooltip');
  const data = RES_TOOLTIP_DATA[type];
  if (!data) return;
  
  document.getElementById('resTooltipTitle').textContent = data.title;
  document.getElementById('resTooltipDesc').textContent = data.desc;
  
  tooltip.classList.add('visible');
  
  // Position tooltip near the mouse
  const margin = 15;
  const screenPadding = 10;
  let x = event.clientX + margin;
  let y = event.clientY - margin;
  
  tooltip.style.left = x + 'px';
  tooltip.style.top = y + 'px';
  
  // Keep on screen - use requestAnimationFrame for accurate rect
  requestAnimationFrame(() => {
    const tooltipRect = tooltip.getBoundingClientRect();
    
    // Check right edge
    if (tooltipRect.right > window.innerWidth - screenPadding) {
      tooltip.style.left = (event.clientX - tooltipRect.width - margin) + 'px';
    }
    // Check left edge after adjustment
    if (parseFloat(tooltip.style.left) < screenPadding) {
      tooltip.style.left = screenPadding + 'px';
    }
    
    // Check bottom edge
    if (tooltipRect.bottom > window.innerHeight - screenPadding) {
      tooltip.style.top = (window.innerHeight - tooltipRect.height - screenPadding) + 'px';
    }
    // Check top edge
    if (parseFloat(tooltip.style.top) < screenPadding) {
      tooltip.style.top = screenPadding + 'px';
    }
  });
}

function hideResTooltip() {
  document.getElementById('resTooltip').classList.remove('visible');
}

// Stat tooltip data for character panel
const STAT_TOOLTIP_DATA = {
  life: {
    title: 'Life',
    desc: 'Your maximum health pool. When Life reaches zero, you die. Increased by level and +Life modifiers on equipment.'
  },
  health: {
    title: 'Maximum Health',
    desc: 'Your maximum health pool. Increased by leveling up and by +Life modifiers on equipment.'
  },
  mana: {
    title: 'Mana',
    desc: 'Resource used to cast skills. Restored by Mana on Hit, Mana on Kill, and Potions. Increased by +Mana modifiers.'
  },
  damage: {
    title: 'Damage',
    desc: 'The damage range for your basic attacks. Modified by weapon damage, % increased damage, flat added damage, and your primary stat.'
  },
  atkspd: {
    title: 'Attack Speed',
    desc: 'How many attacks per second you perform. Higher attack speed means more damage and more Life/Mana on Hit triggers.'
  },
  armor: {
    title: 'Armor',
    desc: 'Reduces physical damage using diminishing returns formula. Strong vs small hits, weak vs big hits. Bosses deal mostly elemental - you need RESISTS!'
  },
  dodge: {
    title: 'Dodge Rating',
    desc: 'Chance to evade attacks using diminishing returns. Higher rating = more dodges. Bosses and Elites have high accuracy, making them harder to dodge. Stack Resists first!'
  },
  shield: {
    title: 'Shield',
    desc: 'Additional protection layer. Increased by Intelligence (+1 per 5 INT). Absorbs damage before Life.'
  }
};

// Get dynamic tooltip data for attributes
function getAttributeTooltip(attr) {
  const primaryStat = CLASS_PRIMARY_STAT[player.class] || 'dex';
  const isPrimary = primaryStat === attr;
  
  if (attr === 'str') {
    const armorBonus = Math.floor(player.str / 10);
    const dmgBonus = isPrimary ? Math.floor(player.str / 50) : 0;
    return {
      title: 'Strength',
      lines: [
        { text: `Current: ${player.str}`, color: isPrimary ? '#ffd700' : '#c0a070' },
        { text: `+${armorBonus} Armor`, color: '#cc9966', sub: '(+1 per 10 STR)' },
        isPrimary ? { text: `+${dmgBonus}% Damage`, color: '#ff8866', sub: '(Primary Stat: +1% per 50)' } : null,
        !isPrimary ? { text: 'Not your primary stat', color: '#666666' } : null
      ].filter(Boolean)
    };
  } else if (attr === 'dex') {
    const dodgeRating = Math.floor(player.dex * 1.5);
    const estimatedDodge = Math.floor(getEstimatedDodgeChance());
    const dmgBonus = isPrimary ? Math.floor(player.dex / 50) : 0;
    return {
      title: 'Dexterity',
      lines: [
        { text: `Current: ${player.dex}`, color: isPrimary ? '#ffd700' : '#c0a070' },
        { text: `+${dodgeRating} Dodge Rating`, color: '#66cccc', sub: '(+1.5 per DEX)' },
        { text: `~${estimatedDodge}% Dodge vs current enemies`, color: '#448888', sub: '(reduced vs bosses)' },
        isPrimary ? { text: `+${dmgBonus}% Damage`, color: '#ff8866', sub: '(Primary Stat: +1% per 50)' } : null,
        !isPrimary ? { text: 'Not your primary stat', color: '#666666' } : null
      ].filter(Boolean)
    };
  } else if (attr === 'int') {
    const shieldBonus = Math.floor(player.int / 5);
    const dmgBonus = isPrimary ? Math.floor(player.int / 50) : 0;
    return {
      title: 'Intelligence',
      lines: [
        { text: `Current: ${player.int}`, color: isPrimary ? '#ffd700' : '#c0a070' },
        { text: `+${shieldBonus} Shield`, color: '#8888ff', sub: '(+1 per 5 INT)' },
        isPrimary ? { text: `+${dmgBonus}% Damage`, color: '#ff8866', sub: '(Primary Stat: +1% per 50)' } : null,
        !isPrimary ? { text: 'Not your primary stat', color: '#666666' } : null
      ].filter(Boolean)
    };
  }
  return null;
}

function showStatTooltip(type, event) {
  const tooltip = document.getElementById('resTooltip');
  
  // Check if it's an attribute type
  if (type === 'str' || type === 'dex' || type === 'int') {
    const attrData = getAttributeTooltip(type);
    if (!attrData) return;
    
    document.getElementById('resTooltipTitle').textContent = attrData.title;
    
    // Build multi-line description
    let descHtml = '';
    for (const line of attrData.lines) {
      descHtml += `<div style="color:${line.color};margin:4px 0;">`;
      descHtml += line.text;
      if (line.sub) {
        descHtml += `<span style="color:#666;font-size:10px;margin-left:4px;">${line.sub}</span>`;
      }
      descHtml += '</div>';
    }
    document.getElementById('resTooltipDesc').innerHTML = descHtml;
    document.querySelector('.res-tooltip-cap').style.display = 'none';
  } else {
    const data = STAT_TOOLTIP_DATA[type];
    if (!data) return;
    
    document.getElementById('resTooltipTitle').textContent = data.title;
    document.getElementById('resTooltipDesc').textContent = data.desc;
    document.querySelector('.res-tooltip-cap').style.display = 'none';
  }
  
  tooltip.classList.add('visible');
  
  const margin = 15;
  const screenPadding = 10;
  let x = event.clientX + margin;
  let y = event.clientY - margin;
  
  tooltip.style.left = x + 'px';
  tooltip.style.top = y + 'px';
  
  // Keep on screen - use requestAnimationFrame for accurate rect
  requestAnimationFrame(() => {
    const tooltipRect = tooltip.getBoundingClientRect();
    
    // Check right edge
    if (tooltipRect.right > window.innerWidth - screenPadding) {
      tooltip.style.left = (event.clientX - tooltipRect.width - margin) + 'px';
    }
    // Check left edge
    if (parseFloat(tooltip.style.left) < screenPadding) {
      tooltip.style.left = screenPadding + 'px';
    }
    
    // Check bottom edge
    if (tooltipRect.bottom > window.innerHeight - screenPadding) {
      tooltip.style.top = (window.innerHeight - tooltipRect.height - screenPadding) + 'px';
    }
    // Check top edge
    if (parseFloat(tooltip.style.top) < screenPadding) {
      tooltip.style.top = screenPadding + 'px';
    }
  });
}

function hideStatTooltip() {
  document.getElementById('resTooltip').classList.remove('visible');
  document.querySelector('.res-tooltip-cap').style.display = 'block';
}

// ============ HEALTH/MANA BAR TOOLTIPS ============
let barTooltipTimeout = null;

function showHealthTooltip(event) {
  // Clear any pending hide
  if (barTooltipTimeout) {
    clearTimeout(barTooltipTimeout);
    barTooltipTimeout = null;
  }
  
  const tooltip = document.getElementById('barTooltip');
  const titleEl = document.getElementById('barTooltipTitle');
  const contentEl = document.getElementById('barTooltipContent');
  
  // Build title with current values
  const totalEHP = player.maxHp + player.shield;
  const currentEHP = Math.floor(player.hp) + Math.floor(player.currentShield);
  titleEl.innerHTML = `<span class="name" style="color:#4a4;">Life & Shield</span><span class="current" style="color:#aaa;">${currentEHP}/${totalEHP}</span>`;
  
  // Build content
  let html = '';
  
  // Life section
  html += '<div class="bar-tooltip-section">';
  html += '<div class="bar-tooltip-section-title" style="color:#4a4;">Life</div>';
  
  const baseLife = 80;
  const levelLife = player.level * 8;
  
  // Calculate equipment life bonus
  let equipLife = 0;
  for (const item of Object.values(equipment)) {
    if (!item || !item.mods) continue;
    const allMods = [...(item.mods.prefixes || []), ...(item.mods.suffixes || []), item.mods.implicit].filter(Boolean);
    for (const mod of allMods) {
      if (mod.stat && mod.stat.includes('maximum Life')) equipLife += mod.value1 || 0;
    }
  }
  
  html += `<div class="bar-tooltip-row"><span class="label">Base</span><span class="value" style="color:#6a6;">${baseLife}</span></div>`;
  html += `<div class="bar-tooltip-row"><span class="label">Level ${player.level}</span><span class="value" style="color:#6a6;">+${levelLife}</span></div>`;
  if (equipLife > 0) {
    html += `<div class="bar-tooltip-row"><span class="label">Equipment</span><span class="value" style="color:#6a6;">+${equipLife}</span></div>`;
  }
  html += `<div class="bar-tooltip-row total"><span class="label">Maximum Life</span><span class="value" style="color:#4a4;">${player.maxHp}</span></div>`;
  html += '</div>';
  
  // Shield section (only if player has shield)
  if (player.shield > 0) {
    html += '<div class="bar-tooltip-section">';
    html += '<div class="bar-tooltip-section-title" style="color:#88f;">Shield</div>';
    
    const intShield = Math.floor(player.int / 5);
    
    // Calculate equipment shield
    let equipShield = 0;
    for (const item of Object.values(equipment)) {
      if (!item) continue;
      if (item.baseShield) equipShield += item.baseShield;
    }
    
    html += `<div class="bar-tooltip-row"><span class="label">Intelligence (${player.int})</span><span class="value" style="color:#aaf;">+${intShield}</span></div>`;
    if (equipShield > 0) {
      html += `<div class="bar-tooltip-row"><span class="label">Equipment</span><span class="value" style="color:#aaf;">+${equipShield}</span></div>`;
    }
    html += `<div class="bar-tooltip-row total"><span class="label">Maximum Shield</span><span class="value" style="color:#88f;">${player.shield}</span></div>`;
    html += '</div>';
    
    // Recharge status
    if (player.currentShield < player.shield) {
      if (player.shieldRechargeDelay > 0) {
        html += `<div class="bar-tooltip-status" style="color:#888;">⏳ Recharge in ${player.shieldRechargeDelay.toFixed(1)}s</div>`;
      } else {
        html += `<div class="bar-tooltip-status" style="color:#8af;">⚡ Recharging...</div>`;
      }
    }
  }
  
  // Recovery info
  html += '<div class="bar-tooltip-section" style="margin-top:8px;padding-top:8px;border-top:1px solid #333;">';
  html += `<div class="bar-tooltip-row"><span class="label">Life on Hit</span><span class="value" style="color:#6a6;">+${player.lifeOnHit}</span></div>`;
  html += '</div>';
  
  contentEl.innerHTML = html;
  
  // Position and show
  tooltip.classList.add('visible');
  positionBarTooltip(tooltip, event);
}

function showManaTooltip(event) {
  // Clear any pending hide
  if (barTooltipTimeout) {
    clearTimeout(barTooltipTimeout);
    barTooltipTimeout = null;
  }
  
  const tooltip = document.getElementById('barTooltip');
  const titleEl = document.getElementById('barTooltipTitle');
  const contentEl = document.getElementById('barTooltipContent');
  
  // Build title
  titleEl.innerHTML = `<span class="name" style="color:#48a;">Mana</span><span class="current" style="color:#aaa;">${Math.floor(player.mana)}/${player.maxMana}</span>`;
  
  // Build content
  let html = '';
  
  html += '<div class="bar-tooltip-section">';
  html += '<div class="bar-tooltip-section-title" style="color:#48a;">Mana Pool</div>';
  
  const baseMana = 40;
  const levelMana = player.level * 4;
  
  // Calculate equipment mana bonus
  let equipMana = 0;
  for (const item of Object.values(equipment)) {
    if (!item || !item.mods) continue;
    const allMods = [...(item.mods.prefixes || []), ...(item.mods.suffixes || []), item.mods.implicit].filter(Boolean);
    for (const mod of allMods) {
      if (mod.stat && mod.stat.includes('maximum Mana')) equipMana += mod.value1 || 0;
    }
  }
  
  html += `<div class="bar-tooltip-row"><span class="label">Base</span><span class="value" style="color:#6af;">${baseMana}</span></div>`;
  html += `<div class="bar-tooltip-row"><span class="label">Level ${player.level}</span><span class="value" style="color:#6af;">+${levelMana}</span></div>`;
  if (equipMana > 0) {
    html += `<div class="bar-tooltip-row"><span class="label">Equipment</span><span class="value" style="color:#6af;">+${equipMana}</span></div>`;
  }
  html += `<div class="bar-tooltip-row total"><span class="label">Maximum Mana</span><span class="value" style="color:#48a;">${player.maxMana}</span></div>`;
  html += '</div>';
  
  // Recovery info
  html += '<div class="bar-tooltip-section" style="margin-top:8px;padding-top:8px;border-top:1px solid #333;">';
  html += `<div class="bar-tooltip-row"><span class="label">Mana on Hit</span><span class="value" style="color:#6af;">+${player.manaOnHit}</span></div>`;
  html += '</div>';
  
  contentEl.innerHTML = html;
  
  // Position and show
  tooltip.classList.add('visible');
  positionBarTooltip(tooltip, event);
}

function positionBarTooltip(tooltip, event) {
  const screenPadding = 10;
  
  // Position above the bar
  const rect = event.currentTarget.getBoundingClientRect();
  
  tooltip.style.left = rect.left + 'px';
  tooltip.style.top = (rect.top - 10) + 'px';
  tooltip.style.transform = 'translateY(-100%)';
  
  // Wait a frame for render, then adjust
  requestAnimationFrame(() => {
    const tooltipRect = tooltip.getBoundingClientRect();
    
    // Adjust X position
    if (tooltipRect.left < screenPadding) {
      tooltip.style.left = screenPadding + 'px';
    } else if (tooltipRect.right > window.innerWidth - screenPadding) {
      tooltip.style.left = (window.innerWidth - tooltipRect.width - screenPadding) + 'px';
    }
    
    // Check if tooltip goes off top of screen
    if (tooltipRect.top < screenPadding) {
      // Show below the bar instead
      tooltip.style.top = (rect.bottom + 10) + 'px';
      tooltip.style.transform = 'translateY(0)';
      
      // Check if it now goes off bottom
      const newRect = tooltip.getBoundingClientRect();
      if (newRect.bottom > window.innerHeight - screenPadding) {
        tooltip.style.top = (window.innerHeight - tooltipRect.height - screenPadding) + 'px';
      }
    }
  });
}

function hideBarTooltip() {
  // Small delay to prevent flicker when moving between bars
  barTooltipTimeout = setTimeout(() => {
    document.getElementById('barTooltip').classList.remove('visible');
    barTooltipTimeout = null;
  }, 50);
}

function switchStashTab(tabName) {
  hideTooltip();  // Hide any visible tooltip when switching tabs
  activeStashTab = tabName;
  
  // Find the tab to determine its type
  const tab = stashTabs.find(t => t.id === tabName);
  const isItemsTab = tab && tab.type === 'items';
  const isOverflowTab = tab && tab.type === 'overflow';
  
  // Update tab buttons
  document.querySelectorAll('.stash-tab').forEach(tabEl => {
    tabEl.classList.toggle('active', tabEl.dataset.tab === tabName);
  });
  
  // Update tab content - all items tabs share the same grid (tab-stash)
  document.querySelectorAll('.stash-tab-content').forEach(content => {
    if (isItemsTab) {
      // For items tabs, show the stash grid
      content.classList.toggle('active', content.id === 'tab-stash');
    } else {
      // For currency/overflow tabs, show their specific content
      content.classList.toggle('active', content.id === 'tab-' + tabName);
    }
  });
  
  // Update displays based on tab type
  if (isItemsTab) {
    updateStashDisplay();
  } else if (isOverflowTab) {
    updateOverflowDisplay();
  } else if (tabName === 'currency') {
    updateCurrencyStates(craftingItem);
  }
}

// Render stash tabs dynamically
function renderStashTabs() {
  const tabsRow = document.getElementById('stashTabsRow');
  if (!tabsRow) return;
  
  tabsRow.innerHTML = '';
  
  stashTabs.forEach(tab => {
    const tabEl = document.createElement('div');
    let tabClass = 'stash-tab';
    if (tab.type === 'currency') tabClass += ' currency';
    else if (tab.type === 'overflow') tabClass += ' overflow';
    else tabClass += ' stash-main';
    if (activeStashTab === tab.id) tabClass += ' active';
    tabEl.className = tabClass;
    tabEl.dataset.tab = tab.id;
    tabEl.innerHTML = tab.name;
    
    // Add overflow badge
    if (tab.type === 'overflow' && overflowItems.length > 0) {
      const badge = document.createElement('span');
      badge.className = 'overflow-badge';
      if (overflowItems.length >= overflowCapacity) {
        badge.classList.add('full');
      } else if (overflowItems.length >= overflowCapacity * 0.8) {
        badge.classList.add('warning');
      }
      badge.textContent = overflowItems.length;
      tabEl.appendChild(badge);
    }
    
    // Click to switch tab
    tabEl.onclick = () => switchStashTab(tab.id);
    
    // Add tooltip for renaming (not for currency or overflow)
    if (tab.type !== 'currency' && tab.type !== 'overflow') {
      tabEl.title = 'Right-click or double-click to rename';
    }
    
    // Double-click to rename
    tabEl.ondblclick = (e) => {
      e.preventDefault();
      e.stopPropagation();
      if (tab.type !== 'currency' && tab.type !== 'overflow') {
        openTabRename(tab.id);
      }
    };
    
    // Right-click to rename
    tabEl.oncontextmenu = (e) => {
      e.preventDefault();
      if (tab.type !== 'currency' && tab.type !== 'overflow') {
        openTabRename(tab.id);
      }
    };
    
    tabsRow.appendChild(tabEl);
  });
}

// ========== LOOT TAB SYSTEM ==========
// Update overflow display
function updateOverflowDisplay() {
  const listEl = document.getElementById('overflowList');
  const capacityEl = document.getElementById('overflowCapacity');
  
  if (!listEl) return;
  
  // Update capacity display
  if (capacityEl) {
    capacityEl.textContent = `${overflowItems.length} / ${overflowCapacity}`;
    capacityEl.className = 'overflow-capacity';
    if (overflowItems.length >= overflowCapacity) {
      capacityEl.classList.add('full');
    } else if (overflowItems.length >= overflowCapacity * 0.8) {
      capacityEl.classList.add('warning');
    }
  }
  
  // Update badge in tab
  renderStashTabs();
  
  // Render items list
  if (overflowItems.length === 0) {
    listEl.innerHTML = `
      <div class="overflow-empty">
        <div class="overflow-empty-icon">📦</div>
        <div>Overflow is empty</div>
        <div style="margin-top: 8px; font-size: 11px; color: #555;">Items go here when inventory & stash are full</div>
      </div>
    `;
    return;
  }
  
  listEl.innerHTML = '';
  
  overflowItems.forEach((item, idx) => {
    const dropTier = calculateDropTier(item);
    const tierVisuals = getDropTierVisuals(dropTier);
    
    const itemEl = document.createElement('div');
    itemEl.className = `overflow-item ${item.rarity}`;
    if (item.isNew) {
      itemEl.classList.add('new');
      // Remove new flag after animation
      setTimeout(() => { item.isNew = false; }, 600);
    }
    
    // Get icon
    const icon = item.image 
      ? `<img src="${item.image}" onerror="this.parentElement.innerHTML='${getItemIcon(item.name)}'">`
      : getItemIcon(item.name);
    
    // Count mods
    const mods = item.mods || {};
    const modCount = (mods.prefixes?.length || 0) + (mods.suffixes?.length || 0);
    const socketCount = item.sockets?.length || 0;
    
    let statsText = '';
    if (modCount > 0) statsText += `${modCount} mods`;
    if (socketCount > 0) statsText += (statsText ? ' · ' : '') + `${socketCount} sockets`;
    
    // Quality badge - show stars instead of T1-T5 to avoid confusion with Affix Tiers
    const tierBadge = `<span class="overflow-item-tier t${dropTier}">${tierVisuals.stars}</span>`;
    
    itemEl.innerHTML = `
      <div class="overflow-item-icon">${icon}</div>
      <div class="overflow-item-info">
        <div class="overflow-item-name ${item.rarity}">${item.name}</div>
        <div class="overflow-item-stats">${statsText || 'No mods'}</div>
      </div>
      ${tierBadge}
    `;
    
    // Hover for tooltip
    itemEl.onmouseenter = (e) => showOverflowItemTooltip(item, e);
    itemEl.onmouseleave = hideTooltip;
    itemEl.onmousemove = (e) => {
      const tooltip = document.getElementById('itemTooltip');
      if (tooltip.classList.contains('visible')) {
        const tooltipRect = tooltip.getBoundingClientRect();
        const padding = 15;
        let x = e.clientX + 15;
        let y = e.clientY + 10;
        
        // Check right edge
        if (x + tooltipRect.width + padding > window.innerWidth) {
          x = e.clientX - tooltipRect.width - 15;
        }
        // Check bottom edge
        if (y + tooltipRect.height + padding > window.innerHeight) {
          y = window.innerHeight - tooltipRect.height - padding;
        }
        // Keep on screen
        x = Math.max(padding, x);
        y = Math.max(padding, y);
        
        tooltip.style.left = x + 'px';
        tooltip.style.top = y + 'px';
      }
    };
    
    // Right-click context menu
    itemEl.oncontextmenu = (e) => {
      e.preventDefault();
      showOverflowContextMenu(idx, item, e);
    };
    
    // Left-click behavior based on current mode
    itemEl.onclick = () => handleOverflowItemClick(idx);
    
    listEl.appendChild(itemEl);
  });
}

// Show tooltip for overflow item
function showOverflowItemTooltip(item, event) {
  const tooltip = document.getElementById('itemTooltip');
  const header = document.getElementById('tooltipHeader');
  const name = document.getElementById('tooltipName');
  const type = document.getElementById('tooltipType');
  const body = document.getElementById('tooltipBody');
  
  header.className = 'tooltip-header ' + item.rarity;
  name.className = 'tooltip-name ' + item.rarity;
  name.textContent = item.name;
  type.textContent = getItemType(item.name);
  
  body.innerHTML = buildItemTooltipHTML(item);
  tooltip.classList.add('visible');
  
  // Position tooltip with screen boundary detection
  const tooltipRect = tooltip.getBoundingClientRect();
  const padding = 15;
  let x = event.clientX + 15;
  let y = event.clientY + 10;
  
  // Check right edge
  if (x + tooltipRect.width + padding > window.innerWidth) {
    x = event.clientX - tooltipRect.width - 15;
  }
  
  // Check bottom edge
  if (y + tooltipRect.height + padding > window.innerHeight) {
    y = window.innerHeight - tooltipRect.height - padding;
  }
  
  // Keep on screen
  x = Math.max(padding, x);
  y = Math.max(padding, y);
  
  tooltip.style.left = x + 'px';
  tooltip.style.top = y + 'px';
}

// Toggle overflow mode (move/salvage)
function toggleOverflowMode(mode) {
  const moveModeBtn = document.getElementById('overflowMoveMode');
  const salvageModeBtn = document.getElementById('overflowSalvageMode');
  const indicator = document.getElementById('overflowModeIndicator');
  
  // If clicking the same mode, turn it off
  if (overflowMode === mode) {
    overflowMode = null;
    moveModeBtn.classList.remove('active');
    salvageModeBtn.classList.remove('active', 'salvage');
    indicator.classList.remove('visible', 'salvage');
    return;
  }
  
  // Set new mode
  overflowMode = mode;
  
  // Update button states
  moveModeBtn.classList.toggle('active', mode === 'move');
  salvageModeBtn.classList.toggle('active', mode === 'salvage');
  salvageModeBtn.classList.toggle('salvage', mode === 'salvage');
  
  // Update indicator
  indicator.classList.add('visible');
  indicator.classList.toggle('salvage', mode === 'salvage');
  indicator.textContent = mode === 'move' ? '📥 Click items to move to inventory' : '♻️ Click items to salvage';
}

// Handle overflow item click based on mode
function handleOverflowItemClick(idx) {
  if (overflowMode === 'move') {
    moveOverflowItemToInventory(idx);
  } else if (overflowMode === 'salvage') {
    salvageOverflowItem(idx);
  } else {
    // Default: move to inventory
    moveOverflowItemToInventory(idx);
  }
}

// Add item to overflow
function addToOverflow(item) {
  // Calculate tier for the new item
  const newTier = calculateDropTier(item);
  
  if (overflowItems.length >= overflowCapacity) {
    // Overflow full - find the lowest tier item
    let worstIdx = 0;
    let worstTier = calculateDropTier(overflowItems[0]);
    
    for (let i = 1; i < overflowItems.length; i++) {
      const tier = calculateDropTier(overflowItems[i]);
      if (tier < worstTier) {
        worstTier = tier;
        worstIdx = i;
      }
    }
    
    // Only add if new item is better than the worst
    if (newTier > worstTier) {
      const removed = overflowItems[worstIdx];
      overflowItems.splice(worstIdx, 1);
      salvageItem(removed, true); // Silent salvage
      addLog(`Loot tab: Replaced T${worstTier} ${removed.name} with T${newTier} ${item.name}`, 'loot');
    } else {
      // New item isn't better - salvage it instead
      salvageItem(item, true);
      addLog(`Loot tab full - salvaged T${newTier} ${item.name}`, 'warning');
      return; // Don't add to overflow
    }
  } else if (overflowItems.length === Math.floor(overflowCapacity * 0.8)) {
    // Warning at 80% capacity
    addLog(`⚠️ Loot tab nearing capacity (${overflowItems.length + 1}/${overflowCapacity})`, 'warning');
  }
  
  item.isNew = true; // Mark for pulse animation
  overflowItems.push(item);
  
  // Sort overflow by tier (best at top, T5 first)
  sortOverflowByTier();
  
  addLog(`→ Loot tab: T${newTier} ${item.name}`, 'loot');
  updateOverflowDisplay();
}

// Sort overflow items by drop tier (best first)
function sortOverflowByTier() {
  overflowItems.sort((a, b) => {
    const tierA = calculateDropTier(a);
    const tierB = calculateDropTier(b);
    if (tierB !== tierA) return tierB - tierA; // Higher tier first
    // Same tier - sort by rarity as tiebreaker
    const rarityOrder = { unique: 0, rare: 1, magic: 2, normal: 3 };
    return (rarityOrder[a.rarity] || 3) - (rarityOrder[b.rarity] || 3);
  });
}

// Move single item from overflow to inventory
function moveOverflowItemToInventory(idx) {
  const item = overflowItems[idx];
  if (!item) return;
  
  const w = item.width || 1;
  const h = item.height || 1;
  const pos = findPositionForItem(w, h);
  
  if (!pos) {
    showToast('📦', 'Inventory Full', 'Make room in your inventory first', 'warning');
    return;
  }
  
  // Remove from overflow
  overflowItems.splice(idx, 1);
  
  // Add to inventory
  placeItemOnGrid(item, pos.x, pos.y);
  inventoryItems.push(item);
  
  addLog(`Moved ${item.name} to inventory`, 'loot');
  updateOverflowDisplay();
  updateInventoryDisplay();
}

// Show a toast notification
let toastTimeout = null;
function showToast(icon, title, message, type = 'info') {
  const toast = document.getElementById('toastNotification');
  const toastIcon = document.getElementById('toastIcon');
  const toastTitle = document.getElementById('toastTitle');
  const toastMessage = document.getElementById('toastMessage');
  
  // Clear any existing timeout
  if (toastTimeout) {
    clearTimeout(toastTimeout);
  }
  
  // Set content
  toastIcon.textContent = icon;
  toastTitle.textContent = title;
  toastMessage.textContent = message;
  
  // Set type class
  toast.className = 'toast-notification ' + type;
  
  // Show with slight delay for re-trigger animation
  toast.classList.remove('visible');
  setTimeout(() => {
    toast.classList.add('visible');
  }, 10);
  
  // Auto-hide after 3 seconds
  toastTimeout = setTimeout(() => {
    toast.classList.remove('visible');
  }, 3000);
}

// Move all overflow items to inventory
function moveAllOverflowToInventory() {
  if (overflowItems.length === 0) {
    showToast('📦', 'Overflow Empty', 'No items to move', 'info');
    return;
  }
  
  let moved = 0;
  let failed = 0;
  
  // Move items by tier priority (T5 first, since overflow is sorted best→worst)
  // Iterate from start and rebuild array with items that couldn't fit
  const remaining = [];
  for (const item of overflowItems) {
    const w = item.width || 1;
    const h = item.height || 1;
    const pos = findPositionForItem(w, h);
    
    if (pos) {
      placeItemOnGrid(item, pos.x, pos.y);
      inventoryItems.push(item);
      moved++;
    } else {
      remaining.push(item);
      failed++;
    }
  }
  
  overflowItems = remaining;
  
  if (moved > 0 && failed === 0) {
    showToast('✅', 'Items Moved', `Moved ${moved} item${moved > 1 ? 's' : ''} to inventory`, 'info');
  } else if (moved > 0 && failed > 0) {
    showToast('⚠️', 'Partial Move', `Moved ${moved}, ${failed} couldn't fit`, 'warning');
  } else if (failed > 0) {
    showToast('📦', 'Inventory Full', 'No room for any items', 'warning');
  }
  
  updateOverflowDisplay();
  updateInventoryDisplay();
}

// Salvage single overflow item
function salvageOverflowItem(idx) {
  const item = overflowItems[idx];
  if (!item) return;
  
  overflowItems.splice(idx, 1);
  salvageItem(item, false);
  updateOverflowDisplay();
}

// Salvage all overflow items
function salvageAllOverflow() {
  if (overflowItems.length === 0) {
    addLog('Loot tab is empty', 'info');
    return;
  }
  
  const count = overflowItems.length;
  let totalGold = 0;
  let cores = { basic: 0, advanced: 0 };
  let totalGemsReturned = 0;
  
  overflowItems.forEach(item => {
    // Return socketed gems
    if (item.sockets && item.sockets.length > 0) {
      for (const socket of item.sockets) {
        if (socket.gem) {
          addGemToInventory(socket.gem, socket.gemQuality || 0);
          totalGemsReturned++;
        }
      }
    }
    
    // Roll salvage type: 94% gold, 5% base cores, 1% advanced cores
    const roll = Math.random() * 100;
    
    if (roll < 94) {
      // GOLD (94%)
      const goldValues = SALVAGE_GOLD_VALUES[item.rarity] || SALVAGE_GOLD_VALUES.normal;
      const starBonus = (item.dropTier || 1) * goldValues.perStar;
      const goldAmount = goldValues.base + starBonus + Math.floor(Math.random() * goldValues.perStar * 2);
      totalGold += goldAmount;
    } else if (roll < 99) {
      // BASE CORE (5%)
      const core = BASIC_CORES[Math.floor(Math.random() * BASIC_CORES.length)];
      stash[core] = (stash[core] || 0) + 1;
      cores.basic++;
    } else {
      // ADVANCED CORE (1%)
      const core = ADVANCED_CORES[Math.floor(Math.random() * ADVANCED_CORES.length)];
      stash[core] = (stash[core] || 0) + 1;
      cores.advanced++;
    }
  });
  
  // Add total gold
  player.gold = (player.gold || 0) + totalGold;
  
  // Track session stats
  sessionStats.itemsSalvaged += count;
  sessionStats.goldEarned += totalGold;
  sessionStats.coresEarned += cores.basic + cores.advanced;
  
  overflowItems = [];
  
  // Build summary message
  let msg = `Salvaged ${count} item${count > 1 ? 's' : ''}`;
  if (totalGold > 0) {
    msg += ` → 💰${totalGold}g`;
  }
  if (cores.basic > 0 || cores.advanced > 0) {
    msg += ` 🔵${cores.basic} ⭐${cores.advanced}`;
  }
  addLog(msg, 'loot');
  
  if (totalGemsReturned > 0) {
    addLog(`💎 ${totalGemsReturned} gem(s) returned to inventory`, 'loot');
  }
  
  updateOverflowDisplay();
  updateCurrencyDisplay();
  updateGemInventoryDisplay();
}

// Context menu for overflow items
function showOverflowContextMenu(idx, item, event) {
  closeContextMenu(); // Close any existing menu
  
  // Check if item is equippable
  const slot = getItemSlot(item.name);
  const isEquippable = slot && slot !== 'unknown';
  
  const menu = document.getElementById('itemContextMenu');
  menu.innerHTML = `
    ${isEquippable ? `<div class="context-menu-item equip" onclick="equipFromOverflow(${idx}); closeContextMenu();">
      <span class="icon">⚔️</span> Equip
    </div>` : ''}
    <div class="context-menu-item craft" onclick="putOverflowItemInCraftingSlot(${idx}); closeContextMenu();">
      <span class="icon">🔧</span> Craft
    </div>
    <div class="context-menu-item" onclick="moveOverflowItemToStash(${idx}); closeContextMenu();">
      <span class="icon">📦</span> Move to Stash
    </div>
    <div class="context-menu-divider"></div>
    <div class="context-menu-item drop" onclick="salvageOverflowItem(${idx}); closeContextMenu();">
      <span class="icon">♻️</span> Salvage
    </div>
  `;
  
  menu.style.left = event.clientX + 'px';
  menu.style.top = event.clientY + 'px';
  menu.classList.add('visible');
  
  // Close menu when clicking elsewhere
  setTimeout(() => {
    document.addEventListener('click', closeContextMenu, { once: true });
  }, 10);
}

// Move overflow item to stash
function moveOverflowItemToStash(idx) {
  const item = overflowItems[idx];
  if (!item) return;
  
  const w = item.width || 1;
  const h = item.height || 1;
  const pos = findStashPosition(w, h);
  
  if (!pos) {
    showToast('📦', 'Stash Full', 'Make room in your stash first', 'warning');
    return;
  }
  
  // Remove from overflow
  overflowItems.splice(idx, 1);
  
  // Add to stash
  placeItemInStash(item, pos.x, pos.y);
  stashItems.push(item);
  
  addLog(`Moved ${item.name} to stash`, 'loot');
  updateOverflowDisplay();
  updateStashDisplay();
}

// Equip item directly from overflow
function equipFromOverflow(idx) {
  const item = overflowItems[idx];
  if (!item) return;
  
  const slot = getItemSlot(item.name);
  if (!slot || slot === 'unknown') {
    addLog(`Can't equip ${item.name}!`, 'warning');
    return;
  }
  
  // Handle ring slots (pick ring1 if empty, else ring2)
  let targetSlot = slot;
  if (slot === 'ring') {
    targetSlot = equipment.ring1 ? 'ring2' : 'ring1';
  }
  
  // Remove from overflow
  overflowItems.splice(idx, 1);
  
  // Swap with currently equipped item if any
  const oldItem = equipment[targetSlot];
  if (oldItem) {
    // Unregister old item's unique effect
    if (oldItem.isUnique && oldItem.uniqueId && UNIQUE_ITEMS[oldItem.uniqueId]?.onUnequip) {
      UNIQUE_ITEMS[oldItem.uniqueId].onUnequip(player);
    }
    // Put old item in overflow
    oldItem.isNew = true;
    overflowItems.push(oldItem);
  }
  
  // Equip new item
  equipment[targetSlot] = item;
  
  // Register new item's unique effect
  if (item.isUnique && item.uniqueId && UNIQUE_ITEMS[item.uniqueId]?.onEquip) {
    UNIQUE_ITEMS[item.uniqueId].onEquip(player);
  }
  
  addLog(`Equipped ${item.name}`, 'loot');
  updateOverflowDisplay();
  updateEquipmentDisplay();
  recalculateStats();
  updateStats();
  updateCharPanel(); // Update STR/DEX/INT/Damage display
}

// Put overflow item in crafting slot
function putOverflowItemInCraftingSlot(idx) {
  const item = overflowItems[idx];
  if (!item) return;
  
  // Remove from overflow
  overflowItems.splice(idx, 1);
  
  // Put previous crafting item back (to overflow since inventory might be full)
  if (craftingItem) {
    craftingItem.isNew = true;
    overflowItems.push(craftingItem);
  }
  
  craftingItem = item;
  craftingItemSource = 'overflow';
  
  // Switch to crafting tab
  switchStashTab('currency');
  updateCraftingSlot();
  updateOverflowDisplay();
}

function buyNewStashTab() {
  // Open the store modal instead of buying directly
  openStoreModal();
}

function openStoreModal() {
  const modal = document.getElementById('storeModal');
  modal.classList.add('visible');
  
  // Update gold display
  document.getElementById('storeGoldAmount').textContent = player.gold.toLocaleString();
  document.getElementById('storeCurrentOverflow').textContent = overflowCapacity;
}

function closeStoreModal() {
  const modal = document.getElementById('storeModal');
  modal.classList.remove('visible');
}

function purchaseStashTab() {
  const tabCost = 1000;
  
  if (player.gold < tabCost) {
    showToast('💰', 'Not Enough Gold', `Need ${tabCost.toLocaleString()}g (have ${player.gold.toLocaleString()}g)`, 'warning');
    return;
  }
  
  player.gold -= tabCost;
  stashTabCounter++;
  
  const newTab = {
    id: 'stash' + stashTabCounter,
    name: 'Tab ' + (stashTabs.length),
    type: 'items'
  };
  
  // Insert before currency tab
  const currencyIdx = stashTabs.findIndex(t => t.id === 'currency');
  if (currencyIdx >= 0) {
    stashTabs.splice(currencyIdx, 0, newTab);
  } else {
    stashTabs.push(newTab);
  }
  
  showToast('✅', 'Tab Purchased', `New stash tab: ${newTab.name}`, 'info');
  renderStashTabs();
  updateStats();
  
  // Update store display
  document.getElementById('storeGoldAmount').textContent = player.gold.toLocaleString();
}

function purchaseOverflowUpgrade() {
  const upgradeCost = 2500;
  
  if (player.gold < upgradeCost) {
    showToast('💰', 'Not Enough Gold', `Need ${upgradeCost.toLocaleString()}g (have ${player.gold.toLocaleString()}g)`, 'warning');
    return;
  }
  
  player.gold -= upgradeCost;
  overflowCapacity += 25;
  
  showToast('✅', 'Upgrade Purchased', `Overflow now holds ${overflowCapacity} items`, 'info');
  updateOverflowDisplay();
  updateStats();
  
  // Update store display
  document.getElementById('storeGoldAmount').textContent = player.gold.toLocaleString();
  document.getElementById('storeCurrentOverflow').textContent = overflowCapacity;
}

// ════════════════════════════════════════════════════════════════════════════════
// DUNGEON SELECTOR FUNCTIONS
// ════════════════════════════════════════════════════════════════════════════════

function openDungeonSelector() {
  dungeonSelectorOpen = true;
  const modal = document.getElementById('dungeonModal');
  modal.style.display = '';  // Clear any inline display:none from returnToMainMenu
  modal.classList.add('visible');
  renderDungeonOptions();
  updateDungeonCurrentDisplay();
  updateShardDisplay();  // Update shard counts
  setupShardTooltips();  // Setup tooltip listeners
}

function closeDungeonSelector() {
  dungeonSelectorOpen = false;
  const modal = document.getElementById('dungeonModal');
  modal.classList.remove('visible');
}

function toggleDungeonSelector() {
  if (dungeonSelectorOpen) {
    closeDungeonSelector();
  } else {
    openDungeonSelector();
  }
}

function updateDungeonCurrentDisplay() {
  const settings = getDungeonSettings();
  document.getElementById('currentDiffName').textContent = settings.name;
  document.getElementById('currentDiffIlvl').textContent = `${settings.ilvlMin}-${settings.ilvlMax}`;
}

function renderDungeonOptions() {
  const grid = document.getElementById('dungeonGrid');
  grid.innerHTML = '';
  
  for (const [key, diff] of Object.entries(DUNGEON_DIFFICULTIES)) {
    const unlocked = isDifficultyUnlocked(key);
    const selected = currentDifficulty === key;
    
    const option = document.createElement('div');
    option.className = `dungeon-option${selected ? ' selected' : ''}${!unlocked ? ' locked' : ''}`;
    option.style.borderColor = selected ? diff.color : '';
    
    if (unlocked) {
      option.onclick = () => selectDifficulty(key);
    }
    
    // Best tier text (lower = better)
    const tierText = `T${diff.bestTier}`;
    
    option.innerHTML = `
      <div class="dungeon-option-header">
        <span class="dungeon-option-icon">${diff.icon}</span>
        <span class="dungeon-option-name" style="color: ${diff.color}">${diff.name}</span>
      </div>
      <div class="dungeon-option-subtitle">${diff.subtitle}</div>
      <div class="dungeon-option-stats">
        <div class="dungeon-stat">Item Level:</div>
        <div class="dungeon-stat-value good">${diff.ilvlMin}-${diff.ilvlMax}</div>
        <div class="dungeon-stat">Best Affix:</div>
        <div class="dungeon-stat-value ${diff.bestTier <= 2 ? 'good' : ''}">${tierText}</div>
        <div class="dungeon-stat">Enemy HP:</div>
        <div class="dungeon-stat-value danger">${diff.enemyHpMult}x</div>
        <div class="dungeon-stat">Enemy Damage:</div>
        <div class="dungeon-stat-value danger">${diff.enemyDmgMult}x</div>
        <div class="dungeon-stat">Exp/Gold:</div>
        <div class="dungeon-stat-value good">${diff.expMult}x</div>
      </div>
      <div class="dungeon-option-defense" style="color: ${diff.enemyDmgMult >= 6 ? '#ff6666' : '#aaaaaa'}; font-size: 10px; margin-top: 4px;">⚔️ ${diff.defenseRec}</div>
      <div class="dungeon-option-aspect">${diff.aspectInfo}</div>
      ${!unlocked ? `<div class="dungeon-unlock-req">🔒 Requires Level ${diff.unlockLevel}</div>` : ''}
    `;
    
    grid.appendChild(option);
  }
}

function selectDifficulty(key) {
  if (!isDifficultyUnlocked(key)) {
    const diff = DUNGEON_DIFFICULTIES[key];
    showToast('🔒', 'Locked', `Reach level ${diff.unlockLevel} to unlock ${diff.name}`, 'warning');
    return;
  }
  
  const oldDiff = currentDifficulty;
  currentDifficulty = key;
  const settings = getDungeonSettings();
  
  // Re-render to update selection
  renderDungeonOptions();
  updateDungeonCurrentDisplay();
  
  // Show confirmation and reset dungeon
  showToast(settings.icon, 'Difficulty Changed', `${settings.name} (ilvl ${settings.ilvlMin}-${settings.ilvlMax})`, 'info');
  
  // Reset dungeon to level 1 of new difficulty
  dungeon.level = 1;
  enemies = [];
  loot = [];
  generateDungeon();
  
  closeDungeonSelector();
}

// ════════════════════════════════════════════════════════════════════════════════
// DUNGEON MODAL TAB SWITCHING
// ════════════════════════════════════════════════════════════════════════════════

let currentDungeonTab = 'dungeons';

function switchDungeonTab(tabName) {
  currentDungeonTab = tabName;
  
  // Update tab buttons
  document.getElementById('tabDungeons').classList.toggle('active', tabName === 'dungeons');
  document.getElementById('tabShards').classList.toggle('active', tabName === 'shards');
  document.getElementById('tabGreaterRifts').classList.toggle('active', tabName === 'greaterRifts');
  
  // Update content visibility
  document.getElementById('dungeonTabContent').classList.toggle('active', tabName === 'dungeons');
  document.getElementById('shardsTabContent').classList.toggle('active', tabName === 'shards');
  document.getElementById('greaterRiftsTabContent').classList.toggle('active', tabName === 'greaterRifts');
  
  // Update shard display when switching to shards tab
  if (tabName === 'shards') {
    updateShardDisplay();
  }
  
  // Update greater rift display when switching to GR tab
  if (tabName === 'greaterRifts') {
    updateGreaterRiftTabDisplay();
  }
}

// ════════════════════════════════════════════════════════════════════════════════
// RIFT SURGE MECHANIC
// Optional high-risk/high-reward encounter that can be activated mid-dungeon.
// Enemies spawn in waves, difficulty increases over time, rewards scale with survival.
// ════════════════════════════════════════════════════════════════════════════════

// ════════════════════════════════════════════════════════════════════════════════
// RIFT SURGE - HORIZONTAL GAUNTLET SYSTEM
// A timed sprint through a corridor filled with enemy packs.
// Kill as many as possible in 60 seconds!
// ════════════════════════════════════════════════════════════════════════════════

const RIFT_TIER_CONFIG = {
  1: {
    name: 'Stable Rift',
    color: '#4488cc',
    timeLimit: 60,              // seconds
    corridorLength: 120,        // tiles wide
    packCount: 8,               // number of enemy packs
    packSize: [4, 6],           // enemies per pack
    eliteChance: 0.15,
    bossCount: 1,
    // Fixed difficulty - equivalent to Nightmare
    enemyHpMult: 3.5,
    enemyDmgMult: 6.0,
    expMult: 4.0,
    goldMult: 4.0,
    shardBonusBase: 1.0,
    difficultyLabel: 'Nightmare'
  },
  2: {
    name: 'Unstable Rift',
    color: '#9944cc',
    timeLimit: 60,
    corridorLength: 140,
    packCount: 10,
    packSize: [5, 7],           // enemies per pack
    eliteChance: 0.25,
    bossCount: 2,
    // Fixed difficulty - equivalent to Core
    enemyHpMult: 5.0,
    enemyDmgMult: 8.0,
    expMult: 5.0,
    goldMult: 5.0,
    shardBonusBase: 1.5,
    difficultyLabel: 'Core'
  },
  3: {
    name: 'Fractured Rift',
    color: '#cc4444',
    timeLimit: 60,
    corridorLength: 160,
    packCount: 12,
    packSize: [6, 8],           // enemies per pack
    eliteChance: 0.35,
    bossCount: 3,
    // Fixed difficulty - 2x Nightmare (beyond Core)
    enemyHpMult: 7.0,
    enemyDmgMult: 12.0,
    expMult: 6.0,
    goldMult: 6.0,
    shardBonusBase: 2.0,
    difficultyLabel: '2x Nightmare'
  }
};

function activateRiftSurge(tier) {
  const cost = RIFT_SURGE_COSTS[tier];
  const config = RIFT_TIER_CONFIG[tier];
  
  if (shards.rift < cost) {
    showToast('💎', 'Not Enough Shards', `Need ${cost} Rift Shards (have ${shards.rift})`, 'warning');
    return;
  }
  
  // Deduct shards
  shards.rift -= cost;
  updateShardDisplay();
  
  // Close the modal
  closeDungeonSelector();
  
  // Start Rift Surge
  startRiftSurge(tier);
}

function startRiftSurge(tier) {
  const config = RIFT_TIER_CONFIG[tier];
  
  // === CLEANUP: Hide boss bar and clear combat state ===
  document.getElementById('bossBar').classList.remove('visible');
  currentBoss = null;
  enemies = [];
  loot = [];
  path = [];
  pathTarget = null;
  cycloneActive = false;
  cycloneTimer = 0;
  particles = [];
  skillProjectiles = [];
  damageNumbers = [];
  
  // Save current game state
  riftSavedState = {
    map: JSON.parse(JSON.stringify(map)),
    enemies: [],
    loot: [],
    playerX: player.x,
    playerY: player.y,
    playerHp: player.hp,
    playerMana: player.mana,
    exitPos: exitPos ? { ...exitPos } : null,
    biome: biome,
    dungeonLevel: dungeon.level
  };
  
  // === FULL HEAL: Restore HP, mana, potions ===
  player.hp = player.maxHp;
  player.mana = player.maxMana;
  player.potions = player.maxPotions || 3;
  player.currentShield = player.shield || 0;
  
  // Initialize rift state - using real time!
  riftSurgeActive = true;
  riftSurgeTier = tier;
  riftSurgeStartTime = performance.now(); // Real timestamp
  riftSurgeTimeLimit = config.timeLimit;  // Seconds
  riftSurgeKills = 0;
  riftSurgeEliteKills = 0;
  riftSurgeBossKills = 0;
  riftSurgeShardBonus = config.shardBonusBase;
  window.riftSpawnTimer = 0; // Reset spawn timer
  
  // Generate the horizontal gauntlet
  generateRiftGauntlet(config);
  
  showToast('🌀', `${config.name} OPENED`, `${config.timeLimit}s to kill everything! Press R to exit early.`, 'info');
  addLog(`⚠️ ${config.name.toUpperCase()} - GAUNTLET STARTED!`, 'warning');
  
  // Show rift surge UI
  showRiftSurgeUI();
}

function generateRiftGauntlet(config) {
  // Create a wide horizontal corridor
  const corridorHeight = 12;  // tiles tall
  const corridorLength = config.corridorLength;
  
  // Set up new map
  map.width = corridorLength + 10;
  map.height = corridorHeight + 10;
  map.tiles = [];
  map.explored = [];
  map.decorations = [];
  map.edgeShadows = [];
  map.rooms = [];
  
  // Initialize all tiles as void
  for (let y = 0; y < map.height; y++) {
    map.tiles[y] = [];
    map.explored[y] = [];
    for (let x = 0; x < map.width; x++) {
      map.tiles[y][x] = 0;
      map.explored[y][x] = true; // Fully revealed
    }
  }
  
  // Carve the main corridor
  const startY = 5;
  for (let y = startY; y < startY + corridorHeight; y++) {
    for (let x = 3; x < corridorLength + 3; x++) {
      map.tiles[y][x] = 1; // Floor
    }
  }
  
  // Add some variation - wider areas for pack fights
  for (let i = 0; i < 5; i++) {
    const areaX = 15 + Math.floor(i * (corridorLength - 20) / 5);
    const areaWidth = 8 + Math.floor(Math.random() * 6);
    const extraHeight = 2 + Math.floor(Math.random() * 3);
    
    // Expand upward
    for (let y = startY - extraHeight; y < startY; y++) {
      for (let x = areaX; x < areaX + areaWidth && x < corridorLength + 3; x++) {
        if (y >= 0) map.tiles[y][x] = 1;
      }
    }
    // Expand downward
    for (let y = startY + corridorHeight; y < startY + corridorHeight + extraHeight; y++) {
      for (let x = areaX; x < areaX + areaWidth && x < corridorLength + 3; x++) {
        if (y < map.height) map.tiles[y][x] = 1;
      }
    }
  }
  
  // Add walls around floors
  addWalls();
  
  // Create a single room entry for compatibility
  map.rooms = [{
    x: 3, y: startY, w: corridorLength, h: corridorHeight, cleared: true
  }];
  
  // Set rift biome
  biome = { 
    name: config.name, 
    floorColor: config.color + '40',
    wallColor: '#1a1520',
    wallTop: '#2a2030',
    ambient: config.color + '20'
  };
  
  // Clear existing entities
  enemies = [];
  loot = [];
  blood = [];
  path = [];
  pathTarget = null;
  exitPos = null;
  
  // Position player at the left
  player.x = 5 * TILE;
  player.y = (startY + corridorHeight / 2) * TILE;
  player.state = 'idle';
  
  // Spawn enemy packs along the corridor
  spawnRiftPacks(config, corridorLength, startY, corridorHeight);
  
  // Generate decorations
  generateRiftDecorations(config);
}

function spawnRiftPacks(config, corridorLength, startY, corridorHeight) {
  // Rifts use FIXED difficulty from config, not dungeon settings
  const packSpacing = Math.floor((corridorLength - 20) / config.packCount);
  
  for (let i = 0; i < config.packCount; i++) {
    const packX = 15 + i * packSpacing + Math.floor(Math.random() * 5);
    const packY = startY + 2 + Math.floor(Math.random() * (corridorHeight - 4));
    const packSize = config.packSize[0] + Math.floor(Math.random() * (config.packSize[1] - config.packSize[0] + 1));
    
    // Spawn pack
    for (let j = 0; j < packSize; j++) {
      const type = ENEMIES[Math.floor(Math.random() * ENEMIES.length)];
      const offsetX = (Math.random() - 0.5) * 80;
      const offsetY = (Math.random() - 0.5) * 60;
      
      const ex = packX * TILE + offsetX;
      const ey = packY * TILE + offsetY;
      
      const isElite = Math.random() < config.eliteChance;
      const eliteHpMult = isElite ? 3.0 : 1.0;
      const eliteDmgMult = isElite ? 1.4 : 1.0;
      
      // Use config's fixed difficulty multipliers
      const totalHpMult = config.enemyHpMult * eliteHpMult;
      const totalDmgMult = config.enemyDmgMult * eliteDmgMult;
      
      enemies.push({
        ...type,
        name: isElite ? `Rift Elite ${type.name}` : `Rift ${type.name}`,
        x: ex, y: ey,
        hp: Math.floor(type.hp * totalHpMult),
        maxHp: Math.floor(type.hp * totalHpMult),
        dmg: [Math.floor(type.dmg[0] * totalDmgMult), Math.floor(type.dmg[1] * totalDmgMult)],
        atkCD: 0,
        flash: 0,
        id: Math.random(),
        room: map.rooms[0],
        active: false,  // Start inactive - player must find them like normal dungeons
        isBoss: false,
        isElite: isElite,
        isRift: true,
        size: isElite ? type.size * 1.3 : type.size,
        color: isElite ? config.color : shadeColor(config.color, -30),
        exp: Math.floor((isElite ? type.exp * 2 : type.exp) * config.expMult),
        gold: [Math.floor(type.gold[0] * config.goldMult), 
               Math.floor(type.gold[1] * config.goldMult)],
        debuffs: [],
      });
    }
  }
  
  // Spawn bosses spread along the corridor
  for (let i = 0; i < config.bossCount; i++) {
    const bossX = 30 + Math.floor((i + 1) * (corridorLength - 40) / (config.bossCount + 1));
    const bossY = startY + corridorHeight / 2;
    spawnRiftBoss(bossX * TILE, bossY * TILE, config);
  }
}

function spawnRiftBoss(x, y, config) {
  const type = ENEMIES[Math.floor(Math.random() * ENEMIES.length)];
  const bossHpMult = 8.0;
  const bossDmgMult = 2.0;
  
  // Use config's fixed difficulty multipliers
  const totalHpMult = config.enemyHpMult * bossHpMult;
  const totalDmgMult = config.enemyDmgMult * bossDmgMult;
  
  const bossName = generateBossName();
  
  enemies.push({
    ...type,
    name: bossName,
    x: x, y: y,
    hp: Math.floor(type.hp * totalHpMult),
    maxHp: Math.floor(type.hp * totalHpMult),
    dmg: [Math.floor(type.dmg[0] * totalDmgMult), Math.floor(type.dmg[1] * totalDmgMult)],
    atkCD: 0,
    flash: 0,
    id: Math.random(),
    room: map.rooms[0],
    active: false,  // Start inactive - player must find them like normal dungeons
    isBoss: true,
    isElite: true,
    isRift: true,
    isRiftBoss: true,
    size: type.size * 1.8,
    color: '#ffcc00',
    exp: Math.floor(type.exp * 10 * config.expMult),
    gold: [Math.floor(type.gold[0] * 10 * config.goldMult), 
           Math.floor(type.gold[1] * 10 * config.goldMult)],
    debuffs: [],
  });
}

function generateRiftDecorations(config) {
  map.decorations = [];
  
  // Add rift-themed decorations (purple/blue cracks)
  for (let i = 0; i < 50; i++) {
    const tx = Math.floor(Math.random() * map.width);
    const ty = Math.floor(Math.random() * map.height);
    if (map.tiles[ty] && map.tiles[ty][tx] === 1) {
      map.decorations.push({
        x: tx * TILE + Math.random() * TILE,
        y: ty * TILE + Math.random() * TILE,
        type: Math.random() < 0.5 ? 'riftCrack' : 'riftGlow',
        color: config.color,
        size: 3 + Math.random() * 5
      });
    }
  }
}

function shadeColor(color, percent) {
  const num = parseInt(color.replace('#', ''), 16);
  const amt = Math.round(2.55 * percent);
  const R = (num >> 16) + amt;
  const G = (num >> 8 & 0x00FF) + amt;
  const B = (num & 0x0000FF) + amt;
  return '#' + (0x1000000 + (R < 255 ? R < 1 ? 0 : R : 255) * 0x10000 +
    (G < 255 ? G < 1 ? 0 : G : 255) * 0x100 +
    (B < 255 ? B < 1 ? 0 : B : 255)).toString(16).slice(1);
}

function updateRiftSurge() {
  if (!riftSurgeActive) return;
  
  // Calculate elapsed time using real timestamps
  const elapsed = (performance.now() - riftSurgeStartTime) / 1000; // Seconds
  const timeRemaining = riftSurgeTimeLimit - elapsed;
  
  // Time's up!
  if (timeRemaining <= 0) {
    endRiftSurge(false);
    return;
  }
  
  // Continuous enemy spawning with target cap
  const config = RIFT_TIER_CONFIG[riftSurgeTier];
  const activeRiftEnemies = enemies.filter(e => e.isRift && !e.dead && e.hp > 0);
  
  // Target enemy count - keep manageable
  const targetEnemies = 8 + (riftSurgeTier * 3); // T1: 11, T2: 14, T3: 17
  
  // Spawn enemies to maintain target count (pack spawning)
  if (activeRiftEnemies.length < targetEnemies) {
    const deficit = targetEnemies - activeRiftEnemies.length;
    const packsToSpawn = Math.ceil(deficit / 5);
    
    for (let i = 0; i < Math.min(packsToSpawn, 2); i++) {
      spawnRiftReinforcementPack(config);
    }
  }
  
  // Trickle spawn - MUST respect target cap (balance + performance rule)
  if (!window.riftSpawnTimer) window.riftSpawnTimer = 0;
  window.riftSpawnTimer++;
  if (window.riftSpawnTimer >= 60) {
    window.riftSpawnTimer = 0;
    // Only trickle if BELOW target - never exceed cap
    if (activeRiftEnemies.length < targetEnemies) {
      const trickleCount = 1 + (riftSurgeTier > 2 ? 1 : 0);
      for (let i = 0; i < trickleCount; i++) {
        // Re-check cap before each spawn
        const currentActive = enemies.filter(e => e.isRift && !e.dead && e.hp > 0).length;
        if (currentActive < targetEnemies) {
          spawnSingleRiftEnemy(config);
        }
      }
    }
  }
  
  // Update UI
  updateRiftSurgeUI();
}

function spawnSingleRiftEnemy(config) {
  // Rifts use FIXED difficulty from config
  const type = ENEMIES[Math.floor(Math.random() * ENEMIES.length)];
  
  // Spawn in a ring around player
  let ex = 0, ey = 0, found = false;
  for (let attempt = 0; attempt < 15 && !found; attempt++) {
    const angle = Math.random() * Math.PI * 2;
    const dist = TILE * (5 + Math.random() * 8);
    const tx = player.x + Math.cos(angle) * dist;
    const ty = player.y + Math.sin(angle) * dist;
    
    if (isWalkable(tx, ty)) {
      ex = tx;
      ey = ty;
      found = true;
    }
  }
  
  if (!found) return;
  
  const isElite = Math.random() < config.eliteChance;
  const eliteHpMult = isElite ? 3.0 : 1.0;
  const eliteDmgMult = isElite ? 1.4 : 1.0;
  
  // Use config's fixed difficulty
  const totalHpMult = config.enemyHpMult * eliteHpMult;
  const totalDmgMult = config.enemyDmgMult * eliteDmgMult;
  
  enemies.push({
    ...type,
    name: isElite ? `Rift Elite ${type.name}` : `Rift ${type.name}`,
    x: ex, y: ey,
    hp: Math.floor(type.hp * totalHpMult),
    maxHp: Math.floor(type.hp * totalHpMult),
    dmg: [Math.floor(type.dmg[0] * totalDmgMult), Math.floor(type.dmg[1] * totalDmgMult)],
    atkCD: 0,
    flash: 0,
    id: Math.random(),
    room: map.rooms[0],
    active: true,
    isBoss: false,
    isElite: isElite,
    isRift: true,
    size: isElite ? type.size * 1.3 : type.size,
    color: isElite ? config.color : shadeColor(config.color, -30),
    exp: Math.floor((isElite ? type.exp * 2 : type.exp) * config.expMult),
    gold: [Math.floor(type.gold[0] * config.goldMult), 
           Math.floor(type.gold[1] * config.goldMult)],
    debuffs: [],
  });
}

function spawnRiftReinforcementPack(config) {
  // Rifts use FIXED difficulty from config
  
  // Spawn pack AHEAD of the player in the corridor (not on top of them)
  // This makes rifts feel more like dungeons where you explore and find enemies
  const packSize = config.packSize[0] + Math.floor(Math.random() * (config.packSize[1] - config.packSize[0] + 1));
  
  let spawned = 0;
  for (let j = 0; j < packSize; j++) {
    const type = ENEMIES[Math.floor(Math.random() * ENEMIES.length)];
    
    // Try to find a valid spawn position AHEAD of the player (to the right in the corridor)
    let ex = 0, ey = 0, found = false;
    
    // Spawn further ahead in the corridor (20-40 tiles ahead of player)
    for (let attempt = 0; attempt < 30 && !found; attempt++) {
      const aheadDist = TILE * (20 + Math.random() * 20); // 20-40 tiles ahead
      const lateralOffset = (Math.random() - 0.5) * TILE * 8; // Some vertical spread
      const tx = player.x + aheadDist;
      const ty = player.y + lateralOffset;
      
      if (isWalkable(tx, ty)) {
        ex = tx;
        ey = ty;
        found = true;
      }
    }
    
    // Fallback: spawn at random corridor position if ahead spawning fails
    if (!found) {
      for (let attempt = 0; attempt < 20 && !found; attempt++) {
        const tx = Math.random() * map.width * TILE;
        const ty = (map.height / 2 + (Math.random() - 0.5) * 6) * TILE;
        
        if (isWalkable(tx, ty)) {
          ex = tx;
          ey = ty;
          found = true;
        }
      }
    }
    
    if (!found) continue; // Skip if truly no valid position
    
    const isElite = Math.random() < config.eliteChance;
    const eliteHpMult = isElite ? 3.0 : 1.0;
    const eliteDmgMult = isElite ? 1.4 : 1.0;
    
    // Use config's fixed difficulty
    const totalHpMult = config.enemyHpMult * eliteHpMult;
    const totalDmgMult = config.enemyDmgMult * eliteDmgMult;
    
    enemies.push({
      ...type,
      name: isElite ? `Rift Elite ${type.name}` : `Rift ${type.name}`,
      x: ex, y: ey,
      hp: Math.floor(type.hp * totalHpMult),
      maxHp: Math.floor(type.hp * totalHpMult),
      dmg: [Math.floor(type.dmg[0] * totalDmgMult), Math.floor(type.dmg[1] * totalDmgMult)],
      atkCD: 0,
      flash: 0,
      id: Math.random(),
      room: map.rooms[0],
      active: false, // Start inactive - player must find them like normal dungeons
      isBoss: false,
      isElite: isElite,
      isRift: true,
      size: isElite ? type.size * 1.3 : type.size,
      color: isElite ? config.color : shadeColor(config.color, -30),
      exp: Math.floor((isElite ? type.exp * 2 : type.exp) * config.expMult),
      gold: [Math.floor(type.gold[0] * config.goldMult), 
             Math.floor(type.gold[1] * config.goldMult)],
      debuffs: [],
    });
    spawned++;
  }
}

function getRiftTimeRemaining() {
  if (!riftSurgeActive) return 0;
  const elapsed = (performance.now() - riftSurgeStartTime) / 1000;
  return Math.max(0, riftSurgeTimeLimit - elapsed);
}

function getRiftTimeUsed() {
  if (!riftSurgeActive && riftSurgeStartTime === 0) return 0;
  const elapsed = (performance.now() - riftSurgeStartTime) / 1000;
  return Math.min(elapsed, riftSurgeTimeLimit);
}

function endRiftSurge(voluntary = false) {
  if (!riftSurgeActive) return;
  
  const config = RIFT_TIER_CONFIG[riftSurgeTier];
  const timeUsed = Math.floor(getRiftTimeUsed());
  riftSurgeActive = false;
  
  // Calculate rewards - use tier for scaling (T1=1, T2=1.5, T3=2)
  const tierMult = config.shardBonusBase;
  const baseShards = Math.floor(riftSurgeKills * 0.3 * tierMult);
  const eliteBonus = riftSurgeEliteKills * 2;
  const bossBonus = riftSurgeBossKills * 10;
  const bonusShards = Math.floor((baseShards + eliteBonus + bossBonus) * riftSurgeShardBonus);
  
  shards.rift += bonusShards;
  
  hideRiftSurgeUI();
  
  // Restore original map FIRST
  restoreFromRift();
  
  // NOW drop loot burst around restored player position!
  dropRiftLootBurst(config);
  
  // Guaranteed rift amulets based on tier: T1=1, T2=2, T3=3
  const amuletCount = riftSurgeTier;
  for (let i = 0; i < amuletCount; i++) {
    dropRiftAmulet(config);
  }
  addLog(`✨ ${amuletCount} Rift Amulet${amuletCount > 1 ? 's' : ''} dropped!`, 'unique');
  
  // Roll for aspect drop (requires 60+ kills)
  rollAspectFromRift(riftSurgeTier, riftSurgeKills);
  
  const reason = voluntary ? 'Exited' : 'Time Up';
  showToast('🌀', `${config.name} ${reason}!`, 
    `Kills: ${riftSurgeKills} (${riftSurgeEliteKills} elites, ${riftSurgeBossKills} bosses) | +${bonusShards} shards`, 'info');
  addLog(`${config.name} complete - ${riftSurgeKills} kills in ${timeUsed}s, +${bonusShards} shards`, 'loot');
  
  updateShardDisplay();
}

function dropRiftLootBurst(config) {
  // Calculate number of loot drops based on kills
  // 1 per boss, 10% per elite, 1 per 20 kills
  const killLoot = Math.floor(riftSurgeKills / 20);
  
  // Roll 10% per elite kill
  let eliteLoot = 0;
  for (let i = 0; i < riftSurgeEliteKills; i++) {
    if (Math.random() < 0.10) eliteLoot++;
  }
  
  const bossLoot = riftSurgeBossKills; // 1 per boss
  const totalLoot = killLoot + eliteLoot + bossLoot;
  
  if (totalLoot <= 0) return;
  
  addLog(`💎 LOOT BURST! ${totalLoot} items dropped!`, 'loot');
  
  // Drop loot in a circle around player
  for (let i = 0; i < totalLoot; i++) {
    const angle = (i / totalLoot) * Math.PI * 2 + Math.random() * 0.3;
    const radius = TILE * (1.5 + Math.random() * 2);
    const lootX = player.x + Math.cos(angle) * radius;
    const lootY = player.y + Math.sin(angle) * radius;
    
    // Higher tier = better chance of rare loot
    const rarityRoll = Math.random();
    const tierBonus = riftSurgeTier * 0.1; // T1: 0.1, T2: 0.2, T3: 0.3
    
    if (rarityRoll < 0.20 + tierBonus * 2) {
      // Rare
      dropRiftLootItem(lootX, lootY, 'rare');
    } else if (rarityRoll < 0.55 + tierBonus) {
      // Magic
      dropRiftLootItem(lootX, lootY, 'magic');
    } else {
      // Normal
      dropRiftLootItem(lootX, lootY, 'normal');
    }
  }
  
  // Also drop some currency (1 per 15 kills + 1 per boss)
  const currencyDrops = Math.floor(riftSurgeKills / 15) + riftSurgeBossKills;
  for (let i = 0; i < currencyDrops; i++) {
    dropCurrency(riftSurgeBossKills > 0);
  }
}

function dropRiftLootItem(x, y, rarity) {
  // Find walkable position
  let lootX = x, lootY = y;
  if (!isWalkable(x, y)) {
    for (let r = TILE; r < TILE * 4; r += TILE/2) {
      for (let a = 0; a < Math.PI * 2; a += Math.PI/6) {
        const tx = x + Math.cos(a) * r;
        const ty = y + Math.sin(a) * r;
        if (isWalkable(tx, ty)) {
          lootX = tx;
          lootY = ty;
          break;
        }
      }
    }
  }
  
  // Rift Surge is endgame content - always drops Core-tier items (ilvl 71-80)
  const ilvl = 71 + Math.floor(Math.random() * 10); // 71-80
  
  // Generate random slot
  const slots = ['helmet', 'chest', 'gloves', 'boots', 'weapon', 'ring', 'amulet', 'belt'];
  const slot = slots[Math.floor(Math.random() * slots.length)];
  
  // Get item name for slot
  const slotItemNames = {
    helmet: ['Iron Helm', 'Leather Cap', 'Mage Hat', 'Scale Helm', 'Crusader Helm', 'Bone Circlet'],
    chest: ['Plate Armor', 'Leather Tunic', 'Silk Robe', 'Scale Armor', 'Crusader Armor', 'Assassin Garb'],
    gloves: ['Plate Gauntlets', 'Leather Gloves', 'Silk Gloves', 'Scale Gauntlets', 'Crusader Gauntlets', 'Assassin Gloves'],
    boots: ['Plate Greaves', 'Leather Boots', 'Silk Slippers', 'Scale Boots', 'Crusader Greaves', 'Assassin Boots'],
    weapon: ['Viper Blade', 'War Blade', 'Windspire Quarterstaff', 'Ironbark Quarterstaff', 'Windrunner Bow', 'Ironwood Bow', 'Mystic Staff', 'Elder Staff'],
    ring: ['Nature Ring', 'Vitality Ring', 'Arcane Ring', 'Flame Ring', 'Frost Ring', 'Storm Ring', 'Prismatic Ring'],
    amulet: ['Might Amulet', 'Grace Amulet', 'Wisdom Amulet', 'Harmony Amulet'],
    belt: ['Leather Belt', 'Chain Belt', 'Heavy Belt', 'Cloth Sash']
  };
  const itemName = slotItemNames[slot][Math.floor(Math.random() * slotItemNames[slot].length)];
  
  // Generate mods
  const mods = generateItemMods(rarity, itemName, null, ilvl);
  
  const item = {
    x: lootX,
    y: lootY,
    name: itemName,
    rarity: rarity,
    id: Math.random(),
    mods: mods,
    sockets: [],
    slot: slot,
    baseLevel: ilvl,
    width: slot === 'weapon' ? 1 : 1,
    height: slot === 'weapon' ? 3 : (slot === 'chest' ? 3 : (slot === 'ring' || slot === 'amulet' ? 1 : 2)),
    image: null
  };
  
  loot.push(item);
  addLootPopup(item, lootX, lootY);
}

function restoreFromRift() {
  if (!riftSavedState) return;
  
  // Restore map
  map.tiles = riftSavedState.map.tiles;
  map.width = riftSavedState.map.width;
  map.height = riftSavedState.map.height;
  map.rooms = riftSavedState.map.rooms;
  map.explored = riftSavedState.map.explored;
  map.decorations = riftSavedState.map.decorations || [];
  map.edgeShadows = riftSavedState.map.edgeShadows || [];
  
  // Restore entities
  enemies = riftSavedState.enemies;
  loot = riftSavedState.loot;
  exitPos = riftSavedState.exitPos;
  biome = riftSavedState.biome;
  
  // Restore player position
  player.x = riftSavedState.playerX;
  player.y = riftSavedState.playerY;
  player.state = 'idle';
  
  // Clear path and reset
  path = [];
  pathTarget = null;
  blood = [];
  
  riftSavedState = null;
}

function dropRiftAmulet(config) {
  // Rift Amulets ALWAYS drop at 0% quality
  // Quality is added ONLY via Rift-specific currency
  // Max quality cap = 50% (Rift-exclusive)
  const ilvl = getDungeonItemLevel();
  
  const amuletNames = ['Rift Pendant', 'Void Amulet', 'Abyssal Choker', 'Dimensional Talisman', 'Tear of the Rift'];
  const name = amuletNames[Math.floor(Math.random() * amuletNames.length)];
  
  const mods = generateItemMods('rare', name, null, ilvl);
  
  // Spread amulets out in a circle around player
  const angle = Math.random() * Math.PI * 2;
  const dist = TILE * (1 + Math.random() * 1.5);
  
  const item = {
    x: player.x + Math.cos(angle) * dist,
    y: player.y + Math.sin(angle) * dist,
    name: name,
    rarity: 'rare',
    id: Math.random(),
    mods: mods,
    sockets: [],
    slot: 'amulet',
    baseLevel: ilvl,
    quality: 0,         // ALWAYS drops at 0% - upgrade via currency only
    maxQuality: 50,     // Rift-exclusive max quality cap
    width: 1,
    height: 1,
    image: null,
    isRiftItem: true
  };
  
  loot.push(item);
  addLootPopup(item, item.x, item.y);
}

// Rift Surge UI - Countdown Timer Display
function showRiftSurgeUI() {
  const config = RIFT_TIER_CONFIG[riftSurgeTier];
  let ui = document.getElementById('riftSurgeUI');
  if (!ui) {
    ui = document.createElement('div');
    ui.id = 'riftSurgeUI';
    document.body.appendChild(ui);
  }
  
  ui.style.cssText = `
    position: fixed;
    top: 10px;
    left: 50%;
    transform: translateX(-50%);
    background: linear-gradient(180deg, rgba(20,15,30,0.95) 0%, rgba(10,8,15,0.95) 100%);
    border: 2px solid ${config.color};
    border-radius: 8px;
    padding: 10px 24px;
    z-index: 5000;
    text-align: center;
    box-shadow: 0 0 40px ${config.color}80;
    min-width: 280px;
  `;
  
  ui.style.display = 'block';
  updateRiftSurgeUI();
}

function updateRiftSurgeUI() {
  const ui = document.getElementById('riftSurgeUI');
  if (!ui || !riftSurgeActive) return;
  
  const config = RIFT_TIER_CONFIG[riftSurgeTier];
  const timeRemaining = getRiftTimeRemaining();
  const secondsLeft = Math.ceil(timeRemaining);
  const riftEnemies = enemies.filter(e => e.isRift && !e.dead && e.hp > 0);
  const progress = (timeRemaining / riftSurgeTimeLimit) * 100;
  
  // Color transitions as time runs out
  const timerColor = secondsLeft > 20 ? '#8f8' : secondsLeft > 10 ? '#ff8' : '#f66';
  
  ui.innerHTML = `
    <div style="color: ${config.color}; font-size: 14px; font-weight: 700; margin-bottom: 8px; letter-spacing: 2px;">🌀 ${config.name.toUpperCase()}</div>
    <div style="font-size: 32px; font-weight: 700; color: ${timerColor}; font-family: monospace; margin: 4px 0;">
      ${secondsLeft}s
    </div>
    <div style="background: #111; border-radius: 4px; height: 6px; margin: 8px 0; overflow: hidden;">
      <div style="background: linear-gradient(90deg, ${config.color}, ${timerColor}); height: 100%; width: ${progress}%; transition: width 0.1s;"></div>
    </div>
    <div style="display: flex; justify-content: space-around; color: #aaa; font-size: 11px;">
      <span>Kills: <span style="color: #8f8; font-weight: 600;">${riftSurgeKills}</span></span>
      <span>Elites: <span style="color: #88f; font-weight: 600;">${riftSurgeEliteKills}</span></span>
      <span>Bosses: <span style="color: #fc0; font-weight: 600;">${riftSurgeBossKills}</span></span>
    </div>
    <div style="color: #666; font-size: 9px; margin-top: 6px;">Remaining: ${riftEnemies.length} | Press R to exit</div>
  `;
}

function hideRiftSurgeUI() {
  const ui = document.getElementById('riftSurgeUI');
  if (ui) ui.style.display = 'none';
}

// ════════════════════════════════════════════════════════════════════════════════
// ECHO DOMAIN - 7x7 Grid Dungeon System
// ════════════════════════════════════════════════════════════════════════════════
// Design Philosophy:
// - 7x7 grid dungeon (49 rooms total)
// - Find and defeat the hidden Echo Overlord boss
// - Room types: Combat, Buff, Debuff, Kick-out
// - Buffs/debuffs persist for the entire run
// - Echo Ring drops only from the Echo Overlord
// ════════════════════════════════════════════════════════════════════════════════

const ECHO_DOMAIN_COSTS = { 1: 50, 2: 75, 3: 100 };

const ECHO_DOMAIN_CONFIG = {
  1: {
    name: 'Fading Echo',
    color: '#6688aa',
    enemyCount: [3, 5],
    eliteChance: 0.10,
    buffCount: 6,      // More buffs for stacking
    debuffCount: 4,
    kickoutCount: 2,   // ~4% of 49 rooms
    echoRingChance: 0.01,
    // Fixed difficulty - equivalent to Nightmare
    enemyHpMult: 3.5,
    enemyDmgMult: 6.0,
    expMult: 4.0,
    goldMult: 4.0,
    difficultyLabel: 'Nightmare'
  },
  2: {
    name: 'Resonant Echo',
    color: '#9966cc',
    enemyCount: [4, 7],
    eliteChance: 0.20,
    buffCount: 8,
    debuffCount: 5,
    kickoutCount: 3,   // ~6% of 49 rooms
    echoRingChance: 0.03,
    // Fixed difficulty - equivalent to Core
    enemyHpMult: 5.0,
    enemyDmgMult: 8.0,
    expMult: 5.0,
    goldMult: 5.0,
    difficultyLabel: 'Core'
  },
  3: {
    name: 'Shattered Echo',
    color: '#cc6666',
    enemyCount: [5, 9],
    eliteChance: 0.30,
    buffCount: 10,
    debuffCount: 6,
    kickoutCount: 4,   // ~8% of 49 rooms
    echoRingChance: 0.05,
    // Fixed difficulty - 2x Nightmare (beyond Core)
    enemyHpMult: 7.0,
    enemyDmgMult: 12.0,
    expMult: 6.0,
    goldMult: 6.0,
    difficultyLabel: '2x Nightmare'
  }
};

// Echo Domain buffs and debuffs
// Echo Domain buffs - small bonuses that stack over multiple rooms
// Values are intentionally modest; power comes from accumulation
const ECHO_BUFFS = [
  { id: 'dmg_up', name: 'Echo Fury', icon: '⚔️', desc: '+5% Damage', effect: { dmgMult: 1.05 } },
  { id: 'speed_up', name: 'Echo Haste', icon: '💨', desc: '+8% Move Speed', effect: { speedMult: 1.08 } },
  { id: 'life_up', name: 'Echo Vitality', icon: '❤️', desc: '+15 Max Life', effect: { maxHp: 15 } },
  { id: 'armor_up', name: 'Echo Shell', icon: '🛡️', desc: '+10 Armor', effect: { armor: 10 } },
  { id: 'shield_up', name: 'Echo Recovery', icon: '💚', desc: '+5 Shield Recharge', effect: { shieldRecharge: 5 } },
  { id: 'crit_up', name: 'Echo Precision', icon: '🎯', desc: '+3% Crit Chance', effect: { critChance: 0.03 } },
  { id: 'leech_up', name: 'Echo Leech', icon: '🩸', desc: '+1 Life on Hit', effect: { lifeOnHit: 1 } },
  { id: 'atk_speed', name: 'Echo Frenzy', icon: '⚡', desc: '+5% Attack Speed', effect: { atkSpeedMult: 1.05 } }
];

// Echo Domain debuffs - mild penalties, dangerous when stacked
const ECHO_DEBUFFS = [
  { id: 'dmg_down', name: 'Echo Weakness', icon: '💔', desc: '-5% Damage', effect: { dmgMult: 0.95 } },
  { id: 'speed_down', name: 'Echo Slow', icon: '🐌', desc: '-8% Move Speed', effect: { speedMult: 0.92 } },
  { id: 'life_down', name: 'Echo Frailty', icon: '💀', desc: '-10 Max Life', effect: { maxHp: -10 } },
  { id: 'armor_down', name: 'Echo Vulnerability', icon: '🔓', desc: '-8 Armor', effect: { armor: -8 } },
  { id: 'slow_atk', name: 'Echo Lethargy', icon: '🐢', desc: '-5% Attack Speed', effect: { atkSpeedMult: 0.95 } },
  { id: 'dodge_down', name: 'Echo Exposure', icon: '👁️', desc: '-5% Dodge', effect: { dodgePenalty: 5 } }
];

// Echo Domain state
let echoDomainActive = false;
let echoDomainTier = 1;
let echoDomainGrid = [];           // 7x7 grid of rooms
let echoDomainPlayerX = 0;
let echoDomainPlayerY = 6;         // Start at bottom-left
let echoDomainBuffs = [];          // Active buffs for this run
let echoDomainDebuffs = [];        // Active debuffs for this run
let echoDomainRoomsExplored = 0;
let echoDomainBossFound = false;
let echoSavedState = null;
let echoCoresEarned = 0;
let echoDomainKills = 0;           // Track kills for stats

// Echo Ring definition
const ECHO_RING_BASE = {
  name: 'Echo Ring',
  slot: 'ring',
  rarity: 'unique',
  isEchoRing: true,
  width: 1,
  height: 1
};

function generateEchoRing() {
  const echoPercent = 60 + Math.floor(Math.random() * 51); // 60-110%
  return {
    ...ECHO_RING_BASE,
    id: Math.random(),
    echoPercent: echoPercent,
    mods: [],
    sockets: [],
    baseLevel: getDungeonItemLevel(),
    description: `Mirrors ${echoPercent}% of your other ring's power`
  };
}

function calculateEchoRingStats(echoRing, otherRing) {
  if (!otherRing || otherRing.isEchoRing) return {};
  
  const echoMult = echoRing.echoPercent / 100;
  const qualityMult = 1 + (otherRing.quality || 0) / 100;
  const effectiveStats = {};
  
  if (otherRing.mods) {
    otherRing.mods.forEach(mod => {
      const match = mod.match(/([+-]?\d+(?:\.\d+)?)/);
      if (match) {
        const baseValue = parseFloat(match[1]);
        const afterQuality = baseValue * qualityMult;
        const afterEcho = Math.round(afterQuality * echoMult * 10) / 10;
        effectiveStats[mod] = afterEcho;
      }
    });
  }
  
  return effectiveStats;
}

function activateEchoDomain(tier) {
  const cost = ECHO_DOMAIN_COSTS[tier];
  
  if (shards.echo < cost) {
    showToast('💎', 'Not Enough Shards', `Need ${cost} Echo Shards (have ${shards.echo})`, 'warning');
    return;
  }
  
  shards.echo -= cost;
  updateShardDisplays();
  closeDungeonSelector();
  startEchoDomain(tier);
}

function startEchoDomain(tier) {
  const config = ECHO_DOMAIN_CONFIG[tier];
  
  // === CLEANUP: Hide boss bar and clear combat state ===
  document.getElementById('bossBar').classList.remove('visible');
  currentBoss = null;
  enemies = [];
  loot = [];
  path = [];
  pathTarget = null;
  cycloneActive = false;
  cycloneTimer = 0;
  particles = [];
  skillProjectiles = [];
  damageNumbers = [];
  
  // Save current game state
  echoSavedState = {
    map: JSON.parse(JSON.stringify(map)),
    enemies: [],
    loot: [],
    playerX: player.x,
    playerY: player.y,
    playerHp: player.hp,
    playerMana: player.mana,
    exitPos: exitPos ? { ...exitPos } : null,
    biome: biome,
    dungeonLevel: dungeon.level
  };
  
  // === FULL HEAL: Restore HP, mana, potions ===
  player.hp = player.maxHp;
  player.mana = player.maxMana;
  player.potions = player.maxPotions || 3;
  player.currentShield = player.shield || 0;
  
  // Initialize domain state
  echoDomainActive = true;
  echoDomainTier = tier;
  echoDomainPlayerX = 0;
  echoDomainPlayerY = 6; // Start bottom-left
  echoDomainBuffs = [];
  echoDomainDebuffs = [];
  echoDomainRoomsExplored = 0;
  echoDomainBossFound = false;
  echoCoresEarned = 0;
  echoDomainKills = 0;  // Reset kills for stats
  
  // Generate 7x7 grid
  generateEchoDomainGrid(config);
  
  showToast('🔮', `${config.name} Opened`, `Find and defeat the Echo Overlord!`, 'info');
  addLog(`⚠️ ECHO DOMAIN - ${config.name.toUpperCase()} ENTERED`, 'warning');
  
  showEchoDomainUI();
}

function generateEchoDomainGrid(config) {
  echoDomainGrid = [];
  
  // Create 7x7 grid of unknown rooms
  for (let y = 0; y < 7; y++) {
    echoDomainGrid[y] = [];
    for (let x = 0; x < 7; x++) {
      echoDomainGrid[y][x] = {
        x, y,
        type: 'combat',
        revealed: false,
        cleared: false,
        enemyCount: config.enemyCount[0] + Math.floor(Math.random() * (config.enemyCount[1] - config.enemyCount[0] + 1)),
        eliteChance: config.eliteChance,
        buff: null,
        debuff: null,
        nearBoss: false,    // Hint system
        unstable: false     // Kickout warning
      };
    }
  }
  
  // Mark starting room as revealed and cleared
  echoDomainGrid[6][0].revealed = true;
  echoDomainGrid[6][0].cleared = true;
  echoDomainGrid[6][0].type = 'start';
  
  // Place boss randomly - NOT in bottom 2 rows (rows 5-6), must be rows 0-4
  let bossX, bossY;
  do {
    bossX = Math.floor(Math.random() * 7);
    bossY = Math.floor(Math.random() * 5); // Rows 0-4 only (top 5 rows)
  } while (bossY >= 4 && bossX <= 1); // Extra safety: not too close to start path
  
  echoDomainGrid[bossY][bossX].type = 'boss';
  echoDomainGrid[bossY][bossX].enemyCount = 1; // Just the boss
  
  // Mark adjacent rooms as "near boss" for hints
  const bossAdjacent = [
    [bossX-1, bossY], [bossX+1, bossY],
    [bossX, bossY-1], [bossX, bossY+1]
  ];
  for (const [ax, ay] of bossAdjacent) {
    if (ax >= 0 && ax < 7 && ay >= 0 && ay < 7) {
      echoDomainGrid[ay][ax].nearBoss = true;
    }
  }
  
  // Place buff rooms (can stack same buff multiple times)
  const availableBuffs = [...ECHO_BUFFS, ...ECHO_BUFFS]; // Allow duplicates for stacking
  for (let i = 0; i < config.buffCount; i++) {
    const pos = getRandomEmptyRoom();
    if (pos && availableBuffs.length > 0) {
      const buffIdx = Math.floor(Math.random() * availableBuffs.length);
      echoDomainGrid[pos.y][pos.x].type = 'buff';
      echoDomainGrid[pos.y][pos.x].buff = availableBuffs.splice(buffIdx, 1)[0];
      echoDomainGrid[pos.y][pos.x].enemyCount = Math.max(1, Math.floor(echoDomainGrid[pos.y][pos.x].enemyCount / 2));
    }
  }
  
  // Place debuff rooms (can stack same debuff)
  const availableDebuffs = [...ECHO_DEBUFFS, ...ECHO_DEBUFFS];
  for (let i = 0; i < config.debuffCount; i++) {
    const pos = getRandomEmptyRoom();
    if (pos && availableDebuffs.length > 0) {
      const debuffIdx = Math.floor(Math.random() * availableDebuffs.length);
      echoDomainGrid[pos.y][pos.x].type = 'debuff';
      echoDomainGrid[pos.y][pos.x].debuff = availableDebuffs.splice(debuffIdx, 1)[0];
      echoDomainGrid[pos.y][pos.x].enemyCount = Math.max(1, Math.floor(echoDomainGrid[pos.y][pos.x].enemyCount / 2));
    }
  }
  
  // Place kickout rooms - mark as "unstable" for telegraphing
  for (let i = 0; i < config.kickoutCount; i++) {
    const pos = getRandomEmptyRoom();
    if (pos) {
      echoDomainGrid[pos.y][pos.x].type = 'kickout';
      echoDomainGrid[pos.y][pos.x].enemyCount = 0;
      echoDomainGrid[pos.y][pos.x].unstable = true;
    }
  }
}

function getRandomEmptyRoom() {
  const attempts = 50;
  for (let i = 0; i < attempts; i++) {
    const x = Math.floor(Math.random() * 7);
    const y = Math.floor(Math.random() * 7);
    if (echoDomainGrid[y][x].type === 'combat' && !(x === 0 && y === 6)) {
      return { x, y };
    }
  }
  return null;
}

function showEchoDomainUI() {
  let ui = document.getElementById('echoDomainUI');
  if (!ui) {
    ui = document.createElement('div');
    ui.id = 'echoDomainUI';
    document.body.appendChild(ui);
  }
  
  ui.style.cssText = `
    position: fixed;
    top: 0; left: 0; right: 0; bottom: 0;
    background: rgba(0, 0, 0, 0.98);
    z-index: 20000;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    font-family: 'Exocet', Georgia, serif;
  `;
  
  updateEchoDomainUI();
}

function updateEchoDomainUI() {
  const ui = document.getElementById('echoDomainUI');
  if (!ui) return;
  
  const config = ECHO_DOMAIN_CONFIG[echoDomainTier];
  
  // Check if any adjacent cleared room is nearBoss (for hints)
  const showBossHint = (x, y) => {
    // Only show hint if we've cleared enough rooms and an adjacent room has nearBoss
    if (echoDomainRoomsExplored < 5) return false;
    const room = echoDomainGrid[y][x];
    if (room.revealed) return false;
    
    // Check if any adjacent CLEARED room is nearBoss
    const adjacent = [[x-1,y],[x+1,y],[x,y-1],[x,y+1]];
    for (const [ax, ay] of adjacent) {
      if (ax >= 0 && ax < 7 && ay >= 0 && ay < 7) {
        const adj = echoDomainGrid[ay][ax];
        if (adj.cleared && adj.nearBoss) return true;
      }
    }
    return false;
  };
  
  // Build grid HTML
  let gridHTML = '';
  for (let y = 0; y < 7; y++) {
    for (let x = 0; x < 7; x++) {
      const room = echoDomainGrid[y][x];
      const isPlayer = (x === echoDomainPlayerX && y === echoDomainPlayerY);
      const isAdjacent = isAdjacentToPlayer(x, y);
      // Can move to any adjacent room: unexplored OR cleared (for backtracking)
      const canExplore = isAdjacent && !room.cleared && room.revealed === false;
      const canBacktrack = isAdjacent && room.cleared && !isPlayer;
      const hasBossHint = showBossHint(x, y);
      
      let cellClass = 'echo-cell';
      let cellContent = '?';
      let cellStyle = 'background: #1a1a2a; border-color: #333;';
      let cellTitle = '';
      
      if (room.revealed) {
        if (room.cleared) {
          cellStyle = 'background: #0a0a0a; border-color: #222;';
          cellContent = getRoomIcon(room.type, true);
          // Cleared rooms are clickable for backtracking
          if (isAdjacent && !isPlayer) {
            cellStyle = 'background: #1a1a1a; border-color: #444; cursor: pointer;';
            cellTitle = 'Click to move here';
          }
          // Show if this cleared room is near boss
          if (room.nearBoss && echoDomainRoomsExplored >= 5) {
            cellStyle = 'background: #1a0a0a; border-color: #422;' + (isAdjacent ? ' cursor: pointer;' : '');
            cellTitle = 'You sense a powerful presence nearby...';
          }
        } else {
          cellStyle = `background: #2a2a3a; border-color: ${config.color};`;
          cellContent = getRoomIcon(room.type, false);
        }
      } else if (isAdjacent) {
        // Unrevealed but adjacent - can explore
        if (hasBossHint) {
          // Boss is near this room!
          cellStyle = 'background: #3a2a2a; border-color: #a55; cursor: pointer;';
          cellContent = '⚠️';
          cellTitle = 'Something powerful lurks nearby...';
        } else {
          cellStyle = 'background: #2a2a4a; border-color: #558; cursor: pointer;';
          cellContent = '?';
        }
      }
      
      if (isPlayer) {
        cellContent = '🧙';
        cellStyle = 'background: #3a4a3a; border-color: #8a8;';
      }
      
      // Allow clicking to explore OR backtrack
      const onclick = (canExplore || canBacktrack) ? `onclick="enterEchoDomainRoom(${x}, ${y})"` : '';
      const titleAttr = cellTitle ? `title="${cellTitle}"` : '';
      
      gridHTML += `<div class="${cellClass}" style="${cellStyle}" ${onclick} ${titleAttr}>${cellContent}</div>`;
    }
  }
  
  // Build buffs/debuffs display
  let effectsHTML = '';
  if (echoDomainBuffs.length > 0) {
    effectsHTML += `<div style="color: #4a8; margin-right: 20px;">`;
    echoDomainBuffs.forEach(b => {
      effectsHTML += `<span title="${b.name}: ${b.desc}" style="margin-right: 8px; font-size: 20px;">${b.icon}</span>`;
    });
    effectsHTML += `</div>`;
  }
  if (echoDomainDebuffs.length > 0) {
    effectsHTML += `<div style="color: #a44;">`;
    echoDomainDebuffs.forEach(d => {
      effectsHTML += `<span title="${d.name}: ${d.desc}" style="margin-right: 8px; font-size: 20px;">${d.icon}</span>`;
    });
    effectsHTML += `</div>`;
  }
  
  ui.innerHTML = `
    <div style="text-align: center; margin-bottom: 20px;">
      <div style="font-size: 28px; color: ${config.color}; text-shadow: 0 0 20px ${config.color};">
        🔮 ${config.name}
      </div>
      <div style="font-size: 14px; color: #888; margin-top: 5px;">
        Rooms Explored: ${echoDomainRoomsExplored} / 49 | Find the Echo Overlord!
      </div>
    </div>
    
    <!-- Active Effects -->
    <div style="display: flex; justify-content: center; margin-bottom: 15px; min-height: 30px;">
      ${effectsHTML || '<span style="color: #555;">No active effects</span>'}
    </div>
    
    <!-- 7x7 Grid -->
    <div style="
      display: grid;
      grid-template-columns: repeat(7, 50px);
      grid-template-rows: repeat(7, 50px);
      gap: 4px;
      margin-bottom: 20px;
    ">
      ${gridHTML}
    </div>
    
    <!-- Legend -->
    <div style="display: flex; gap: 20px; color: #888; font-size: 12px; margin-bottom: 20px;">
      <span>⚔️ Combat</span>
      <span>💚 Buff</span>
      <span>💔 Debuff</span>
      <span>🚪 Unstable</span>
      <span>👹 Boss</span>
    </div>
    
    <!-- Leave Button -->
    <button onclick="leaveEchoDomain()" style="
      padding: 12px 30px;
      font-size: 16px;
      background: linear-gradient(180deg, #633 0%, #411 100%);
      border: 2px solid #844;
      color: #faa;
      cursor: pointer;
      border-radius: 4px;
    ">
      🚪 Leave Domain
    </button>
    
    <div style="color: #666; font-size: 11px; margin-top: 10px;">
      Click adjacent rooms to explore • Press R to leave
    </div>
  `;
}

function getRoomIcon(type, cleared) {
  if (cleared) {
    return '<span style="opacity: 0.3;">✓</span>';
  }
  switch (type) {
    case 'start': return '🏠';
    case 'boss': return '👹';
    case 'buff': return '💚';
    case 'debuff': return '💔';
    case 'kickout': return '🚪';
    case 'combat': return '⚔️';
    default: return '?';
  }
}

function isAdjacentToPlayer(x, y) {
  const dx = Math.abs(x - echoDomainPlayerX);
  const dy = Math.abs(y - echoDomainPlayerY);
  return (dx + dy === 1); // Only orthogonal adjacency
}

function enterEchoDomainRoom(x, y) {
  if (!echoDomainActive) return;
  if (!isAdjacentToPlayer(x, y)) return;
  
  const room = echoDomainGrid[y][x];
  
  // Backtracking - move to cleared room without combat
  if (room.cleared) {
    echoDomainPlayerX = x;
    echoDomainPlayerY = y;
    updateEchoDomainUI();
    return;
  }
  
  // Reveal the room
  room.revealed = true;
  echoDomainRoomsExplored++;
  
  // Move player
  echoDomainPlayerX = x;
  echoDomainPlayerY = y;
  
  // Handle room type
  switch (room.type) {
    case 'kickout':
      // Unstable room - kicked out with nothing! This is a punishment.
      showToast('🚪', 'UNSTABLE ECHO!', 'Room collapsed! You are ejected from the domain.', 'warning');
      addLog(`💨 Unstable room collapsed! Ejected from domain.`, 'warning');
      setTimeout(() => {
        leaveEchoDomain();
      }, 1200);
      updateEchoDomainUI();
      return;
      
    case 'buff':
      // Apply buff and then fight
      if (room.buff) {
        echoDomainBuffs.push(room.buff);
        recalculateStats(); // Apply buff effects
        showToast(room.buff.icon, room.buff.name, room.buff.desc, 'info');
        addLog(`✨ Gained buff: ${room.buff.name} - ${room.buff.desc}`, 'skill');
      }
      break;
      
    case 'debuff':
      // Apply debuff and then fight
      if (room.debuff) {
        echoDomainDebuffs.push(room.debuff);
        recalculateStats(); // Apply debuff effects
        showToast(room.debuff.icon, room.debuff.name, room.debuff.desc, 'warning');
        addLog(`💀 Gained debuff: ${room.debuff.name} - ${room.debuff.desc}`, 'warning');
      }
      break;
      
    case 'boss':
      echoDomainBossFound = true;
      showToast('👹', 'ECHO OVERLORD', 'The boss awaits!', 'warning');
      addLog('⚠️ ECHO OVERLORD FOUND!', 'warning');
      break;
  }
  
  // Generate combat room (except for kickout which already returned)
  generateEchoDomainCombatRoom(room);
  
  // Hide domain UI, show game
  document.getElementById('echoDomainUI').style.display = 'none';
}

function generateEchoDomainCombatRoom(room) {
  const config = ECHO_DOMAIN_CONFIG[echoDomainTier];
  // Echo Domains use FIXED difficulty from config, not dungeon settings
  
  // Create small arena
  map.width = 25;
  map.height = 20;
  map.tiles = [];
  map.explored = [];
  map.decorations = [];
  map.edgeShadows = [];
  
  for (let y = 0; y < map.height; y++) {
    map.tiles[y] = [];
    map.explored[y] = [];
    for (let x = 0; x < map.width; x++) {
      if (x < 2 || x >= map.width - 2 || y < 2 || y >= map.height - 2) {
        map.tiles[y][x] = 0;
      } else {
        map.tiles[y][x] = 1;
      }
      map.explored[y][x] = true;
    }
  }
  
  map.rooms = [{ x: 2, y: 2, w: map.width - 4, h: map.height - 4, cleared: false }];
  
  // Position player
  player.x = (map.width / 2) * TILE;
  player.y = (map.height - 4) * TILE;
  player.state = 'idle';
  
  // Clear entities
  enemies = [];
  loot = [];
  path = [];
  pathTarget = null;
  exitPos = null;
  window.pathCommitment = 0;
  window.targetDistHistory = [];
  
  camera.x = player.x;
  camera.y = player.y;
  
  // Spawn enemies based on room type
  if (room.type === 'boss') {
    // Spawn Echo Overlord
    const bossX = (map.width / 2) * TILE;
    const bossY = 5 * TILE;
    
    // Use config's fixed difficulty for boss
    const bossHp = Math.floor(5000 * echoDomainTier * config.enemyHpMult);
    const bossDmg = [Math.floor((25 + echoDomainTier * 5) * config.enemyDmgMult), 
                     Math.floor((35 + echoDomainTier * 8) * config.enemyDmgMult)];
    
    enemies.push({
      name: 'Echo Overlord',
      x: bossX,
      y: bossY,
      hp: bossHp,
      maxHp: bossHp,
      dmg: bossDmg,
      spd: 50,
      atkCD: 0,
      flash: 0,
      id: Math.random(),
      room: map.rooms[0],
      active: true,
      isBoss: true,
      isEcho: true,
      size: 1.8,
      color: config.color,
      exp: Math.floor(500 * echoDomainTier * config.expMult),
      gold: 100 * echoDomainTier,
      debuffs: [],
      unreachable: false
    });
    
    window.fightingOverlord = true;
  } else {
    // Normal enemies
    for (let i = 0; i < room.enemyCount; i++) {
      const type = ENEMIES[Math.floor(Math.random() * ENEMIES.length)];
      const isElite = Math.random() < room.eliteChance;
      
      const ex = (4 + Math.random() * (map.width - 8)) * TILE;
      const ey = (3 + Math.random() * 6) * TILE;
      
      // Use config's fixed difficulty
      const eliteHpMult = isElite ? 3.0 : 1.0;
      const eliteDmgMult = isElite ? 1.4 : 1.0;
      const totalHpMult = config.enemyHpMult * eliteHpMult;
      const totalDmgMult = config.enemyDmgMult * eliteDmgMult;
      
      enemies.push({
        ...type,
        name: isElite ? `Echo Elite ${type.name}` : `Echo ${type.name}`,
        x: ex,
        y: ey,
        hp: Math.floor(type.hp * totalHpMult),
        maxHp: Math.floor(type.hp * totalHpMult),
        dmg: [Math.floor(type.dmg[0] * totalDmgMult), Math.floor(type.dmg[1] * totalDmgMult)],
        spd: type.spd || 40,
        atkCD: 0,
        flash: 0,
        id: Math.random(),
        room: map.rooms[0],
        active: true,
        isElite: isElite,
        isEcho: true,
        size: isElite ? type.size * 1.3 : type.size,
        color: isElite ? config.color : shadeColor(config.color, -30),
        exp: Math.floor((isElite ? type.exp * 2 : type.exp) * config.expMult),
        gold: type.gold,
        debuffs: [],
        unreachable: false
      });
    }
    
    window.fightingOverlord = false;
  }
  
  window.currentEchoDomainRoom = room;
}

function applyEchoDomainEffects() {
  // This modifies player stats based on active buffs/debuffs
  // Effects are applied during recalculateStats()
}

function checkEchoDomainRoomComplete() {
  if (!echoDomainActive || !window.currentEchoDomainRoom) return;
  
  const room = window.currentEchoDomainRoom;
  const aliveEnemies = enemies.filter(e => !e.dead && e.hp > 0);
  
  if (aliveEnemies.length === 0 && !room.cleared) {
    completeEchoDomainRoom(room);
  }
}

function completeEchoDomainRoom(room) {
  room.cleared = true;
  
  const config = ECHO_DOMAIN_CONFIG[echoDomainTier];
  
  // Echo Domain rewards are SPARSE - mostly nothing per room
  // Occasional crafting materials, very rare Echo Cores (Divine-tier)
  
  // Small chance at crafting materials per room (10-20%)
  const orbChance = 0.05 + echoDomainTier * 0.05; // 10%/15%/20% per room
  if (Math.random() < orbChance) {
    const roll = Math.random() * 100;
    let orbType;
    if (roll < 50) orbType = 'orbOfTransmute';
    else if (roll < 80) orbType = 'orbOfAugment';
    else if (roll < 95) orbType = 'chaosOrb';
    else orbType = 'exaltedOrb'; // 5% of drops
    
    player.currency = player.currency || {};
    player.currency[orbType] = (player.currency[orbType] || 0) + 1;
    addLog(`Found ${orbType === 'exaltedOrb' ? 'Exalted Orb!' : 'crafting orb'}`, 'loot');
  }
  
  // Boss killed? This is the ONLY way to get Echo Cores
  if (room.type === 'boss') {
    window.fightingOverlord = false;
    
    // GUARANTEED: 6-mod rare item at high ilvl (75-80 - better than regular Core drops)
    const bossIlvl = 75 + Math.floor(Math.random() * 6); // 75-80
    const rareSlots = ['helm', 'chest', 'gloves', 'boots', 'belt', 'amulet', 'ring'];
    const rareSlot = rareSlots[Math.floor(Math.random() * rareSlots.length)];
    const rareItems = LOOT.rare.filter(name => getItemSlot(name) === rareSlot);
    if (rareItems.length > 0) {
      const rareName = rareItems[Math.floor(Math.random() * rareItems.length)];
      const mods = { implicit: null, prefixes: [], suffixes: [] };
      const slot = getItemSlot(rareName);
      const usedModStats = new Set();
      
      // Force 3 prefixes + 3 suffixes at high ilvl
      for (let i = 0; i < 3; i++) {
        let attempts = 0;
        while (attempts < 20) {
          const mod = generateMod(true, slot, rareName, bossIlvl);
          if (mod) {
            const baseStat = mod.stat.replace(/#/g, '').trim();
            if (!usedModStats.has(baseStat)) {
              usedModStats.add(baseStat);
              mods.prefixes.push(mod);
              break;
            }
          }
          attempts++;
        }
      }
      for (let i = 0; i < 3; i++) {
        let attempts = 0;
        while (attempts < 20) {
          const mod = generateMod(false, slot, rareName, bossIlvl);
          if (mod) {
            const baseStat = mod.stat.replace(/#/g, '').trim();
            if (!usedModStats.has(baseStat)) {
              usedModStats.add(baseStat);
              mods.suffixes.push(mod);
              break;
            }
          }
          attempts++;
        }
      }
      
      // Add implicit
      mods.implicit = generateImplicit(rareName);
      
      const overlordRare = {
        name: rareName,
        rarity: 'rare',
        mods: mods,
        ilvl: bossIlvl,
        baseLevel: bossIlvl,
        id: Math.random()
      };
      addToOverflow(overlordRare);
      showToast('🎁', 'Overlord Rare!', `${rareName} (6 mods, ilvl ${bossIlvl})`, 'loot');
      addLog(`🎁 Echo Overlord dropped: ${rareName} (6 mods)`, 'loot');
    }
    
    // Echo Ring - Stat mirroring ring (60-110% of other ring's stats)
    // Drop chance based on tier: T1=1%, T2=3%, T3=5%
    const echoRingChance = [0.01, 0.03, 0.05][echoDomainTier - 1];
    if (Math.random() < echoRingChance) {
      const echoRing = generateEchoRing();
      addToOverflow(echoRing);
      showToast('💍', 'ECHO RING!', `Mirrors ${echoRing.echoPercent}% of your other ring's stats!`, 'unique');
      addLog(`🎉 ECHO RING DROPPED! (${echoRing.echoPercent}% roll)`, 'unique');
    }
    
    // Echo Core - Divine-tier rarity (30%/60%/90% for ONE core)
    const coreChance = [0.30, 0.60, 0.90][echoDomainTier - 1];
    if (Math.random() < coreChance) {
      echoCoresEarned = 1; // Only ever 1 core
      showToast('💎', 'ECHO CORE!', 'An incredibly rare find!', 'unique');
      addLog('💎 ECHO CORE FOUND! (Divine-tier rarity)', 'unique');
    }
    
    // Roll for Aspect drop (only from killing Echo Overlord)
    rollAspectFromEchoDomain(echoDomainTier);
    
    showToast('🏆', 'ECHO OVERLORD DEFEATED!', echoCoresEarned > 0 ? '+1 Echo Core!' : 'Domain complete!', 'info');
    addLog('🏆 ECHO OVERLORD DEFEATED! Domain complete!', 'unique');
    
    // Victory - return to main game
    setTimeout(() => {
      leaveEchoDomain();
    }, 1500);
    return;
  }
  
  addLog(`✓ Room cleared`, 'info');
  showToast('✓', 'Room Cleared', 'Continue exploring...', 'info');
  
  // Return to domain map
  window.currentEchoDomainRoom = null;
  
  setTimeout(() => {
    showEchoDomainUI();
    document.getElementById('echoDomainUI').style.display = 'flex';
  }, 500);
}

function leaveEchoDomain() {
  if (!echoDomainActive) return;
  
  // Award Echo Cores (if any - they're Divine-tier rare)
  player.echoCores = (player.echoCores || 0) + echoCoresEarned;
  
  if (echoCoresEarned > 0) {
    showToast('💎', 'Echo Core!', `An incredibly rare find!`, 'unique');
    addLog(`💎 Gained ${echoCoresEarned} Echo Core(s)!`, 'unique');
  }
  
  // Clear domain state FIRST
  echoDomainActive = false;
  echoDomainBuffs = [];
  echoDomainDebuffs = [];
  window.currentEchoDomainRoom = null;
  window.fightingOverlord = false;
  
  // Restore game state
  if (echoSavedState) {
    map = echoSavedState.map;
    biome = echoSavedState.biome;
    dungeon.level = echoSavedState.dungeonLevel;
    exitPos = echoSavedState.exitPos;
    
    // Restore player position
    player.x = echoSavedState.playerX;
    player.y = echoSavedState.playerY;
    
    // Restore HP/Mana to saved values (or full if not saved)
    player.hp = echoSavedState.playerHp || player.maxHp;
    player.mana = echoSavedState.playerMana || player.maxMana;
    
    // Clear enemies and loot - they were saved as empty
    enemies = [];
    loot = [];
  }
  
  // Reset player state to ensure they're not stuck
  player.state = 'idle';
  path = [];
  pathTarget = null;
  window.pathCommitment = 0;
  window.targetDistHistory = [];
  pathTimer = 0;
  
  // Reset camera to player
  camera.x = player.x;
  camera.y = player.y;
  
  // Recalculate stats (removes echo buffs/debuffs)
  recalculateStats();
  
  hideEchoDomainUI();
  
  addLog('Left Echo Domain', 'system');
  
  // Force a path recalculation on next frame
  setTimeout(() => {
    pathTimer = 0;
    path = [];
  }, 100);
}

function hideEchoDomainUI() {
  const ui = document.getElementById('echoDomainUI');
  if (ui) ui.style.display = 'none';
}

function updateShardDisplays() {
  const riftDisplay = document.getElementById('riftShardCount');
  const echoDisplay = document.getElementById('echoShardCount');
  
  if (riftDisplay) riftDisplay.textContent = shards.rift;
  if (echoDisplay) echoDisplay.textContent = shards.echo;
}

// ════════════════════════════════════════════════════════════════════════════════
// GREATER RIFT SYSTEM (Diablo 3 Style)
// ════════════════════════════════════════════════════════════════════════════════
// - Unlimited scaling difficulty (GR 1, 2, 3... ∞)
// - 5 minute timer
// - Kill enemies to fill progress bar
// - Rift Guardian spawns at 100%
// - Higher GR = better rewards
// - Leaderboard tracks highest completed per class
// ════════════════════════════════════════════════════════════════════════════════

// Greater Rift state
let greaterRiftActive = false;
let greaterRiftLevel = 1;
let greaterRiftProgress = 0;          // 0-100%
let greaterRiftStartTime = 0;         // Timestamp
let greaterRiftTimeLimit = 300;       // 5 minutes in seconds
let greaterRiftGuardianSpawned = false;
let greaterRiftGuardian = null;
let greaterRiftKills = 0;
let greaterRiftHighest = {};          // { monk: 5, warrior: 3, ... }
let greaterRiftKeys = 0;

// Greater Rift saved state (to restore after)
let greaterRiftSavedState = null;

// Greater Rift configuration
const GREATER_RIFT_CONFIG = {
  keysCost: 1,                        // Keys per run
  timeLimit: 300,                     // 5 minutes
  
  // Progress per kill type (percentage) - balanced for ~2-3 floors
  progressPerKill: {
    trash: 0.8,                       // Regular enemy (~125 kills to fill)
    elite: 3.0,                       // Elite enemy (~33 kills to fill)
    champion: 2.0,                    // Champion (mini-elite)
    pack: 1.5                         // Pack member
  },
  // Note: Bosses give 20% progress via orbs (4 orbs x 5% each)
  
  // Enemy scaling per GR level (exponential)
  hpScaling: 1.10,                    // +10% HP per level
  dmgScaling: 1.08,                   // +8% damage per level
  
  // Rewards scaling
  baseGold: 100,                      // Gold per GR level
  basePrismChance: 0.05,              // 5% base prism chance
  prismChancePerLevel: 0.005,         // +0.5% per GR level
  aspectChanceStart: 20,              // Aspects start dropping at GR 20
  aspectChancePerLevel: 0.001,        // +0.1% per level above 20
  
  // Key drops from bosses
  keyDropChance: 0.15                 // 15% chance from dungeon bosses
};

// ========== SKILL XP SYSTEM ==========
// XP required to reach each skill level (1-20)
// Level 1 starts at 0 XP, level 20 is max
const SKILL_XP_TABLE = [
  0,       // Level 1 (starting)
  100,     // Level 2
  250,     // Level 3
  475,     // Level 4
  815,     // Level 5
  1315,    // Level 6
  2065,    // Level 7
  3165,    // Level 8
  4815,    // Level 9
  7315,    // Level 10
  11065,   // Level 11
  16665,   // Level 12
  25065,   // Level 13
  37665,   // Level 14
  56665,   // Level 15
  85165,   // Level 16
  127915,  // Level 17
  191915,  // Level 18
  287915,  // Level 19
  431915   // Level 20 (max)
];

// Calculate skill XP granted from completing a GR
// Formula: 50 × 1.08^level (exponential scaling)
function getGreaterRiftSkillXP(grLevel) {
  return Math.floor(50 * Math.pow(1.08, grLevel));
}

// Get skill level from total XP
function getSkillLevel(totalXP) {
  for (let level = SKILL_XP_TABLE.length - 1; level >= 0; level--) {
    if (totalXP >= SKILL_XP_TABLE[level]) {
      return level + 1; // Level is 1-indexed
    }
  }
  return 1;
}

// Get XP progress toward next level (0-100%)
function getSkillXPProgress(totalXP) {
  const level = getSkillLevel(totalXP);
  if (level >= 20) return 100; // Max level
  
  const currentLevelXP = SKILL_XP_TABLE[level - 1];
  const nextLevelXP = SKILL_XP_TABLE[level];
  const xpInLevel = totalXP - currentLevelXP;
  const xpNeeded = nextLevelXP - currentLevelXP;
  
  return Math.floor((xpInLevel / xpNeeded) * 100);
}

// Store pending XP to award when player selects a skill
let pendingSkillXP = 0;

// Award skill XP to player after GR completion - shows selection modal
function awardSkillXP(grLevel) {
  const xpGained = getGreaterRiftSkillXP(grLevel);
  pendingSkillXP = xpGained;
  
  // Show skill selection modal
  showSkillUpgradeModal(xpGained);
}

// Apply XP to a specific skill
function applySkillXP(skillId, xpAmount) {
  // Initialize skill XP tracking if not present
  if (!player.skillLevels) player.skillLevels = {};
  if (!player.skillLevels[skillId]) player.skillLevels[skillId] = 0;
  
  const oldLevel = getSkillLevel(player.skillLevels[skillId]);
  player.skillLevels[skillId] += xpAmount;
  const newLevel = getSkillLevel(player.skillLevels[skillId]);
  
  // Get skill name for display
  const skillData = SKILL_TOOLTIPS[skillId] || { name: skillId };
  const skillName = skillData.name || skillId;
  
  // Log XP gain
  addLog(`⚡ +${xpAmount} XP to ${skillName}`, 'skill');
  
  // Check for level up
  if (newLevel > oldLevel) {
    addLog(`🎉 ${skillName} reached Rank ${newLevel}!`, 'unique');
    showToast('🎉', 'Skill Rank Up!', `${skillName} Rank ${newLevel}`, 'skill');
  }
}

// Show skill upgrade modal after GR completion - let player pick skill
function showSkillUpgradeModal(xpGained) {
  const classKey = player.class;
  const classSkills = CLASS_SKILLS[classKey] || [];
  
  // Create modal if it doesn't exist
  let modal = document.getElementById('skillUpgradeModal');
  if (!modal) {
    modal = document.createElement('div');
    modal.id = 'skillUpgradeModal';
    modal.className = 'modal-overlay';
    document.body.appendChild(modal);
  }
  
  // Default to first skill if none selected
  const defaultSkill = classSkills[0] || 'fistsOfThunderPrimary';
  window.selectedUpgradeSkill = defaultSkill;
  
  // Build skill grid HTML
  let skillGridHTML = '';
  classSkills.forEach((skillId, index) => {
    const skillData = SKILL_TOOLTIPS[skillId] || { name: skillId, icon: '⚡' };
    const skillIcon = skillData.icon || '⚡';
    const currentXP = (player.skillLevels && player.skillLevels[skillId]) || 0;
    const currentLevel = getSkillLevel(currentXP);
    const isSelected = skillId === defaultSkill;
    
    skillGridHTML += `
      <div class="skill-upgrade-grid-item ${isSelected ? 'selected' : ''}" 
           onclick="selectSkillInGrid('${skillId}')" 
           data-skill="${skillId}"
           title="${skillData.name || skillId}">
        ${skillIcon}
        <span class="skill-upgrade-grid-item-rank">${currentLevel}</span>
      </div>
    `;
  });
  
  // Get default skill info
  const defaultData = SKILL_TOOLTIPS[defaultSkill] || { name: defaultSkill, icon: '⚡' };
  const defaultXP = (player.skillLevels && player.skillLevels[defaultSkill]) || 0;
  const defaultLevel = getSkillLevel(defaultXP);
  const defaultProgress = getSkillXPProgress(defaultXP);
  const defaultLevelXP = SKILL_XP_TABLE[defaultLevel - 1] || 0;
  const defaultNextXP = defaultLevel < 20 ? SKILL_XP_TABLE[defaultLevel] : SKILL_XP_TABLE[19];
  
  modal.innerHTML = `
    <div class="skill-upgrade-modal">
      <div class="skill-upgrade-header">⚔ RIFT COMPLETE ⚔</div>
      <div class="skill-upgrade-body">
        <div class="skill-upgrade-display">
          <div class="skill-upgrade-glow"></div>
          <div class="skill-upgrade-selected-icon" id="upgradeSelectedIcon">${defaultData.icon || '⚡'}</div>
          <div class="skill-upgrade-selected-name" id="upgradeSelectedName">${defaultData.name || defaultSkill}</div>
          <div class="skill-upgrade-selected-rank" id="upgradeSelectedRank">Rank ${defaultLevel}</div>
        </div>
        
        <div class="skill-upgrade-xp-container">
          <div class="skill-upgrade-xp-bar">
            <div class="skill-upgrade-xp-fill" id="upgradeXPFill" style="width: ${defaultProgress}%"></div>
            <div class="skill-upgrade-xp-text" id="upgradeXPText">
              ${defaultXP - defaultLevelXP} / ${defaultNextXP - defaultLevelXP} XP
            </div>
          </div>
        </div>
        
        <div class="skill-upgrade-xp-gain">+${xpGained} XP</div>
        
        <button class="skill-upgrade-btn" onclick="confirmSkillUpgrade()">UPGRADE</button>
        
        <div class="skill-upgrade-timer" id="upgradeTimer">
          Auto-assign in <span id="upgradeTimerSeconds">30</span>s
        </div>
        
        <div class="skill-upgrade-grid-label">Select a skill to upgrade</div>
        <div class="skill-upgrade-grid">
          ${skillGridHTML}
        </div>
      </div>
    </div>
  `;
  
  modal.style.display = 'flex';
  
  // Start auto-assign timer (30 seconds)
  window.skillUpgradeTimeLeft = 30;
  clearInterval(window.skillUpgradeTimer);
  window.skillUpgradeTimer = setInterval(() => {
    window.skillUpgradeTimeLeft--;
    const timerEl = document.getElementById('upgradeTimerSeconds');
    if (timerEl) timerEl.textContent = window.skillUpgradeTimeLeft;
    
    if (window.skillUpgradeTimeLeft <= 0) {
      clearInterval(window.skillUpgradeTimer);
      // Auto-assign to random skill
      autoAssignSkillXP();
    }
  }, 1000);
}

// Auto-assign XP to a random skill when timer expires
function autoAssignSkillXP() {
  // Clear the timer regardless
  clearInterval(window.skillUpgradeTimer);
  
  if (pendingSkillXP <= 0) {
    // No pending XP - just close the modal to prevent being stuck
    closeSkillUpgradeModal();
    return;
  }
  
  const classKey = player.class;
  const classSkills = CLASS_SKILLS[classKey] || [];
  
  if (classSkills.length === 0) {
    closeSkillUpgradeModal();
    return;
  }
  
  // Pick random skill
  const randomSkill = classSkills[Math.floor(Math.random() * classSkills.length)];
  const skillData = SKILL_TOOLTIPS[randomSkill] || { name: randomSkill, icon: '⚡' };
  const xpAwarded = pendingSkillXP;
  
  // Get state before applying
  const oldXP = (player.skillLevels && player.skillLevels[randomSkill]) || 0;
  const oldLevel = getSkillLevel(oldXP);
  
  // Apply XP
  applySkillXP(randomSkill, xpAwarded);
  pendingSkillXP = 0;
  
  // Get state after
  const newXP = (player.skillLevels && player.skillLevels[randomSkill]) || 0;
  const newLevel = getSkillLevel(newXP);
  const newProgress = getSkillXPProgress(newXP);
  const leveledUp = newLevel > oldLevel;
  const newLevelXP = SKILL_XP_TABLE[newLevel - 1] || 0;
  const nextLevelXP = newLevel < 20 ? SKILL_XP_TABLE[newLevel] : SKILL_XP_TABLE[19];
  
  addLog(`⏱️ Auto-assigned ${xpAwarded} XP to ${skillData.name || randomSkill}`, 'skill');
  
  // Show toast notification immediately
  showToast('⏱️', 'Auto-Assigned', `+${xpAwarded} XP → ${skillData.name || randomSkill}`, 'skill');
  
  // Update modal to show what happened
  const modal = document.getElementById('skillUpgradeModal');
  if (modal) {
    modal.innerHTML = `
      <div class="skill-upgrade-modal">
        <div class="skill-upgrade-header">⏱️ AUTO-ASSIGNED ⏱️</div>
        <div class="skill-upgrade-body">
          <div class="skill-upgrade-auto-message">
            You were away, so XP was assigned to a random skill:
          </div>
          <div class="skill-upgrade-display">
            <div class="skill-upgrade-glow"></div>
            <div class="skill-upgrade-selected-icon">${skillData.icon || '⚡'}</div>
            <div class="skill-upgrade-selected-name">${skillData.name || randomSkill}</div>
            <div class="skill-upgrade-selected-rank">Rank ${newLevel}</div>
            ${leveledUp ? '<div class="skill-upgrade-levelup">★ RANK UP! ★</div>' : ''}
          </div>
          
          <div class="skill-upgrade-xp-container">
            <div class="skill-upgrade-xp-bar">
              <div class="skill-upgrade-xp-fill" style="width: ${newProgress}%"></div>
              <div class="skill-upgrade-xp-text">
                ${newXP - newLevelXP} / ${nextLevelXP - newLevelXP} XP
              </div>
            </div>
          </div>
          
          <div class="skill-upgrade-xp-gain">+${xpAwarded} XP</div>
          
          <button class="skill-upgrade-btn" onclick="closeSkillUpgradeModal()">GOT IT!</button>
          
          <div class="skill-upgrade-timer" id="autoCloseTimer">
            Closing in <span id="autoCloseSeconds">5</span>s...
          </div>
        </div>
      </div>
    `;
    modal.style.display = 'flex';
    
    // Auto-close after 5 seconds
    window.autoCloseCountdown = 5;
    window.autoCloseTimer = setInterval(() => {
      window.autoCloseCountdown--;
      const el = document.getElementById('autoCloseSeconds');
      if (el) el.textContent = window.autoCloseCountdown;
      
      if (window.autoCloseCountdown <= 0) {
        clearInterval(window.autoCloseTimer);
        closeSkillUpgradeModal();
      }
    }, 1000);
  }
}

// Select a skill in the grid
function selectSkillInGrid(skillId) {
  window.selectedUpgradeSkill = skillId;
  
  // Update selection visuals
  document.querySelectorAll('.skill-upgrade-grid-item').forEach(el => {
    el.classList.remove('selected');
    if (el.dataset.skill === skillId) {
      el.classList.add('selected');
    }
  });
  
  // Update center display
  const skillData = SKILL_TOOLTIPS[skillId] || { name: skillId, icon: '⚡' };
  const currentXP = (player.skillLevels && player.skillLevels[skillId]) || 0;
  const currentLevel = getSkillLevel(currentXP);
  const progress = getSkillXPProgress(currentXP);
  const currentLevelXP = SKILL_XP_TABLE[currentLevel - 1] || 0;
  const nextLevelXP = currentLevel < 20 ? SKILL_XP_TABLE[currentLevel] : SKILL_XP_TABLE[19];
  
  document.getElementById('upgradeSelectedIcon').textContent = skillData.icon || '⚡';
  document.getElementById('upgradeSelectedName').textContent = skillData.name || skillId;
  document.getElementById('upgradeSelectedRank').textContent = `Rank ${currentLevel}`;
  document.getElementById('upgradeXPFill').style.width = `${progress}%`;
  document.getElementById('upgradeXPText').textContent = `${currentXP - currentLevelXP} / ${nextLevelXP - currentLevelXP} XP`;
}

// Confirm skill upgrade - animate and apply
function confirmSkillUpgrade() {
  const skillId = window.selectedUpgradeSkill;
  if (!skillId || pendingSkillXP <= 0) return;
  
  // Clear auto-assign timer
  clearInterval(window.skillUpgradeTimer);
  
  // Hide timer display
  const timerEl = document.getElementById('upgradeTimer');
  if (timerEl) timerEl.style.display = 'none';
  
  const xpToAdd = pendingSkillXP;
  const skillData = SKILL_TOOLTIPS[skillId] || { name: skillId, icon: '⚡' };
  
  // Get current state BEFORE applying XP
  const currentXP = (player.skillLevels && player.skillLevels[skillId]) || 0;
  const currentLevel = getSkillLevel(currentXP);
  
  // Calculate what it will be AFTER
  const newXP = currentXP + xpToAdd;
  const newLevel = getSkillLevel(newXP);
  const newProgress = getSkillXPProgress(newXP);
  const leveledUp = newLevel > currentLevel;
  
  // Get XP thresholds for display
  const newLevelXP = SKILL_XP_TABLE[newLevel - 1] || 0;
  const nextLevelXP = newLevel < 20 ? SKILL_XP_TABLE[newLevel] : SKILL_XP_TABLE[19];
  
  // Disable button during animation
  const btn = document.querySelector('.skill-upgrade-btn');
  if (btn) {
    btn.disabled = true;
    btn.textContent = 'UPGRADING...';
  }
  
  // Animate the XP bar filling
  const xpFill = document.getElementById('upgradeXPFill');
  const xpText = document.getElementById('upgradeXPText');
  const rankText = document.getElementById('upgradeSelectedRank');
  const display = document.querySelector('.skill-upgrade-display');
  
  // Animate over 1.2 seconds
  let animProgress = 0;
  const animDuration = 1200;
  const startTime = performance.now();
  
  function animateXP(timestamp) {
    const elapsed = timestamp - startTime;
    animProgress = Math.min(1, elapsed / animDuration);
    
    // Ease out cubic
    const eased = 1 - Math.pow(1 - animProgress, 3);
    
    const animXP = Math.floor(currentXP + xpToAdd * eased);
    const animLevel = getSkillLevel(animXP);
    const animLevelProgress = getSkillXPProgress(animXP);
    const animLevelXP = SKILL_XP_TABLE[animLevel - 1] || 0;
    const animNextXP = animLevel < 20 ? SKILL_XP_TABLE[animLevel] : SKILL_XP_TABLE[19];
    
    xpFill.style.width = `${animLevelProgress}%`;
    xpText.textContent = `${animXP - animLevelXP} / ${animNextXP - animLevelXP} XP`;
    
    if (animLevel > currentLevel && !display.querySelector('.skill-upgrade-levelup')) {
      rankText.textContent = `Rank ${animLevel}`;
      const levelUpEl = document.createElement('div');
      levelUpEl.className = 'skill-upgrade-levelup';
      levelUpEl.textContent = '★ RANK UP! ★';
      display.appendChild(levelUpEl);
    }
    
    if (animProgress < 1) {
      requestAnimationFrame(animateXP);
    } else {
      // Animation complete - apply XP and enable close
      applySkillXP(skillId, xpToAdd);
      pendingSkillXP = 0;
      
      if (btn) {
        btn.textContent = 'CONTINUE';
        btn.disabled = false;
        btn.onclick = closeSkillUpgradeModal;
      }
    }
  }
  
  requestAnimationFrame(animateXP);
}

function closeSkillUpgradeModal() {
  // Clear all timers
  clearInterval(window.skillUpgradeTimer);
  clearInterval(window.autoCloseTimer);
  
  const modal = document.getElementById('skillUpgradeModal');
  if (modal) modal.style.display = 'none';
  
  // Reset pending XP to prevent issues
  pendingSkillXP = 0;
}

// Get enemy scaling multipliers for current GR level
function getGreaterRiftScaling() {
  const config = GREATER_RIFT_CONFIG;
  return {
    hp: Math.pow(config.hpScaling, greaterRiftLevel - 1),
    damage: Math.pow(config.dmgScaling, greaterRiftLevel - 1)
  };
}

// Start a Greater Rift
function startGreaterRift(level) {
  if (greaterRiftActive || riftSurgeActive || echoDomainActive) {
    showToast('⚠️', 'Already Active', 'Complete current activity first', 'warning');
    return;
  }
  
  // Calculate gold cost based on level and tier
  let tierMult = 1.0;
  if (level === 1) tierMult = 1.0;
  else if (level <= 5) tierMult = 1.2;
  else if (level <= 15) tierMult = 1.5;
  else if (level <= 30) tierMult = 2.0;
  else if (level <= 39) tierMult = 2.5;
  else if (level <= 49) tierMult = 3.0;
  else if (level <= 59) tierMult = 4.0;
  else if (level <= 69) tierMult = 5.0;
  else tierMult = 6.0;
  
  const goldCost = Math.floor(500 * level * tierMult);
  
  if ((player.gold || 0) < goldCost) {
    showToast('💰', 'Not Enough Gold', `You need ${goldCost.toLocaleString()} gold`, 'warning');
    return;
  }
  
  // Charge gold
  player.gold = (player.gold || 0) - goldCost;
  
  // Save current state
  greaterRiftSavedState = {
    difficulty: currentDifficulty,
    floor: dungeon.level,
    enemies: [...enemies],
    loot: [...loot]
  };
  
  // Initialize Greater Rift
  greaterRiftActive = true;
  greaterRiftLevel = level;
  greaterRiftProgress = 0;
  greaterRiftStartTime = Date.now();
  greaterRiftGuardianSpawned = false;
  greaterRiftGuardian = null;
  greaterRiftKills = 0;
  
  // Clear player debuffs
  player.frozen = 0;
  
  // Clear hazards from any previous GR
  guardianHazards = [];
  
  // Clear current enemies and generate rift enemies
  enemies = [];
  loot = [];
  progressOrbs = [];  // Clear any existing progress orbs
  
  // Clear any existing boss bar from regular dungeon
  document.getElementById('bossBar').classList.remove('visible');
  currentBoss = null;
  
  // Generate initial rift enemies
  spawnGreaterRiftEnemies();
  
  // Show UI
  showGreaterRiftUI();
  closeGreaterRiftModal();
  closeDungeonSelector();
  
  addLog(`⚔️ GREATER RIFT ${level} STARTED!`, 'level');
  showToast('⚔️', `Greater Rift ${level}`, '5 minutes to complete!', 'skill');
}

// Spawn enemies for Greater Rift
function spawnGreaterRiftEnemies() {
  const scaling = getGreaterRiftScaling();
  const settings = getDungeonSettings();
  const hpMult = settings.enemyHpMult || 1;
  
  // Greater Rifts should spawn enemies throughout the dungeon like normal dungeons
  // Spawn enough enemies to reach 100% progress (with some extra)
  // Progress per kill: trash = 0.25%, elite = 1.25%, boss = 20% (via orbs)
  // So we need ~400 trash kills, ~80 elite kills, or ~5 boss kills for 100%
  // Spawn ~60-80 regular enemies + bosses spread across all rooms
  
  const totalEnemies = 60 + Math.floor(Math.random() * 20);
  
  // Get all rooms from the map (skip first room where player spawns)
  const spawnRooms = map.rooms.filter((r, idx) => idx > 0);
  
  if (spawnRooms.length === 0) {
    // Fallback if no rooms - use whole map
    spawnRooms.push({ x: 5, y: 5, w: map.width - 10, h: map.height - 10 });
  }
  
  // Distribute enemies across rooms
  const enemiesPerRoom = Math.ceil(totalEnemies / spawnRooms.length);
  
  for (const room of spawnRooms) {
    const roomEnemyCount = enemiesPerRoom + Math.floor(Math.random() * 4) - 2;
    
    for (let i = 0; i < roomEnemyCount; i++) {
      const template = ENEMIES[Math.floor(Math.random() * ENEMIES.length)];
      
      // Spawn within the room bounds
      let x, y, attempts = 0;
      do {
        const margin = 2;
        x = (room.x + margin + Math.random() * Math.max(1, room.w - margin * 2)) * TILE;
        y = (room.y + margin + Math.random() * Math.max(1, room.h - margin * 2)) * TILE;
        attempts++;
      } while (!isWalkable(x, y) && attempts < 30);
      
      // If couldn't find walkable spot, skip this enemy
      if (attempts >= 30) continue;
      
      // 15% chance for elite
      const isElite = Math.random() < 0.15;
      
      // Apply damage scaling to dmg array
      const scaledDmgMin = Math.floor(template.dmg[0] * scaling.damage * (isElite ? 1.5 : 1));
      const scaledDmgMax = Math.floor(template.dmg[1] * scaling.damage * (isElite ? 1.5 : 1));
      
      const enemy = {
        ...template,
        id: Math.random(),
        x, y,
        hp: Math.floor(template.hp * hpMult * scaling.hp * (isElite ? 3 : 1)),
        maxHp: Math.floor(template.hp * hpMult * scaling.hp * (isElite ? 3 : 1)),
        dmg: [scaledDmgMin, scaledDmgMax],
        isGreaterRift: true,
        isElite: isElite,
        grDamageScale: scaling.damage,
        accuracy: template.accuracy || 100,
        damage: template.damage || { physical: 0.5, element: 'fire', elemental: 0.5 },
        room: room,
        active: false  // Start inactive - player must explore to find them!
      };
      
      enemies.push(enemy);
    }
    
    // Spawn a GR boss in most rooms (70% chance) - gives 20% progress via orbs
    if (Math.random() < 0.7) {
      spawnGreaterRiftBoss(room, scaling, hpMult);
    }
  }
  
  // Log enemy count for debugging
  console.log(`Greater Rift: Spawned ${enemies.length} enemies across ${spawnRooms.length} rooms`);
}

// Spawn a Greater Rift boss in a room
function spawnGreaterRiftBoss(room, scaling, hpMult) {
  const template = ENEMIES[Math.floor(Math.random() * ENEMIES.length)];
  
  // Spawn in center of room
  let x = (room.x + room.w / 2) * TILE;
  let y = (room.y + room.h / 2) * TILE;
  
  // Make sure spawn is walkable
  let attempts = 0;
  while (!isWalkable(x, y) && attempts < 20) {
    x = (room.x + 1 + Math.random() * (room.w - 2)) * TILE;
    y = (room.y + 1 + Math.random() * (room.h - 2)) * TILE;
    attempts++;
  }
  
  // Boss stats: 8x HP, 2x damage, larger size
  const scaledDmgMin = Math.floor(template.dmg[0] * scaling.damage * 2);
  const scaledDmgMax = Math.floor(template.dmg[1] * scaling.damage * 2);
  
  const boss = {
    ...template,
    id: Math.random(),
    x, y,
    hp: Math.floor(template.hp * hpMult * scaling.hp * 8),
    maxHp: Math.floor(template.hp * hpMult * scaling.hp * 8),
    dmg: [scaledDmgMin, scaledDmgMax],
    size: template.size * 1.8,
    isBoss: true,
    isGreaterRift: true,
    grDamageScale: scaling.damage,
    name: generateBossName(),
    accuracy: (template.accuracy || 100) + 20,
    damage: template.damage || { physical: 0.5, element: 'fire', elemental: 0.5 },
    room: room,
    active: false
  };
  
  enemies.push(boss);
}

// Handle Greater Rift enemy kill
function handleGreaterRiftKill(enemy) {
  if (!greaterRiftActive) return;
  
  greaterRiftKills++;
  
  // Bosses spawn progress orbs instead of giving instant progress
  if (enemy.isBoss && !enemy.isGuardian) {
    spawnProgressOrbs(enemy.x, enemy.y, 4, 5.0);  // 4 orbs, 5% each = 20% total
    // Play sound/effect
    addLog('💜 Progress orbs released!', 'skill');
  } else {
    // Regular enemies give instant progress
    let progressGain = GREATER_RIFT_CONFIG.progressPerKill.trash;
    if (enemy.isElite) {
      progressGain = GREATER_RIFT_CONFIG.progressPerKill.elite;
    }
    
    greaterRiftProgress = Math.min(100, greaterRiftProgress + progressGain);
  }
  
  // Check for guardian spawn
  if (greaterRiftProgress >= 100 && !greaterRiftGuardianSpawned) {
    spawnGreaterRiftGuardian();
  }
  
  // No continuous respawning - Greater Rifts have a fixed enemy pool like dungeons
  // Player must explore to find remaining enemies
  
  updateGreaterRiftUI();
}

// Spawn progress orbs from boss kills
function spawnProgressOrbs(x, y, count, progressEach) {
  const angles = [];
  for (let i = 0; i < count; i++) {
    angles.push((Math.PI * 2 * i) / count + Math.random() * 0.3);
  }
  
  for (let i = 0; i < count; i++) {
    const angle = angles[i];
    const dist = 40 + Math.random() * 30;  // Spread out from boss
    
    progressOrbs.push({
      x: x + Math.cos(angle) * dist,
      y: y + Math.sin(angle) * dist,
      targetX: x + Math.cos(angle) * dist,  // Initial burst position
      targetY: y + Math.sin(angle) * dist,
      vx: Math.cos(angle) * 3,  // Initial burst velocity
      vy: Math.sin(angle) * 3,
      progress: progressEach,
      size: 12 + Math.random() * 4,
      pulse: Math.random() * Math.PI * 2,  // Phase offset for pulsing
      trail: [],  // Trail particles
      state: 'burst',  // 'burst' -> 'hover' -> 'collect'
      burstTime: 0,
      hoverTime: 0,
      collectSpeed: 0,
      collected: false,
      sparkles: []  // Orbiting sparkles
    });
  }
}

// Update progress orbs - animate toward player and collect
function updateProgressOrbs(dt) {
  const deltaSeconds = window.deltaSeconds || 0.016;
  
  for (let i = progressOrbs.length - 1; i >= 0; i--) {
    const orb = progressOrbs[i];
    
    // Update pulse animation
    orb.pulse += deltaSeconds * 4;
    
    // State machine for orb behavior
    if (orb.state === 'burst') {
      // Initial burst outward
      orb.x += orb.vx * dt;
      orb.y += orb.vy * dt;
      orb.vx *= Math.pow(0.92, dt);
      orb.vy *= Math.pow(0.92, dt);
      orb.burstTime += deltaSeconds;
      
      // After burst, start hovering
      if (orb.burstTime > 0.5) {
        orb.state = 'hover';
        orb.hoverTime = 0;
      }
    } else if (orb.state === 'hover') {
      // Gentle float with slight wobble
      orb.x += Math.sin(orb.pulse * 2) * 0.3 * dt;
      orb.y += Math.cos(orb.pulse * 1.5) * 0.2 * dt;
      orb.hoverTime += deltaSeconds;
      
      // After hovering, start collecting toward player
      if (orb.hoverTime > 0.8) {
        orb.state = 'collect';
        orb.collectSpeed = 0.5;
      }
    } else if (orb.state === 'collect') {
      // Accelerate toward player
      orb.collectSpeed = Math.min(orb.collectSpeed + deltaSeconds * 8, 15);
      
      const dx = player.x - orb.x;
      const dy = player.y - orb.y;
      const dist = Math.hypot(dx, dy);
      
      if (dist > 0) {
        const speed = orb.collectSpeed * TILE * deltaSeconds;
        orb.x += (dx / dist) * speed;
        orb.y += (dy / dist) * speed;
      }
      
      // Check for collection
      if (dist < TILE * 0.8) {
        // Collected! Add progress
        greaterRiftProgress = Math.min(100, greaterRiftProgress + orb.progress);
        
        // Spawn collection burst particles
        for (let j = 0; j < 12; j++) {
          const angle = (Math.PI * 2 * j) / 12;
          particles.push({
            x: orb.x,
            y: orb.y,
            vx: Math.cos(angle) * 3,
            vy: Math.sin(angle) * 3,
            life: 20,
            size: 4 + Math.random() * 3,
            color: j % 2 === 0 ? '#a855f7' : '#c084fc'
          });
        }
        
        // Check for guardian spawn
        if (greaterRiftProgress >= 100 && !greaterRiftGuardianSpawned) {
          spawnGreaterRiftGuardian();
        }
        
        updateGreaterRiftUI();
        progressOrbs.splice(i, 1);
        continue;
      }
    }
    
    // Update trail
    orb.trail.unshift({ x: orb.x, y: orb.y, alpha: 1 });
    if (orb.trail.length > 12) orb.trail.pop();
    for (let t = 0; t < orb.trail.length; t++) {
      orb.trail[t].alpha *= 0.85;
    }
    
    // Update orbiting sparkles
    if (orb.sparkles.length < 4) {
      orb.sparkles.push({
        angle: Math.random() * Math.PI * 2,
        dist: orb.size * 1.5 + Math.random() * 5,
        speed: 2 + Math.random() * 2,
        size: 2 + Math.random() * 2
      });
    }
    for (const sparkle of orb.sparkles) {
      sparkle.angle += sparkle.speed * deltaSeconds;
    }
  }
}

// Render progress orbs with glow effects
function renderProgressOrbs(ctx) {
  for (const orb of progressOrbs) {
    const pulseScale = 1 + Math.sin(orb.pulse) * 0.15;
    const currentSize = orb.size * pulseScale;
    
    // Draw trail
    ctx.lineCap = 'round';
    for (let t = 0; t < orb.trail.length - 1; t++) {
      const t1 = orb.trail[t];
      const t2 = orb.trail[t + 1];
      const trailSize = currentSize * (1 - t / orb.trail.length) * 0.6;
      
      ctx.globalAlpha = t1.alpha * 0.5;
      ctx.strokeStyle = '#a855f7';
      ctx.lineWidth = trailSize;
      ctx.beginPath();
      ctx.moveTo(t1.x, t1.y);
      ctx.lineTo(t2.x, t2.y);
      ctx.stroke();
    }
    
    // Draw outer glow
    const gradient = ctx.createRadialGradient(orb.x, orb.y, 0, orb.x, orb.y, currentSize * 3);
    gradient.addColorStop(0, 'rgba(168, 85, 247, 0.4)');
    gradient.addColorStop(0.5, 'rgba(139, 92, 246, 0.2)');
    gradient.addColorStop(1, 'rgba(139, 92, 246, 0)');
    
    ctx.globalAlpha = 0.8;
    ctx.fillStyle = gradient;
    ctx.beginPath();
    ctx.arc(orb.x, orb.y, currentSize * 3, 0, Math.PI * 2);
    ctx.fill();
    
    // Draw middle glow
    const innerGradient = ctx.createRadialGradient(orb.x, orb.y, 0, orb.x, orb.y, currentSize * 1.5);
    innerGradient.addColorStop(0, 'rgba(233, 213, 255, 0.9)');
    innerGradient.addColorStop(0.5, 'rgba(192, 132, 252, 0.7)');
    innerGradient.addColorStop(1, 'rgba(168, 85, 247, 0.3)');
    
    ctx.globalAlpha = 1;
    ctx.fillStyle = innerGradient;
    ctx.beginPath();
    ctx.arc(orb.x, orb.y, currentSize * 1.5, 0, Math.PI * 2);
    ctx.fill();
    
    // Draw core
    ctx.fillStyle = '#f5f3ff';
    ctx.beginPath();
    ctx.arc(orb.x, orb.y, currentSize * 0.5, 0, Math.PI * 2);
    ctx.fill();
    
    // Draw orbiting sparkles
    for (const sparkle of orb.sparkles) {
      const sx = orb.x + Math.cos(sparkle.angle) * sparkle.dist;
      const sy = orb.y + Math.sin(sparkle.angle) * sparkle.dist;
      
      ctx.globalAlpha = 0.8;
      ctx.fillStyle = '#e9d5ff';
      ctx.beginPath();
      ctx.arc(sx, sy, sparkle.size, 0, Math.PI * 2);
      ctx.fill();
    }
  }
  
  ctx.globalAlpha = 1;
}

// Spawn the Rift Guardian
function spawnGreaterRiftGuardian() {
  if (greaterRiftGuardianSpawned) return;
  
  greaterRiftGuardianSpawned = true;
  
  const scaling = getGreaterRiftScaling();
  const settings = getDungeonSettings();
  const hpMult = settings.enemyHpMult || 1;
  
  // Guardian is a super-boss (reduced HP for faster fights)
  const guardianHP = Math.floor(187 * hpMult * scaling.hp);
  
  // Spawn near player on walkable tile - try closer first
  let x, y, attempts = 0;
  let spawnDist = TILE * 3; // Start close
  do {
    const angle = Math.random() * Math.PI * 2;
    x = player.x + Math.cos(angle) * spawnDist;
    y = player.y + Math.sin(angle) * spawnDist;
    attempts++;
    // Gradually increase spawn distance if having trouble finding spot
    if (attempts % 10 === 0) spawnDist += TILE;
  } while (!isWalkable(x, y) && attempts < 100);
  
  // Fallback - spawn directly on player (they'll bump apart)
  if (!isWalkable(x, y)) {
    x = player.x + TILE * 2;
    y = player.y + TILE * 2;
    // If still not walkable, just put on player
    if (!isWalkable(x, y)) {
      x = player.x;
      y = player.y;
    }
  }
  
  // Guardian base damage scaled by GR level
  const guardianDmgMin = Math.floor(15 * scaling.damage);
  const guardianDmgMax = Math.floor(25 * scaling.damage);
  
  // Ability damage scales much slower (sqrt scaling, capped)
  // This prevents abilities from one-shotting at high GR levels
  const abilityDamageScale = Math.min(10, 1 + Math.sqrt(greaterRiftLevel) * 0.5);
  const abilityBaseDamage = 20 * abilityDamageScale;  // Used for hazard calculations
  
  // Pick random mechanics for this guardian (2-3 mechanics)
  const allMechanics = ['tornado', 'flamethrower', 'iceExplosion', 'voidZone'];
  const numMechanics = 2 + (greaterRiftLevel >= 20 ? 1 : 0);
  const shuffled = allMechanics.sort(() => Math.random() - 0.5);
  const guardianMechanics = shuffled.slice(0, numMechanics);
  
  greaterRiftGuardian = {
    id: Math.random(),
    name: `Rift Guardian (GR${greaterRiftLevel})`,
    x, y,
    hp: guardianHP,
    maxHp: guardianHP,
    dmg: [guardianDmgMin, guardianDmgMax],
    abilityDamage: abilityBaseDamage,  // Separate, softer scaling for abilities
    spd: 1.2,
    color: '#8a3030',
    size: 45,  // Bigger than regular bosses
    type: 'demon',  // Use demon sprite for proper appearance
    exp: 100 * greaterRiftLevel,
    gold: [50, 100],
    isBoss: true,
    isGuardian: true,
    isGreaterRift: true,
    accuracy: 120,
    grDamageScale: scaling.damage,
    canLeap: true,
    leapChance: 0.06,
    damage: { physical: 0.4, element: 'fire', elemental: 0.6 },
    active: true,
    // Guardian special mechanics
    mechanics: guardianMechanics,
    mechanicTimers: {
      tornado: 0,
      flamethrower: 0,
      iceExplosion: 0,
      voidZone: 0
    }
  };
  
  enemies.push(greaterRiftGuardian);
  
  // Clear remaining trash
  enemies = enemies.filter(e => e.isGuardian || e.dead);
  
  addLog(`💀 RIFT GUARDIAN SPAWNED!`, 'level');
  showToast('💀', 'Rift Guardian!', 'Defeat it to complete the rift!', 'warning');
  
  // Show boss bar
  currentBoss = greaterRiftGuardian;
  document.getElementById('bossBar').classList.add('visible');
  document.getElementById('bossName').textContent = greaterRiftGuardian.name;
  updateBossBar();
}

// Complete Greater Rift (called when guardian dies)
function completeGreaterRift() {
  if (!greaterRiftActive) return;
  
  const timeElapsed = (Date.now() - greaterRiftStartTime) / 1000;
  const timeRemaining = Math.max(0, greaterRiftTimeLimit - timeElapsed);
  
  // Get tier multiplier for rewards (Core tiers give bonus)
  let tierMult = 1.0;
  let tierName = 'Normal';
  if (greaterRiftLevel === 1) { tierMult = 1.0; tierName = 'Normal'; }
  else if (greaterRiftLevel <= 5) { tierMult = 1.2; tierName = 'Hard'; }
  else if (greaterRiftLevel <= 15) { tierMult = 1.5; tierName = 'Elite'; }
  else if (greaterRiftLevel <= 30) { tierMult = 2.0; tierName = 'Nightmare'; }
  else if (greaterRiftLevel <= 39) { tierMult = 2.5; tierName = 'Core'; }
  else if (greaterRiftLevel <= 49) { tierMult = 3.0; tierName = 'Core II'; }
  else if (greaterRiftLevel <= 59) { tierMult = 4.0; tierName = 'Core III'; }
  else if (greaterRiftLevel <= 69) { tierMult = 5.0; tierName = 'Core IV'; }
  else { tierMult = 6.0; tierName = 'Core V'; }
  
  // Calculate rewards with tier scaling
  const config = GREATER_RIFT_CONFIG;
  const goldReward = Math.floor(config.baseGold * greaterRiftLevel * tierMult);
  const prismChance = (config.basePrismChance + (greaterRiftLevel * config.prismChancePerLevel)) * tierMult;
  const aspectChance = greaterRiftLevel >= config.aspectChanceStart 
    ? (greaterRiftLevel - config.aspectChanceStart) * config.aspectChancePerLevel * tierMult
    : 0;
  
  // Award gold
  player.gold = (player.gold || 0) + goldReward;
  
  // Roll for prism
  let prismAwarded = false;
  if (Math.random() < prismChance) {
    player.currency = player.currency || {};
    player.currency.gemcuttersPrism = (player.currency.gemcuttersPrism || 0) + 1;
    prismAwarded = true;
  }
  
  // Roll for aspect (GR 20+)
  let aspectAwarded = false;
  if (Math.random() < aspectChance) {
    const aspect = getRandomAspectOfRarity('rare');
    if (aspect) {
      unlockAspect(aspect.id);
      aspectAwarded = true;
    }
  }
  
  // Award bonus keys for fast completion (under 10 min)
  let bonusKeys = 0;
  if (timeRemaining > 300) { // More than 5 min left
    bonusKeys = 2;
  } else if (timeRemaining > 0) {
    bonusKeys = 1;
  }
  greaterRiftKeys += bonusKeys;
  
  // Update highest completed
  if (!greaterRiftHighest[player.class] || greaterRiftLevel > greaterRiftHighest[player.class]) {
    greaterRiftHighest[player.class] = greaterRiftLevel;
    addLog(`🏆 NEW RECORD: GR${greaterRiftLevel} for ${player.class}!`, 'unique');
  }
  
  // Build completion message
  let msg = `Greater Rift ${greaterRiftLevel} Complete!`;
  addLog(`✅ ${msg}`, 'level');
  addLog(`💰 +${goldReward}g${prismAwarded ? ' 💎+1 Prism' : ''}${bonusKeys > 0 ? ` 🔑+${bonusKeys} Keys` : ''}`, 'loot');
  if (aspectAwarded) {
    addLog(`🔮 Aspect Unlocked!`, 'unique');
  }
  
  showToast('✅', msg, `+${goldReward}g${bonusKeys > 0 ? ` +${bonusKeys} keys` : ''}`, 'skill');
  
  // Award skill XP
  awardSkillXP(greaterRiftLevel);
  
  // Steam integration: GR completion achievement and leaderboard
  onGRCompleted_Steam(greaterRiftLevel, timeElapsed);
  
  // End the rift
  endGreaterRift(true);
}

// Fail Greater Rift (time ran out)
function failGreaterRift() {
  addLog(`❌ Greater Rift ${greaterRiftLevel} Failed - Time's Up!`, 'warning');
  showToast('❌', 'Time Expired', `Greater Rift ${greaterRiftLevel} failed`, 'warning');
  endGreaterRift(false);
}

// End Greater Rift and restore state
function endGreaterRift(success) {
  greaterRiftActive = false;
  greaterRiftGuardianSpawned = false;
  greaterRiftGuardian = null;
  
  // Clear guardian hazards
  guardianHazards = [];
  
  // Clear player debuffs from GR
  player.frozen = 0;
  
  // Hide UI
  hideGreaterRiftUI();
  document.getElementById('bossBar').classList.remove('visible');
  currentBoss = null;
  
  // Clear all GR enemies
  enemies = [];
  loot = [];
  progressOrbs = [];  // Clear progress orbs
  if (greaterRiftSavedState) {
    // Restore difficulty and floor
    currentDifficulty = greaterRiftSavedState.difficulty || 'easy';
    dungeon.level = greaterRiftSavedState.floor || 1;
    greaterRiftSavedState = null;
  }
  
  // Regenerate the dungeon (this sets up rooms properly for spawnEnemy)
  generateDungeon();
  
  updateGreaterRiftKeyDisplay();
  
  addLog('Returned to dungeon', 'system');
}

// Update Greater Rift timer (called from game loop)
function updateGreaterRiftTimer() {
  if (!greaterRiftActive) return;
  
  const timeElapsed = (Date.now() - greaterRiftStartTime) / 1000;
  const timeRemaining = Math.max(0, greaterRiftTimeLimit - timeElapsed);
  
  // Check for timeout
  if (timeRemaining <= 0) {
    failGreaterRift();
    return;
  }
  
  updateGreaterRiftUI();
}

// Show Greater Rift UI overlay
function showGreaterRiftUI() {
  let ui = document.getElementById('greaterRiftUI');
  if (!ui) {
    // Create UI if it doesn't exist
    ui = document.createElement('div');
    ui.id = 'greaterRiftUI';
    ui.className = 'greater-rift-ui';
    ui.innerHTML = `
      <div class="gr-objectives-header">
        <span class="gr-objectives-title">⚔ Objectives</span>
      </div>
      <div class="gr-objectives-body">
        <div class="gr-rift-name">Greater Rift <span id="grLevelDisplay">1</span></div>
        <div class="gr-objective-item" id="grObjective1">
          <div class="gr-objective-checkbox" id="grCheck1"></div>
          <span>Fill the progress bar</span>
        </div>
        <div class="gr-objective-item" id="grObjective2">
          <div class="gr-objective-checkbox" id="grCheck2"></div>
          <span>Kill the Rift Guardian</span>
        </div>
        <div class="gr-bonus-item">
          <div class="gr-bonus-icon">★</div>
          <div class="gr-bonus-text"><strong>Bonus:</strong> Complete before time runs out to earn skill XP!</div>
        </div>
      </div>
      <div class="gr-progress-section">
        <div class="gr-progress-label">Your Progress</div>
        <div class="gr-progress-container">
          <div class="gr-progress-behind" id="grProgressBehind"></div>
          <div class="gr-progress-bar" id="grProgressBar"></div>
          <div class="gr-timer-marker" id="grTimerMarker"></div>
          <div class="gr-timer-display" id="grTimer">5:00</div>
        </div>
      </div>
    `;
    document.body.appendChild(ui);
  }
  ui.style.display = 'flex';
  
  // Reset progress bar to purple (remove guardian orange)
  const progressBar = document.getElementById('grProgressBar');
  if (progressBar) {
    progressBar.classList.remove('guardian');
    progressBar.style.width = '0%';
  }
  
  // Reset behind indicator
  const behindBar = document.getElementById('grProgressBehind');
  if (behindBar) {
    behindBar.style.width = '0%';
  }
  
  // Reset objective checkboxes
  const check1 = document.getElementById('grCheck1');
  const check2 = document.getElementById('grCheck2');
  const obj1 = document.getElementById('grObjective1');
  const obj2 = document.getElementById('grObjective2');
  if (check1) check1.classList.remove('checked');
  if (check2) check2.classList.remove('checked');
  if (obj1) obj1.classList.remove('completed');
  if (obj2) obj2.classList.remove('completed');
  
  // Activate purple overlay
  const overlay = document.getElementById('greaterRiftOverlay');
  if (overlay) overlay.classList.add('active');
  
  // Update dungeon info display
  const dungeonInfo = document.getElementById('dungeonInfo');
  const dungeonName = document.getElementById('dungeonName');
  const dungeonDifficulty = document.getElementById('dungeonDifficulty');
  if (dungeonInfo) dungeonInfo.classList.add('greater-rift-active');
  if (dungeonName) dungeonName.textContent = `Greater Rift ${greaterRiftLevel}`;
  if (dungeonDifficulty) {
    let tierName = 'Normal';
    if (greaterRiftLevel === 1) tierName = 'Normal';
    else if (greaterRiftLevel <= 5) tierName = 'Hard';
    else if (greaterRiftLevel <= 15) tierName = 'Elite';
    else if (greaterRiftLevel <= 30) tierName = 'Nightmare';
    else if (greaterRiftLevel <= 39) tierName = 'Core';
    else if (greaterRiftLevel <= 49) tierName = 'Core II';
    else if (greaterRiftLevel <= 59) tierName = 'Core III';
    else if (greaterRiftLevel <= 69) tierName = 'Core IV';
    else tierName = 'Core V';
    dungeonDifficulty.textContent = tierName;
  }
  
  updateGreaterRiftUI();
}

// Hide Greater Rift UI
function hideGreaterRiftUI() {
  const ui = document.getElementById('greaterRiftUI');
  if (ui) ui.style.display = 'none';
  
  // Remove purple overlay
  const overlay = document.getElementById('greaterRiftOverlay');
  if (overlay) overlay.classList.remove('active');
  
  // Restore dungeon info display
  const dungeonInfo = document.getElementById('dungeonInfo');
  const dungeonName = document.getElementById('dungeonName');
  const dungeonDifficulty = document.getElementById('dungeonDifficulty');
  if (dungeonInfo) dungeonInfo.classList.remove('greater-rift-active');
  
  // Restore normal dungeon name
  const settings = getDungeonSettings();
  if (dungeonName && settings) dungeonName.textContent = settings.subtitle || settings.name;
  if (dungeonDifficulty && settings) dungeonDifficulty.textContent = settings.name;
}

// Update Greater Rift UI
function updateGreaterRiftUI() {
  const levelDisplay = document.getElementById('grLevelDisplay');
  const timerDisplay = document.getElementById('grTimer');
  const timerMarker = document.getElementById('grTimerMarker');
  const progressBar = document.getElementById('grProgressBar');
  const behindBar = document.getElementById('grProgressBehind');
  const check1 = document.getElementById('grCheck1');
  const check2 = document.getElementById('grCheck2');
  const obj1 = document.getElementById('grObjective1');
  const obj2 = document.getElementById('grObjective2');
  
  if (!levelDisplay) return;
  
  levelDisplay.textContent = greaterRiftLevel;
  
  // Timer
  const timeElapsed = (Date.now() - greaterRiftStartTime) / 1000;
  const timeRemaining = Math.max(0, greaterRiftTimeLimit - timeElapsed);
  const minutes = Math.floor(timeRemaining / 60);
  const seconds = Math.floor(timeRemaining % 60);
  timerDisplay.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
  
  // Timer marker position (shows time ELAPSED - moves left to right)
  // If progress bar is ahead of marker, you're ahead of schedule!
  const timeElapsedPercent = (timeElapsed / greaterRiftTimeLimit) * 100;
  if (timerMarker) timerMarker.style.left = `${Math.min(100, timeElapsedPercent)}%`;
  
  // Color timer based on urgency
  if (timeRemaining < 30) {
    timerDisplay.classList.add('urgent');
  } else {
    timerDisplay.classList.remove('urgent');
  }
  
  // Progress bar
  progressBar.style.width = `${greaterRiftProgress}%`;
  
  // Behind indicator - show dark red bar from progress to timer marker when behind
  if (behindBar) {
    if (greaterRiftProgress < timeElapsedPercent && !greaterRiftGuardianSpawned) {
      // We're behind schedule - show the gap
      behindBar.style.left = `${greaterRiftProgress}%`;
      behindBar.style.width = `${Math.min(100, timeElapsedPercent) - greaterRiftProgress}%`;
    } else {
      // We're ahead or caught up - hide the behind bar
      behindBar.style.width = '0%';
    }
  }
  
  // Update objectives checkboxes
  if (greaterRiftProgress >= 100) {
    if (check1) check1.classList.add('checked');
    if (obj1) obj1.classList.add('completed');
  }
  
  if (greaterRiftGuardianSpawned && greaterRiftGuardian && greaterRiftGuardian.dead) {
    if (check2) check2.classList.add('checked');
    if (obj2) obj2.classList.add('completed');
  }
  
  // Change progress bar color when guardian spawned
  if (greaterRiftGuardianSpawned) {
    progressBar.classList.add('guardian');
  }
}

// Open Greater Rift selection modal
function openGreaterRiftModal() {
  let modal = document.getElementById('greaterRiftModal');
  if (!modal) {
    // Create modal
    modal = document.createElement('div');
    modal.id = 'greaterRiftModal';
    modal.className = 'modal-overlay';
    modal.onclick = function(e) { if (e.target === modal) closeGreaterRiftModal(); };
    modal.innerHTML = `
      <div class="gr-d3-modal">
        <div class="gr-d3-header">
          <div class="gr-d3-header-decor left"></div>
          <span class="gr-d3-title">GREATER RIFTS</span>
          <div class="gr-d3-header-decor right"></div>
        </div>
        
        <div class="gr-d3-body">
          <div class="gr-d3-portal">
            <img src="https://raw.githubusercontent.com/Graphic37/ARPG-/main/greater%20rift1.png" alt="Greater Rift Portal" class="gr-d3-portal-img">
          </div>
          
          <div class="gr-d3-select-wrapper">
            <div class="gr-custom-dropdown" id="grCustomDropdown">
              <div class="gr-custom-dropdown-selected" id="grDropdownSelected" onclick="toggleGRDropdown()">
                Level 1 (Normal)
              </div>
              <div class="gr-custom-dropdown-arrow">▼</div>
              <div class="gr-custom-dropdown-list" id="grDropdownList">
                ${Array.from({length: 100}, (_, i) => {
                  const level = i + 1;
                  let tierName = '';
                  let tierClass = '';
                  if (level === 1) { tierName = 'Normal'; tierClass = 'tier-normal'; }
                  else if (level <= 5) { tierName = 'Hard'; tierClass = 'tier-hard'; }
                  else if (level <= 15) { tierName = 'Elite'; tierClass = 'tier-elite'; }
                  else if (level <= 30) { tierName = 'Nightmare'; tierClass = 'tier-nightmare'; }
                  else if (level <= 39) { tierName = 'Core'; tierClass = 'tier-core'; }
                  else if (level <= 49) { tierName = 'Core II'; tierClass = 'tier-core2'; }
                  else if (level <= 59) { tierName = 'Core III'; tierClass = 'tier-core3'; }
                  else if (level <= 69) { tierName = 'Core IV'; tierClass = 'tier-core4'; }
                  else { tierName = 'Core V'; tierClass = 'tier-core5'; }
                  return '<div class="gr-custom-dropdown-item ' + tierClass + (level === 1 ? ' selected' : '') + '" data-value="' + level + '" onclick="selectGRLevel(' + level + ')">Level ' + level + ' (' + tierName + ')</div>';
                }).join('')}
              </div>
            </div>
          </div>
          
          <div class="gr-d3-stats-box">
            <div class="gr-d3-stat-row">
              <span class="gr-d3-stat-label">Enemy HP</span>
              <span id="grScaleHP" class="gr-d3-stat-value">100%</span>
            </div>
            <div class="gr-d3-stat-row">
              <span class="gr-d3-stat-label">Enemy Damage</span>
              <span id="grScaleDmg" class="gr-d3-stat-value">100%</span>
            </div>
            <div class="gr-d3-stat-row highlight">
              <span class="gr-d3-stat-label">Reward Bonus</span>
              <span id="grRewardBonus" class="gr-d3-stat-value bonus">×1.0</span>
            </div>
          </div>
          
          <div class="gr-d3-record-box">
            <span class="gr-d3-record-label">🏆 Personal Best:</span>
            <span id="grHighestDisplay" class="gr-d3-record-value">-</span>
          </div>
          
          <div class="gr-d3-info-box">
            <div class="gr-d3-info-title">Greater Rift Challenge</div>
            <div class="gr-d3-info-text">
              Defeat enemies to fill the progress bar, then slay the Rift Guardian before time runs out. Higher levels grant greater rewards!
            </div>
          </div>
        </div>
        
        <div class="gr-d3-footer">
          <button class="gr-d3-accept" onclick="acceptGreaterRift()">
            ACCEPT
          </button>
          <div class="gr-d3-cost">
            <span class="gr-d3-cost-icon">💰</span>
            <span id="grCostDisplay" class="gr-d3-cost-amount">1,000</span>
          </div>
        </div>
      </div>
    `;
    document.body.appendChild(modal);
  }
  
  updateGreaterRiftModal();
  modal.style.display = 'flex';
}

// Close Greater Rift modal
function closeGreaterRiftModal() {
  const modal = document.getElementById('greaterRiftModal');
  if (modal) modal.style.display = 'none';
}

// Custom dropdown state
let selectedGRLevel = 1;

// Toggle GR dropdown open/closed
function toggleGRDropdown() {
  const dropdown = document.getElementById('grCustomDropdown');
  if (dropdown) {
    const wasOpen = dropdown.classList.contains('open');
    dropdown.classList.toggle('open');
    
    // Scroll to selected item when opening
    if (!wasOpen && dropdown.classList.contains('open')) {
      const list = document.getElementById('grDropdownList');
      const selected = list?.querySelector('.selected');
      if (selected && list) {
        selected.scrollIntoView({ block: 'center' });
      }
      
      // Add click-outside-to-close listener
      setTimeout(() => {
        document.addEventListener('click', closeGRDropdownOnClickOutside);
      }, 10);
    }
  }
}

// Close dropdown when clicking outside
function closeGRDropdownOnClickOutside(e) {
  const dropdown = document.getElementById('grCustomDropdown');
  if (dropdown && !dropdown.contains(e.target)) {
    dropdown.classList.remove('open');
    document.removeEventListener('click', closeGRDropdownOnClickOutside);
  }
}

// Select a GR level from dropdown
function selectGRLevel(level) {
  selectedGRLevel = level;
  
  // Update selected display
  let tierName = '';
  let tierClass = '';
  if (level === 1) { tierName = 'Normal'; tierClass = 'tier-normal'; }
  else if (level <= 5) { tierName = 'Hard'; tierClass = 'tier-hard'; }
  else if (level <= 15) { tierName = 'Elite'; tierClass = 'tier-elite'; }
  else if (level <= 30) { tierName = 'Nightmare'; tierClass = 'tier-nightmare'; }
  else if (level <= 39) { tierName = 'Core'; tierClass = 'tier-core'; }
  else if (level <= 49) { tierName = 'Core II'; tierClass = 'tier-core2'; }
  else if (level <= 59) { tierName = 'Core III'; tierClass = 'tier-core3'; }
  else if (level <= 69) { tierName = 'Core IV'; tierClass = 'tier-core4'; }
  else { tierName = 'Core V'; tierClass = 'tier-core5'; }
  
  const display = document.getElementById('grDropdownSelected');
  if (display) {
    display.textContent = `Level ${level} (${tierName})`;
    // Apply tier color
    display.className = 'gr-custom-dropdown-selected ' + tierClass;
  }
  
  // Update selection state in list
  const items = document.querySelectorAll('.gr-custom-dropdown-item');
  items.forEach(item => {
    item.classList.remove('selected');
    if (parseInt(item.dataset.value) === level) {
      item.classList.add('selected');
    }
  });
  
  // Close dropdown
  const dropdown = document.getElementById('grCustomDropdown');
  if (dropdown) dropdown.classList.remove('open');
  
  // Update modal stats
  updateGreaterRiftModal();
}

// Accept button handler for Greater Rift modal
function acceptGreaterRift() {
  const level = selectedGRLevel || 1;
  startGreaterRift(level);
}

// Adjust GR level in modal (legacy, keeping for compatibility)
function adjustGRLevel(delta) {
  const newLevel = Math.max(1, Math.min(100, selectedGRLevel + delta));
  selectGRLevel(newLevel);
}

// Update Greater Rift modal preview
function updateGreaterRiftModal() {
  const level = selectedGRLevel || 1;
  const config = GREATER_RIFT_CONFIG;
  
  const hpScale = Math.pow(config.hpScaling, level - 1);
  const dmgScale = Math.pow(config.dmgScaling, level - 1);
  
  // Get tier multiplier and color for rewards display
  let tierMult = 1.0;
  let tierColor = '#ffffff';
  if (level === 1) { tierMult = 1.0; tierColor = '#ffffff'; }
  else if (level <= 5) { tierMult = 1.2; tierColor = '#ffdd44'; }
  else if (level <= 15) { tierMult = 1.5; tierColor = '#ff9933'; }
  else if (level <= 30) { tierMult = 2.0; tierColor = '#ff5555'; }
  else if (level <= 39) { tierMult = 2.5; tierColor = '#ff3333'; }
  else if (level <= 49) { tierMult = 3.0; tierColor = '#ff44aa'; }
  else if (level <= 59) { tierMult = 4.0; tierColor = '#cc44ff'; }
  else if (level <= 69) { tierMult = 5.0; tierColor = '#9944ff'; }
  else { tierMult = 6.0; tierColor = '#6666ff'; }
  
  // Calculate gold cost to open rift (scales with level and tier)
  const goldCost = Math.floor(500 * level * tierMult);
  
  const hpEl = document.getElementById('grScaleHP');
  const dmgEl = document.getElementById('grScaleDmg');
  const bonusEl = document.getElementById('grRewardBonus');
  const costEl = document.getElementById('grCostDisplay');
  const highestEl = document.getElementById('grHighestDisplay');
  
  if (hpEl) hpEl.textContent = `${Math.round(hpScale * 100)}%`;
  if (dmgEl) dmgEl.textContent = `${Math.round(dmgScale * 100)}%`;
  if (bonusEl) {
    bonusEl.textContent = `×${tierMult.toFixed(1)}`;
    bonusEl.style.color = tierColor;
  }
  if (costEl) costEl.textContent = goldCost.toLocaleString();
  if (highestEl) highestEl.textContent = greaterRiftHighest[player.class] ? `GR ${greaterRiftHighest[player.class]}` : '-';
}

// Update key display in UI (both modal and tab)
function updateGreaterRiftKeyDisplay() {
  // Update modal display
  const keyEl = document.getElementById('grKeyCount');
  if (keyEl) keyEl.textContent = greaterRiftKeys;
  
  // Update tab display
  const keyDisplayMain = document.getElementById('grKeyDisplayMain');
  if (keyDisplayMain) keyDisplayMain.textContent = greaterRiftKeys;
}

// Award Greater Rift key (called from boss kills)
function rollGreaterRiftKey() {
  if (Math.random() < GREATER_RIFT_CONFIG.keyDropChance) {
    greaterRiftKeys++;
    addLog('🔑 Greater Rift Key dropped!', 'loot');
    showToast('🔑', 'Key Found!', 'Greater Rift Key', 'skill');
    updateGreaterRiftKeyDisplay();
  }
}

// Update Greater Rift tab display
function updateGreaterRiftTabDisplay() {
  const keyDisplay = document.getElementById('grKeyDisplayMain');
  if (keyDisplay) keyDisplay.textContent = greaterRiftKeys;
  
  // Update records
  const classes = ['monk', 'warrior', 'ranger', 'mage'];
  classes.forEach(cls => {
    const el = document.getElementById(`grRecord${cls.charAt(0).toUpperCase() + cls.slice(1)}`);
    if (el) {
      el.textContent = greaterRiftHighest[cls] ? `GR ${greaterRiftHighest[cls]}` : '-';
    }
  });
}

function openTabRename(tabId) {
  tabRenameTarget = tabId;
  const tab = stashTabs.find(t => t.id === tabId);
  if (!tab) return;
  
  const modal = document.getElementById('tabRenameModal');
  const input = document.getElementById('tabRenameInput');
  input.value = tab.name;
  modal.style.display = 'flex';
  input.focus();
  input.select();
}

function closeTabRename() {
  document.getElementById('tabRenameModal').style.display = 'none';
  tabRenameTarget = null;
}

function confirmTabRename() {
  if (!tabRenameTarget) return;
  
  const tab = stashTabs.find(t => t.id === tabRenameTarget);
  const input = document.getElementById('tabRenameInput');
  const newName = input.value.trim() || 'Tab';
  
  if (tab) {
    tab.name = newName.substring(0, 12); // Max 12 chars
    addLog(`Tab renamed to: ${tab.name}`, 'info');
    renderStashTabs();
  }
  
  closeTabRename();
}

// Find stash position in a specific tab
function findStashPositionInTab(tabId, w, h) {
  // For now, all item tabs share the same grid
  // In future could have separate grids per tab
  return findStashPosition(w, h);
}

// Stash grid configuration (matches inventory)
const STASH_COLS = 12;
const STASH_ROWS = 10;
let stashGrid = []; // 2D array tracking occupied cells

function initStashGrid() {
  stashGrid = [];
  for (let y = 0; y < STASH_ROWS; y++) {
    stashGrid[y] = [];
    for (let x = 0; x < STASH_COLS; x++) {
      stashGrid[y][x] = null;
    }
  }
}

function canPlaceInStash(x, y, w, h) {
  if (x < 0 || y < 0 || x + w > STASH_COLS || y + h > STASH_ROWS) return false;
  for (let dy = 0; dy < h; dy++) {
    for (let dx = 0; dx < w; dx++) {
      if (stashGrid[y + dy][x + dx] !== null) return false;
    }
  }
  return true;
}

function placeItemInStash(item, x, y) {
  const w = item.width || 1;
  const h = item.height || 1;
  for (let dy = 0; dy < h; dy++) {
    for (let dx = 0; dx < w; dx++) {
      stashGrid[y + dy][x + dx] = item;
    }
  }
  item.stashX = x;
  item.stashY = y;
}

function removeItemFromStash(item) {
  const w = item.width || 1;
  const h = item.height || 1;
  if (item.stashX !== undefined) {
    for (let dy = 0; dy < h; dy++) {
      for (let dx = 0; dx < w; dx++) {
        if (stashGrid[item.stashY + dy] && stashGrid[item.stashY + dy][item.stashX + dx] === item) {
          stashGrid[item.stashY + dy][item.stashX + dx] = null;
        }
      }
    }
  }
}

function findStashPosition(w, h) {
  for (let y = 0; y <= STASH_ROWS - h; y++) {
    for (let x = 0; x <= STASH_COLS - w; x++) {
      if (canPlaceInStash(x, y, w, h)) return { x, y };
    }
  }
  return null;
}

function rebuildStashGrid() {
  initStashGrid();
  stashItems.forEach(item => {
    if (item.stashX !== undefined && item.stashY !== undefined) {
      const w = item.width || 1;
      const h = item.height || 1;
      if (canPlaceInStash(item.stashX, item.stashY, w, h)) {
        placeItemInStash(item, item.stashX, item.stashY);
      } else {
        const pos = findStashPosition(w, h);
        if (pos) placeItemInStash(item, pos.x, pos.y);
      }
    } else {
      const w = item.width || 1;
      const h = item.height || 1;
      const pos = findStashPosition(w, h);
      if (pos) placeItemInStash(item, pos.x, pos.y);
    }
  });
}

function updateStashDisplay(skipRebuild = false) {
  // Update currency counts
  for (const [key, value] of Object.entries(stash)) {
    const el = document.getElementById('stash-' + key);
    if (el) el.textContent = value;
  }
  
  // Update stash grid (items tab)
  const grid = document.getElementById('stashGrid');
  if (!grid) return;
  
  // Only rebuild grid data if not skipping (for performance)
  if (!skipRebuild) {
    rebuildStashGrid();
  }
  
  grid.innerHTML = '';
  
  // Create background cells
  for (let y = 0; y < STASH_ROWS; y++) {
    for (let x = 0; x < STASH_COLS; x++) {
      const cell = document.createElement('div');
      cell.className = 'stash-slot';
      cell.dataset.x = x;
      cell.dataset.y = y;
      // Click empty cell - move selected inv item to stash
      cell.onclick = () => transferToStash(x, y);
      grid.appendChild(cell);
    }
  }
  
  // Cell size as percentage
  const cellWidthPct = 100 / STASH_COLS;
  const cellHeightPct = 100 / STASH_ROWS;
  
  // Place items using absolute positioning with percentages
  const placed = new Set();
  stashItems.forEach((item, idx) => {
    if (item.stashX === undefined || placed.has(item)) return;
    placed.add(item);
    
    const w = item.width || 1;
    const h = item.height || 1;
    
    const itemEl = document.createElement('div');
    itemEl.className = 'stash-item ' + item.rarity;
    
    // Add item slot type for CSS targeting
    const itemSlot = getItemSlot(item.name);
    if (itemSlot) itemEl.dataset.slot = itemSlot;
    
    // Use absolute positioning with calc for precise placement
    itemEl.style.position = 'absolute';
    itemEl.style.left = `calc(${item.stashX * cellWidthPct}% + 4px)`;
    itemEl.style.top = `calc(${item.stashY * cellHeightPct}% + 4px)`;
    itemEl.style.width = `calc(${w * cellWidthPct}% - 2px)`;
    itemEl.style.height = `calc(${h * cellHeightPct}% - 2px)`;
    
    const iconSpan = document.createElement('span');
    iconSpan.className = 'item-icon';
    // Try to assign image if missing
    if (!item.image) {
      item.image = getItemImage(item.name);
    }
    if (item.image) {
      const fallbackIcon = getItemIcon(item.name);
      iconSpan.innerHTML = `<img src="${item.image}" style="width:100%;height:100%;object-fit:contain;" onerror="this.parentElement.textContent='${fallbackIcon}'">`;
    } else {
      iconSpan.textContent = getItemIcon(item.name);
    }
    itemEl.appendChild(iconSpan);
    
    // Add socket display
    if (item.sockets && item.sockets.length > 0) {
      const socketsDiv = document.createElement('div');
      socketsDiv.className = 'item-sockets';
      item.sockets.forEach(socket => {
        const pip = document.createElement('div');
        pip.className = 'socket-pip ' + (socket.gem ? 'filled' : 'empty');
        if (socket.gem) {
          const gemData = GEM_DATA[socket.gem];
          pip.style.background = gemData ? gemData.icon : '#fff';
          pip.textContent = gemData ? gemData.icon : '';
          pip.style.fontSize = '7px';
          pip.style.display = 'flex';
          pip.style.alignItems = 'center';
          pip.style.justifyContent = 'center';
        }
        socketsDiv.appendChild(pip);
      });
      itemEl.appendChild(socketsDiv);
    }
    
    // Don't set title - we have our own tooltip
    itemEl.dataset.idx = idx;
    
    // Tooltip handlers
    itemEl.onmouseenter = (e) => showTooltipWithComparison(item, e);
    itemEl.onmouseleave = hideTooltip;
    
    // Left-click: smart action based on context
    itemEl.onclick = (e) => {
      e.stopPropagation();
      smartStashClick(idx, item, e);
    };
    
    // Right-click: always show context menu
    itemEl.oncontextmenu = (e) => {
      e.preventDefault();
      e.stopPropagation();
      showItemContextMenu(e, { type: 'stash', idx: idx, item: item });
    };
    
    grid.appendChild(itemEl);
  });
}

// Smart left-click action for stash items
function smartStashClick(idx, item, event) {
  hideTooltip();
  
  // If crafting tab is active -> put in crafting slot
  if (activeStashTab === 'currency') {
    putItemInCraftingSlot(idx, item, 'stash');
    return;
  }
  
  // Otherwise -> move to inventory
  moveStashItemToInventory(idx, item);
}

// Move stash item to inventory
function moveStashItemToInventory(idx, item) {
  const w = item.width || 1;
  const h = item.height || 1;
  const pos = findPositionForItem(w, h);
  if (!pos) {
    addLog('Inventory is full!', 'warning');
    return;
  }
  
  removeItemFromStashGrid(item);
  stashItems.splice(idx, 1);
  placeItemOnGrid(item, pos.x, pos.y);
  inventoryItems.push(item);
  rebuildStashGrid();
  rebuildInventoryGrid();
  addLog(`Moved ${item.name} to inventory`, 'item');
}

// Transfer item from inventory to stash
function transferToStash(targetX, targetY) {
  if (selectedInvItem === null) return;
  
  const item = inventoryItems[selectedInvItem];
  if (!item) return;
  
  const w = item.width || 1;
  const h = item.height || 1;
  
  // Find position in stash
  let pos;
  if (canPlaceInStash(targetX, targetY, w, h)) {
    pos = { x: targetX, y: targetY };
  } else {
    pos = findStashPosition(w, h);
  }
  
  if (!pos) {
    addLog('Stash is full!', 'warning');
    return;
  }
  
  // Remove from inventory
  removeItemFromGrid(item);
  inventoryItems.splice(selectedInvItem, 1);
  selectedInvItem = null;
  
  // Add to stash
  stashItems.push(item);
  placeItemInStash(item, pos.x, pos.y);
  
  addLog(`Stashed ${item.name}`, 'loot');
  updateInventoryDisplay();
  updateStashDisplay();
}

// Transfer item from stash to inventory
function transferToInventory(stashIdx) {
  const item = stashItems[stashIdx];
  if (!item) return;
  
  const w = item.width || 1;
  const h = item.height || 1;
  
  // Find position in inventory
  const pos = findPositionForItem(w, h);
  if (!pos) {
    addLog('Inventory is full!', 'warning');
    return;
  }
  
  // Remove from stash
  removeItemFromStash(item);
  stashItems.splice(stashIdx, 1);
  
  // Add to inventory
  delete item.stashX;
  delete item.stashY;
  inventoryItems.push(item);
  placeItemOnGrid(item, pos.x, pos.y);
  
  addLog(`Retrieved ${item.name}`, 'loot');
  updateStashDisplay();
  updateInventoryDisplay();
}

function dropCurrency(isBoss = false) {
  const roll = Math.random();
  let pool;
  
  if (isBoss) {
    if (roll < 0.01) pool = CURRENCY_DROPS.unique;
    else if (roll < 0.2) pool = CURRENCY_DROPS.boss;
    else if (roll < 0.5) pool = CURRENCY_DROPS.rare;
    else pool = CURRENCY_DROPS.uncommon;
  } else {
    if (roll < 0.001) pool = CURRENCY_DROPS.boss;
    else if (roll < 0.02) pool = CURRENCY_DROPS.rare;
    else if (roll < 0.1) pool = CURRENCY_DROPS.uncommon;
    else if (roll < 0.3) pool = CURRENCY_DROPS.common;
    else return; // No drop
  }
  
  const currency = pool[Math.floor(Math.random() * pool.length)];
  const amount = isBoss ? Math.floor(Math.random() * 3) + 1 : 1;
  stash[currency] = (stash[currency] || 0) + amount;
  
  // Gemcutter's Prism drops (gems are purchased from shop with gold)
  const prismChance = isBoss ? PRISM_DROP_CHANCES.boss : PRISM_DROP_CHANCES.common;
  if (Math.random() < prismChance) {
    player.currency = player.currency || {};
    player.currency.gemcuttersPrism = (player.currency.gemcuttersPrism || 0) + 1;
    sessionStats.prismsEarned++;
    showToast('💎', "Gemcutter's Prism!", 'Use to increase gem quality', 'unique');
    addLog("💎 Found Gemcutter's Prism!", 'unique');
    updateCurrencyDisplay();
  }
}

function toggleInventory() {
  inventoryOpen = !inventoryOpen;
  const panel = document.getElementById('inventoryPanel');
  
  if (inventoryOpen) {
    panel.style.display = '';  // Clear any inline display:none from returnToMainMenu
    panel.classList.add('visible');
    updateInventoryDisplay();
  } else {
    panel.classList.remove('visible');
  }
  updateHotkeyLegend();
}

// Inventory grid configuration
const INV_COLS = 12;
const INV_ROWS = 10;
let inventoryGrid = []; // 2D array tracking occupied cells
let gridNeedsRebuild = true;

// Initialize empty grid
function initInventoryGrid() {
  inventoryGrid = [];
  for (let y = 0; y < INV_ROWS; y++) {
    inventoryGrid[y] = [];
    for (let x = 0; x < INV_COLS; x++) {
      inventoryGrid[y][x] = null;
    }
  }
}

// Check if item can be placed at position
function canPlaceItem(x, y, w, h) {
  if (x < 0 || y < 0 || x + w > INV_COLS || y + h > INV_ROWS) return false;
  for (let dy = 0; dy < h; dy++) {
    for (let dx = 0; dx < w; dx++) {
      if (inventoryGrid[y + dy][x + dx] !== null) return false;
    }
  }
  return true;
}

// Place item on grid
function placeItemOnGrid(item, x, y) {
  const w = item.width || 1;
  const h = item.height || 1;
  for (let dy = 0; dy < h; dy++) {
    for (let dx = 0; dx < w; dx++) {
      inventoryGrid[y + dy][x + dx] = item.id;
    }
  }
  item.gridX = x;
  item.gridY = y;
}

// Remove item from grid
function removeItemFromGrid(item) {
  const w = item.width || 1;
  const h = item.height || 1;
  const x = item.gridX;
  const y = item.gridY;
  if (x === undefined || y === undefined) return;
  for (let dy = 0; dy < h; dy++) {
    for (let dx = 0; dx < w; dx++) {
      if (y + dy < INV_ROWS && x + dx < INV_COLS) {
        inventoryGrid[y + dy][x + dx] = null;
      }
    }
  }
  item.gridX = undefined;
  item.gridY = undefined;
  gridNeedsRebuild = true;
}

// Find first available position for item
function findPositionForItem(w, h) {
  for (let y = 0; y <= INV_ROWS - h; y++) {
    for (let x = 0; x <= INV_COLS - w; x++) {
      if (canPlaceItem(x, y, w, h)) {
        return { x, y };
      }
    }
  }
  return null;
}

// Rebuild grid from items - only when needed
function rebuildInventoryGrid() {
  if (!gridNeedsRebuild) return;
  
  // Clear the grid completely
  initInventoryGrid();
  gridNeedsRebuild = false;
  
  // Clear all item positions first to ensure fresh placement
  inventoryItems.forEach(item => {
    // Keep track of old position for preference
    item._oldGridX = item.gridX;
    item._oldGridY = item.gridY;
    item.gridX = undefined;
    item.gridY = undefined;
  });
  
  // Now place each item one by one
  inventoryItems.forEach(item => {
    const w = item.width || 1;
    const h = item.height || 1;
    
    // Try to use old position if available and free
    if (item._oldGridX !== undefined && item._oldGridY !== undefined) {
      if (canPlaceItem(item._oldGridX, item._oldGridY, w, h)) {
        placeItemOnGrid(item, item._oldGridX, item._oldGridY);
        delete item._oldGridX;
        delete item._oldGridY;
        return;
      }
    }
    
    // Find new position
    const pos = findPositionForItem(w, h);
    if (pos) {
      placeItemOnGrid(item, pos.x, pos.y);
    }
    
    // Clean up temp properties
    delete item._oldGridX;
    delete item._oldGridY;
  });
}

function updateInventoryDisplay() {
  // Update gold display
  const goldEl = document.getElementById('invGold');
  if (goldEl) goldEl.textContent = formatNumber(player.gold);
  
  // Rebuild grid positions only when needed
  rebuildInventoryGrid();
  
  // Render grid
  const grid = document.getElementById('invGrid');
  grid.innerHTML = '';
  
  // Create background cells (these form the stable grid structure)
  for (let y = 0; y < INV_ROWS; y++) {
    for (let x = 0; x < INV_COLS; x++) {
      const cell = document.createElement('div');
      cell.className = 'inv-cell';
      grid.appendChild(cell);
    }
  }
  
  // Cell size as percentage (accounting for 1px gaps)
  const cellWidthPct = 100 / INV_COLS;
  const cellHeightPct = 100 / INV_ROWS;
  
  // Place items using absolute positioning with percentages
  inventoryItems.forEach((item, idx) => {
    if (item.gridX === undefined) return;
    
    const w = item.width || 1;
    const h = item.height || 1;
    
    const itemEl = document.createElement('div');
    itemEl.className = 'inv-item ' + item.rarity;
    
    // Add item slot type for CSS targeting
    const itemSlot = getItemSlot(item.name);
    if (itemSlot) itemEl.dataset.slot = itemSlot;
    
    // Use absolute positioning with calc for precise placement
    itemEl.style.position = 'absolute';
    itemEl.style.left = `calc(${item.gridX * cellWidthPct}% + 2px)`;
    itemEl.style.top = `calc(${item.gridY * cellHeightPct}% + 2px)`;
    itemEl.style.width = `calc(${w * cellWidthPct}% - 2px)`;
    itemEl.style.height = `calc(${h * cellHeightPct}% - 2px)`;
    
    // Icon - try to assign image if missing
    const iconSpan = document.createElement('span');
    iconSpan.className = 'item-icon';
    if (!item.image) {
      item.image = getItemImage(item.name);
    }
    if (item.image) {
      const fallbackIcon = getItemIcon(item.name);
      iconSpan.innerHTML = `<img src="${item.image}" style="width:100%;height:100%;object-fit:contain;" onerror="this.parentElement.textContent='${fallbackIcon}'">`;
    } else {
      iconSpan.textContent = getItemIcon(item.name);
    }
    itemEl.appendChild(iconSpan);
    
    // Add socket display
    if (item.sockets && item.sockets.length > 0) {
      const socketsDiv = document.createElement('div');
      socketsDiv.className = 'item-sockets';
      item.sockets.forEach(socket => {
        const pip = document.createElement('div');
        pip.className = 'socket-pip ' + (socket.gem ? 'filled' : 'empty');
        if (socket.gem) {
          const gemData = GEM_DATA[socket.gem];
          pip.textContent = gemData ? gemData.icon : '●';
          pip.style.fontSize = '7px';
          pip.style.display = 'flex';
          pip.style.alignItems = 'center';
          pip.style.justifyContent = 'center';
          pip.style.background = 'transparent';
        }
        socketsDiv.appendChild(pip);
      });
      itemEl.appendChild(socketsDiv);
    }
    
    // Don't set title - we have our own tooltip
    itemEl.dataset.idx = idx;
    
    if (selectedInvItem === idx) {
      itemEl.classList.add('selected');
    }
    
    // Left-click: smart action based on context
    itemEl.onclick = (e) => {
      e.stopPropagation();
      smartInventoryClick(idx, item, e);
    };
    // Right-click: always show context menu
    itemEl.oncontextmenu = (e) => {
      e.preventDefault();
      e.stopPropagation();
      showItemContextMenu(e, { type: 'inventory', idx: idx, item: item });
    };
    itemEl.onmouseenter = (e) => showTooltipWithComparison(item, e);
    itemEl.onmouseleave = hideTooltip;
    
    grid.appendChild(itemEl);
  });
}

// Smart left-click action based on what panels/tabs are open
function smartInventoryClick(idx, item, event) {
  hideTooltip();
  
  const stashPanel = document.getElementById('stashPanel');
  const stashVisible = stashPanel && stashPanel.classList.contains('visible');
  
  // If stash panel is open
  if (stashVisible) {
    // If crafting tab is active -> put in crafting slot
    if (activeStashTab === 'currency') {
      putItemInCraftingSlot(idx, item, 'inventory');
      return;
    }
    // If stash tab is active -> move to stash
    if (activeStashTab === 'stash' || activeStashTab.startsWith('stash')) {
      moveInventoryItemToStash(idx, item);
      return;
    }
  }
  
  // If stash is not open but character panel is -> try to equip
  const validSlot = getValidSlotForItem(item.name);
  if (validSlot) {
    selectedInvItem = idx;
    clickEquipSlot(validSlot);
    updateInventoryDisplay();
    return;
  }
  
  // Fallback: show context menu
  showItemContextMenu(event, { type: 'inventory', idx: idx, item: item });
}

// Move inventory item to stash
function moveInventoryItemToStash(idx, item) {
  const w = item.width || 1;
  const h = item.height || 1;
  const pos = findStashPosition(w, h);
  if (!pos) {
    addLog('Stash is full!', 'warning');
    return;
  }
  
  // Remove from inventory
  removeItemFromGrid(item);
  inventoryItems.splice(idx, 1);
  
  // Place in stash (updates stashGrid directly)
  placeItemInStash(item, pos.x, pos.y);
  item.stashTabId = activeStashTab;
  stashItems.push(item);
  
  // Immediate UI updates - skip grid rebuild since we just updated it
  updateInventoryDisplay();
  updateStashDisplay(true); // Skip rebuild for performance
  addLog(`Moved ${item.name} to stash`, 'item');
}

// Put item directly into crafting slot
function putItemInCraftingSlot(idx, item, source) {
  // If there's already an item in the crafting slot, return it to inventory
  if (craftingItem) {
    const w = craftingItem.width || 1;
    const h = craftingItem.height || 1;
    const pos = findPositionForItem(w, h);
    if (pos) {
      placeItemOnGrid(craftingItem, pos.x, pos.y);
      inventoryItems.push(craftingItem);
    } else {
      addLog('Inventory full! Cannot return crafting item.', 'warning');
      return;
    }
  }
  
  // Remove item from its current location
  if (source === 'inventory') {
    removeItemFromGrid(item);
    inventoryItems.splice(idx, 1);
  } else if (source === 'stash') {
    removeItemFromStashGrid(item);
    stashItems.splice(idx, 1);
  }
  
  // Set as the crafting item
  craftingItem = item;
  craftingItemSource = source;
  
  // Update displays
  updateCraftingSlot();
  updateInventoryDisplay();
  if (source === 'stash') {
    updateStashDisplay();
  }
  updateCurrencyStates(craftingItem);
  
  addLog(`Selected ${item.name} for crafting`, 'skill');
}

function selectInventoryItem(idx, event) {
  const item = inventoryItems[idx];
  if (!item) return;
  
  hideTooltip();  // Always hide tooltip when selecting
  
  // Right-click or normal click shows context menu
  event.preventDefault();
  showItemContextMenu(event, { type: 'inventory', idx: idx, item: item });
}

// Show item context menu
function showItemContextMenu(event, target) {
  contextMenuTarget = target;
  const menu = document.getElementById('itemContextMenu');
  const item = target.item;
  
  // Position menu
  menu.style.left = event.clientX + 'px';
  menu.style.top = event.clientY + 'px';
  
  // Update menu options based on item source
  const equipBtn = menu.querySelector('.equip');
  const unequipBtn = menu.querySelector('.unequip');
  const moveToStashBtn = menu.querySelector('.move-to-stash');
  const moveToInvBtn = menu.querySelector('.move-to-inv');
  const salvageBtn = menu.querySelector('.salvage');
  
  // Update salvage tooltip with item-specific info
  if (salvageBtn && item) {
    const goldValues = SALVAGE_GOLD_VALUES[item.rarity] || SALVAGE_GOLD_VALUES.normal;
    const starBonus = (item.dropTier || 1) * goldValues.perStar;
    const minGold = goldValues.base + starBonus;
    const maxGold = goldValues.base + starBonus + goldValues.perStar * 2;
    const hasGems = item.sockets && item.sockets.some(s => s.gem);
    const gemNote = hasGems ? '\n💎 All socketed gems will be returned' : '';
    salvageBtn.title = `Salvage this ${item.rarity} item:\n94% → 💰${minGold}-${maxGold}g\n5% → 🔵 Basic Core\n1% → ⭐ Advanced Core${gemNote}`;
    
    // Update odds text display with color coding
    const oddsText = document.getElementById('salvageOddsText');
    if (oddsText) {
      const rarityColors = { normal: '#888', magic: '#66f', rare: '#fc4', unique: '#f84' };
      oddsText.style.color = rarityColors[item.rarity] || '#666';
      oddsText.textContent = `💰${minGold}-${maxGold}g | 5% Core | 1% Adv`;
    }
  }
  
  const validSlot = getValidSlotForItem(item.name);
  
  if (target.type === 'inventory') {
    // Item is in inventory
    if (validSlot) {
      equipBtn.style.display = 'flex';
    } else {
      equipBtn.style.display = 'none';
    }
    unequipBtn.style.display = 'none';
    moveToStashBtn.style.display = 'flex';
    moveToInvBtn.style.display = 'none';
  } else if (target.type === 'stash') {
    // Item is in stash
    if (validSlot) {
      equipBtn.style.display = 'flex';
    } else {
      equipBtn.style.display = 'none';
    }
    unequipBtn.style.display = 'none';
    moveToStashBtn.style.display = 'none';
    moveToInvBtn.style.display = 'flex';
  } else if (target.type === 'equipped') {
    equipBtn.style.display = 'none';
    unequipBtn.style.display = 'flex';
    moveToStashBtn.style.display = 'none';
    moveToInvBtn.style.display = 'none';
  }
  
  menu.classList.add('visible');
  
  // Close menu on outside click
  setTimeout(() => {
    document.addEventListener('click', closeContextMenu, { once: true });
  }, 10);
}

function closeContextMenu() {
  document.getElementById('itemContextMenu').classList.remove('visible');
  contextMenuTarget = null;
}

function contextMenuEquip() {
  if (!contextMenuTarget) return;
  
  const item = contextMenuTarget.item;
  const idx = contextMenuTarget.idx;
  const slot = getValidSlotForItem(item.name);
  
  if (!slot) {
    closeContextMenu();
    return;
  }
  
  if (contextMenuTarget.type === 'inventory') {
    selectedInvItem = idx;
    clickEquipSlot(slot);
    updateInventoryDisplay();
  } else if (contextMenuTarget.type === 'stash') {
    // Remove from stash and equip
    removeItemFromStashGrid(item);
    stashItems.splice(idx, 1);
    
    // Handle existing equipment
    if (equipment[slot]) {
      const oldItem = equipment[slot];
      // Unregister old item's unique effect
      if (oldItem.isUnique && oldItem.uniqueId && UNIQUE_ITEMS[oldItem.uniqueId]?.onUnequip) {
        UNIQUE_ITEMS[oldItem.uniqueId].onUnequip(player);
      }
      // Try to put old item in inventory
      const pos = findPositionForItem(oldItem.width || 1, oldItem.height || 1);
      if (pos) {
        placeItemOnGrid(oldItem, pos.x, pos.y);
        inventoryItems.push(oldItem);
      } else {
        // Put in overflow instead (not stash - stash is for intentional storage)
        addToOverflow(oldItem);
      }
    }
    
    equipment[slot] = item;
    // Register new item's unique effect
    if (item.isUnique && item.uniqueId && UNIQUE_ITEMS[item.uniqueId]?.onEquip) {
      UNIQUE_ITEMS[item.uniqueId].onEquip(player);
    }
    addLog(`Equipped ${item.name}`, 'loot');
    updateInventoryDisplay();
    updateStashDisplay();
    updateEquipmentDisplay();
    recalculateStats();
    updateStats();
    updateCharPanel(); // Update STR/DEX/INT/Damage display
  }
  
  closeContextMenu();
}

function contextMenuUnequip() {
  if (!contextMenuTarget || contextMenuTarget.type !== 'equipped') return;
  
  const slot = contextMenuTarget.slot;
  if (equipment[slot]) {
    unequipItem(slot);
  }
  
  closeContextMenu();
  updateInventoryDisplay();
  updateEquipmentDisplay();
}

function contextMenuSalvage() {
  if (!contextMenuTarget) return;
  
  const item = contextMenuTarget.item;
  const idx = contextMenuTarget.idx;
  
  if (contextMenuTarget.type === 'inventory') {
    removeItemFromGrid(item);
    inventoryItems.splice(idx, 1);
    salvageItem(item);
    updateInventoryDisplay();
  } else if (contextMenuTarget.type === 'stash') {
    removeItemFromStashGrid(item);
    stashItems.splice(idx, 1);
    salvageItem(item);
    updateStashDisplay();
  }
  
  closeContextMenu();
}

function contextMenuCraft() {
  if (!contextMenuTarget) return;
  
  const item = contextMenuTarget.item;
  const idx = contextMenuTarget.idx;
  const source = contextMenuTarget.type;
  
  // Open stash panel to craft tab first
  const stashPanel = document.getElementById('stashPanel');
  if (!stashPanel.classList.contains('visible')) {
    stashOpen = true;
    stashPanel.classList.add('visible');
    renderStashTabs();
    updateStashDisplay();
    updateCurrencyDisplay();
  }
  switchStashTab('currency');
  
  // Put item in crafting slot
  putItemInCraftingSlot(idx, item, source);
  
  closeContextMenu();
}

function contextMenuDrop() {
  if (!contextMenuTarget) return;
  
  const item = contextMenuTarget.item;
  const idx = contextMenuTarget.idx;
  
  if (contextMenuTarget.type === 'inventory') {
    removeItemFromGrid(item);
    inventoryItems.splice(idx, 1);
    addLog(`Dropped ${item.name}`, 'info');
    updateInventoryDisplay();
  } else if (contextMenuTarget.type === 'stash') {
    removeItemFromStashGrid(item);
    stashItems.splice(idx, 1);
    addLog(`Dropped ${item.name}`, 'info');
    updateStashDisplay();
  }
  
  closeContextMenu();
}

function contextMenuMoveToStash() {
  if (!contextMenuTarget || contextMenuTarget.type !== 'inventory') return;
  
  const item = contextMenuTarget.item;
  const idx = contextMenuTarget.idx;
  const w = item.width || 1;
  const h = item.height || 1;
  
  // Find position in stash
  const stashPos = findStashPosition(w, h);
  if (!stashPos) {
    addLog('Stash is full!', 'warning');
    closeContextMenu();
    return;
  }
  
  // Remove from inventory
  removeItemFromGrid(item);
  inventoryItems.splice(idx, 1);
  
  // Add to stash
  placeItemInStash(item, stashPos.x, stashPos.y);
  stashItems.push(item);
  
  addLog(`Moved ${item.name} to stash`, 'info');
  updateInventoryDisplay();
  updateStashDisplay();
  closeContextMenu();
}

function contextMenuMoveToInventory() {
  if (!contextMenuTarget || contextMenuTarget.type !== 'stash') return;
  
  const item = contextMenuTarget.item;
  const idx = contextMenuTarget.idx;
  const w = item.width || 1;
  const h = item.height || 1;
  
  // Find position in inventory
  const invPos = findPositionForItem(w, h);
  if (!invPos) {
    addLog('Inventory is full!', 'warning');
    closeContextMenu();
    return;
  }
  
  // Remove from stash
  removeItemFromStashGrid(item);
  stashItems.splice(idx, 1);
  
  // Add to inventory
  placeItemOnGrid(item, invPos.x, invPos.y);
  inventoryItems.push(item);
  
  addLog(`Moved ${item.name} to inventory`, 'info');
  updateInventoryDisplay();
  updateStashDisplay();
  closeContextMenu();
}

function updateCraftingSlot() {
  const slot = document.getElementById('craftingSlot');
  const modsDiv = document.getElementById('craftingMods');
  
  if (!craftingItem) {
    slot.className = 'crafting-slot';
    slot.innerHTML = '<span class="placeholder">Click an item<br>in inventory<br>to craft</span>';
    modsDiv.innerHTML = '<div style="color: #504030; font-style: italic; text-align: center; padding: 20px;">No item selected</div>';
    updateCurrencyStates(null);
    return;
  }
  
  slot.className = 'crafting-slot has-item ' + craftingItem.rarity;
  
  // Try to assign image if missing
  if (!craftingItem.image) {
    craftingItem.image = getItemImage(craftingItem.name);
  }
  
  // Use item.image if available, otherwise fall back to emoji
  const iconHtml = craftingItem.image 
    ? `<img src="${craftingItem.image}" style="width:100%;height:100%;object-fit:contain;" onerror="this.parentElement.innerHTML='${getItemIcon(craftingItem.name)}'">`
    : getItemIcon(craftingItem.name);
  
  slot.innerHTML = `
    <span class="item-icon">${iconHtml}</span>
    <span class="item-name ${craftingItem.rarity}">${craftingItem.name}</span>
  `;
  
  // Use the same tooltip builder as regular items
  const tooltipHtml = buildItemTooltipHTML(craftingItem);
  modsDiv.innerHTML = tooltipHtml;
  
  // Update which currencies can be used
  updateCurrencyStates(craftingItem);
}

// Update the currency count displays
function updateCurrencyDisplay() {
  Object.keys(stash).forEach(key => {
    const el = document.getElementById(`stash-${key}`);
    if (el) {
      el.textContent = stash[key] || 0;
    }
  });
  
  // Update Gemcutter's Prism display
  const prismEl = document.getElementById('stash-gemcuttersPrism');
  if (prismEl) {
    prismEl.textContent = player.currency?.gemcuttersPrism || 0;
  }
  
  // Update gem inventory display
  updateGemInventoryDisplay();
}

// Alias for removeItemFromStash
function removeItemFromStashGrid(item) {
  removeItemFromStash(item);
}

// Update currency item enabled/disabled states based on current crafting item
function updateCurrencyStates(item) {
  // If no item is selected, enable all items so players can hover and learn what each does
  const noItemSelected = !item;
  
  const currencyMap = {
    // Echo Ring can only use: echo (reroll %), vaal (uncontrolled core)
    'transmute': { check: (i) => i && i.rarity === 'normal' && !i.mods?.isImmutable && !i.isEchoRing },
    'augment': { check: (i) => i && i.rarity === 'magic' && !i.mods?.isImmutable && !i.isEchoRing && ((i.mods?.prefixes?.length || 0) + (i.mods?.suffixes?.length || 0)) < 2 },
    'upgrade': { check: (i) => i && i.rarity === 'magic' && !i.mods?.isImmutable && !i.isEchoRing && ((i.mods?.prefixes?.length || 0) + (i.mods?.suffixes?.length || 0)) >= 2 },
    'rare': { check: (i) => i && i.rarity === 'rare' && !i.mods?.isImmutable && !i.isEchoRing && ((i.mods?.prefixes?.length || 0) + (i.mods?.suffixes?.length || 0)) < 6 },
    'wild': { check: (i) => i && i.rarity === 'rare' && !i.mods?.isImmutable && !i.isEchoRing },
    'echo': { check: (i) => i && !i.mods?.isImmutable && (i.isEchoRing || (i.rarity === 'magic' || i.rarity === 'rare')) },
    'annul': { check: (i) => i && (i.rarity === 'magic' || i.rarity === 'rare') && !i.mods?.isImmutable && !i.isEchoRing && ((i.mods?.prefixes?.length || 0) + (i.mods?.suffixes?.length || 0)) > 0 },
    'vaal': { check: (i) => i && !i.mods?.isImmutable },
    'armorer': { check: (i) => {
      if (!i || i.mods?.isImmutable || i.isEchoRing) return false;
      const slot = getItemSlot(i.name);
      return ['body', 'helmet', 'gloves', 'boots'].includes(slot) && (!i.quality || i.quality < 20);
    }},
    'whetstone': { check: (i) => {
      if (!i || i.mods?.isImmutable || i.isEchoRing) return false;
      const slot = getItemSlot(i.name);
      return slot === 'weapon' && (!i.quality || i.quality < 20);
    }},
    'jeweller': { check: (i) => {
      if (!i || i.mods?.isImmutable || i.isEchoRing) return false;
      if (!canHaveSockets(i.name)) return false;
      const maxSockets = getMaxSockets(i.name, i.mods?.isImmutable);
      return (!i.sockets || i.sockets.length < maxSockets);
    }}
  };
  
  // Gems - can only socket if item has empty sockets
  const gemCheck = (i) => i && i.sockets && i.sockets.some(s => !s.gem);
  
  // Update each currency item
  Object.keys(currencyMap).forEach(key => {
    const el = document.getElementById(`stash-${key}`)?.parentElement;
    if (el) {
      // If no item selected, show all as enabled (for browsing/learning)
      if (noItemSelected || currencyMap[key].check(item)) {
        el.classList.remove('disabled');
      } else {
        el.classList.add('disabled');
      }
    }
  });
  
  // Update gems
  ['gem-iron', 'gem-flame', 'gem-frost', 'gem-storm', 'gem-life', 'gem-vitality', 'gem-haste', 'gem-might', 'gem-resist'].forEach(gemId => {
    const el = document.getElementById(`stash-${gemId}`)?.parentElement;
    if (el) {
      // If no item selected, show all as enabled (for browsing/learning)
      if (noItemSelected || gemCheck(item)) {
        el.classList.remove('disabled');
      } else {
        el.classList.add('disabled');
      }
    }
  });
}

function clearCraftingSlot() {
  if (craftingItem) {
    const w = craftingItem.width || 1;
    const h = craftingItem.height || 1;
    const pos = findPositionForItem(w, h);
    if (pos) {
      placeItemOnGrid(craftingItem, pos.x, pos.y);
      inventoryItems.push(craftingItem);
    } else {
      // Inventory full, put in overflow
      addToOverflow(craftingItem);
    }
    craftingItem = null;
    updateCraftingSlot();
    updateInventoryDisplay();
  }
}

// Uncontrolled Core confirmation modal
function confirmUncontrolled() {
  if (!craftingItem) {
    addLog('Place an item in the crafting slot first!', 'warning');
    return;
  }
  if (stash.vaal <= 0) {
    addLog('No Uncontrolled Cores!', 'warning');
    return;
  }
  if (craftingItem.mods?.isImmutable) {
    addLog('Item is already immutable!', 'warning');
    return;
  }
  document.getElementById('uncontrolledModal').style.display = 'flex';
}

function closeUncontrolledModal() {
  document.getElementById('uncontrolledModal').style.display = 'none';
}

function applyUncontrolled() {
  closeUncontrolledModal();
  applyCraft('vaal');
}

// Update gem inventory display
function updateGemInventoryDisplay() {
  const container = document.getElementById('gemInventoryDisplay');
  if (!container) return;
  
  if (gemInventory.length === 0) {
    container.innerHTML = '<div style="color: #666; font-size: 11px; padding: 8px;">No gems in inventory</div>';
    return;
  }
  
  // Stack gems by id + quality
  const stacks = {};
  gemInventory.forEach((gem, index) => {
    const key = `${gem.id}_${gem.quality}`;
    if (!stacks[key]) {
      stacks[key] = { id: gem.id, quality: gem.quality, count: 0, indices: [] };
    }
    stacks[key].count++;
    stacks[key].indices.push(index);
  });
  
  // Sort by quality (highest first), then by gem type
  const sortedStacks = Object.values(stacks).sort((a, b) => {
    if (b.quality !== a.quality) return b.quality - a.quality;
    return a.id.localeCompare(b.id);
  });
  
  let html = '';
  sortedStacks.forEach(stack => {
    const gemData = GEM_DATA[stack.id];
    if (!gemData) return;
    
    const qualityColor = stack.quality >= 100 ? '#ff0' : stack.quality >= 80 ? '#ff8' : stack.quality >= 40 ? '#8f8' : '#888';
    const qualityText = stack.quality > 0 ? `<span style="color: ${qualityColor}; font-size: 9px;">${stack.quality}%</span>` : '';
    const countBadge = stack.count > 1 ? `<span class="currency-count" style="position:absolute;bottom:0;right:0;font-size:9px;background:#222;padding:1px 3px;border-radius:3px;">${stack.count}</span>` : '';
    
    // Use the first index in the stack for socketing
    const firstIndex = stack.indices[0];
    
    html += `
      <div class="currency-item magic clickable" 
           onclick="socketGemFromInventory(${firstIndex})" 
           oncontextmenu="unsocketGemToInventory(${firstIndex}); return false;"
           onmouseenter="showGemTooltip('${stack.id}', ${stack.quality}, ${stack.count}, event)"
           onmouseleave="hideCurrencyTooltip()"
           style="position: relative;">
        <span class="icon">${gemData.icon}</span>
        ${qualityText}
        ${countBadge}
      </div>
    `;
  });
  
  container.innerHTML = html;
}

// Show tooltip for a gem with quality
function showGemTooltip(gemId, quality, count, event) {
  const tooltip = document.getElementById('currencyTooltip');
  const nameEl = document.getElementById('currencyTooltipName');
  const stackEl = document.getElementById('currencyTooltipStack');
  const bodyEl = document.getElementById('currencyTooltipBody');
  
  const gemData = GEM_DATA[gemId];
  if (!gemData) return;
  
  nameEl.textContent = gemData.name;
  nameEl.className = 'currency-tooltip-name magic';
  
  let stackText = '';
  if (count > 1) stackText += `Stack: ${count}`;
  if (quality > 0) stackText += (stackText ? ' · ' : '') + `Quality: ${quality}%`;
  stackEl.textContent = stackText;
  
  let bodyHtml = '';
  
  // Show the simple tip that explains both weapon and armor effects
  if (gemData.tip) {
    bodyHtml += `<div class="currency-tooltip-tip" style="font-style: normal; color: #ccbb99; padding: 0 0 6px 0;">${gemData.tip}</div>`;
  }
  
  bodyHtml += '<div class="currency-tooltip-useon">Click to socket into selected item</div>';
  
  bodyEl.innerHTML = bodyHtml;
  
  // Position and show
  tooltip.classList.add('visible');
  positionCurrencyTooltip(event);
}

// Socket a gem from inventory into crafting item
function socketGemFromInventory(gemIndex) {
  if (!craftingItem) {
    addLog('Place an item in the crafting slot first!', 'warning');
    return;
  }
  if (gemIndex < 0 || gemIndex >= gemInventory.length) {
    addLog('Invalid gem!', 'warning');
    return;
  }
  
  const item = craftingItem;
  if (!item.sockets || item.sockets.length === 0) {
    addLog('Item has no sockets! Use Socket Core first.', 'warning');
    return;
  }
  
  // Find first empty socket
  const emptySocketIdx = item.sockets.findIndex(s => !s.gem);
  if (emptySocketIdx === -1) {
    addLog('All sockets are full!', 'warning');
    return;
  }
  
  // Remove gem from inventory and socket it
  const gem = gemInventory.splice(gemIndex, 1)[0];
  const gemData = GEM_DATA[gem.id];
  
  item.sockets[emptySocketIdx].gem = gem.id;
  item.sockets[emptySocketIdx].gemQuality = gem.quality;
  
  const qualityText = gem.quality > 0 ? ` (${gem.quality}% quality)` : '';
  addLog(`Socketed ${gemData.name}${qualityText}!`, 'loot');
  updateCraftingSlot();
  updateGemInventoryDisplay();
  recalculateStats();
}

// Remove a gem from an item socket back to inventory
function unsocketGemFromItem(socketIndex) {
  if (!craftingItem) {
    addLog('Place an item in the crafting slot first!', 'warning');
    return;
  }
  
  const item = craftingItem;
  if (!item.sockets || socketIndex >= item.sockets.length) {
    return;
  }
  
  const socket = item.sockets[socketIndex];
  if (!socket.gem) {
    addLog('Socket is empty!', 'warning');
    return;
  }
  
  // Return gem to inventory with its quality
  addGemToInventory(socket.gem, socket.gemQuality || 0);
  
  // Clear the socket
  socket.gem = null;
  socket.gemQuality = 0;
  
  updateCraftingSlot();
  updateGemInventoryDisplay();
  recalculateStats();
}

// Open gem quality modal to use Gemcutter's Prism
function openGemQualityModal() {
  if (gemInventory.length === 0) {
    showToast('❌', 'No Gems', 'You have no gems to quality up', 'warning');
    return;
  }
  
  const prismCount = player.currency?.gemcuttersPrism || 0;
  
  // Sort gems by quality (highest first), then by name
  const sortedGems = gemInventory.map((gem, index) => ({ ...gem, originalIndex: index }))
    .sort((a, b) => {
      if (b.quality !== a.quality) return b.quality - a.quality;
      return a.id.localeCompare(b.id);
    });
  
  let html = `
    <div style="position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.85); z-index: 10000; display: flex; align-items: center; justify-content: center;" onclick="closeGemQualityModal(event)">
      <div style="background: linear-gradient(135deg, #1a1a2a 0%, #0d0d15 100%); border: 2px solid #4a6a4a; padding: 20px; border-radius: 8px; max-width: 450px; min-width: 350px; box-shadow: 0 0 30px rgba(0,0,0,0.8);" onclick="event.stopPropagation()">
        <h3 style="color: #8c8; margin: 0 0 10px 0; display: flex; align-items: center; gap: 10px;">
          <span style="font-size: 28px;">💎</span>
          <span>Gemcutter's Prism</span>
        </h3>
        <div style="color: #666; font-size: 11px; margin-bottom: 15px; padding-bottom: 10px; border-bottom: 1px solid #333;">
          Each use adds <span style="color: #8f8;">+5% quality</span> to a gem (max 100%)
        </div>
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px;">
          <span style="color: #888; font-size: 12px;">Available Prisms:</span>
          <span style="color: ${prismCount > 0 ? '#ff8' : '#f66'}; font-size: 16px; font-weight: bold;">${prismCount}</span>
        </div>
        <div style="color: #666; font-size: 10px; margin-bottom: 8px;">Click a gem to improve it (sorted by quality)</div>
        <div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(70px, 1fr)); gap: 8px; max-height: 280px; overflow-y: auto; padding: 12px; background: #0a0a14; border-radius: 4px; border: 1px solid #222;">
  `;
  
  sortedGems.forEach((gem) => {
    const gemData = GEM_DATA[gem.id];
    if (!gemData) return;
    
    const qualityColor = gem.quality >= 100 ? '#ff0' : gem.quality >= 80 ? '#ff8' : gem.quality >= 40 ? '#8f8' : '#aaa';
    const maxed = gem.quality >= 100;
    const progress = gem.quality / 100;
    
    html += `
      <div onclick="${maxed || prismCount <= 0 ? '' : 'applyGemcuttersPrism(' + gem.originalIndex + ')'}" 
           oncontextmenu="salvageGem(${gem.originalIndex}); return false;"
           style="background: ${maxed ? '#1a1a1a' : '#1a2a1a'}; border: 1px solid ${maxed ? '#444' : '#4a6a4a'}; 
                  padding: 10px 8px; border-radius: 6px; cursor: ${maxed || prismCount <= 0 ? 'context-menu' : 'pointer'}; text-align: center;
                  opacity: ${maxed ? '0.7' : '1'}; transition: all 0.15s;
                  ${!maxed && prismCount > 0 ? 'box-shadow: 0 0 0 0 rgba(136,204,136,0);' : ''}"
           ${!maxed && prismCount > 0 ? 'onmouseenter="this.style.boxShadow=\'0 0 10px rgba(136,204,136,0.3)\'; this.style.borderColor=\'#6a8a6a\';" onmouseleave="this.style.boxShadow=\'0 0 0 0 rgba(136,204,136,0)\'; this.style.borderColor=\'#4a6a4a\';"' : ''}>
        <div style="font-size: 28px; margin-bottom: 4px;">${gemData.icon}</div>
        <div style="color: ${qualityColor}; font-size: 13px; font-weight: bold;">${gem.quality}%</div>
        <div style="background: #222; height: 4px; border-radius: 2px; margin: 4px 0; overflow: hidden;">
          <div style="background: ${qualityColor}; height: 100%; width: ${progress * 100}%; transition: width 0.3s;"></div>
        </div>
        <div style="color: #777; font-size: 9px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">${gemData.name.replace(' Gem', '')}</div>
        ${maxed ? '<div style="color: #ff0; font-size: 8px; margin-top: 2px;">MAX</div>' : ''}
      </div>
    `;
  });
  
  html += `
        </div>
        <div style="display: flex; justify-content: space-between; align-items: center; margin-top: 15px;">
          <div style="color: #555; font-size: 9px;">
            Left-click: Use prism (+5% quality)<br>
            Right-click: Salvage gem → 💎 Prism
          </div>
          <button onclick="closeGemQualityModal()" style="padding: 8px 20px; background: #633; border: 1px solid #844; color: #faa; cursor: pointer; border-radius: 4px; font-size: 12px;">Close</button>
        </div>
      </div>
    </div>
  `;
  
  const modal = document.createElement('div');
  modal.id = 'gemQualityModal';
  modal.innerHTML = html;
  document.body.appendChild(modal);
}

function closeGemQualityModal(event) {
  if (event && event.target !== event.currentTarget) return;
  const modal = document.getElementById('gemQualityModal');
  if (modal) modal.remove();
}

function applyGemcuttersPrism(gemIndex) {
  if (useGemcuttersPrism(gemIndex)) {
    // Refresh modal
    closeGemQualityModal();
    openGemQualityModal();
    updateCurrencyDisplay();
  }
}

// Salvage a gem to get a Gemcutter's Prism
function salvageGem(gemIndex) {
  if (gemIndex < 0 || gemIndex >= gemInventory.length) return;
  
  const gem = gemInventory[gemIndex];
  const gemData = GEM_DATA[gem.id];
  
  // Remove the gem
  gemInventory.splice(gemIndex, 1);
  
  // Give a Gemcutter's Prism
  player.currency = player.currency || {};
  player.currency.gemcuttersPrism = (player.currency.gemcuttersPrism || 0) + 1;
  
  showToast('💎', 'Gem Salvaged!', `${gemData.name} → Gemcutter's Prism`, 'info');
  addLog(`Salvaged ${gemData.name} (${gem.quality}%) → Gemcutter's Prism`, 'craft');
  
  // Refresh modal and displays
  closeGemQualityModal();
  if (gemInventory.length > 0) {
    openGemQualityModal();
  }
  updateCurrencyDisplay();
  updateGemInventoryDisplay();
}

// Legacy function for backwards compatibility - now shows message
function socketGem(gemId) {
  addLog('Use the gem inventory to socket gems!', 'warning');
}

function applyCraft(orbType) {
  if (!craftingItem) {
    addLog('Place an item in the crafting slot first!', 'warning');
    return;
  }
  if (stash[orbType] <= 0) {
    addLog(`No ${orbType} cores!`, 'warning');
    return;
  }
  
  const item = craftingItem;
  const mods = item.mods || {};
  const slot = getItemSlot(item.name);
  
  // Check if immutable
  if (mods.isImmutable && orbType !== 'vaal') {
    addLog('Cannot modify immutable items!', 'warning');
    return;
  }
  
  let success = false;
  const ilvl = item.baseLevel || player.level || 1;
  
  switch(orbType) {
    case 'transmute':
      if (item.rarity === 'normal') {
        item.rarity = 'magic';
        // Keep implicit, add 1 mod
        const implicit = mods.implicit || generateImplicit(item.name);
        item.mods = { implicit, prefixes: [], suffixes: [] };
        if (Math.random() < 0.5) {
          item.mods.prefixes.push(generateMod(true, slot, item.name, ilvl));
        } else {
          item.mods.suffixes.push(generateMod(false, slot, item.name, ilvl));
        }
        success = true;
        addLog('Common Core: Normal → Magic (1 mod)!', 'loot');
      } else {
        addLog('Common Core only works on normal items!', 'warning');
      }
      break;
    
    case 'augment':
      if (item.rarity === 'magic') {
        const totalMods = (mods.prefixes?.length || 0) + (mods.suffixes?.length || 0);
        if (totalMods < 2) {
          // Add a mod (prefer the type we don't have)
          if ((mods.prefixes?.length || 0) === 0) {
            if (!mods.prefixes) mods.prefixes = [];
            mods.prefixes.push(generateUniqueModForItem(true, slot, item.name, ilvl, mods));
          } else {
            if (!mods.suffixes) mods.suffixes = [];
            mods.suffixes.push(generateUniqueModForItem(false, slot, item.name, ilvl, mods));
          }
          success = true;
          addLog('Magic Core: Added mod (1 → 2 mods)!', 'loot');
        } else {
          addLog('Magic item already has 2 mods!', 'warning');
        }
      } else {
        addLog('Magic Core only works on magic items!', 'warning');
      }
      break;
      
    case 'upgrade':
      if (item.rarity === 'magic') {
        const totalMods = (mods.prefixes?.length || 0) + (mods.suffixes?.length || 0);
        if (totalMods >= 2) {
          item.rarity = 'rare';
          // Keep existing mods and add one more
          const existingPrefixes = mods.prefixes || [];
          const existingSuffixes = mods.suffixes || [];
          item.mods = { 
            implicit: mods.implicit,
            prefixes: existingPrefixes,
            suffixes: existingSuffixes
          };
          // Add one more mod to make it 3 total (avoiding duplicates)
          if (Math.random() < 0.5 && existingPrefixes.length < 3) {
            item.mods.prefixes.push(generateUniqueModForItem(true, slot, item.name, ilvl, item.mods));
          } else if (existingSuffixes.length < 3) {
            item.mods.suffixes.push(generateUniqueModForItem(false, slot, item.name, ilvl, item.mods));
          } else {
            item.mods.prefixes.push(generateUniqueModForItem(true, slot, item.name, ilvl, item.mods));
          }
          success = true;
          addLog('Upgrade Core: Magic → Rare!', 'loot');
        } else {
          addLog('Magic item needs 2 mods first! Use Magic Core.', 'warning');
        }
      } else {
        addLog('Upgrade Core only works on magic items!', 'warning');
      }
      break;
      
    case 'wild':
      if (item.rarity === 'rare') {
        item.mods = generateItemMods('rare', item.name, null, ilvl);
        success = true;
      } else {
        addLog('Wild Core only works on rare items!', 'warning');
      }
      break;
      
    case 'rare':
      if (item.rarity === 'rare' && mods.prefixes && mods.prefixes.length < 3) {
        mods.prefixes.push(generateUniqueModForItem(true, slot, item.name, ilvl, mods));
        success = true;
      } else if (item.rarity === 'rare' && mods.suffixes && mods.suffixes.length < 3) {
        mods.suffixes.push(generateUniqueModForItem(false, slot, item.name, ilvl, mods));
        success = true;
      } else {
        addLog('Item has max mods or is not rare!', 'warning');
      }
      break;
      
    case 'echo':
      // Echo Core on Echo Ring: reroll the echo percent (60-110%)
      if (item.isEchoRing) {
        const oldPercent = item.echoPercent;
        item.echoPercent = 60 + Math.floor(Math.random() * 51);
        item.description = `Mirrors ${item.echoPercent}% of your other ring's power`;
        addLog(`Echo Core: Rerolled ${oldPercent}% → ${item.echoPercent}%!`, item.echoPercent > oldPercent ? 'loot' : 'warning');
        success = true;
      } else if (item.rarity !== 'normal') {
        // Reroll values within tier range
        if (mods.prefixes) mods.prefixes.forEach(m => {
          m.value1 = Math.floor(Math.random() * (m.max - m.min + 1)) + m.min;
          if (m.min2 !== undefined) {
            m.value2 = Math.floor(Math.random() * (m.max2 - m.min2 + 1)) + m.min2;
          }
          m.text = m.stat.replace('#', m.value1).replace('#', m.value2 || '');
        });
        if (mods.suffixes) mods.suffixes.forEach(m => {
          m.value1 = Math.floor(Math.random() * (m.max - m.min + 1)) + m.min;
          m.text = m.stat.replace('#', m.value1).replace('#', m.value2 || '');
        });
        success = true;
      } else {
        addLog('Echo Core does not work on normal items!', 'warning');
      }
      break;
      
    case 'vaal':
      // Random outcome - Uncontrolled Core makes item immutable
      
      // Special handling for Echo Ring
      if (item.isEchoRing) {
        const vaalOutcome = Math.random();
        if (vaalOutcome < 0.4) {
          // Boost echo % by 10-25, capped at 130%
          const boost = 10 + Math.floor(Math.random() * 16);
          const oldPercent = item.echoPercent;
          item.echoPercent = Math.min(130, item.echoPercent + boost);
          addLog(`Uncontrolled: Echo boosted ${oldPercent}% → ${item.echoPercent}%!`, 'unique');
        } else if (vaalOutcome < 0.7) {
          // Reduce echo % by 10-20, minimum 40%
          const reduction = 10 + Math.floor(Math.random() * 11);
          const oldPercent = item.echoPercent;
          item.echoPercent = Math.max(40, item.echoPercent - reduction);
          addLog(`Uncontrolled: Echo reduced ${oldPercent}% → ${item.echoPercent}%...`, 'warning');
        } else {
          addLog('Uncontrolled: No effect...', 'warning');
        }
        item.description = `Mirrors ${item.echoPercent}% of your other ring's power`;
        if (!item.mods) item.mods = {};
        item.mods.isImmutable = true;
        success = true;
        break;
      }
      
      const outcome = Math.random();
      if (outcome < 0.25) {
        // Add/change implicit
        mods.implicit = generateImplicit(item.name);
        addLog('Uncontrolled: Added implicit modifier!', 'loot');
      } else if (outcome < 0.45) {
        // Add socket - ONLY Uncontrolled Core can exceed slot max
        // Weapon/Chest: can get 3rd socket (normally max 2)
        // Helm/Gloves/Boots: can get 2nd socket (normally max 1)
        // Jewelry: NEVER gets sockets
        if (canHaveSockets(item.name)) {
          if (!item.sockets) item.sockets = [];
          const slotMax = getMaxSockets(item.name, false);
          const corruptedMax = Math.min(slotMax + 1, 3); // +1 above slot max, capped at 3
          if (item.sockets.length < corruptedMax) {
            item.sockets.push({ color: 'white', gem: null });
            addLog('Uncontrolled: Added socket!', 'unique');
          } else {
            addLog('Uncontrolled: No effect (max sockets)...', 'warning');
          }
        } else {
          addLog('Uncontrolled: No effect (jewelry)...', 'warning');
        }
      } else if (outcome < 0.65) {
        // Change to rare with random mods
        item.rarity = 'rare';
        item.mods = generateItemMods('rare', item.name, null, ilvl);
        item.mods.isImmutable = true;
        addLog('Uncontrolled: Item transformed to rare!', 'loot');
      } else {
        // Brick - nothing happens
        addLog('Uncontrolled: No effect...', 'warning');
      }
      mods.isImmutable = true;
      success = true;
      break;
      
    case 'jeweller':
      // Add socket to item - respects slot max (only Uncontrolled Core can exceed)
      if (canHaveSockets(item.name)) {
        if (!item.sockets) item.sockets = [];
        // Jeweller's Orb can only add up to slot max, NOT above it
        // Extra sockets (3rd on weapon/chest, 2nd on helm/gloves/boots) ONLY from Uncontrolled Core
        const maxSockets = getMaxSockets(item.name, false); // Never pass isImmutable for Jeweller
        if (item.sockets.length < maxSockets) {
          item.sockets.push({ color: getRandomSocketColor(), gem: null });
          addLog('Socket Core: Added socket!', 'loot');
          success = true;
        } else {
          addLog('Item has maximum sockets for this slot!', 'warning');
        }
      } else {
        addLog('This item cannot have sockets!', 'warning');
      }
      break;
      
    case 'armorer':
      // Add quality to armor
      if (['body', 'helmet', 'gloves', 'boots'].includes(slot)) {
        if (!item.quality) item.quality = 0;
        if (item.quality < 20) {
          item.quality = Math.min(20, item.quality + 5);
          addLog(`Armor Shard: Quality now ${item.quality}%!`, 'loot');
          success = true;
        } else {
          addLog('Item already at max quality!', 'warning');
        }
      } else {
        addLog('Armor Shard only works on armor!', 'warning');
      }
      break;
      
    case 'whetstone':
      // Add quality to weapons
      if (slot === 'weapon') {
        if (!item.quality) item.quality = 0;
        if (item.quality < 20) {
          item.quality = Math.min(20, item.quality + 5);
          addLog(`Weapon Shard: Quality now ${item.quality}%!`, 'loot');
          success = true;
        } else {
          addLog('Item already at max quality!', 'warning');
        }
      } else {
        addLog('Weapon Shard only works on weapons!', 'warning');
      }
      break;
      
    case 'annul':
      if (item.rarity === 'magic' || item.rarity === 'rare') {
        // Remove a random mod
        const allMods = [];
        if (mods.prefixes) mods.prefixes.forEach((m, i) => allMods.push({ type: 'prefix', idx: i }));
        if (mods.suffixes) mods.suffixes.forEach((m, i) => allMods.push({ type: 'suffix', idx: i }));
        
        if (allMods.length > 0) {
          const toRemove = allMods[Math.floor(Math.random() * allMods.length)];
          if (toRemove.type === 'prefix') {
            const removed = mods.prefixes.splice(toRemove.idx, 1)[0];
            addLog(`Void Core removed: ${removed.name || removed.stat}`, 'loot');
          } else {
            const removed = mods.suffixes.splice(toRemove.idx, 1)[0];
            addLog(`Void Core removed: ${removed.name || removed.stat}`, 'loot');
          }
          // If no mods left, becomes normal
          if (mods.prefixes.length === 0 && mods.suffixes.length === 0) {
            item.rarity = 'normal';
          }
          success = true;
        } else {
          addLog('No mods to remove!', 'warning');
        }
      } else {
        addLog('Void Core only works on magic/rare items!', 'warning');
      }
      break;
  }
  
  if (success) {
    stash[orbType]--;
    sessionStats.craftsUsed++;
    player.totalCrafts = (player.totalCrafts || 0) + 1;
    addLog(`Used ${orbType} orb!`, 'loot');
    updateCraftingSlot();
    updateStashDisplay();
    
    // Steam integration: crafting achievement
    onCraftingUsed_Steam(player.totalCrafts);
  }
}

function formatNumber(n) {
  if (n >= 1000000) return (n / 1000000).toFixed(1) + 'M';
  if (n >= 1000) return (n / 1000).toFixed(1) + 'K';
  return Math.floor(n).toLocaleString();
}

function getItemIcon(name) {
  const icons = {
    // ═══════════════════════════════════════════════════════════════════════
    // WEAPONS (8 types - 2 per class)
    // ═══════════════════════════════════════════════════════════════════════
    // Sword type (STR)
    'Viper Blade': '🗡️', 'War Blade': '⚔️',
    // Quarterstaff type (STR/DEX)
    'Windspire Quarterstaff': '🥢', 'Ironbark Quarterstaff': '🥢',
    // Bow type (DEX)
    'Windrunner Bow': '🏹', 'Ironwood Bow': '🏹',
    // Staff type (INT)
    'Mystic Staff': '🔮', 'Elder Staff': '🔮',
    
    // ═══════════════════════════════════════════════════════════════════════
    // BODY ARMOR (6 bases: 3 pure + 3 hybrid)
    // ═══════════════════════════════════════════════════════════════════════
    'Plate Armor': '🦺',      // STR (Armor)
    'Leather Tunic': '🦺',    // DEX (Dodge)
    'Silk Robe': '👘',        // INT (Shield)
    'Scale Armor': '🦺',      // STR/DEX
    'Crusader Armor': '🦺',   // STR/INT
    'Assassin Garb': '👘',    // DEX/INT
    
    // ═══════════════════════════════════════════════════════════════════════
    // HELMETS (6 bases: 3 pure + 3 hybrid)
    // ═══════════════════════════════════════════════════════════════════════
    'Iron Helm': '⛑️',       // STR (Armor)
    'Leather Cap': '🧢',      // DEX (Dodge)
    'Mage Hat': '🧙',        // INT (Shield)
    'Scale Helm': '⛑️',       // STR/DEX
    'Crusader Helm': '⛑️',    // STR/INT
    'Bone Circlet': '👑',    // DEX/INT
    
    // ═══════════════════════════════════════════════════════════════════════
    // GLOVES (6 bases: 3 pure + 3 hybrid)
    // ═══════════════════════════════════════════════════════════════════════
    'Plate Gauntlets': '🧤',     // STR (Armor)
    'Leather Gloves': '🧤',      // DEX (Dodge)
    'Silk Gloves': '🧤',         // INT (Shield)
    'Scale Gauntlets': '🧤',     // STR/DEX
    'Crusader Gauntlets': '🧤',  // STR/INT
    'Assassin Gloves': '🧤',     // DEX/INT
    
    // ═══════════════════════════════════════════════════════════════════════
    // BOOTS (6 bases: 3 pure + 3 hybrid)
    // ═══════════════════════════════════════════════════════════════════════
    'Plate Greaves': '👢',     // STR (Armor)
    'Leather Boots': '👢',     // DEX (Dodge)
    'Silk Slippers': '👢',     // INT (Shield)
    'Scale Boots': '👢',       // STR/DEX
    'Crusader Greaves': '👢',  // STR/INT
    'Assassin Boots': '👢',    // DEX/INT
    
    // ═══════════════════════════════════════════════════════════════════════
    // ACCESSORIES
    // ═══════════════════════════════════════════════════════════════════════
    // Rings - renamed to match implicits
    'Nature Ring': '🌿', 'Vitality Ring': '❤️', 'Arcane Ring': '💎',
    'Flame Ring': '🔥', 'Frost Ring': '❄️', 'Storm Ring': '⚡', 'Prismatic Ring': '🌈',
    // Amulets - renamed to match implicits
    'Might Amulet': '📿', 'Grace Amulet': '📿', 'Wisdom Amulet': '📿', 'Harmony Amulet': '📿',
    // Flasks
    'Life Flask': '🧪', 'Mana Flask': '🧪', 'Quicksilver Flask': '🧪', 'Granite Flask': '🧪',
    // Jewels
    'Crimson Jewel': '🔴', 'Viridian Jewel': '🟢', 'Cobalt Jewel': '🔵',
  };
  return icons[name] || '📦';
}

// ============ DUNGEON GENERATION ============
function generateDungeon() {
  biome = BIOMES[Math.floor(Math.random() * BIOMES.length)];
  
  const numRooms = 8 + Math.floor(Math.random() * 5); // More rooms
  map.width = 90;  // Bigger map
  map.height = 70;
  
  // Init tiles (0=void, 1=floor, 2=wall)
  map.tiles = [];
  map.explored = [];
  map.decorations = []; // Pre-generated decorations for performance
  map.edgeShadows = []; // Pre-generated wall shadows
  for (let y = 0; y < map.height; y++) {
    map.tiles[y] = [];
    map.explored[y] = [];
    for (let x = 0; x < map.width; x++) {
      map.tiles[y][x] = 0;
      map.explored[y][x] = false;
    }
  }
  
  map.rooms = [];
  enemies = [];
  loot = [];
  blood = [];
  path = [];
  pathTarget = null;
  
  // Generate rooms - bigger rooms
  for (let i = 0; i < numRooms; i++) {
    for (let attempt = 0; attempt < 100; attempt++) {
      const rw = 8 + Math.floor(Math.random() * 6);  // Bigger rooms
      const rh = 7 + Math.floor(Math.random() * 5);
      const rx = 4 + Math.floor(Math.random() * (map.width - rw - 8));
      const ry = 4 + Math.floor(Math.random() * (map.height - rh - 8));
      
      let ok = true;
      for (const room of map.rooms) {
        if (rx < room.x + room.w + 5 && rx + rw + 5 > room.x &&
            ry < room.y + room.h + 5 && ry + rh + 5 > room.y) {
          ok = false;
          break;
        }
      }
      
      if (ok) {
        map.rooms.push({ x: rx, y: ry, w: rw, h: rh, cleared: false });
        carveRoom(rx, ry, rw, rh);
        break;
      }
    }
  }
  
  // Connect rooms with wide corridors
  for (let i = 1; i < map.rooms.length; i++) {
    connectRooms(map.rooms[i - 1], map.rooms[i]);
  }
  
  // Add walls around floors
  addWalls();
  
  // Generate decorations (pre-computed for performance)
  generateDecorations();
  
  // Generate ambient particles
  generateAmbientParticles();
  
  // Player start - ensure valid spawn
  const start = map.rooms[0];
  let spawnX = (start.x + Math.floor(start.w / 2)) * TILE + TILE / 2;
  let spawnY = (start.y + Math.floor(start.h / 2)) * TILE + TILE / 2;
  
  // Validate spawn is walkable, if not find nearby walkable tile
  if (!isWalkable(spawnX, spawnY)) {
    let found = false;
    for (let dy = 0; dy <= start.h && !found; dy++) {
      for (let dx = 0; dx <= start.w && !found; dx++) {
        const testX = (start.x + dx) * TILE + TILE / 2;
        const testY = (start.y + dy) * TILE + TILE / 2;
        if (isWalkable(testX, testY)) {
          spawnX = testX;
          spawnY = testY;
          found = true;
        }
      }
    }
  }
  
  player.x = spawnX;
  player.y = spawnY;
  player.state = 'idle';  // Ensure player starts idle
  start.cleared = true;
  
  // Reset stuck detection
  stuckFrames = 0;
  window.stuckAccum = 0;
  window.oscillationFrames = 0;
  window.posHistory = [];
  window.moveHistory = [];
  window.targetDistHistory = [];
  window.pathDirHistory = [];
  window.pathCommitment = 0;
  window.lastTargetId = null;
  lastX = player.x;
  lastY = player.y;
  path = [];
  pathTarget = null;
  
  // Clear any active skills
  cycloneActive = false;
  cycloneTimer = 0;
  
  // Exit
  const end = map.rooms[map.rooms.length - 1];
  exitPos = { x: (end.x + end.w / 2) * TILE, y: (end.y + end.h / 2) * TILE };
  
  // Spawn enemies - use GR spawning if in Greater Rift
  if (greaterRiftActive) {
    // Greater Rift: use dedicated GR enemy spawning with isGreaterRift flag
    spawnGreaterRiftEnemies();
  } else {
    // Normal dungeon: spawn regular enemies and bosses
    for (let i = 1; i < map.rooms.length; i++) {
      const room = map.rooms[i];
      
      // Base enemy count per room (flat per difficulty)
      let count = 4 + Math.floor(Math.random() * 3); // 4-6 base enemies
      
      // 35% chance for a "pack room" with extra grouped enemies
      if (Math.random() < 0.35) {
        count += 2 + Math.floor(Math.random() * 2); // +2-3 extra enemies
      }
      
      // Spawn enemies - some in packs, some spread out
      let spawned = 0;
      while (spawned < count) {
        // 40% chance to spawn a tight cluster of 3-4 enemies
        if (count - spawned >= 3 && Math.random() < 0.40) {
          const packSize = Math.min(3 + Math.floor(Math.random() * 2), count - spawned);
          spawnEnemyPack(room, packSize);
          spawned += packSize;
        } else {
          spawnEnemy(room);
          spawned++;
        }
      }
      
      // 70% chance for a boss in each room (except first)
      if (Math.random() < 0.7) {
        spawnBoss(room);
      }
    }
  }
  
  currentBoss = null;
  bossDebuffs = [];
  document.getElementById('bossBar').classList.remove('visible');
  
  showZone();
  updateStats();
}

// Generate floor decorations (cracks, debris, etc.) - pre-computed for performance
function generateDecorations() {
  map.decorations = [];
  map.edgeShadows = []; // Pre-compute wall edge shadows
  const decorTypes = biome.decorTypes || ['cracks', 'debris'];
  
  // Floor decorations - very sparse
  for (let y = 0; y < map.height; y++) {
    for (let x = 0; x < map.width; x++) {
      if (map.tiles[y][x] === 1) {
        // Sparse floor decorations (5% chance)
        if (Math.random() < 0.05) {
          const type = decorTypes[Math.floor(Math.random() * decorTypes.length)];
          map.decorations.push({
            x: x * TILE + Math.random() * TILE,
            y: y * TILE + Math.random() * TILE,
            type: type,
            size: 2 + Math.random() * 3,
            alpha: 0.15 + Math.random() * 0.2
          });
        }
        
        // Check for adjacent walls to create edge shadows
        const hasWallAbove = map.tiles[y-1]?.[x] === 2;
        const hasWallLeft = map.tiles[y]?.[x-1] === 2;
        
        if (hasWallAbove || hasWallLeft) {
          map.edgeShadows.push({
            x: x * TILE,
            y: y * TILE,
            fromTop: hasWallAbove,
            fromLeft: hasWallLeft
          });
        }
      }
    }
  }
}

// Generate ambient particles (dust, embers, etc.)
let ambientParticles = [];
function generateAmbientParticles() {
  ambientParticles = [];
  const pConfig = biome.particles || { color: '#666', count: 20, speed: 0.3 };
  
  for (let i = 0; i < pConfig.count; i++) {
    ambientParticles.push({
      x: Math.random() * map.width * TILE,
      y: Math.random() * map.height * TILE,
      vx: (Math.random() - 0.5) * pConfig.speed,
      vy: (Math.random() - 0.5) * pConfig.speed - 0.1,
      size: 1 + Math.random() * 2,
      alpha: 0.2 + Math.random() * 0.5,
      color: pConfig.color
    });
  }
}

function carveRoom(rx, ry, rw, rh) {
  for (let y = ry; y < ry + rh; y++) {
    for (let x = rx; x < rx + rw; x++) {
      if (y >= 0 && y < map.height && x >= 0 && x < map.width) {
        map.tiles[y][x] = 1;
      }
    }
  }
}

function connectRooms(r1, r2) {
  const x1 = Math.floor(r1.x + r1.w / 2);
  const y1 = Math.floor(r1.y + r1.h / 2);
  const x2 = Math.floor(r2.x + r2.w / 2);
  const y2 = Math.floor(r2.y + r2.h / 2);
  
  const cw = 2; // Corridor half-width
  
  // Horizontal first
  for (let x = Math.min(x1, x2); x <= Math.max(x1, x2); x++) {
    for (let dy = -cw; dy <= cw; dy++) {
      const y = y1 + dy;
      if (y >= 0 && y < map.height && x >= 0 && x < map.width) {
        map.tiles[y][x] = 1;
      }
    }
  }
  
  // Then vertical
  for (let y = Math.min(y1, y2); y <= Math.max(y1, y2); y++) {
    for (let dx = -cw; dx <= cw; dx++) {
      const x = x2 + dx;
      if (y >= 0 && y < map.height && x >= 0 && x < map.width) {
        map.tiles[y][x] = 1;
      }
    }
  }
}

function addWalls() {
  for (let y = 0; y < map.height; y++) {
    for (let x = 0; x < map.width; x++) {
      if (map.tiles[y][x] === 0) {
        for (let dy = -1; dy <= 1; dy++) {
          for (let dx = -1; dx <= 1; dx++) {
            if (map.tiles[y + dy]?.[x + dx] === 1) {
              map.tiles[y][x] = 2;
              break;
            }
          }
        }
      }
    }
  }
}

// ========== ENEMY SCALING SYSTEM ==========
// ENEMY STATS VALIDATION - LOCKED DOWN
//
// Base Enemy Stats (dungeon level 1):
// | Enemy    | HP | Damage  | Speed |
// |----------|----|---------| ------|
// | Skeleton | 3  | 2-4     | 1.8   |
// | Zombie   | 5  | 3-5     | 1.2   |
// | Specter  | 2  | 4-6     | 2.5   |
// | Golem    | 8  | 5-8     | 0.8   |
// | Cultist  | 4  | 3-5     | 1.6   |
//
// Scaling Formula: stat * (1 + (level - 1) * 0.15)
// - Level 1:  1.00x (base)
// - Level 10: 2.35x
// - Level 20: 3.85x
// - Level 50: 8.35x
// - Level 70: 11.35x
//
// Boss Multipliers:
// - HP: base * levelMult * (3 + level * 0.2) → 3x at L1, 5x at L10, 17x at L70
// - Damage: base * levelMult * 1.2
//
// Example at Level 10 (mult = 2.35):
// - Skeleton: HP 7, Dmg 5-9
// - Golem: HP 19, Dmg 12-19
// - Boss Golem: HP 94, Dmg 14-22

function spawnEnemy(room) {
  // Limit enemies for performance
  if (enemies.length >= MAX_ENEMIES) return;
  
  const type = ENEMIES[Math.floor(Math.random() * ENEMIES.length)];
  const dungeonSettings = getDungeonSettings();
  const difficultyHpMult = dungeonSettings.enemyHpMult;     // Difficulty HP multiplier
  const difficultyDmgMult = dungeonSettings.enemyDmgMult;   // Difficulty damage multiplier
  
  // Elite chance: 15% of enemies are elites
  const isElite = Math.random() < 0.15;
  const eliteHpMult = isElite ? 3.0 : 1.0;   // Spec: Elites have 3x HP (8-12 hits)
  const eliteDmgMult = isElite ? 1.4 : 1.0;  // Spec: Elites deal 1.4x damage
  
  // Combined multipliers (no floor scaling - flat per difficulty)
  const totalHpMult = difficultyHpMult * eliteHpMult;
  const totalDmgMult = difficultyDmgMult * eliteDmgMult;
  
  // Try to find a walkable spawn position (with stricter bounds checking)
  let ex, ey;
  let attempts = 0;
  do {
    // Stay 2 tiles away from room edges to prevent wall spawns
    const margin = 2;
    ex = (room.x + margin + Math.random() * Math.max(1, room.w - margin * 2)) * TILE;
    ey = (room.y + margin + Math.random() * Math.max(1, room.h - margin * 2)) * TILE;
    attempts++;
  } while (!isWalkable(ex, ey) && attempts < 20);
  
  // If we couldn't find a walkable spot, don't spawn
  if (!isWalkable(ex, ey)) return;
  
  // Double-check surrounding tiles are also walkable (prevents edge spawns)
  const checkOffsets = [[TILE/2, 0], [-TILE/2, 0], [0, TILE/2], [0, -TILE/2]];
  let validPosition = true;
  for (const [dx, dy] of checkOffsets) {
    if (!isWalkable(ex + dx, ey + dy)) {
      validPosition = false;
      break;
    }
  }
  if (!validPosition) return;
  
  enemies.push({
    ...type,
    name: isElite ? `Elite ${type.name}` : type.name,
    x: ex, y: ey,
    hp: Math.floor(type.hp * totalHpMult),
    maxHp: Math.floor(type.hp * totalHpMult),
    dmg: [Math.floor(type.dmg[0] * totalDmgMult), Math.floor(type.dmg[1] * totalDmgMult)],
    atkCD: 0,
    flash: 0,
    id: Math.random(),
    room,
    active: false,
    isBoss: false,
    isElite: isElite,
    size: isElite ? type.size * 1.3 : type.size,
    color: isElite ? '#cc8800' : type.color, // Elites are golden/orange
    exp: Math.floor((isElite ? type.exp * 2 : type.exp) * dungeonSettings.expMult),
    gold: [Math.floor((isElite ? type.gold[0] * 2 : type.gold[0]) * dungeonSettings.goldMult), 
           Math.floor((isElite ? type.gold[1] * 2 : type.gold[1]) * dungeonSettings.goldMult)],
    debuffs: [],
  });
}

// Spawn a tight cluster of enemies (pack) for satisfying AoE
function spawnEnemyPack(room, packSize) {
  if (enemies.length >= MAX_ENEMIES) return;
  
  const dungeonSettings = getDungeonSettings();
  const difficultyHpMult = dungeonSettings.enemyHpMult;
  const difficultyDmgMult = dungeonSettings.enemyDmgMult;
  
  // Find a center point for the pack
  let centerX, centerY;
  let attempts = 0;
  do {
    const margin = 3;
    centerX = (room.x + margin + Math.random() * Math.max(1, room.w - margin * 2)) * TILE;
    centerY = (room.y + margin + Math.random() * Math.max(1, room.h - margin * 2)) * TILE;
    attempts++;
  } while (!isWalkable(centerX, centerY) && attempts < 20);
  
  if (!isWalkable(centerX, centerY)) return;
  
  // Spawn pack members in a tight cluster around center
  for (let i = 0; i < packSize; i++) {
    if (enemies.length >= MAX_ENEMIES) return;
    
    const type = ENEMIES[Math.floor(Math.random() * ENEMIES.length)];
    
    // No elites in packs - they're meant to be weak trash for AoE
    const totalHpMult = difficultyHpMult;
    const totalDmgMult = difficultyDmgMult;
    
    // Spread enemies in a small radius (0.5-1.5 tiles from center)
    const angle = (i / packSize) * Math.PI * 2 + Math.random() * 0.5;
    const dist = TILE * (0.5 + Math.random() * 1.0);
    let ex = centerX + Math.cos(angle) * dist;
    let ey = centerY + Math.sin(angle) * dist;
    
    // Make sure spawn position is walkable
    if (!isWalkable(ex, ey)) {
      ex = centerX;
      ey = centerY;
    }
    
    enemies.push({
      ...type,
      x: ex, y: ey,
      hp: Math.floor(type.hp * totalHpMult),
      maxHp: Math.floor(type.hp * totalHpMult),
      dmg: [Math.floor(type.dmg[0] * totalDmgMult), Math.floor(type.dmg[1] * totalDmgMult)],
      atkCD: 0,
      flash: 0,
      id: Math.random(),
      room,
      active: false,
      isBoss: false,
      isElite: false,
      size: type.size,
      color: type.color,
      exp: Math.floor(type.exp * dungeonSettings.expMult),
      gold: [Math.floor(type.gold[0] * dungeonSettings.goldMult), 
             Math.floor(type.gold[1] * dungeonSettings.goldMult)],
      debuffs: [],
    });
  }
}

function spawnBoss(room) {
  const baseType = ENEMIES[Math.floor(Math.random() * ENEMIES.length)];
  const dungeonSettings = getDungeonSettings();
  const bossHpMult = 10;   // Spec: Bosses have 10x HP (30-40 hits to kill)
  const bossDmgMult = 2.0; // Spec: Bosses deal 2x damage
  
  // Combined multipliers with difficulty (no floor scaling)
  const totalHpMult = dungeonSettings.enemyHpMult * bossHpMult;
  const totalDmgMult = dungeonSettings.enemyDmgMult * bossDmgMult;
  
  // Try to find a walkable position for the boss, starting from center
  let bx = (room.x + room.w / 2) * TILE;
  let by = (room.y + room.h / 2) * TILE;
  
  // If center isn't walkable, search for a valid spot
  if (!isWalkable(bx, by)) {
    let found = false;
    // Spiral outward from center to find walkable spot
    for (let r = 1; r < Math.max(room.w, room.h) && !found; r++) {
      for (let dx = -r; dx <= r && !found; dx++) {
        for (let dy = -r; dy <= r && !found; dy++) {
          const testX = (room.x + room.w / 2 + dx) * TILE;
          const testY = (room.y + room.h / 2 + dy) * TILE;
          if (isWalkable(testX, testY)) {
            bx = testX;
            by = testY;
            found = true;
          }
        }
      }
    }
  }
  
  enemies.push({
    ...baseType,
    name: generateBossName(),
    x: bx, y: by,
    hp: Math.floor(baseType.hp * totalHpMult),
    maxHp: Math.floor(baseType.hp * totalHpMult),
    dmg: [Math.floor(baseType.dmg[0] * totalDmgMult), Math.floor(baseType.dmg[1] * totalDmgMult)],
    atkCD: 0,
    flash: 0,
    id: Math.random(),
    room,
    active: false,
    isBoss: true,
    canLeap: true,
    leapChance: 0.05, // Bosses leap more often
    size: baseType.size * 1.8,
    color: '#8a4040', // Bosses are reddish
    exp: Math.floor(baseType.exp * 5 * dungeonSettings.expMult),
    gold: [Math.floor(baseType.gold[0] * 4 * dungeonSettings.goldMult), 
           Math.floor(baseType.gold[1] * 4 * dungeonSettings.goldMult)],
    debuffs: [],
  });
}

// Dungeon timer tracking
let dungeonStartTime = Date.now();

function showZone() {
  const settings = getDungeonSettings();
  document.getElementById('zoneName').textContent = biome.name;
  document.getElementById('zoneLevel').textContent = `${settings.name} • ilvl ${settings.ilvlMin}-${settings.ilvlMax}`;
  document.getElementById('zoneTitle').classList.add('visible');
  setTimeout(() => document.getElementById('zoneTitle').classList.remove('visible'), 3000);
  
  // Update persistent dungeon info panel
  document.getElementById('dungeonName').textContent = biome.name;
  document.getElementById('dungeonLevel').textContent = dungeon.level;
  const diffEl = document.getElementById('dungeonDifficulty');
  if (diffEl) {
    diffEl.textContent = settings.name;
    diffEl.style.color = settings.color;
  }
  dungeonStartTime = Date.now(); // Reset timer on zone change
  
  addLog(`Entering ${biome.name} (${settings.name})...`, 'zone');
}

// Update dungeon timer display
function updateDungeonTimer() {
  const elapsed = Math.floor((Date.now() - dungeonStartTime) / 1000);
  const mins = Math.floor(elapsed / 60);
  const secs = elapsed % 60;
  const timerEl = DOM.dungeonTimer || document.getElementById('dungeonTimer');
  if (timerEl) {
    timerEl.textContent = `${mins}:${secs.toString().padStart(2, '0')}`;
  }
}

// ============ PATHFINDING ============
function isWalkable(x, y) {
  const tx = Math.floor(x / TILE);
  const ty = Math.floor(y / TILE);
  return tx >= 0 && tx < map.width && ty >= 0 && ty < map.height && map.tiles[ty]?.[tx] === 1;
}

function canMoveTo(x, y) {
  // Check center and 4 corners with smaller radius for more forgiving collision
  const r = PLAYER_RADIUS * 0.6;  // Even smaller hitbox for easier corner navigation
  return isWalkable(x, y) && 
         isWalkable(x - r, y - r) && isWalkable(x + r, y - r) &&
         isWalkable(x - r, y + r) && isWalkable(x + r, y + r);
}

// Stricter collision check for path planning - uses larger radius and more check points
function canMoveToStrict(x, y) {
  const r = PLAYER_RADIUS * 0.85;  // Larger radius for safer path planning
  // Check center, 4 corners, and 4 cardinal points
  return isWalkable(x, y) && 
         isWalkable(x - r, y - r) && isWalkable(x + r, y - r) &&
         isWalkable(x - r, y + r) && isWalkable(x + r, y + r) &&
         isWalkable(x - r, y) && isWalkable(x + r, y) &&
         isWalkable(x, y - r) && isWalkable(x, y + r);
}

// Find best direction to slide along a wall
function findWallSlideDirection(px, py, targetAngle) {
  const testDist = TILE * 0.3;
  const perpAngles = [
    targetAngle + Math.PI/2,  // 90° right
    targetAngle - Math.PI/2,  // 90° left
    targetAngle + Math.PI/3,  // 60° right
    targetAngle - Math.PI/3,  // 60° left
    targetAngle + Math.PI*2/3,  // 120° right
    targetAngle - Math.PI*2/3,  // 120° left
    targetAngle + Math.PI,      // Backwards (last resort)
  ];
  
  for (const angle of perpAngles) {
    const tx = px + Math.cos(angle) * testDist;
    const ty = py + Math.sin(angle) * testDist;
    if (canMoveTo(tx, ty)) {
      return angle;
    }
  }
  return null;
}

// Nudge player away from nearby walls - helps with corner navigation
function nudgeAwayFromWalls(px, py, amount) {
  const checkDist = TILE * 0.4;
  let nudgeX = 0, nudgeY = 0;
  
  // Check all 8 directions for walls
  const dirs = [
    [-1, 0], [1, 0], [0, -1], [0, 1],
    [-1, -1], [1, -1], [-1, 1], [1, 1]
  ];
  
  for (const [dx, dy] of dirs) {
    const testX = px + dx * checkDist;
    const testY = py + dy * checkDist;
    if (!isWalkable(testX, testY)) {
      // Push away from this wall
      nudgeX -= dx * amount;
      nudgeY -= dy * amount;
    }
  }
  
  // Apply nudge if it results in a valid position
  if (nudgeX !== 0 || nudgeY !== 0) {
    const newX = px + nudgeX;
    const newY = py + nudgeY;
    if (canMoveTo(newX, newY)) {
      return { x: newX, y: newY, nudged: true };
    }
  }
  return { x: px, y: py, nudged: false };
}

function findPath(sx, sy, tx, ty) {
  // If very close, just return direct path
  const directDist = Math.hypot(tx - sx, ty - sy);
  
  // For very short distances, be lenient
  if (directDist < TILE * 1.5) {
    return [{ x: tx, y: ty }];
  }
  
  // For medium distances, do basic collision check
  if (directDist < TILE * 4) {
    const steps = Math.ceil(directDist / (TILE * 0.4));
    let canWalkDirect = true;
    for (let i = 1; i <= steps && canWalkDirect; i++) {
      const t = i / steps;
      const checkX = sx + (tx - sx) * t;
      const checkY = sy + (ty - sy) * t;
      if (!canMoveTo(checkX, checkY)) {
        canWalkDirect = false;
      }
    }
    if (canWalkDirect) {
      return [{ x: tx, y: ty }];
    }
  }
  
  const startX = Math.floor(sx / TILE);
  const startY = Math.floor(sy / TILE);
  let endX = Math.floor(tx / TILE);
  let endY = Math.floor(ty / TILE);
  
  // Clamp to valid range
  endX = Math.max(1, Math.min(map.width - 2, endX));
  endY = Math.max(1, Math.min(map.height - 2, endY));
  
  // Find walkable goal
  if (map.tiles[endY]?.[endX] !== 1) {
    let found = false;
    for (let r = 1; r <= 10 && !found; r++) {
      for (let dy = -r; dy <= r && !found; dy++) {
        for (let dx = -r; dx <= r && !found; dx++) {
          const ny = endY + dy, nx = endX + dx;
          if (ny >= 1 && ny < map.height - 1 && nx >= 1 && nx < map.width - 1) {
            if (map.tiles[ny]?.[nx] === 1) {
              endX = nx;
              endY = ny;
              found = true;
            }
          }
        }
      }
    }
    if (!found) return [];
  }
  
  // A*
  const open = [{ x: startX, y: startY, g: 0, f: 0, p: null }];
  const closed = new Set();
  const openMap = new Map();
  openMap.set(`${startX},${startY}`, open[0]);
  
  while (open.length > 0) {
    // Find lowest f
    let bestIdx = 0;
    for (let i = 1; i < open.length; i++) {
      if (open[i].f < open[bestIdx].f) bestIdx = i;
    }
    
    const curr = open.splice(bestIdx, 1)[0];
    const key = `${curr.x},${curr.y}`;
    openMap.delete(key);
    closed.add(key);
    
    if (curr.x === endX && curr.y === endY) {
      const result = [];
      let node = curr;
      while (node) {
        result.unshift({ x: node.x * TILE + TILE / 2, y: node.y * TILE + TILE / 2 });
        node = node.p;
      }
      if (result.length > 1) result.shift();
      
      // Push waypoints away from walls to prevent corner clipping
      for (let i = 0; i < result.length; i++) {
        const wp = result[i];
        let pushX = 0, pushY = 0;
        const checkDist = TILE * 0.7;
        const pushForce = TILE * 0.2;
        
        // Check each direction for walls
        if (!isWalkable(wp.x - checkDist, wp.y)) pushX += pushForce;
        if (!isWalkable(wp.x + checkDist, wp.y)) pushX -= pushForce;
        if (!isWalkable(wp.x, wp.y - checkDist)) pushY += pushForce;
        if (!isWalkable(wp.x, wp.y + checkDist)) pushY -= pushForce;
        
        // Apply push if still walkable
        const newX = wp.x + pushX;
        const newY = wp.y + pushY;
        if (isWalkable(newX, newY)) {
          wp.x = newX;
          wp.y = newY;
        }
      }
      
      // Smooth the path - remove unnecessary intermediate waypoints
      // Be conservative to avoid cutting through walls
      if (result.length > 2) {
        const smoothed = [result[0]];
        let i = 0;
        while (i < result.length - 1) {
          // Only try to skip to the NEXT waypoint (not further) to be safe
          let furthest = i + 1;
          
          // Check if we can skip to i+2 (one waypoint ahead)
          if (i + 2 < result.length) {
            const from = result[i];
            const to = result[i + 2];
            const dist = Math.hypot(to.x - from.x, to.y - from.y);
            // Use smaller step size for more accurate collision checking
            const steps = Math.ceil(dist / (TILE * 0.2));
            let canWalk = true;
            
            // Check path with larger collision radius to be safe
            for (let s = 0; s <= steps && canWalk; s++) {
              const t = s / steps;
              const cx = from.x + (to.x - from.x) * t;
              const cy = from.y + (to.y - from.y) * t;
              // Use stricter check - full collision check at each point
              if (!canMoveTo(cx, cy)) canWalk = false;
            }
            if (canWalk) furthest = i + 2;
          }
          
          smoothed.push(result[furthest]);
          i = furthest;
        }
        return smoothed;
      }
      return result;
    }
    
    // 8-directional neighbors
    const dirs = [
      [-1, 0, 1], [1, 0, 1], [0, -1, 1], [0, 1, 1],
      [-1, -1, 1.4], [1, -1, 1.4], [-1, 1, 1.4], [1, 1, 1.4]
    ];
    
    for (const [dx, dy, cost] of dirs) {
      const nx = curr.x + dx;
      const ny = curr.y + dy;
      const nkey = `${nx},${ny}`;
      
      if (nx < 0 || nx >= map.width || ny < 0 || ny >= map.height) continue;
      if (map.tiles[ny]?.[nx] !== 1) continue;
      if (closed.has(nkey)) continue;
      
      // Diagonal check - both adjacent cells must be walkable
      if (Math.abs(dx) + Math.abs(dy) === 2) {
        if (map.tiles[curr.y + dy]?.[curr.x] !== 1) continue;
        if (map.tiles[curr.y]?.[curr.x + dx] !== 1) continue;
      }
      
      // Add penalty for tiles near walls/corners to prefer open paths
      let cornerPenalty = 0;
      const cardinals = [[0,-1], [0,1], [-1,0], [1,0]];
      for (const [cdx, cdy] of cardinals) {
        if (map.tiles[ny + cdy]?.[nx + cdx] !== 1) {
          cornerPenalty += 0.4;  // Stronger penalty per adjacent wall
        }
      }
      // Extra penalty for diagonal tiles near corners (more likely to clip)
      const diagonals = [[-1,-1], [1,-1], [-1,1], [1,1]];
      for (const [cdx, cdy] of diagonals) {
        if (map.tiles[ny + cdy]?.[nx + cdx] !== 1) {
          cornerPenalty += 0.2;
        }
      }
      
      const g = curr.g + cost + cornerPenalty;
      const h = Math.abs(nx - endX) + Math.abs(ny - endY);
      const f = g + h;
      
      const existing = openMap.get(nkey);
      if (existing) {
        if (g < existing.g) {
          existing.g = g;
          existing.f = f;
          existing.p = curr;
        }
      } else {
        const node = { x: nx, y: ny, g, f, p: curr };
        open.push(node);
        openMap.set(nkey, node);
      }
    }
    
    if (closed.size > 5000) break;
  }
  
  return [];
}

// ============ COMBAT ============
function attack(target) {
  if (player.atkCD > 0) return;
  
  const dmg = player.minDmg + Math.floor(Math.random() * (player.maxDmg - player.minDmg + 1));
  target.hp -= dmg;
  target.flash = 6;
  player.atkCD = 1.0 / player.atkSpd;  // Cooldown in seconds
  player.atkAnim = 20; // Start attack animation (visual frames)
  
  // Life and Mana on Hit
  player.hp = Math.min(player.maxHp, player.hp + player.lifeOnHit);
  player.mana = Math.min(player.maxMana, player.mana + player.manaOnHit);
  
  showDamage(target.x, target.y - target.size, dmg, '#ffcc44');
  spawnParticles(target.x, target.y, 5, '#aa4444');
  
  // Attack swing trail effect (slash particles)
  const swingAngle = Math.atan2(target.y - player.y, target.x - player.x);
  for (let i = 0; i < 4; i++) {
    const spread = (i - 1.5) * 0.3;
    addParticle({
      x: player.x + Math.cos(swingAngle) * 25,
      y: player.y + Math.sin(swingAngle) * 25 + (i - 1.5) * 8,
      vx: Math.cos(swingAngle + spread) * 4,
      vy: Math.sin(swingAngle + spread) * 4,
      life: 10,
      color: '#ffeeaa',
      size: 4
    });
  }
  
  // Small screen shake on hit
  camera.shake = Math.max(camera.shake, 2);
  
  // Boss handling
  if (target.isBoss) {
    currentBoss = target;
    document.getElementById('bossBar').classList.add('visible');
    document.getElementById('bossName').textContent = target.name;
    
    // Random chance to apply debuff on hit
    if (Math.random() < 0.3) {
      applyDebuff(target);
    }
    
    updateBossBar();
  }
  
  if (target.hp <= 0) killEnemy(target);
}

// Ranged attack for Ranger and Mage
function rangedAttack(target) {
  if (player.atkCD > 0) return;
  
  player.atkCD = 1.0 / player.atkSpd;  // Cooldown in seconds
  player.atkAnim = 20;
  
  // Face the target
  player.facing = target.x > player.x ? 1 : -1;
  
  const dmg = player.minDmg + Math.floor(Math.random() * (player.maxDmg - player.minDmg + 1));
  const angle = Math.atan2(target.y - player.y, target.x - player.x);
  
  // Spawn projectile slightly ahead of player toward target for better close-range accuracy
  const spawnOffset = TILE * 0.5;
  const spawnX = player.x + Math.cos(angle) * spawnOffset;
  const spawnY = player.y + Math.sin(angle) * spawnOffset;
  
  // Muzzle flash effect
  const flashColor = player.class === 'ranger' ? '#ffdd88' : '#aa88ff';
  for (let i = 0; i < 5; i++) {
    addParticle({
      x: spawnX + (Math.random() - 0.5) * 10,
      y: spawnY + (Math.random() - 0.5) * 10,
      vx: Math.cos(angle) * (2 + Math.random() * 2) + (Math.random() - 0.5) * 2,
      vy: Math.sin(angle) * (2 + Math.random() * 2) + (Math.random() - 0.5) * 2,
      life: 12,
      color: flashColor,
      size: 3 + Math.random() * 3
    });
  }
  
  // Create projectile based on class
  const projectile = {
    x: spawnX,
    y: spawnY,
    vx: Math.cos(angle) * 8,
    vy: Math.sin(angle) * 8,
    damage: dmg,
    target: target,
    life: 120, // 2 seconds max
    type: player.class === 'ranger' ? 'arrow' : 'magicBolt',
    color: player.class === 'ranger' ? '#8B7355' : '#9966FF'
  };
  
  skillProjectiles.push(projectile);
}

function applyDebuff(boss) {
  const debuffType = DEBUFFS[Math.floor(Math.random() * DEBUFFS.length)];
  
  // Check if debuff already exists
  const existing = boss.debuffs.find(d => d.name === debuffType.name);
  if (existing) {
    existing.stacks = Math.min(existing.stacks + 1, 9);
    existing.duration = 5.0; // Reset duration (5 seconds)
  } else {
    boss.debuffs.push({
      ...debuffType,
      stacks: 1,
      duration: 5.0  // 5 seconds
    });
  }
  
  updateBossDebuffs();
}

function updateBossBar() {
  // Safety check - hide boss bar if boss is dead or doesn't exist
  if (!currentBoss || currentBoss.dead || currentBoss.hp <= 0) {
    document.getElementById('bossBar').classList.remove('visible');
    currentBoss = null;
    return;
  }
  
  const pct = Math.max(0, currentBoss.hp / currentBoss.maxHp * 100);
  document.getElementById('bossHealthFill').style.width = pct + '%';
  document.getElementById('bossHealthText').textContent = Math.ceil(pct) + '%';
  
  // Update boss name with marked indicator
  const bossNameEl = document.getElementById('bossName');
  let displayName = currentBoss.name;
  if (currentBoss.markedForDeath) {
    displayName = '💀 ' + displayName + ' 💀';
    bossNameEl.style.color = '#ff6666';
  } else {
    bossNameEl.style.color = '';
  }
  bossNameEl.textContent = displayName;
}

function updateBossDebuffs() {
  if (!currentBoss) return;
  
  const container = document.getElementById('bossDebuffs');
  container.innerHTML = '';
  
  currentBoss.debuffs.forEach(d => {
    const el = document.createElement('div');
    el.className = 'debuff-icon';
    el.innerHTML = d.icon;
    if (d.stacks > 1) {
      const stacks = document.createElement('span');
      stacks.className = 'debuff-stacks';
      stacks.textContent = d.stacks;
      el.appendChild(stacks);
    }
    
    // Add tooltip events
    el.onmouseenter = (e) => showDebuffTooltip(d, e);
    el.onmouseleave = hideDebuffTooltip;
    
    container.appendChild(el);
  });
}

function showDebuffTooltip(debuff, event) {
  const tooltip = document.getElementById('debuffTooltip');
  document.getElementById('debuffTooltipName').textContent = debuff.name;
  document.getElementById('debuffTooltipName').style.color = debuff.color;
  document.getElementById('debuffTooltipDesc').textContent = debuff.desc || 'Applies a negative effect to the enemy';
  
  const stacksEl = document.getElementById('debuffTooltipStacks');
  if (debuff.stacks > 1) {
    stacksEl.textContent = `Stacks: ${debuff.stacks}`;
    stacksEl.style.display = 'block';
  } else {
    stacksEl.style.display = 'none';
  }
  
  tooltip.classList.add('visible');
  
  // Position tooltip below the debuff icon
  const screenPadding = 10;
  const rect = event.target.getBoundingClientRect();
  
  requestAnimationFrame(() => {
    const tooltipRect = tooltip.getBoundingClientRect();
    let x = rect.left + rect.width / 2 - tooltipRect.width / 2;
    let y = rect.bottom + 8;
    
    // Clamp X to screen
    x = Math.max(screenPadding, Math.min(x, window.innerWidth - tooltipRect.width - screenPadding));
    
    // If goes off bottom, show above instead
    if (y + tooltipRect.height > window.innerHeight - screenPadding) {
      y = rect.top - tooltipRect.height - 8;
    }
    
    // Clamp Y to screen
    y = Math.max(screenPadding, Math.min(y, window.innerHeight - tooltipRect.height - screenPadding));
    
    tooltip.style.left = x + 'px';
    tooltip.style.top = y + 'px';
  });
}

function hideDebuffTooltip() {
  document.getElementById('debuffTooltip').classList.remove('visible');
}

// ========== DAMAGE INTAKE SYSTEM ==========
// HYBRID DAMAGE MODEL (PoE2-style)
//
// Most enemies deal MIXED damage: Physical + Elemental
// This makes BOTH armor AND resistances always relevant
//
// Order of operations:
// 1. DODGE CHECK - % chance to completely avoid attack (capped at 70%)
// 2. RAW DAMAGE - Roll from enemy's min-max damage range
// 3. SPLIT DAMAGE - Divide into physical and elemental portions
//    - Bosses deal MORE elemental damage (shifted toward 70-90%)
// 4. APPLY DEFENSES:
//    - Physical portion: Armor (PoE-style scaling - weak vs big hits)
//    - Elemental portion: Resistance (capped 75%)
// 5. COMBINE - Total damage = reduced physical + reduced elemental
// 6. SHIELD ABSORPTION - Shield absorbs damage before HP
// 7. HP DAMAGE - Remaining damage applied to health
//
// ARMOR FORMULA (PoE-style, scales with hit size):
//   reduction = armor / (armor + rawDamage * 5)
//   - Strong vs small hits (trash mobs)
//   - Weak vs large hits (bosses) - you NEED resists!
//
// DEFENSE PRIORITY (like PoE2):
// 1. 🥇 Resistances - Mandatory baseline, bosses hit HARD with elemental
// 2. 🥈 Dodge - Can fully negate hits, RNG-based
// 3. 🪨 Armor - Smooths trash damage, melts vs boss slams

function enemyAttack(e) {
  if (e.atkCD > 0) return;
  
  // Trigger attack animation
  e.atkAnim = 20; // 20 frames of attack animation
  
  // Test mode: no damage taken
  if (testMode) {
    e.atkCD = 40;
    return;
  }
  
  // Step 0: Blind check - enemy may miss entirely
  if (e.blinded && e.blindMissChance && Math.random() < e.blindMissChance) {
    e.atkCD = 40;
    showDamage(player.x, player.y - 25, 'MISS', '#ffff88');
    return;
  }
  
  // Step 0: Invulnerability check (Seven-Sided Strike)
  if (player.invulnerable) {
    e.atkCD = 40;
    showDamage(player.x, player.y - 25, 'IMMUNE', '#88ffff');
    return;
  }
  
  // Step 1: Dodge check using evasion formula
  // DodgeChance = DodgeRating / (DodgeRating + EnemyAccuracy)
  const settings = getDungeonSettings();
  const enemyAccuracy = getEnemyAccuracy(e, settings);
  let dodgeRating = player.dodgeRating || 0;
  
  // Blinding Flash bonus (temporary dodge boost)
  if (player.blindingFlashDodge) {
    dodgeRating += player.blindingFlashDodge * 100; // Convert to rating bonus
  }
  
  const dodgeChance = calculateDodgeChance(dodgeRating, enemyAccuracy);
  if (dodgeChance > 0 && Math.random() * 100 < dodgeChance) {
    e.atkCD = 40;
    showDamage(player.x, player.y - 25, 'DODGE', '#88ffff');
    return;
  }
  
  // Step 2: Roll raw damage from enemy's range
  const raw = e.dmg[0] + Math.floor(Math.random() * (e.dmg[1] - e.dmg[0] + 1));
  
  // Step 3: Split damage into physical and elemental portions
  // Bosses shift toward MORE elemental damage (scary without capped resists)
  const damageInfo = e.damage || { physical: 1.0, element: 'fire', elemental: 0 };
  let physicalRatio = damageInfo.physical || 0;
  let elementalRatio = damageInfo.elemental || 0;
  
  // Boss elemental boost: shift 30% of physical to elemental
  if (e.isBoss) {
    const shift = physicalRatio * 0.3;
    physicalRatio -= shift;
    elementalRatio += shift;
  }
  
  const physicalPortion = raw * physicalRatio;
  const elementalPortion = raw * elementalRatio;
  const element = damageInfo.element || 'fire';
  
  // Step 4a: Apply armor to physical portion
  // PoE-style formula: armor / (armor + rawDamage * 5)
  // This makes armor strong vs small hits, weak vs big hits
  const armorReduction = player.armor / (player.armor + physicalPortion * 5);
  const physicalDamage = Math.floor(physicalPortion * (1 - armorReduction));
  
  // Step 4b: Apply resistance to elemental portion (capped at 75%)
  let resist = 0;
  let elementColor = '#ff5555';
  switch(element) {
    case 'fire':
      resist = Math.min(75, player.fireRes || 0);
      elementColor = '#ff6644';
      break;
    case 'cold':
      resist = Math.min(75, player.coldRes || 0);
      elementColor = '#44aaff';
      break;
    case 'lightning':
      resist = Math.min(75, player.lightRes || 0);
      elementColor = '#ffff44';
      break;
    case 'nature':
      resist = Math.min(75, player.natureRes || 0);
      elementColor = '#44ff66';
      break;
  }
  const elementalDamage = Math.floor(elementalPortion * (1 - resist / 100));
  
  // Step 5: Combine damage (minimum 1)
  let dmg = Math.max(1, physicalDamage + elementalDamage);
  
  // Apply Caltrop damage reduction (enemy is weakened)
  if (e.caltropWeakened && e.caltropDamageReduction) {
    dmg = Math.floor(dmg * (1 - e.caltropDamageReduction));
  }
  
  // Determine display color based on dominant damage type
  const damageColor = elementalDamage > physicalDamage ? elementColor : '#ff5555';
  
  // Step 5.5: Apply Inner Sanctuary damage reduction (works on all damage types)
  if (player.inSanctuary && player.innerSanctuary) {
    dmg = Math.floor(dmg * (1 - player.innerSanctuary.damageReduction));
  }
  
  // Reset shield recharge delay (2 seconds)
  player.shieldRechargeDelay = 2.0;
  
  // Shield absorbs damage first (POE2 style)
  let remainingDmg = dmg;
  let shieldDmg = 0;
  
  if (player.currentShield > 0) {
    shieldDmg = Math.min(player.currentShield, remainingDmg);
    player.currentShield -= shieldDmg;
    remainingDmg -= shieldDmg;
  }
  
  // Apply remaining damage to HP
  if (remainingDmg > 0) {
    player.hp -= remainingDmg;
  }
  
  e.atkCD = 40;
  
  // Show damage numbers - cyan for shield, elemental color for HP
  if (shieldDmg > 0 && remainingDmg > 0) {
    showDamage(player.x - 15, player.y - 25, shieldDmg, '#8888ff'); // Shield damage
    showDamage(player.x + 15, player.y - 25, remainingDmg, damageColor); // HP damage (element color)
  } else if (shieldDmg > 0) {
    showDamage(player.x, player.y - 25, shieldDmg, '#8888ff'); // Only shield damage
  } else {
    showDamage(player.x, player.y - 25, remainingDmg, damageColor); // Only HP damage (element color)
  }
  
  if (player.hp <= 0) {
    player.hp = 0;
    playerDead = true;
    deathTimer = 10;
    lastKiller = e.name || 'Unknown Enemy';
    lastKillerDamage = dmg;
    sessionStats.deathCount++;
    
    // Update HP bar to show 0
    if (DOM.healthBar) {
      DOM.healthBar.style.width = '0%';
    }
    if (DOM.shieldBar) {
      DOM.shieldBar.style.width = '0%';
    }
    if (DOM.healthText) {
      const maxTotal = player.shield > 0 ? player.maxHp + player.shield : player.maxHp;
      DOM.healthText.textContent = `0/${maxTotal}`;
    }
    player.currentShield = 0;
    
    // Calculate and apply gold penalty (2%)
    const goldPenalty = Math.floor(player.gold * 0.02);
    player.gold -= goldPenalty;
    
    // Show death screen
    const deathScreen = document.getElementById('deathScreen');
    document.getElementById('deathKiller').textContent = `Slain by ${lastKiller}`;
    document.getElementById('deathDamage').textContent = `Fatal blow: ${lastKillerDamage} damage`;
    document.getElementById('deathPenalty').textContent = `Lost ${goldPenalty.toLocaleString()} gold (2% penalty)`;
    document.getElementById('deathTimer').textContent = '10';
    deathScreen.classList.add('visible');
    
    addLog(`☠️ Slain by ${lastKiller}! Lost ${goldPenalty} gold.`, 'damage');
    
    // Steam integration: death achievement
    onPlayerDeath_Steam();
    
    // End Rift Surge if active
    if (riftSurgeActive) {
      endRiftSurge(false);  // Defeated, not voluntary
    }
    
    // End Echo Domain if active
    if (echoDomainActive) {
      setTimeout(() => {
        leaveEchoDomain();
        showToast('💀', 'Death in Echo Domain', 'You have been expelled from the domain.', 'warning');
      }, 500);
    }
  }
}

// Trigger Exploding Palm explosion when marked enemy dies
function triggerExplodingPalmExplosion(deadEnemy) {
  if (!deadEnemy.explodingPalmExplosion) return;
  
  const explosionDmg = Math.floor(deadEnemy.explodingPalmExplosion);
  const explosionRadius = deadEnemy.explodingPalmRadius || 120;
  let hitCount = 0;
  
  // Deal damage to all enemies in radius
  enemies.forEach(e => {
    if (e.dead || e === deadEnemy) return;
    const dist = Math.hypot(e.x - deadEnemy.x, e.y - deadEnemy.y);
    if (dist < explosionRadius) {
      e.hp -= explosionDmg;
      e.flash = 15;
      hitCount++;
      spawnDamageNumber(e.x, e.y, explosionDmg, '#ff4400');
      checkEnemyDeath(e);
    }
  });
  
  // Explosion visual - MASSIVE FIERY EXPLOSION
  // Outer ring burst
  for (let i = 0; i < 24; i++) {
    const angle = (i / 24) * Math.PI * 2;
    const dist = explosionRadius * 0.8;
    addParticle({
      x: deadEnemy.x + Math.cos(angle) * 20,
      y: deadEnemy.y + Math.sin(angle) * 20,
      vx: Math.cos(angle) * 8,
      vy: Math.sin(angle) * 8,
      life: 35,
      color: '#ff2200',
      size: 10
    });
  }
  // Middle ring
  for (let i = 0; i < 16; i++) {
    const angle = (i / 16) * Math.PI * 2 + 0.2;
    addParticle({
      x: deadEnemy.x + Math.cos(angle) * 15,
      y: deadEnemy.y + Math.sin(angle) * 15,
      vx: Math.cos(angle) * 6,
      vy: Math.sin(angle) * 6,
      life: 30,
      color: '#ff6600',
      size: 8
    });
  }
  // Inner fireballs
  for (let i = 0; i < 12; i++) {
    const angle = (i / 12) * Math.PI * 2;
    addParticle({
      x: deadEnemy.x,
      y: deadEnemy.y,
      vx: Math.cos(angle) * 4,
      vy: Math.sin(angle) * 4,
      life: 25,
      color: '#ffaa00',
      size: 12
    });
  }
  // Central bright flash
  for (let i = 0; i < 8; i++) {
    addParticle({
      x: deadEnemy.x + (Math.random() - 0.5) * 20,
      y: deadEnemy.y + (Math.random() - 0.5) * 20,
      vx: (Math.random() - 0.5) * 3,
      vy: (Math.random() - 0.5) * 3,
      life: 20,
      color: '#ffffff',
      size: 15
    });
  }
  // Rising embers/sparks
  for (let i = 0; i < 15; i++) {
    addParticle({
      x: deadEnemy.x + (Math.random() - 0.5) * 50,
      y: deadEnemy.y + (Math.random() - 0.5) * 30,
      vx: (Math.random() - 0.5) * 4,
      vy: -4 - Math.random() * 6,
      life: 40,
      color: i % 3 === 0 ? '#ffff44' : i % 3 === 1 ? '#ff8800' : '#ff4400',
      size: 4 + Math.random() * 4
    });
  }
  // Smoke puffs
  for (let i = 0; i < 6; i++) {
    addParticle({
      x: deadEnemy.x + (Math.random() - 0.5) * 40,
      y: deadEnemy.y + (Math.random() - 0.5) * 40,
      vx: (Math.random() - 0.5) * 2,
      vy: -1 - Math.random() * 2,
      life: 45,
      color: '#442200',
      size: 14 + Math.random() * 8
    });
  }
  
  camera.shake = Math.max(camera.shake, 15);
  addLog(`EXPLODING PALM! (${hitCount} caught in blast)`, 'skill');
}

function killEnemy(e) {
  if (e.dead) return; // Already dead
  
  // Check for Exploding Palm explosion BEFORE marking dead
  if (e.explodingPalmMark && e.explodingPalmExplosion) {
    triggerExplodingPalmExplosion(e);
  }
  
  e.dead = true;
  
  player.kills++;
  player.exp += e.exp;
  const goldFromKill = e.gold[0] + Math.floor(Math.random() * (e.gold[1] - e.gold[0]));
  player.gold += goldFromKill;
  
  // Track session stats
  sessionStats.kills++;
  sessionStats.goldEarned += goldFromKill;
  if (e.isBoss) sessionStats.bossKills++;
  
  // Steam integration: kill tracking
  onEnemyKilled_Steam();
  
  // On-kill recovery (small HP/mana restore)
  const hpOnKill = e.isBoss ? 20 : 3;
  const manaOnKill = e.isBoss ? 15 : 5;
  player.hp = Math.min(player.maxHp, player.hp + hpOnKill);
  player.mana = Math.min(player.maxMana, player.mana + manaOnKill);
  
  // Potion charge recovery on kill
  onEnemyKillPotionRecharge();
  
  if (blood.length < MAX_BLOOD) {
    blood.push({ x: e.x, y: e.y, size: e.size * 1.4, alpha: 0.5 });
  }
  spawnParticles(e.x, e.y, e.isBoss ? 25 : 10, e.color);
  
  // Greater Rift handling
  if (greaterRiftActive && e.isGreaterRift) {
    // Check for Guardian kill (complete the rift!)
    if (e.isGuardian) {
      completeGreaterRift();
      return; // Exit early, don't do normal loot
    }
    // Track progress for regular GR enemies
    handleGreaterRiftKill(e);
  }
  
  // Drop currency (not in rift or domain or greater rift)
  if (!riftSurgeActive && !echoDomainActive && !greaterRiftActive) {
    dropCurrency(e.isBoss);
  }
  
  // Award shards (account-wide shard currency)
  awardShards(e);
  
  // Boss death
  if (e.isBoss) {
    currentBoss = null;
    document.getElementById('bossBar').classList.remove('visible');
    addLog(`BOSS SLAIN: ${e.name}!`, 'level');
    // Boss loot - 60% chance, NOT during rift/domain/greater rift
    if (!riftSurgeActive && !echoDomainActive && !greaterRiftActive) {
      if (Math.random() < 0.60) {
        dropLoot(e.x, e.y);
      }
      dropCurrency(true);
      dropCurrency(true);
      // Roll for Greater Rift Key from dungeon bosses
      rollGreaterRiftKey();
    }
    
    // Check for Echo Overlord death
    if (e.isOverlord) {
      checkOverlordDeath();
    }
  } else if (Math.random() < 0.05 && !riftSurgeActive && !echoDomainActive && !greaterRiftActive) {
    // Regular enemy drop rate: 5%
    dropLoot(e.x, e.y);
  }
  
  if (player.exp >= player.expToLevel) levelUp();
  
  enemies = enemies.filter(en => en.id !== e.id);
  
  if (e.room && !e.room.cleared && !enemies.some(en => en.room === e.room)) {
    e.room.cleared = true;
    addLog('Room cleared!', 'zone');
  }
  
  // Check Echo Domain room completion
  if (echoDomainActive && !e.isOverlord) {
    checkEchoDomainRoomComplete();
    echoDomainKills++;  // Track kills for stats
  }
  
  // Roll for aspect from dungeon boss (NOT rift/echo/gr bosses)
  if (e.isBoss && !riftSurgeActive && !echoDomainActive && !greaterRiftActive) {
    rollAspectFromBoss();
  }
  
  addLog(`Killed ${e.name}!`, 'kill');
  updateStats();
}

// Helper to check and kill enemy after damage
function checkEnemyDeath(e) {
  if (e && !e.dead && e.hp <= 0) {
    killEnemy(e);
  }
}

// Show boss bar when hitting a boss (called from skills and attacks)
function updateBossBarOnHit(target) {
  if (target && target.isBoss && !target.dead) {
    currentBoss = target;
    document.getElementById('bossBar').classList.add('visible');
    document.getElementById('bossName').textContent = target.name;
    updateBossBar();
  }
}

function dropLoot(x, y) {
  // Limit loot for performance - remove oldest if at max
  if (loot.length >= MAX_LOOT) {
    loot.shift();
  }
  
  // Ensure loot spawns on a walkable tile
  let lootX = x;
  let lootY = y;
  
  if (!isWalkable(x, y)) {
    // Search for nearby walkable position in expanding circle
    let foundValid = false;
    for (let radius = TILE; radius <= TILE * 4 && !foundValid; radius += TILE / 2) {
      for (let angle = 0; angle < Math.PI * 2; angle += Math.PI / 8) {
        const testX = x + Math.cos(angle) * radius;
        const testY = y + Math.sin(angle) * radius;
        if (isWalkable(testX, testY)) {
          lootX = testX;
          lootY = testY;
          foundValid = true;
          break;
        }
      }
    }
    
    // If still no valid position, try to find any walkable tile near player
    if (!foundValid) {
      const playerOffset = TILE * 2;
      for (let dx = -playerOffset; dx <= playerOffset; dx += TILE) {
        for (let dy = -playerOffset; dy <= playerOffset; dy += TILE) {
          if (isWalkable(player.x + dx, player.y + dy)) {
            lootX = player.x + dx;
            lootY = player.y + dy;
            foundValid = true;
            break;
          }
        }
        if (foundValid) break;
      }
    }
    
    // If still can't find valid position, don't spawn loot
    if (!foundValid) {
      console.log('Could not find valid position for loot drop');
      return;
    }
  }
  
  // Add small random offset so items don't stack exactly
  lootX += (Math.random() - 0.5) * TILE * 0.5;
  lootY += (Math.random() - 0.5) * TILE * 0.5;
  
  // Verify final position is still walkable
  if (!isWalkable(lootX, lootY)) {
    lootX = x;
    lootY = y;
  }
  
  // ========== DROP TIER SYSTEM ==========
  // Roll drop tier FIRST - this controls everything
  const dropTier = rollDropTier(currentDifficulty);
  const constraints = getDropTierConstraints(dropTier);
  
  // Rarity based on drop tier
  // T0-T1: mostly normal, T2-T3: mix, T4-T5: mostly rare
  let rarity;
  if (dropTier <= 1) {
    const roll = Math.random();
    rarity = roll < 0.02 ? 'rare' : roll < 0.12 ? 'magic' : 'normal';
  } else if (dropTier <= 3) {
    const roll = Math.random();
    rarity = roll < 0.15 ? 'rare' : roll < 0.45 ? 'magic' : 'normal';
  } else {
    const roll = Math.random();
    rarity = roll < 0.50 ? 'rare' : roll < 0.85 ? 'magic' : 'normal';
  }
  
  let items = [...LOOT[rarity]]; // Copy array so we can filter
  
  // Filter weapons to only drop class-appropriate types
  const allowedWeapons = CLASS_WEAPONS[player.class] || [];
  items = items.filter(itemName => {
    const slot = getItemSlot(itemName);
    if (slot === 'weapon') {
      const weaponCategory = getWeaponCategory(itemName);
      return allowedWeapons.includes(weaponCategory);
    }
    return true; // Non-weapons pass through
  });
  
  // If no items left after filtering (shouldn't happen), fall back to original
  if (items.length === 0) {
    items = LOOT[rarity];
  }
  
  const name = items[Math.floor(Math.random() * items.length)];
  
  const size = getItemSize(name);
  const slot = getItemSlot(name);
  // Use dungeon difficulty to determine item level
  const baseLevel = getDungeonItemLevel();
  
  // Generate mods using drop tier constraints
  const mods = generateItemModsWithTier(rarity, name, baseLevel, dropTier);
  
  // Generate sockets - HARD CAPPED by slot type
  // Weapon/Chest: max 2, Helm/Gloves/Boots: max 1, Jewelry: 0
  // 3rd socket ONLY possible via Uncontrolled Core corruption (not on drops)
  let sockets = [];
  if (canHaveSockets(name)) {
    const maxSockets = getMaxSockets(name); // 1 or 2 based on slot
    
    // Socket chances by rarity - chance to get ANY sockets at all
    const baseChance = rarity === 'unique' ? 0.35 : rarity === 'rare' ? 0.12 : rarity === 'magic' ? 0.05 : 0.02;
    
    // Roll for first socket
    if (Math.random() < baseChance) {
      sockets.push({ color: getRandomSocketColor(), gem: null });
      
      // If slot allows 2 sockets, roll for second (harder to get)
      if (maxSockets >= 2 && Math.random() < baseChance * 0.4) {
        sockets.push({ color: getRandomSocketColor(), gem: null });
      }
    }
  }
  
  // Calculate base stats
  let baseDmgMin = 0, baseDmgMax = 0, baseArmor = 0, baseDodge = 0, baseShield = 0;
  if (slot === 'weapon') {
    const weaponDmg = getWeaponBaseDamage(name, baseLevel);
    baseDmgMin = weaponDmg.min;
    baseDmgMax = weaponDmg.max;
  } else if (['body', 'helmet', 'gloves', 'boots'].includes(slot)) {
    // Defense values based on base type (helmets max 2 types per spec)
    const armorBaseType = getArmorBaseType(name);
    const armorVal = 20 + baseLevel * 3;
    const dodgeVal = 15 + baseLevel * 2;
    const shieldVal = 12 + baseLevel * 2;
    
    if (armorBaseType === 'str') {
      baseArmor = armorVal;
    } else if (armorBaseType === 'dex') {
      baseDodge = dodgeVal;
    } else if (armorBaseType === 'int') {
      baseShield = shieldVal;
    } else if (armorBaseType === 'str_dex') {
      baseArmor = Math.floor(armorVal * 0.55);
      baseDodge = Math.floor(dodgeVal * 0.55);
    } else if (armorBaseType === 'str_int') {
      baseArmor = Math.floor(armorVal * 0.55);
      baseShield = Math.floor(shieldVal * 0.55);
    } else if (armorBaseType === 'dex_int') {
      baseDodge = Math.floor(dodgeVal * 0.55);
      baseShield = Math.floor(shieldVal * 0.55);
    }
  }
  
  const item = { 
    x: lootX, 
    y: lootY, 
    name, 
    rarity, 
    id: Math.random(),
    mods,
    sockets,
    slot,
    baseLevel,
    baseDmgMin,
    baseDmgMax,
    baseArmor,
    baseDodge,
    baseShield,
    width: size[0],
    height: size[1],
    image: getItemImage(name),
    dropTier  // Store the drop tier on the item!
  };
  loot.push(item);
  
  // Add loot popup for this drop
  addLootPopup(item, lootX, lootY);
}

// Calculate item sell value based on rarity and sockets
function getItemValue(item) {
  const rarityValue = { normal: 1, magic: 5, rare: 20, unique: 100 };
  let value = rarityValue[item.rarity] || 1;
  if (item.sockets) value += item.sockets.length * 3;
  if (item.mods) {
    if (item.mods.prefixes) value += item.mods.prefixes.length * 2;
    if (item.mods.suffixes) value += item.mods.suffixes.length * 2;
  }
  return value;
}

// Basic cores that can drop from salvage
const BASIC_CORES = ['transmute', 'augment', 'armorer', 'whetstone', 'jeweller'];
// Advanced cores that can drop from salvage
const ADVANCED_CORES = ['wild', 'upgrade', 'echo', 'annul'];

// Salvage rewards: 94% gold, 5% base cores, 1% advanced cores
// Gold amount scales with item rarity and drop tier
const SALVAGE_GOLD_VALUES = {
  normal:  { base: 5,   perStar: 2  },   // 5-15g
  magic:   { base: 15,  perStar: 5  },   // 15-40g
  rare:    { base: 50,  perStar: 15 },   // 50-125g
  unique:  { base: 200, perStar: 50 }    // 200-450g
};

// Get salvage odds for an item (now just returns the item for gold calculation)
function getSalvageOdds(item) {
  return item;
}

// Salvage an item for gold/cores
function salvageItem(item, silent = false) {
  let rewards = [];
  let gemsReturned = [];
  
  // Return any socketed gems to gem inventory
  if (item.sockets && item.sockets.length > 0) {
    for (const socket of item.sockets) {
      if (socket.gem) {
        const gemQuality = socket.gemQuality || 0;
        addGemToInventory(socket.gem, gemQuality);
        gemsReturned.push({ id: socket.gem, quality: gemQuality });
      }
    }
  }
  
  // Track items salvaged
  sessionStats.itemsSalvaged++;
  
  // Roll salvage type: 94% gold, 5% base cores, 1% advanced cores
  const roll = Math.random() * 100;
  
  if (roll < 94) {
    // GOLD (94%)
    const goldValues = SALVAGE_GOLD_VALUES[item.rarity] || SALVAGE_GOLD_VALUES.normal;
    const starBonus = (item.dropTier || 1) * goldValues.perStar;
    const goldAmount = goldValues.base + starBonus + Math.floor(Math.random() * goldValues.perStar * 2);
    player.gold = (player.gold || 0) + goldAmount;
    rewards.push({ type: 'gold', amount: goldAmount });
    sessionStats.goldEarned += goldAmount;
  } else if (roll < 99) {
    // BASE CORE (5%)
    const core = BASIC_CORES[Math.floor(Math.random() * BASIC_CORES.length)];
    stash[core] = (stash[core] || 0) + 1;
    rewards.push({ type: 'basic', name: core });
    sessionStats.coresEarned++;
  } else {
    // ADVANCED CORE (1%)
    const core = ADVANCED_CORES[Math.floor(Math.random() * ADVANCED_CORES.length)];
    stash[core] = (stash[core] || 0) + 1;
    rewards.push({ type: 'advanced', name: core });
    sessionStats.coresEarned++;
  }
  
  // Show salvage result popup (unless silent)
  if (!silent) {
    showSalvageResult(item, rewards, gemsReturned);
  }
  
  updateCurrencyDisplay();
  updateStats();
}

// Salvage result popup array
let salvagePopups = [];
const MAX_SALVAGE_POPUPS = 5;

// Show salvage result as a floating popup
function showSalvageResult(item, rewards, gemsReturned = []) {
  // Remove oldest if at limit
  if (salvagePopups.length >= MAX_SALVAGE_POPUPS) {
    salvagePopups.shift();
  }
  
  const rarityColors = {
    normal: '#888888',
    magic: '#6688ff',
    rare: '#ffdd44',
    unique: '#ff8844'
  };
  
  let lines = [];
  lines.push({ text: `♻️ Salvaged ${item.name}`, color: rarityColors[item.rarity] || '#888', size: 12, bold: true });
  
  // Show returned gems
  if (gemsReturned.length > 0) {
    for (const gem of gemsReturned) {
      const gemData = GEM_DATA[gem.id];
      if (gemData) {
        const qualityText = gem.quality > 0 ? ` (${gem.quality}%)` : '';
        lines.push({ text: `💎 ${gemData.icon} ${gemData.name}${qualityText} returned`, color: '#88ffaa', size: 11, bold: false });
      }
    }
  }
  
  // Show rewards (gold, basic core, or advanced core)
  for (const reward of rewards) {
    if (reward.type === 'gold') {
      lines.push({ text: `💰 +${reward.amount}g`, color: '#ffdd44', size: 11, bold: false });
    } else if (reward.type === 'basic') {
      lines.push({ text: '🔵 +1 Basic Core', color: '#44aaff', size: 11, bold: false });
    } else if (reward.type === 'advanced') {
      lines.push({ text: '⭐ +1 Advanced Core!', color: '#ffaa44', size: 11, bold: true });
    }
  }
  
  // Position near the inventory panel
  const invPanel = document.getElementById('inventoryPanel');
  let popupX = window.innerWidth / 2;
  let popupY = 150;
  
  if (invPanel && invPanel.classList.contains('visible')) {
    const rect = invPanel.getBoundingClientRect();
    popupX = rect.left - 100;
    popupY = 200 + salvagePopups.length * 80;
  }
  
  salvagePopups.push({
    lines: lines,
    x: popupX,
    y: popupY,
    life: 150, // 2.5 seconds - longer since it's rare to see
    maxLife: 150,
    hasReward: rewards.length > 0
  });
  
  // Log rewards
  for (const reward of rewards) {
    if (reward.type === 'gold') {
      addLog(`Salvaged ${item.name} → 💰 +${reward.amount}g`, 'loot');
    } else if (reward.type === 'basic') {
      addLog(`Salvaged ${item.name} → 🔵 Basic Core!`, 'loot');
    } else if (reward.type === 'advanced') {
      addLog(`Salvaged ${item.name} → ⭐ Advanced Core!`, 'unique');
    }
  }
  if (gemsReturned.length > 0) {
    addLog(`💎 ${gemsReturned.length} gem(s) returned to inventory`, 'loot');
  }
}

// Salvage the worst item in inventory to make room
function salvageWorstItem() {
  if (inventoryItems.length === 0) return false;
  
  // Find lowest rarity item
  const rarityOrder = { normal: 0, magic: 1, rare: 2, unique: 3 };
  let worstItem = null;
  let worstRarity = Infinity;
  let worstIdx = -1;
  
  for (let i = 0; i < inventoryItems.length; i++) {
    const item = inventoryItems[i];
    const rarity = rarityOrder[item.rarity] || 0;
    if (rarity < worstRarity) {
      worstRarity = rarity;
      worstItem = item;
      worstIdx = i;
    }
  }
  
  if (!worstItem || worstIdx < 0) return false;
  
  removeItemFromGrid(worstItem);
  inventoryItems.splice(worstIdx, 1);
  salvageItem(worstItem);
  updateInventoryDisplay();
  
  return true;
}

function pickupLoot(l) {
  // Use pre-generated mods and sockets from drop time (if available), otherwise generate
  const ilvl = l.baseLevel || Math.max(1, Math.floor(player.level * 0.8));
  const mods = l.mods || generateItemMods(l.rarity, l.name, null, ilvl);
  const size = l.width && l.height ? [l.width, l.height] : getItemSize(l.name);
  
  // Use pre-generated sockets or generate new ones (fallback for legacy items)
  let sockets = l.sockets || [];
  if (!l.sockets && canHaveSockets(l.name)) {
    const maxSockets = getMaxSockets(l.name); // 1 or 2 based on slot
    const baseChance = l.rarity === 'unique' ? 0.35 : l.rarity === 'rare' ? 0.12 : l.rarity === 'magic' ? 0.05 : 0.02;
    
    // Roll for first socket
    if (Math.random() < baseChance) {
      sockets.push({ color: getRandomSocketColor(), gem: null });
      
      // If slot allows 2 sockets, roll for second
      if (maxSockets >= 2 && Math.random() < baseChance * 0.4) {
        sockets.push({ color: getRandomSocketColor(), gem: null });
      }
    }
  }
  
  // Create the item
  const newItem = { 
    name: l.name, 
    rarity: l.rarity,
    mods: mods,
    sockets: sockets,
    width: size[0],
    height: size[1],
    id: l.id || Math.random(),
    image: l.image || getItemImage(l.name),
    baseLevel: ilvl,
    quality: l.quality || 0,
    isRiftItem: l.isRiftItem || false
  };
  
  // ALL loot goes to overflow - inventory is for safekeeping only
  addToOverflow(newItem);
  loot = loot.filter(lo => lo.id !== l.id);
  
  // Track session stats for items looted
  sessionStats.itemsLooted++;
  const itemDropTier = l.dropTier || calculateDropTier(newItem);
  if (itemDropTier > sessionStats.highestStarDrop) {
    sessionStats.highestStarDrop = itemDropTier;
  }
  
  const socketText = sockets.length > 0 ? ` [${sockets.length} socket${sockets.length > 1 ? 's' : ''}]` : '';
  addLog(`Picked up ${l.name}${socketText}`, 'loot');
  updateStats();
}

// Skill unlock popup system
let skillUnlockQueue = [];
let skillUnlockShowing = false;

function checkSkillUnlocks(newLevel) {
  // Get skills for player's class
  const classSkills = CLASS_SKILLS[player.class] || [];
  const classPassives = CLASS_PASSIVES[player.class] || [];
  const allSkills = [...classSkills, ...classPassives];
  
  // Check each skill for unlock
  allSkills.forEach(skillId => {
    const skillDef = SKILLS[skillId];
    if (skillDef && skillDef.unlockLevel === newLevel) {
      skillUnlockQueue.push(skillId);
    }
  });
  
  // Show first unlock if not already showing
  if (skillUnlockQueue.length > 0 && !skillUnlockShowing) {
    showNextSkillUnlock();
  }
}

function showNextSkillUnlock() {
  if (skillUnlockQueue.length === 0) {
    skillUnlockShowing = false;
    return;
  }
  
  skillUnlockShowing = true;
  const skillId = skillUnlockQueue.shift();
  const skillDef = SKILLS[skillId];
  const skillGem = SKILL_GEM_DATA[skillId];
  
  if (!skillDef) {
    showNextSkillUnlock();
    return;
  }
  
  // Update popup content
  document.getElementById('skillUnlockLevel').textContent = skillDef.unlockLevel || player.level;
  document.getElementById('skillUnlockName').textContent = skillDef.name;
  document.getElementById('skillUnlockDesc').textContent = skillDef.description || skillGem?.desc || 'A new ability!';
  
  // Set icon
  const iconContainer = document.getElementById('skillUnlockIcon');
  if (skillDef.imageUrl) {
    iconContainer.innerHTML = `<img src="${skillDef.imageUrl}" alt="${skillDef.name}" draggable="false">`;
  } else {
    iconContainer.innerHTML = `<span class="emoji">${skillDef.icon || skillGem?.icon || '✨'}</span>`;
  }
  
  // Set hint based on skill type
  const hintEl = document.getElementById('skillUnlockHint');
  if (skillDef.isPassive) {
    hintEl.innerHTML = 'Click the <strong>passive slot (5th)</strong> to equip this passive skill!';
  } else if (skillDef.isPrimary) {
    hintEl.innerHTML = 'This is your <strong>primary attack</strong> - always in slot 1!';
  } else {
    hintEl.innerHTML = 'Click a <strong>skill slot</strong> at the bottom of the screen to equip this skill!';
  }
  
  // Show popup
  document.getElementById('skillUnlockModal').classList.add('visible');
}

function closeSkillUnlockPopup() {
  document.getElementById('skillUnlockModal').classList.remove('visible');
  
  // Show next unlock after a short delay
  setTimeout(() => {
    showNextSkillUnlock();
  }, 300);
}

function levelUp() {
  const oldLevel = player.level;
  player.level++;
  player.exp -= player.expToLevel;
  player.expToLevel = Math.floor(player.expToLevel * 1.35);
  
  // Slight on-hit gains per level
  if (player.level % 3 === 0) player.lifeOnHit += 1;
  if (player.level % 5 === 0) player.manaOnHit += 1;
  
  // Grant passive skill point
  grantPassivePoint();
  
  // Recalculate all stats based on new level (including weapon damage)
  recalculateStats();
  
  // Heal to full on level up
  player.hp = player.maxHp;
  player.mana = player.maxMana;
  
  spawnParticles(player.x, player.y, 20, '#ffdd44');
  addLog(`LEVEL UP! Now level ${player.level}`, 'level');
  updateStats();
  updateCharacterFace(); // Update portrait level
  
  // Check for skill unlocks
  checkSkillUnlocks(player.level);
  
  // Steam integration: achievements and leaderboards
  onLevelUp_Steam();
}

// ============ UPDATE ============
function update(dt = 1) {
  // Convert dt to real seconds (dt is normalized to 60fps, so dt/60 = seconds)
  const deltaSeconds = dt / 60;
  window.deltaSeconds = deltaSeconds;  // Make available globally for other systems
  
  // Handle player frozen state (from ice hazards)
  if (player.frozen > 0) {
    player.frozen -= deltaSeconds;
    if (player.frozen <= 0) {
      player.frozen = 0;
      addLog('❄️ Unfrozen!', 'skill');
    }
  }
  
  // Handle death state - pause most game logic while dead
  if (playerDead) {
    deathTimer -= deltaSeconds;
    const timerDisplay = DOM.deathTimer || document.getElementById('deathTimer');
    if (timerDisplay) timerDisplay.textContent = Math.ceil(Math.max(0, deathTimer));
    
    if (deathTimer <= 0) {
      // Respawn in a fresh dungeon (same difficulty)
      playerDead = false;
      player.hp = player.maxHp;
      player.mana = player.maxMana;
      player.currentShield = player.shield;
      const deathScreen = DOM.deathScreen || document.getElementById('deathScreen');
      if (deathScreen) deathScreen.classList.remove('visible');
      
      // End any active Greater Rift on death (counts as failure)
      if (greaterRiftActive) {
        addLog(`❌ Greater Rift ${greaterRiftLevel} Failed - You Died!`, 'warning');
        showToast('❌', 'Rift Failed', 'You died in the Greater Rift', 'warning');
        endGreaterRift(false);
      }
      
      // End any active Rift Surge or Echo Domain
      if (riftSurgeActive) endRiftSurge(true);
      if (echoDomainActive) leaveEchoDomain();
      
      // Generate fresh dungeon to avoid respawning in glitched spots
      dungeon.level = 1;
      generateDungeon();
      
      // Reset camera to player
      camera.x = player.x;
      camera.y = player.y;
      camera.shake = 0;
      
      // Clear any lingering state
      path = [];
      particles = [];
      skillProjectiles = [];
      damageNumbers = [];
      cycloneActive = false;
      cycloneTimer = 0;
      player.state = 'idle';
      player.frozen = 0;  // Clear frozen state on respawn
      guardianHazards = [];  // Clear any lingering hazards
      
      addLog('Resurrected in new dungeon!', 'skill');
      showToast('💫', 'Resurrected', 'You have returned from death.', 'info');
    }
    return; // Skip all other updates while dead
  }
  
  // Track total game time in seconds for time-based checks
  if (!window.gameTime) window.gameTime = 0;
  window.gameTime += deltaSeconds;
  
  frame++;  // Keep frame counter for non-critical visual effects only
  pathTimer -= dt;
  
  // Update dungeon timer (once per second)
  if (!window.timerAccum) window.timerAccum = 0;
  window.timerAccum += deltaSeconds;
  if (window.timerAccum >= 1.0) { // 1 second (real time)
    updateDungeonTimer();
    window.timerAccum -= 1.0;
  }
  
  // Failsafe: reset enteringPortal if stuck for too long
  if (enteringPortal) {
    if (!window.portalTimeout) window.portalTimeout = 0;
    window.portalTimeout += deltaSeconds;
    if (window.portalTimeout > 2.0) {  // 2 seconds (real time)
      console.log('Portal entry timeout - resetting');
      addLog('Portal entry reset (timeout)', 'warning');
      enteringPortal = false;
      window.portalTimeout = 0;
    }
  } else {
    window.portalTimeout = 0;
  }
  
  // Cooldowns in seconds (converted from frames)
  if (player.atkCD > 0) player.atkCD -= deltaSeconds;
  if (player.castCD > 0) player.castCD -= deltaSeconds;
  if (player.escapeDashCD > 0) player.escapeDashCD -= deltaSeconds;
  if (player.fistsDashCD > 0) player.fistsDashCD -= deltaSeconds;
  if (player.atkAnim > 0) player.atkAnim -= dt;  // Animation uses dt for smooth visual
  
  // Test mode: infinite mana
  if (testMode) {
    player.mana = player.maxMana;
  }
  
  // Update skills system
  updateSkills(dt, deltaSeconds);
  
  // Update unique item effects (Echo Ring, etc.)
  updateUniqueEffects(dt);
  
  // Update Rift Surge mechanic
  if (riftSurgeActive) {
    updateRiftSurge();
  }
  
  // Update Greater Rift timer
  if (greaterRiftActive) {
    updateGreaterRiftTimer();
  }
  
  // Update potion system (cooldowns, auto-trigger)
  updatePotions(deltaSeconds);
  
  // Apply life/mana regeneration (once per second, real time)
  if (!window.regenAccum) window.regenAccum = 0;
  window.regenAccum += deltaSeconds;
  if (window.regenAccum >= 1.0) { // Once per second (real time)
    // Life regen (only out of combat or always - can tune later)
    if (player.lifeRegen > 0 && player.hp < player.maxHp) {
      player.hp = Math.min(player.maxHp, player.hp + player.lifeRegen);
    }
    // Mana regen
    if (player.manaRegen > 0 && player.mana < player.maxMana) {
      player.mana = Math.min(player.maxMana, player.mana + player.manaRegen);
    }
    window.regenAccum -= 1.0;
  }
  
  // Update skill cooldown displays (UI)
  updateSkillCooldownDisplays();
  
  // Stuck detection - check every ~200ms
  if (!window.stuckAccum) window.stuckAccum = 0;
  window.stuckAccum += dt;
  if (window.stuckAccum >= 12) {  // Check more frequently
    const moved = Math.hypot(player.x - lastX, player.y - lastY);
    
    // Track accumulated movement over time
    if (!window.moveHistory) window.moveHistory = [];
    window.moveHistory.push(moved);
    if (window.moveHistory.length > 10) window.moveHistory.shift();
    
    const avgMove = window.moveHistory.reduce((a, b) => a + b, 0) / window.moveHistory.length;
    
    // Track position history for oscillation detection
    if (!window.posHistory) window.posHistory = [];
    window.posHistory.push({ x: player.x, y: player.y });
    if (window.posHistory.length > 20) window.posHistory.shift();
    
    // Check if we're in combat range - don't flag oscillation during kiting
    const activeEnemies = enemies.filter(e => e.active && !e.unreachable);
    let nearestEnemyDist = Infinity;
    let nearestEnemy = null;
    if (activeEnemies.length > 0) {
      nearestEnemy = activeEnemies.sort((a, b) => 
        Math.hypot(a.x - player.x, a.y - player.y) - Math.hypot(b.x - player.x, b.y - player.y)
      )[0];
      nearestEnemyDist = Math.hypot(nearestEnemy.x - player.x, nearestEnemy.y - player.y);
    }
    
    const isRangedClass = player.class === 'ranger' || player.class === 'mage';
    const combatRange = isRangedClass ? TILE * 8 : TILE * 1.5;
    const inCombatRange = nearestEnemyDist < combatRange;
    
    // Detect oscillation - only when NOT in combat range (trying to reach target)
    let oscillationCount = 0;
    if (window.posHistory.length >= 10 && !inCombatRange) {
      const recentPos = window.posHistory.slice(-5);
      const olderPos = window.posHistory.slice(0, -5);
      for (const recent of recentPos) {
        for (const older of olderPos) {
          if (Math.hypot(recent.x - older.x, recent.y - older.y) < TILE * 0.5) {
            oscillationCount++;
          }
        }
      }
    }
    
    // Track path direction changes (detects back-and-forth path recalculation)
    if (!window.pathDirHistory) window.pathDirHistory = [];
    if (path.length > 1) {
      const firstWp = path[0];
      const dirAngle = Math.atan2(firstWp.y - player.y, firstWp.x - player.x);
      const dirBucket = Math.round(dirAngle / (Math.PI / 4)); // 8 direction buckets
      
      // Only track if this is a new direction (not just same path)
      const lastDir = window.pathDirHistory[window.pathDirHistory.length - 1];
      if (lastDir === undefined || Math.abs(lastDir - dirBucket) >= 2) {
        window.pathDirHistory.push(dirBucket);
        if (window.pathDirHistory.length > 6) window.pathDirHistory.shift();
      }
    }
    
    // Detect direction oscillation (e.g., going left, right, left, right)
    let dirOscillation = false;
    if (window.pathDirHistory.length >= 4) {
      const recent = window.pathDirHistory.slice(-4);
      // Check if alternating between two directions
      if (recent[0] === recent[2] && recent[1] === recent[3] && recent[0] !== recent[1]) {
        dirOscillation = true;
      }
    }
    
    // If oscillating frequently while trying to reach an enemy, mark enemy as problematic
    if ((oscillationCount > 5 || dirOscillation) && player.state === 'moving' && !inCombatRange) {
      if (!window.oscillationFrames) window.oscillationFrames = 0;
      window.oscillationFrames++;
      
      // When direction oscillation detected, commit to current path strongly
      if (dirOscillation && window.oscillationFrames >= 2) {
        window.pathCommitment = Math.max(window.pathCommitment || 0, 10); // Commit to 10 waypoints
        window.pathDirHistory = []; // Reset direction tracking
        window.oscillationFrames = 0;
      }
      
      if (window.oscillationFrames > 5) {
        // We're oscillating trying to reach an enemy - mark it as problematic
        if (nearestEnemy) {
          nearestEnemy.pathFailCount = (nearestEnemy.pathFailCount || 0) + 3;
          if (nearestEnemy.pathFailCount > 5) {
            nearestEnemy.unreachable = true;
            addLog('Skipping unreachable enemy', 'system');
          }
        }
        
        // Force path recalculation to try different target
        path = [];
        pathTarget = null;
        pathTimer = 0;
        window.oscillationFrames = 0;
        window.posHistory = [];
        window.pathDirHistory = [];
        window.pathCommitment = 0;
      }
    } else {
      window.oscillationFrames = 0;
    }
    
    if (avgMove < 3 && player.state === 'moving' && path.length > 0) {  // Very little movement over time
      stuckFrames++;
      if (stuckFrames > 5) {  // After ~1 second of minimal movement
        // Check if near exit - force enter it
        if (exitPos && !enteringPortal) {
          const exitDist = Math.hypot(exitPos.x - player.x, exitPos.y - player.y);
          if (exitDist < TILE * 6) {
            const allCleared = map.rooms.every(r => r.cleared);
            if (allCleared) {
              // Force enter exit
              addLog('Force-entering portal (stuck detection)', 'skill');
              enteringPortal = true;
              if (!greaterRiftActive) {
                dungeon.level++;
                addLog(`Entering level ${dungeon.level}...`, 'skill');
                
                // Steam integration: dungeon cleared achievement
                onDungeonCleared_Steam(currentDifficulty);
              } else {
                addLog(`Entering next rift floor...`, 'skill');
              }
              path = [];
              particles = [];
              skillProjectiles = [];
              damageNumbers = [];
              cycloneActive = false;
              cycloneTimer = 0;
              player.state = 'idle';
              setTimeout(() => {
                generateDungeon();
                camera.x = player.x;
                camera.y = player.y;
                camera.shake = 0;
                enteringPortal = false;
                // Greater Rifts don't spawn new enemies on floor transitions - fixed enemy pool
                // Regular dungeons continue to spawn normally via generateDungeon()
              }, 100);
              stuckFrames = 0;
              window.stuckAccum = 0;
              return;
            }
          }
        }
        // Try to wiggle out - try multiple directions, prefer toward target
        let wiggled = false;
        const wiggleDist = TILE * 0.5;
        
        // First try directions toward the path target or exit
        const targetAngle = pathTarget ? Math.atan2(pathTarget.y - player.y, pathTarget.x - player.x) : Math.atan2(map.exit.y * TILE - player.y, map.exit.x * TILE - player.x);
        const wiggleAngles = [
          targetAngle,
          targetAngle + Math.PI/4,
          targetAngle - Math.PI/4,
          targetAngle + Math.PI/2,
          targetAngle - Math.PI/2,
          targetAngle + Math.PI*3/4,
          targetAngle - Math.PI*3/4,
          targetAngle + Math.PI,
          Math.random() * Math.PI * 2  // Random as last resort
        ];
        
        for (const wAngle of wiggleAngles) {
          const wx = player.x + Math.cos(wAngle) * wiggleDist;
          const wy = player.y + Math.sin(wAngle) * wiggleDist;
          if (canMoveTo(wx, wy)) {
            player.x = wx;
            player.y = wy;
            wiggled = true;
            break;
          }
        }
        
        // Clear path to force recalculation
        path = [];
        pathTarget = null;
        pathTimer = 0;
        stuckFrames = 0;
      }
    } else {
      stuckFrames = 0;
    }
    lastX = player.x;
    lastY = player.y;
    window.stuckAccum = 0;
  }
  
  // Exploration - run every ~10 frames for performance
  if (!window.exploreAccum) window.exploreAccum = 0;
  window.exploreAccum += dt;
  if (window.exploreAccum >= 10) {
    const px = Math.floor(player.x / TILE);
    const py = Math.floor(player.y / TILE);
    for (let dy = -8; dy <= 8; dy++) {
      for (let dx = -8; dx <= 8; dx++) {
        if (map.explored[py + dy]?.[px + dx] !== undefined) {
          map.explored[py + dy][px + dx] = true;
        }
      }
    }
    window.exploreAccum = 0;
  }
  
  // Activate nearby enemies - larger range in rifts
  const activationRange = riftSurgeActive ? TILE * 15 : TILE * 10;
  for (let i = 0; i < enemies.length; i++) {
    const e = enemies[i];
    if (Math.hypot(e.x - player.x, e.y - player.y) < activationRange) e.active = true;
  }
  
  // Periodic room clearing check - mark rooms as cleared if no enemies left in them
  if (frame % 60 === 0) {  // Every ~1 second
    for (const room of map.rooms) {
      if (!room.cleared) {
        const enemiesInRoom = enemies.filter(e => !e.dead && e.room === room);
        if (enemiesInRoom.length === 0) {
          room.cleared = true;
          if (debugMode) addLog(`Room auto-cleared (no enemies)`, 'zone');
        }
      }
    }
    
    // Also check if player is in a room with no enemies - clear it
    const px = Math.floor(player.x / TILE);
    const py = Math.floor(player.y / TILE);
    for (const room of map.rooms) {
      if (!room.cleared && 
          px >= room.x && px < room.x + room.w &&
          py >= room.y && py < room.y + room.h) {
        const enemiesInRoom = enemies.filter(e => !e.dead && e.room === room);
        if (enemiesInRoom.length === 0) {
          room.cleared = true;
          if (debugMode) addLog(`Player room cleared`, 'zone');
        }
      }
    }
  }
  
  // Auto-pickup loot when walking near it (no pathfinding needed)
  for (let i = 0; i < loot.length; i++) {
    const l = loot[i];
    
    // Check if loot is on unwalkable tile and try to relocate
    if (!isWalkable(l.x, l.y)) {
      let relocated = false;
      // Try to find nearby walkable position
      for (let radius = TILE; radius <= TILE * 3 && !relocated; radius += TILE) {
        for (let angle = 0; angle < Math.PI * 2; angle += Math.PI / 6) {
          const testX = l.x + Math.cos(angle) * radius;
          const testY = l.y + Math.sin(angle) * radius;
          if (isWalkable(testX, testY)) {
            l.x = testX;
            l.y = testY;
            relocated = true;
            break;
          }
        }
      }
      // If still can't relocate, remove the loot
      if (!relocated) {
        loot.splice(i, 1);
        i--;
        continue;
      }
    }
    
    const dist = Math.hypot(l.x - player.x, l.y - player.y);
    if (dist < TILE * 2) {
      pickupLoot(l);
    }
  }
  
  // Auto-enter exit portal when close and all rooms cleared
  // During Greater Rifts, portal leads to next floor of the same rift
  if (exitPos) {
    const exitDist = Math.hypot(exitPos.x - player.x, exitPos.y - player.y);
    const allCleared = map.rooms.every(r => r.cleared);
    const livingEnemies = enemies.filter(e => !e.dead).length;
    
    // Debug logging
    if (debugMode && frame % 60 === 0) {
      console.log(`Portal check: dist=${exitDist.toFixed(0)}, cleared=${allCleared}, entering=${enteringPortal}, enemies=${livingEnemies}`);
    }
    
    // ULTRA AGGRESSIVE: If literally standing on portal (< 20px), force enter NOW
    if (exitDist < 20 && !enteringPortal) {
      console.log('ULTRA FORCE ENTERING PORTAL (on portal)!');
      addLog('Entering portal...', 'skill');
      // Mark all rooms cleared to prevent any blocking
      map.rooms.forEach(r => r.cleared = true);
      enteringPortal = true;
      if (!greaterRiftActive) dungeon.level++;
      path = [];
      particles = [];
      skillProjectiles = [];
      damageNumbers = [];
      cycloneActive = false;
      cycloneTimer = 0;
      player.state = 'idle';
      setTimeout(() => {
        generateDungeon();
        camera.x = player.x;
        camera.y = player.y;
        camera.shake = 0;
        enteringPortal = false;
        // Greater Rifts don't spawn new enemies on floor transitions - fixed enemy pool
      }, 100);
      return;
    }
    
    // Force-clear portal room if player is there and no living enemies nearby
    if (exitDist < TILE * 3) {
      const portalRoom = map.rooms[map.rooms.length - 1];
      if (!portalRoom.cleared) {
        const enemiesInPortalRoom = enemies.filter(e => !e.dead && e.room === portalRoom);
        if (enemiesInPortalRoom.length === 0) {
          portalRoom.cleared = true;
          addLog('Portal room force-cleared!', 'zone');
        }
      }
    }
    
    // If VERY close (within 1.5 tiles) AND no enemies left, enter regardless
    if (exitDist < TILE * 1.5 && livingEnemies === 0 && !enteringPortal) {
      console.log('FORCE ENTERING PORTAL (very close, no enemies)!');
      addLog('Entering portal...', 'skill');
      enteringPortal = true;
      if (!greaterRiftActive) dungeon.level++;
      path = [];
      particles = [];
      skillProjectiles = [];
      damageNumbers = [];
      cycloneActive = false;
      cycloneTimer = 0;
      player.state = 'idle';
      setTimeout(() => {
        generateDungeon();
        camera.x = player.x;
        camera.y = player.y;
        camera.shake = 0;
        enteringPortal = false;
        // Greater Rifts don't spawn new enemies on floor transitions - fixed enemy pool
      }, 100);
      return;
    }
    
    // Normal entry at 4 tile range when all cleared
    if (allCleared && exitDist < TILE * 4 && !enteringPortal) {
      console.log('ENTERING PORTAL!');
      enteringPortal = true;
      if (!greaterRiftActive) {
        dungeon.level++;
        addLog(`Entering level ${dungeon.level}...`, 'skill');
      } else {
        addLog(`Entering next rift floor...`, 'skill');
      }
      path = [];
      particles = [];
      skillProjectiles = [];
      damageNumbers = [];
      cycloneActive = false;
      cycloneTimer = 0;
      player.state = 'idle';
      setTimeout(() => {
        generateDungeon();
        camera.x = player.x;
        camera.y = player.y;
        camera.shake = 0;
        enteringPortal = false;
        // Greater Rifts don't spawn new enemies on floor transitions - fixed enemy pool
      }, 100);
      return;
    }
  }
  
  // ═══════════════════════════════════════════════════════════════════════════
  // POSITION-BASED STUCK DETECTION
  // Track actual player position changes, not just whether a move was attempted
  // ═══════════════════════════════════════════════════════════════════════════
  if (!window.positionHistory) window.positionHistory = [];
  if (!window.lastStuckCheck) window.lastStuckCheck = 0;
  
  window.positionHistory.push({ x: player.x, y: player.y, t: performance.now() });
  if (window.positionHistory.length > 90) window.positionHistory.shift(); // Keep ~1.5 seconds
  
  // Check every 30 frames (~0.5 seconds)
  if (window.positionHistory.length >= 30 && frame % 30 === 0) {
    const oldest = window.positionHistory[0];
    const newest = window.positionHistory[window.positionHistory.length - 1];
    const totalMovement = Math.hypot(newest.x - oldest.x, newest.y - oldest.y);
    const timeSpan = newest.t - oldest.t;
    
    // If player hasn't moved more than 10 pixels in the last ~1 second, they're stuck
    if (totalMovement < 10 && timeSpan > 800 && player.state === 'moving') {
      window.lastStuckCheck++;
      
      // After 3 stuck checks (~1.5 seconds of being stuck), force escape
      if (window.lastStuckCheck >= 3) {
        console.log('STUCK DETECTED - forcing escape teleport');
        addLog('Stuck! Teleporting to safety...', 'system');
        
        // Find nearest walkable tile at increasing distances
        let escaped = false;
        for (let r = 2; r <= 8 && !escaped; r++) {
          for (let a = 0; a < 16 && !escaped; a++) {
            const angle = a * Math.PI / 8;
            const tx = player.x + Math.cos(angle) * TILE * r;
            const ty = player.y + Math.sin(angle) * TILE * r;
            if (canMoveTo(tx, ty)) {
              player.x = tx;
              player.y = ty;
              escaped = true;
            }
          }
        }
        
        // If still stuck, teleport toward center of current room
        if (!escaped && map && map.rooms) {
          const currentRoom = map.rooms.find(room => {
            return player.x >= room.x * TILE && player.x < (room.x + room.w) * TILE &&
                   player.y >= room.y * TILE && player.y < (room.y + room.h) * TILE;
          });
          if (currentRoom) {
            const centerX = (currentRoom.x + currentRoom.w / 2) * TILE;
            const centerY = (currentRoom.y + currentRoom.h / 2) * TILE;
            if (canMoveTo(centerX, centerY)) {
              player.x = centerX;
              player.y = centerY;
              escaped = true;
            }
          }
        }
        
        // Reset all stuck-related state
        window.positionHistory = [];
        window.lastStuckCheck = 0;
        window.pathFailCount = 0;
        path = [];
        pathTarget = null;
        pathTimer = 0;
        
        // Clear any unreachable flags - give everything another try
        enemies.forEach(e => {
          e.unreachable = false;
          e.pathFailCount = 0;
          e.altTargetTried = false;
        });
      }
    } else {
      // Player is moving, reset stuck counter
      window.lastStuckCheck = 0;
    }
  }
  
  // Find target (enemies first, then loot, then explore/exit)
  let targetX, targetY, targetType, targetObj;
  
  // Check for enemies - include "unreachable" ones if they're close enough to attack
  const isRangedClass = player.class === 'ranger' || player.class === 'mage';
  const attackRange = isRangedClass ? TILE * 8 : (player.class === 'monk') ? TILE * 4 : TILE * 1.5;
  
  // ECHO DOMAIN: Always include all enemies (small arena, direct movement)
  let active;
  if (echoDomainActive) {
    active = enemies.filter(e => e.active && !e.dead && e.hp > 0);
    // Clear any unreachable flags for domain enemies
    active.forEach(e => {
      e.unreachable = false;
      e.pathFailCount = 0;
    });
  } else {
    // First try: enemies that aren't unreachable
    active = enemies.filter(e => e.active && !e.dead && !e.unreachable);
    
    // If no reachable enemies, check if any "unreachable" enemies are actually within attack range
    if (active.length === 0) {
      const closeUnreachable = enemies.filter(e => {
        if (!e.active || e.dead) return false;
        const dist = Math.hypot(e.x - player.x, e.y - player.y);
        return dist < attackRange; // Include if within attack range even if marked unreachable
      });
      if (closeUnreachable.length > 0) {
        active = closeUnreachable;
        // Clear unreachable flag for these - we can actually attack them!
        closeUnreachable.forEach(e => {
          e.unreachable = false;
          e.pathFailCount = 0;
        });
      }
    }
  }
  
  if (active.length > 0) {
    active.sort((a, b) => Math.hypot(a.x - player.x, a.y - player.y) - Math.hypot(b.x - player.x, b.y - player.y));
    targetObj = active[0];
    targetX = targetObj.x;
    targetY = targetObj.y;
    targetType = 'enemy';
    
    // FROZEN CHECK: Player can't act while frozen
    if (player.frozen > 0) {
      player.state = 'idle';
      // Still allow facing the enemy
      if (targetObj) player.facing = targetObj.x > player.x ? 1 : -1;
      // Skip all combat/movement AI
    } else {
    // BEGIN UNFROZEN PLAYER AI
    
    const currentDist = Math.hypot(targetX - player.x, targetY - player.y);
    
    // PRIORITY CHECK: If ANY enemy is within attack range, reset path commitment
    // This ensures we fight enemies we encounter instead of walking past them
    const primarySkillRange = SKILLS[equippedSkills[0]]?.engageRange || TILE * 1.5;
    const immediateAttackRange = isRangedClass ? TILE * 8 : primarySkillRange;
    
    if (currentDist <= immediateAttackRange) {
      // Enemy in range! Clear path and attack immediately
      window.pathCommitment = 0;
      path = [];
    }
    
    // Flag to skip complex AI when using simpler echo domain movement
    let skipRestOfPlayerAI = false;
    
    // ECHO DOMAIN: Small arena - use direct movement, skip pathfinding
    if (echoDomainActive && !window.fightingOverlord) {
      // Use primary skill's engage range for melee classes
      const isRangedEcho = player.class === 'ranger' || player.class === 'mage';
      const primarySkill = SKILLS[equippedSkills[0]];
      const attackRange = isRangedEcho ? TILE * 8 : 
                          (primarySkill?.engageRange || TILE * 1.2);
      
      if (currentDist <= attackRange) {
        // In range - use skill system!
        player.state = 'attacking';
        player.facing = targetObj.x > player.x ? 1 : -1;
        
        // Use primary skill (this triggers Fists of Thunder's dash, etc.)
        if (canUseSkill(equippedSkills[0])) {
          useSkillSlot(0);
        }
      } else {
        // Move directly toward enemy - arena is open
        player.state = 'moving';
        const angle = Math.atan2(targetY - player.y, targetX - player.x);
        const moveSpeed = player.speed * dt;
        const nx = player.x + Math.cos(angle) * moveSpeed;
        const ny = player.y + Math.sin(angle) * moveSpeed;
        
        if (canMoveTo(nx, ny)) {
          player.x = nx;
          player.y = ny;
        } else if (canMoveTo(nx, player.y)) {
          player.x = nx;
        } else if (canMoveTo(player.x, ny)) {
          player.y = ny;
        }
        player.facing = Math.cos(angle) >= 0 ? 1 : -1;
      }
      
      // Skip the rest of the player AI loop for domain (but DON'T exit update - enemies need to move!)
      pathTimer--;
      skipRestOfPlayerAI = true;
    }
    
    // IN RIFT: Be aggressive! Chase enemies, don't wait passively
    // Enemies are fast (1.85x) so meet them halfway
    if (!skipRestOfPlayerAI && riftSurgeActive && currentDist > TILE * 8) {
      // Check if there's a closer enemy we should focus on first
      const closerEnemy = active.find(e => Math.hypot(e.x - player.x, e.y - player.y) <= TILE * 8);
      if (closerEnemy) {
        targetObj = closerEnemy;
        targetX = closerEnemy.x;
        targetY = closerEnemy.y;
      }
      // Otherwise keep chasing the nearest enemy - don't wait!
    }
    
    // Skip remaining player AI if we already handled movement (echo domain)
    if (!skipRestOfPlayerAI) {
    
    // AGGRESSIVE ENGAGEMENT for melee classes
    // When enemies are within engagement range, speed up pathfinding and try direct movement
    const engagementRange = isRangedClass ? TILE * 10 : TILE * 5; // Melee engages within 5 tiles
    
    if (!isRangedClass && currentDist < engagementRange && currentDist > attackRange) {
      // Enemy is close but not in melee range - be aggressive!
      // Speed up pathfinding when enemies are nearby
      if (pathTimer > 15) pathTimer = 15; // Recalc path more frequently
      
      // If no path or path is empty, try direct movement toward enemy
      if (path.length === 0) {
        const angle = Math.atan2(targetY - player.y, targetX - player.x);
        const moveSpeed = player.speed * dt;
        const nx = player.x + Math.cos(angle) * moveSpeed;
        const ny = player.y + Math.sin(angle) * moveSpeed;
        
        // Try to move directly toward enemy
        if (canMoveTo(nx, ny)) {
          player.x = nx;
          player.y = ny;
          player.state = 'moving';
          player.facing = targetX > player.x ? 1 : -1;
        } else if (canMoveTo(nx, player.y)) {
          player.x = nx;
          player.state = 'moving';
          player.facing = targetX > player.x ? 1 : -1;
        } else if (canMoveTo(player.x, ny)) {
          player.y = ny;
          player.state = 'moving';
        } else {
          // Blocked - try diagonal approaches
          const diagAngles = [angle + Math.PI/4, angle - Math.PI/4, angle + Math.PI/6, angle - Math.PI/6];
          for (const diagAngle of diagAngles) {
            const dx = player.x + Math.cos(diagAngle) * moveSpeed;
            const dy = player.y + Math.sin(diagAngle) * moveSpeed;
            if (canMoveTo(dx, dy)) {
              player.x = dx;
              player.y = dy;
              player.state = 'moving';
              break;
            }
          }
        }
      }
    }
    
    // Track distance progress to this enemy - BUT only for detecting truly stuck situations
    // Only track "no progress" if we're NOT in attack range
    // Ranged classes in attack range are supposed to maintain distance, not close it
    if (currentDist > attackRange) {
      if (!window.targetDistHistory) window.targetDistHistory = [];
      if (!window.lastTargetId) window.lastTargetId = null;
      
      // Reset if target changed (with null check)
      if (targetObj && window.lastTargetId !== targetObj.id) {
        window.targetDistHistory = [];
        window.lastTargetId = targetObj.id;
      }
      
      if (!targetObj) {
        // No target - skip distance tracking
        window.targetDistHistory = [];
      } else {
        window.targetDistHistory.push(currentDist);
        if (window.targetDistHistory.length > 20) window.targetDistHistory.shift();
        
        // Check if we're not making progress toward this enemy (after 20 samples = ~2 seconds)
        if (window.targetDistHistory.length >= 20) {
          const firstHalf = window.targetDistHistory.slice(0, 10);
          const secondHalf = window.targetDistHistory.slice(10);
          const firstAvg = firstHalf.reduce((a, b) => a + b, 0) / firstHalf.length;
          const secondAvg = secondHalf.reduce((a, b) => a + b, 0) / secondHalf.length;
          
          // If distance hasn't decreased significantly, enemy is problematic
          if (secondAvg >= firstAvg - TILE) {
            targetObj.pathFailCount = (targetObj.pathFailCount || 0) + 3;
            if (targetObj.pathFailCount > 5) {
              targetObj.unreachable = true;
              addLog('Enemy unreachable - skipping', 'system');
              window.targetDistHistory = [];
              // Re-find target without this enemy
              const newActive = active.filter(e => e !== targetObj && !e.unreachable);
              if (newActive.length > 0) {
                targetObj = newActive[0];
                targetX = targetObj.x;
                targetY = targetObj.y;
                window.lastTargetId = targetObj.id;
              } else {
                // No more reachable enemies - fall through to loot or explore
                targetType = null;
                targetObj = null;
              }
            }
          }
        }
      }
    } else {
      // In attack range - reset the distance tracking since we're in combat
      window.targetDistHistory = [];
    }
    } // End of !skipRestOfPlayerAI - combat code done
    } // End of frozen check - player can act
  } // End of active.length > 0 - enemy targeting done
  
  // If no enemy target (or all unreachable), try loot
  // BUT skip loot during rift surge - focus on killing!
  if (!targetType && loot.length > 0 && !riftSurgeActive) {
    // No enemies - go pick up loot!
    const sortedLoot = [...loot].sort((a, b) => {
      // Prioritize by rarity (unique > rare > magic > normal) then by distance
      const rarityOrder = { unique: 0, rare: 1, magic: 2, normal: 3 };
      const rarityDiff = rarityOrder[a.rarity] - rarityOrder[b.rarity];
      if (rarityDiff !== 0) return rarityDiff;
      return Math.hypot(a.x - player.x, a.y - player.y) - Math.hypot(b.x - player.x, b.y - player.y);
    });
    const nearestLoot = sortedLoot[0];
    targetX = nearestLoot.x;
    targetY = nearestLoot.y;
    targetType = 'loot';
    targetObj = nearestLoot;
  }
  
  // If still no target, explore or exit
  // In rift surge, move forward to find more enemies instead of exiting
  if (!targetType) {
    if (riftSurgeActive) {
      // In rift: only advance if truly no active enemies nearby
      const nearbyRiftEnemies = enemies.filter(e => 
        e.isRift && !e.dead && e.hp > 0 && 
        Math.hypot(e.x - player.x, e.y - player.y) < TILE * 20
      );
      
      if (nearbyRiftEnemies.length === 0) {
        // No enemies nearby - advance to find more
        targetX = player.x + TILE * 5;
        targetY = player.y;
        targetType = 'rift_advance';
      } else {
        // Move toward nearest enemy - be aggressive!
        const nearest = nearbyRiftEnemies.sort((a, b) => 
          Math.hypot(a.x - player.x, a.y - player.y) - Math.hypot(b.x - player.x, b.y - player.y)
        )[0];
        targetX = nearest.x;
        targetY = nearest.y;
        targetType = 'enemy';
      }
    } else {
      const allCleared = map.rooms.every(r => r.cleared);
      if (allCleared && exitPos) {
        targetX = exitPos.x;
        targetY = exitPos.y;
        targetType = 'exit';
      } else {
        const uncleared = map.rooms.filter(r => !r.cleared).sort((a, b) => {
          const da = Math.hypot((a.x + a.w/2) * TILE - player.x, (a.y + a.h/2) * TILE - player.y);
          const db = Math.hypot((b.x + b.w/2) * TILE - player.x, (b.y + b.h/2) * TILE - player.y);
          return da - db;
        });
        if (uncleared.length > 0) {
          const room = uncleared[0];
          targetX = (room.x + room.w / 2) * TILE;
          targetY = (room.y + room.h / 2) * TILE;
          targetType = 'explore';
        }
      }
    }
  }
  
  // Pathfinding
  if (targetX !== undefined) {
    const key = `${Math.floor(targetX / TILE)},${Math.floor(targetY / TILE)}`;
    
    // Path commitment - prevent recalculating too frequently when we have a valid path
    // This prevents oscillation when pathing around obstacles
    if (!window.pathCommitment) window.pathCommitment = 0;
    
    // Only recalculate if:
    // 1. No path exists
    // 2. Timer expired AND commitment is 0
    // 3. We've consumed enough waypoints (commitment is 0)
    const shouldRecalc = path.length === 0 || 
                         (pathTimer <= 0 && window.pathCommitment <= 0) ||
                         (pathTarget !== key && window.pathCommitment <= 0);
    
    if (shouldRecalc) {
      const newPath = findPath(player.x, player.y, targetX, targetY);
      
      // Only take new path if it's valid or we have no path
      if (newPath.length > 0 || path.length === 0) {
        path = newPath;
        pathTarget = key;
        pathTimer = 60;
        // Commit to following at least 5 waypoints before allowing recalc
        window.pathCommitment = Math.min(5, path.length);
      }
      
      // If path is very long for exploration, try a closer room
      if (path.length > 20 && targetType === 'explore') {
        const uncleared = map.rooms.filter(r => !r.cleared);
        for (const room of uncleared) {
          const altX = (room.x + room.w / 2) * TILE;
          const altY = (room.y + room.h / 2) * TILE;
          const altPath = findPath(player.x, player.y, altX, altY);
          if (altPath.length > 0 && altPath.length < path.length) {
            path = altPath;
            targetX = altX;
            targetY = altY;
          }
        }
      }
      
      // If pathfinding failed, try alternate targets
      if (path.length === 0 && targetType === 'explore') {
        // Try other uncleared rooms
        const uncleared = map.rooms.filter(r => !r.cleared);
        for (const room of uncleared) {
          const altX = (room.x + room.w / 2) * TILE;
          const altY = (room.y + room.h / 2) * TILE;
          const altPath = findPath(player.x, player.y, altX, altY);
          if (altPath.length > 0) {
            path = altPath;
            targetX = altX;
            targetY = altY;
            break;
          }
        }
        
        // Still no path? Try finding nearest active enemy
        if (path.length === 0) {
          const nearestEnemy = enemies.find(e => !e.dead);
          if (nearestEnemy) {
            path = findPath(player.x, player.y, nearestEnemy.x, nearestEnemy.y);
            if (path.length > 0) {
              targetX = nearestEnemy.x;
              targetY = nearestEnemy.y;
              targetType = 'enemy';
              targetObj = nearestEnemy;
            }
          }
        }
      }
      
      // If pathfinding failed for an ENEMY, try other enemies or mark as unreachable
      if (path.length === 0 && targetType === 'enemy') {
        const distToEnemy = Math.hypot(targetX - player.x, targetY - player.y);
        
        // EMERGENCY: If we're very close but path failed, don't mark as unreachable
        // Just try to move/attack directly
        if (distToEnemy < TILE * 3) {
          // We're close enough - skip pathfinding and handle in movement section
          // Don't increment fail count for close enemies
        } else {
          // Try to find a walkable spot near the enemy
          if (targetObj && !targetObj.altTargetTried) {
            for (let r = 1; r <= 3; r++) {
              for (let a = 0; a < 8; a++) {
                const angle = a * Math.PI / 4;
                const altX = targetObj.x + Math.cos(angle) * TILE * r;
                const altY = targetObj.y + Math.sin(angle) * TILE * r;
                const altPath = findPath(player.x, player.y, altX, altY);
                if (altPath.length > 0) {
                  path = altPath;
                  // Don't change targetX/Y so we still target the enemy for combat
                  targetObj.altTargetTried = true;
                  break;
                }
              }
              if (path.length > 0) break;
            }
          }
          
          // If still no path, mark this enemy as having failed pathfinding
          if (path.length === 0 && targetObj) {
            targetObj.pathFailCount = (targetObj.pathFailCount || 0) + 1;
            
            // If pathfinding failed too many times, mark enemy as unreachable
            if (targetObj.pathFailCount > 5) {
              targetObj.unreachable = true;
            }
          
            // Try other active enemies
            const otherEnemies = active.filter(e => e !== targetObj && !e.unreachable);
            for (const enemy of otherEnemies) {
              const altPath = findPath(player.x, player.y, enemy.x, enemy.y);
              if (altPath.length > 0) {
                path = altPath;
                targetX = enemy.x;
                targetY = enemy.y;
                targetObj = enemy;
                break;
              } else {
                enemy.pathFailCount = (enemy.pathFailCount || 0) + 1;
                if (enemy.pathFailCount > 5) {
                  enemy.unreachable = true;
                }
              }
            }
          }
        }
        
        // If ALL enemies are unreachable, just kill them (they're stuck in walls)
        if (path.length === 0 && active.every(e => e.unreachable || e.pathFailCount > 3)) {
          active.forEach(e => {
            if (e.unreachable || e.pathFailCount > 3) {
              e.dead = true; // Kill stuck enemies
              e.hp = 0;
            }
          });
          // Try to find loot or explore instead
          if (loot.length > 0) {
            const nearestLoot = loot[0];
            targetX = nearestLoot.x;
            targetY = nearestLoot.y;
            targetType = 'loot';
            targetObj = nearestLoot;
            path = findPath(player.x, player.y, targetX, targetY);
          }
        }
      }
    }
  }
  
  // Movement
  if (targetX !== undefined) {
    const dist = Math.hypot(targetX - player.x, targetY - player.y);
    
    // Ranged classes attack from distance, melee classes use primary skill's engage range
    const isRanged = player.class === 'ranger' || player.class === 'mage';
    const primarySkillForRange = SKILLS[equippedSkills[0]];
    const attackRange = isRanged ? TILE * 8 : (primarySkillForRange?.engageRange || TILE * 1.2);
    const kiteRange = TILE * 3.5; // Ranged classes try to stay at least this far from enemies
    
    // Check if we can attack
    let canAttack = false;
    let shouldKite = false;
    
    if (targetType === 'enemy' && dist < attackRange && !testMode && targetObj) {
      if (isRanged) {
        // Ranged attack - need LOS (or be very close)
        const hasLOS = hasLineOfSight(player.x, player.y, targetObj.x, targetObj.y);
        if (hasLOS || dist < TILE * 1.5) {
          player.state = 'attacking';
          player.facing = targetObj.x > player.x ? 1 : -1;
          
          // Use the direct rangedAttack function with the target
          rangedAttack(targetObj);
          canAttack = true;
          
          // If enemy is too close, kite away while attacking
          if (dist < kiteRange) {
            shouldKite = true;
          }
        }
        // If no LOS and not very close, canAttack stays false - keep moving toward target
      } else {
        // Melee attack handling - use skill system for primary attacks
        const meleeRange = TILE * 1.2;
        const primarySkill = SKILLS[equippedSkills[0]];
        const engageRange = primarySkill?.engageRange || meleeRange;
        
        // Use primary skill which handles its own dash/leap mechanics
        if (dist <= engageRange && canUseSkill(equippedSkills[0])) {
          player.state = 'attacking';
          player.facing = targetObj.x > player.x ? 1 : -1;
          
          // Use primary skill - this triggers Fists of Thunder's dash, Basic Slash, etc.
          useSkillSlot(0);
          path = [];
          canAttack = true;
        } else if (dist < meleeRange && player.atkCD <= 0) {
          // Fallback: if in melee range but skill on CD, use basic attack
          player.state = 'attacking';
          player.facing = targetObj.x > player.x ? 1 : -1;
          attack(targetObj);
          path = [];
          canAttack = true;
        }
      }
    }
    
    // PROXIMITY ATTACK - For melee classes, always check if ANY enemy is in engage range
    // This catches cases where the targeted enemy is far but another enemy is right next to us
    if (!canAttack && !isRanged) {
      const primarySkill = SKILLS[equippedSkills[0]];
      const engageRange = primarySkill?.engageRange || (TILE * 1.3);
      const meleeEnemy = enemies.find(e => !e.dead && e.active && Math.hypot(e.x - player.x, e.y - player.y) < engageRange);
      if (meleeEnemy && canUseSkill(equippedSkills[0])) {
        player.state = 'attacking';
        player.facing = meleeEnemy.x > player.x ? 1 : -1;
        useSkillSlot(0);
        canAttack = true;
      }
    }
    
    // Kiting logic for ranged classes
    // Disable kiting temporarily if we've been stuck (kite oscillation prevention)
    if (!window.kiteStuckCount) window.kiteStuckCount = 0;
    if (!window.cornerEscapeMode) window.cornerEscapeMode = false;
    
    // After being stuck for a while, enter corner escape mode
    if (window.kiteStuckCount > 15) {
      window.cornerEscapeMode = true;
    }
    
    // Exit corner escape mode once we've moved successfully for a bit
    if (!shouldKite || window.kiteStuckCount === 0) {
      window.cornerEscapeMode = false;
    }
    
    const kiteDisabled = window.kiteStuckCount > 60; // After ~1 sec of failed kiting, give up entirely
    
    // Reset kite stuck counter when kiting is not needed
    if (!shouldKite) {
      window.kiteStuckCount = 0;
    }
    
    if (shouldKite && isRanged && targetType === 'enemy' && !kiteDisabled) {
      // Move away from the enemy
      const awayAngle = Math.atan2(player.y - targetY, player.x - targetX);
      const moveSpeed = player.speed * dt;
      
      // Try to move directly away first
      const kiteX = player.x + Math.cos(awayAngle) * moveSpeed;
      const kiteY = player.y + Math.sin(awayAngle) * moveSpeed;
      
      let moved = false;
      
      // Check if direct retreat is blocked
      const directBlocked = !canMoveTo(kiteX, kiteY);
      
      if (!directBlocked) {
        player.x = kiteX;
        player.y = kiteY;
        moved = true;
      } else {
        // Direct retreat blocked - prioritize wall-sliding!
        // Try perpendicular movement first (sliding along walls)
        // Remember last successful slide direction to avoid oscillation
        if (!window.lastSlideDir) window.lastSlideDir = 1;
        
        const perpAngles = [
          awayAngle + Math.PI/2 * window.lastSlideDir,   // Preferred perpendicular
          awayAngle - Math.PI/2 * window.lastSlideDir,   // Other perpendicular
        ];
        
        // First: Try pure perpendicular (wall sliding) - allow moving toward enemy!
        for (const angle of perpAngles) {
          const slideX = player.x + Math.cos(angle) * moveSpeed;
          const slideY = player.y + Math.sin(angle) * moveSpeed;
          if (canMoveTo(slideX, slideY)) {
            player.x = slideX;
            player.y = slideY;
            moved = true;
            // Remember which direction worked
            window.lastSlideDir = (angle === perpAngles[0]) ? window.lastSlideDir : -window.lastSlideDir;
            window.kiteStuckCount = Math.max(0, window.kiteStuckCount - 2);
            break;
          }
        }
        
        // Second: Try diagonal retreats if perpendicular blocked
        if (!moved) {
          const diagAngles = [
            awayAngle + Math.PI/4,      // 45° left
            awayAngle - Math.PI/4,      // 45° right
            awayAngle + Math.PI/3,      // 60° left
            awayAngle - Math.PI/3,      // 60° right
          ];
          
          for (const angle of diagAngles) {
            const diagX = player.x + Math.cos(angle) * moveSpeed;
            const diagY = player.y + Math.sin(angle) * moveSpeed;
            if (canMoveTo(diagX, diagY)) {
              const newDist = Math.hypot(diagX - targetX, diagY - targetY);
              const oldDist = Math.hypot(player.x - targetX, player.y - targetY);
              // Allow some distance decrease for diagonal escape
              if (newDist >= oldDist - TILE * 0.5) {
                player.x = diagX;
                player.y = diagY;
                moved = true;
                window.kiteStuckCount = Math.max(0, window.kiteStuckCount - 1);
                break;
              }
            }
          }
        }
        
        // Third: Try single-axis slide (axis-aligned wall sliding)
        if (!moved) {
          if (canMoveTo(kiteX, player.y)) {
            player.x = kiteX;
            moved = true;
          } else if (canMoveTo(player.x, kiteY)) {
            player.y = kiteY;
            moved = true;
          }
        }
      }
      
      // Track kite-stuck to prevent infinite corner oscillation
      if (!window.kiteStuckCount) window.kiteStuckCount = 0;
      
      // If still blocked, try more aggressive escape angles
      if (!moved) {
        // In corner escape mode, be more aggressive about finding ANY escape route
        // Try multiple angles in order of preference: perpendicular, then diagonal
        const escapeAngles = [
          awayAngle + Math.PI*2/3,    // 120° left (angled retreat)
          awayAngle - Math.PI*2/3,    // 120° right (angled retreat)
          awayAngle + Math.PI*3/4,    // 135° left (almost forward)
          awayAngle - Math.PI*3/4,    // 135° right (almost forward)
          awayAngle + Math.PI,        // Toward enemy (last resort corner escape)
        ];
        
        // Try each escape angle
        for (const angle of escapeAngles) {
          const altX = player.x + Math.cos(angle) * moveSpeed;
          const altY = player.y + Math.sin(angle) * moveSpeed;
          if (canMoveTo(altX, altY)) {
            const newDist = Math.hypot(altX - targetX, altY - targetY);
            const oldDist = Math.hypot(player.x - targetX, player.y - targetY);
            
            // In corner escape mode, allow ANY movement that gets us out
            // Otherwise, only allow movement that doesn't decrease distance much
            const allowedDistDecrease = window.cornerEscapeMode ? TILE * 2 : TILE * 0.3;
            
            if (newDist >= oldDist - allowedDistDecrease) {
              player.x = altX;
              player.y = altY;
              moved = true;
              window.kiteStuckCount = Math.max(0, window.kiteStuckCount - 2);
              break;
            }
          }
        }
        
        // CORNER ESCAPE: If still stuck and in escape mode, try to path AROUND the obstacle
        if (!moved && window.cornerEscapeMode) {
          // Find the nearest open space that's further from enemy
          const searchDist = TILE * 4;
          let bestEscape = null;
          let bestScore = -Infinity;
          
          for (let angle = 0; angle < Math.PI * 2; angle += Math.PI / 12) {
            for (let dist = TILE; dist <= searchDist; dist += TILE) {
              const testX = player.x + Math.cos(angle) * dist;
              const testY = player.y + Math.sin(angle) * dist;
              
              if (canMoveTo(testX, testY)) {
                const enemyDist = Math.hypot(testX - targetX, testY - targetY);
                // Score based on distance from enemy and how reachable it is
                const score = enemyDist - dist * 0.3; // Prefer closer spots that are far from enemy
                
                if (score > bestScore) {
                  bestScore = score;
                  bestEscape = { x: testX, y: testY, angle };
                }
              }
            }
          }
          
          // If we found an escape point, move toward it
          if (bestEscape) {
            const escapeAngle = Math.atan2(bestEscape.y - player.y, bestEscape.x - player.x);
            const escapeX = player.x + Math.cos(escapeAngle) * moveSpeed;
            const escapeY = player.y + Math.sin(escapeAngle) * moveSpeed;
            
            if (canMoveTo(escapeX, escapeY)) {
              player.x = escapeX;
              player.y = escapeY;
              moved = true;
              window.kiteStuckCount = Math.max(0, window.kiteStuckCount - 1);
            }
          }
        }
      }
      
      // Update stuck counter based on movement result
      if (moved) {
        window.kiteStuckCount = 0;  // Reset when we successfully moved
      } else {
        window.kiteStuckCount++;  // Increment when stuck
      }
      
      // If still cornered and we have a movement ability (monk dash), use it to escape
      // Check cooldown to prevent spam (3 second cooldown = ~180 frames at 60fps)
      if (!moved && player.class === 'monk' && player.escapeDashCD <= 0) {
        // Monk can use their dash defensively to escape corners
        const dashDist = TILE * 2.5; // Escape dash distance
        
        // Try to find the best escape direction
        const escapeDirections = [];
        for (let angle = 0; angle < Math.PI * 2; angle += Math.PI / 8) {
          const testX = player.x + Math.cos(angle) * dashDist;
          const testY = player.y + Math.sin(angle) * dashDist;
          
          // Check if destination is valid
          if (canMoveTo(testX, testY)) {
            const distFromEnemy = Math.hypot(testX - targetX, testY - targetY);
            escapeDirections.push({ angle, x: testX, y: testY, dist: distFromEnemy });
          }
        }
        
        // Pick the direction that gets us furthest from the enemy
        if (escapeDirections.length > 0) {
          escapeDirections.sort((a, b) => b.dist - a.dist);
          const best = escapeDirections[0];
          
          // Only dash if it significantly increases distance
          const currentDist = Math.hypot(player.x - targetX, player.y - targetY);
          if (best.dist > currentDist + TILE) {
            // Perform escape dash
            const oldX = player.x;
            const oldY = player.y;
            player.x = best.x;
            player.y = best.y;
            
            // Set cooldown (3 seconds)
            player.escapeDashCD = 3.0;
            
            // Dash trail particles
            const dashAngle = Math.atan2(best.y - oldY, best.x - oldX);
            for (let i = 0; i < 6; i++) {
              addParticle({
                x: oldX + Math.cos(dashAngle) * (i * dashDist / 6),
                y: oldY + Math.sin(dashAngle) * (i * dashDist / 6),
                vx: 0, vy: 0,
                life: 10 + i * 2,
                color: '#88ccff',
                size: 4 - i * 0.5
              });
            }
            moved = true;
          }
        }
      }
      
      // Clear path so we don't walk toward the enemy
      path = [];
      pathTarget = null;
    }
    
    // Only process movement if we're not actively attacking (and not kiting)
    if (!canAttack && !shouldKite) {
      if (targetType === 'loot' && dist < TILE * 2 && targetObj) {
        // Reached loot - pick it up
        pickupLoot(targetObj);
        path = [];
      } else if (targetType === 'exit' && dist < TILE * 3 && !enteringPortal) {
        enteringPortal = true;
        if (!greaterRiftActive) {
          dungeon.level++;
          addLog(`Entering level ${dungeon.level}...`, 'skill');
        } else {
          addLog(`Entering next rift floor...`, 'skill');
        }
        path = [];
        // Clear all active effects
        particles = [];
        skillProjectiles = [];
        damageNumbers = [];
        cycloneActive = false;
        cycloneTimer = 0;
        // Generate new dungeon after brief delay
        setTimeout(() => {
          generateDungeon();
          // Reset camera to player
          camera.x = player.x;
          camera.y = player.y;
          camera.shake = 0;
          enteringPortal = false;
          // Greater Rifts don't spawn new enemies on floor transitions - fixed enemy pool
        }, 100);
        return;
      } else if (path.length > 0) {
        player.state = 'moving';
        
        const wp = path[0];
        const wpDist = Math.hypot(wp.x - player.x, wp.y - player.y);
        
        if (wpDist < TILE * 0.3) {
          path.shift();
          window.wpStuckCount = 0;  // Reset stuck counter
          // Decrement commitment - only allow path recalc after consuming committed waypoints
          if (window.pathCommitment > 0) window.pathCommitment--;
        }
        
        if (path.length > 0) {
          const next = path[0];
          
          // Check if next waypoint is actually reachable (not through a wall) - every 5 frames
          if (frame % 5 === 0) {
            const distToWp = Math.hypot(next.x - player.x, next.y - player.y);
            if (distToWp > TILE * 0.5) {
              // Validate path to waypoint isn't blocked
              const checkSteps = Math.ceil(distToWp / (TILE * 0.3));
              let pathBlocked = false;
              for (let s = 1; s <= checkSteps && !pathBlocked; s++) {
                const t = s / checkSteps;
                const checkX = player.x + (next.x - player.x) * t;
                const checkY = player.y + (next.y - player.y) * t;
                if (!canMoveTo(checkX, checkY)) {
                  pathBlocked = true;
                }
              }
              
              // If path to waypoint is blocked, recalculate entire path
              if (pathBlocked) {
                path = [];
                pathTarget = null;
                pathTimer = 0;
                window.wpStuckCount = 0;
                window.wpSkipCount = 0;
              }
            }
          }
        }
        
        if (path.length > 0) {
          const next = path[0];
          const angle = Math.atan2(next.y - player.y, next.x - player.x);
          const moveSpeed = player.speed * dt;
          const nx = player.x + Math.cos(angle) * moveSpeed;
          const ny = player.y + Math.sin(angle) * moveSpeed;
          
          // Try to move, with wall sliding
          let didMove = false;
          if (canMoveTo(nx, ny)) {
            player.x = nx;
            player.y = ny;
            didMove = true;
          } else if (canMoveTo(nx, player.y)) {
            player.x = nx;
            didMove = true;
          } else if (canMoveTo(player.x, ny)) {
            player.y = ny;
            didMove = true;
          } else {
            // Try wall sliding - find a perpendicular direction we can move
            const slideAngle = findWallSlideDirection(player.x, player.y, angle);
            if (slideAngle !== null) {
              const slideX = player.x + Math.cos(slideAngle) * moveSpeed;
              const slideY = player.y + Math.sin(slideAngle) * moveSpeed;
              if (canMoveTo(slideX, slideY)) {
                player.x = slideX;
                player.y = slideY;
                didMove = true;
              }
            }
            
            // Still blocked? Try more aggressive alternatives
            if (!didMove) {
              const diagAngles = [angle + Math.PI/4, angle - Math.PI/4, angle + Math.PI/2, angle - Math.PI/2, angle + Math.PI*3/4, angle - Math.PI*3/4];
              for (const altAngle of diagAngles) {
                const altX = player.x + Math.cos(altAngle) * moveSpeed;
                const altY = player.y + Math.sin(altAngle) * moveSpeed;
                if (canMoveTo(altX, altY)) {
                  player.x = altX;
                  player.y = altY;
                  didMove = true;
                  break;
                }
              }
            }
          }
          
          // If we couldn't move toward the waypoint, it might be blocked
          if (!didMove) {
            // Try nudging away from walls first
            const nudgeResult = nudgeAwayFromWalls(player.x, player.y, 1.5);
            if (nudgeResult.nudged) {
              player.x = nudgeResult.x;
              player.y = nudgeResult.y;
              didMove = true;
            }
          }
          
          if (!didMove) {
            if (!window.wpStuckCount) window.wpStuckCount = 0;
            window.wpStuckCount++;
            
            // After being stuck on same waypoint for a while, skip it
            if (window.wpStuckCount > 10) {  // ~0.17 seconds - even faster skip
              path.shift();  // Skip this waypoint
              window.wpStuckCount = 0;
              window.wpSkipCount = (window.wpSkipCount || 0) + 1;
              
              // If skipping too many waypoints, recalculate entire path
              if (path.length === 0 || window.wpSkipCount > 3) {
                pathTimer = 0;
                pathTarget = null;
                window.wpSkipCount = 0;
                // Force immediate recalculation by clearing path
                path = [];
              }
            }
          } else {
            // Check if we're actually making progress toward the waypoint
            const newDistToWp = Math.hypot(next.x - player.x, next.y - player.y);
            const oldDistToWp = window.lastWpDist || newDistToWp;
            
            if (newDistToWp >= oldDistToWp - 0.5) {
              // Not making progress - increment stuck counter
              if (!window.wpNoProgress) window.wpNoProgress = 0;
              window.wpNoProgress++;
              
              if (window.wpNoProgress > 30) {  // ~0.5 seconds of no progress
                path.shift();  // Skip this waypoint
                window.wpNoProgress = 0;
                window.wpSkipCount = (window.wpSkipCount || 0) + 1;
                
                if (path.length === 0 || window.wpSkipCount > 3) {
                  pathTimer = 0;
                  pathTarget = null;
                  window.wpSkipCount = 0;
                  path = [];
                }
              }
            } else {
              window.wpNoProgress = 0;
            }
            window.lastWpDist = newDistToWp;
            window.wpStuckCount = 0;
          }
          
          player.facing = Math.cos(angle) >= 0 ? 1 : -1;
        }
      } else {
        // Fallback - pathfinding failed completely
        player.state = 'moving';
        const moveSpeed = player.speed * dt;
        let moved = false;
        
        // RIFT AGGRESSIVE MODE: Always move toward enemies or forward
        if (riftSurgeActive) {
          const riftEnemies = enemies.filter(e => e.isRift && !e.dead && e.hp > 0);
          if (riftEnemies.length > 0) {
            // Move directly toward nearest rift enemy
            riftEnemies.sort((a, b) => 
              Math.hypot(a.x - player.x, a.y - player.y) - Math.hypot(b.x - player.x, b.y - player.y)
            );
            const nearest = riftEnemies[0];
            const angle = Math.atan2(nearest.y - player.y, nearest.x - player.x);
            const nx = player.x + Math.cos(angle) * moveSpeed;
            const ny = player.y + Math.sin(angle) * moveSpeed;
            
            if (canMoveTo(nx, ny)) {
              player.x = nx;
              player.y = ny;
              moved = true;
            } else if (canMoveTo(nx, player.y)) {
              player.x = nx;
              moved = true;
            } else if (canMoveTo(player.x, ny)) {
              player.y = ny;
              moved = true;
            }
            player.facing = Math.cos(angle) >= 0 ? 1 : -1;
          }
          
          // If still not moving, advance forward in the rift corridor
          if (!moved) {
            const forwardX = player.x + moveSpeed * 1.5;
            if (canMoveTo(forwardX, player.y)) {
              player.x = forwardX;
              moved = true;
            } else {
              // Try slight up/down to navigate around obstacles
              for (let yOff = -TILE; yOff <= TILE; yOff += TILE/2) {
                if (canMoveTo(forwardX, player.y + yOff)) {
                  player.x = forwardX;
                  player.y = player.y + yOff * 0.3;
                  moved = true;
                  break;
                }
              }
            }
            player.facing = 1;
          }
        }
        
        // First, try to move directly toward target if we have one
        if (!moved && targetX !== undefined && targetY !== undefined) {
          const angle = Math.atan2(targetY - player.y, targetX - player.x);
          const nx = player.x + Math.cos(angle) * moveSpeed;
          const ny = player.y + Math.sin(angle) * moveSpeed;
          
          if (canMoveTo(nx, ny)) {
            player.x = nx;
            player.y = ny;
            player.facing = Math.cos(angle) >= 0 ? 1 : -1;
            moved = true;
          } else if (canMoveTo(nx, player.y)) {
            player.x = nx;
            player.facing = Math.cos(angle) >= 0 ? 1 : -1;
            moved = true;
          } else if (canMoveTo(player.x, ny)) {
            player.y = ny;
            moved = true;
          } else {
            // Try wall sliding
            const slideAngle = findWallSlideDirection(player.x, player.y, angle);
            if (slideAngle !== null) {
              const slideX = player.x + Math.cos(slideAngle) * moveSpeed;
              const slideY = player.y + Math.sin(slideAngle) * moveSpeed;
              if (canMoveTo(slideX, slideY)) {
                player.x = slideX;
                player.y = slideY;
                player.facing = Math.cos(slideAngle) >= 0 ? 1 : -1;
                moved = true;
              }
            }
          }
        }
        
        // If direct approach failed, try 8 directions
        if (!moved) {
          const baseAngle = targetX !== undefined ? 
            Math.atan2(targetY - player.y, targetX - player.x) : 
            Math.random() * Math.PI * 2;
          for (let i = 0; i < 8 && !moved; i++) {
            const angle = baseAngle + (i * Math.PI / 4);
            const nx = player.x + Math.cos(angle) * moveSpeed;
            const ny = player.y + Math.sin(angle) * moveSpeed;
            
            if (canMoveTo(nx, ny)) {
              player.x = nx;
              player.y = ny;
              player.facing = Math.cos(angle) >= 0 ? 1 : -1;
              moved = true;
            }
          }
        }
        
        // Track stuck time and force recalculation
        if (!moved) {
          if (!window.pathFailCount) window.pathFailCount = 0;
          window.pathFailCount++;
          
          // After being completely stuck for a while, try teleporting slightly
          if (window.pathFailCount > 15) {  // ~0.25 second - faster recovery
            let escaped = false;
            
            // Find nearest walkable tile - search 16 angles and up to 8 tile radii
            for (let r = 1; r <= 8 && !escaped; r++) {
              for (let a = 0; a < 16 && !escaped; a++) {
                const angle = a * Math.PI / 8;
                const tx = player.x + Math.cos(angle) * TILE * r;
                const ty = player.y + Math.sin(angle) * TILE * r;
                if (canMoveTo(tx, ty)) {
                  player.x = tx;
                  player.y = ty;
                  window.pathFailCount = 0;
                  pathTimer = 0;
                  pathTarget = null;
                  escaped = true;
                }
              }
            }
            
            // If still stuck, try room center
            if (!escaped && map && map.rooms) {
              const currentRoom = map.rooms.find(room => {
                return player.x >= room.x * TILE && player.x < (room.x + room.w) * TILE &&
                       player.y >= room.y * TILE && player.y < (room.y + room.h) * TILE;
              });
              if (currentRoom) {
                const centerX = (currentRoom.x + currentRoom.w / 2) * TILE;
                const centerY = (currentRoom.y + currentRoom.h / 2) * TILE;
                if (canMoveTo(centerX, centerY)) {
                  player.x = centerX;
                  player.y = centerY;
                  window.pathFailCount = 0;
                  escaped = true;
                }
              }
            }
            
            // If still stuck after searching, mark any targeted enemy as unreachable
            if (!escaped && targetType === 'enemy' && targetObj) {
              targetObj.unreachable = true;
              targetObj = null;
              targetType = null;
              targetX = undefined;
              targetY = undefined;
              window.pathFailCount = 0;
            }
          }
        } else {
          window.pathFailCount = 0;
        }
        
        pathTimer = 0;
        pathTarget = null;
      }
    } // End of !canAttack
  }
  
  // ANTI-IDLE FAILSAFE: If player is idle but there are active enemies nearby, something went wrong
  // Force immediate re-engagement
  if (player.state === 'idle') {
    const nearbyActiveEnemy = enemies.find(e => !e.dead && e.active && Math.hypot(e.x - player.x, e.y - player.y) < TILE * 8);
    if (nearbyActiveEnemy) {
      // Force path recalculation immediately
      pathTimer = 0;
      pathTarget = null;
      path = [];
      window.pathCommitment = 0;
      
      // For melee classes, try direct approach if close enough
      const distToEnemy = Math.hypot(nearbyActiveEnemy.x - player.x, nearbyActiveEnemy.y - player.y);
      if (!isRangedClass && distToEnemy < TILE * 4) {
        const angle = Math.atan2(nearbyActiveEnemy.y - player.y, nearbyActiveEnemy.x - player.x);
        const moveSpeed = player.speed * dt;
        const nx = player.x + Math.cos(angle) * moveSpeed;
        const ny = player.y + Math.sin(angle) * moveSpeed;
        if (canMoveTo(nx, ny)) {
          player.x = nx;
          player.y = ny;
          player.state = 'moving';
          player.facing = nearbyActiveEnemy.x > player.x ? 1 : -1;
        }
      }
    }
  }
  
  // Enemies
  for (let i = 0; i < enemies.length; i++) {
    const e = enemies[i];
    if (e.flash > 0) e.flash -= dt;
    if (e.atkCD > 0) e.atkCD -= dt;
    if (e.atkAnim > 0) e.atkAnim -= dt; // Attack animation decay
    if (e.leapCooldown > 0) e.leapCooldown -= window.deltaSeconds;  // Use real seconds
    if (!e.active) continue;
    
    const dist = Math.hypot(player.x - e.x, player.y - e.y);
    
    // Check for leap attack - enemies jump to close distance on ranged players
    if (e.canLeap && dist > TILE * 3 && dist < TILE * 7 && !e.leaping && (!e.leapCooldown || e.leapCooldown <= 0)) {
      // Random chance to initiate leap (increased for more reliable leaping)
      if (Math.random() < (e.leapChance || 0.03)) {
        // Calculate leap target - leap directly AT the player's current position
        const targetX = player.x;
        const targetY = player.y;
        
        // Only leap if target position is walkable
        if (isWalkable(targetX, targetY)) {
          e.leaping = true;
          e.leapProgress = 0;
          e.leapStartX = e.x;
          e.leapStartY = e.y;
          e.leapTargetX = targetX;
          e.leapTargetY = targetY;
          e.leapCooldown = 3.0 + Math.random() * 2.0; // 3-5 second cooldown
        }
      }
    }
    
    // Process leap animation
    if (e.leaping) {
      e.leapProgress += window.deltaSeconds * 5; // Leap speed (completes in ~0.2s)
      if (e.leapProgress >= 1) {
        // Leap complete
        e.leaping = false;
        // Final position - check if valid
        if (isWalkable(e.leapTargetX, e.leapTargetY)) {
          e.x = e.leapTargetX;
          e.y = e.leapTargetY;
          
          // LANDING DAMAGE - deal damage if landed close to player
          const landDist = Math.hypot(player.x - e.x, player.y - e.y);
          if (landDist < TILE * 2.5 && !playerDead && !testMode && !player.invulnerable) {
            // Deal 150% of normal damage on leap slam
            const baseDmg = e.dmg[0] + Math.floor(Math.random() * (e.dmg[1] - e.dmg[0]));
            const leapRaw = Math.floor(baseDmg * 1.5);
            
            // Apply dodge check using evasion formula
            const leapSettings = getDungeonSettings();
            const leapEnemyAccuracy = getEnemyAccuracy(e, leapSettings);
            let leapDodgeRating = player.dodgeRating || 0;
            if (player.blindingFlashDodge) {
              leapDodgeRating += player.blindingFlashDodge * 100;
            }
            const leapDodgeChance = calculateDodgeChance(leapDodgeRating, leapEnemyAccuracy);
            
            if (leapDodgeChance > 0 && Math.random() * 100 < leapDodgeChance) {
              showDamage(player.x, player.y - 25, 'DODGE', '#88ffff');
            } else {
              // Apply damage with defenses
              const damageInfo = e.damage || { physical: 0.5, element: 'fire', elemental: 0.5 };
              let physRatio = damageInfo.physical || 0.5;
              let elemRatio = damageInfo.elemental || 0.5;
              if (e.isBoss) { const shift = physRatio * 0.3; physRatio -= shift; elemRatio += shift; }
              
              const physPortion = leapRaw * physRatio;
              const elemPortion = leapRaw * elemRatio;
              const elem = damageInfo.element || 'fire';
              
              const armorRed = player.armor / (player.armor + physPortion * 5);
              const physDmg = Math.floor(physPortion * (1 - armorRed));
              
              let resist = 0;
              if (elem === 'fire') resist = Math.min(75, player.fireRes || 0);
              else if (elem === 'cold') resist = Math.min(75, player.coldRes || 0);
              else if (elem === 'lightning') resist = Math.min(75, player.lightRes || 0);
              else if (elem === 'nature') resist = Math.min(75, player.natureRes || 0);
              const elemDmg = Math.floor(elemPortion * (1 - resist / 100));
              
              let totalDmg = Math.max(1, physDmg + elemDmg);
              if (player.inSanctuary && player.innerSanctuary) {
                totalDmg = Math.floor(totalDmg * (1 - player.innerSanctuary.damageReduction));
              }
              
              player.shieldRechargeDelay = 2.0;
              let remaining = totalDmg;
              if (player.currentShield > 0) {
                const absorbed = Math.min(player.currentShield, remaining);
                player.currentShield -= absorbed;
                remaining -= absorbed;
              }
              if (remaining > 0) player.hp -= remaining;
              
              showDamage(player.x, player.y - 25, totalDmg, '#ff4444');
              addLog(`${e.name} SLAM! ${totalDmg} damage`, 'damage');
            }
            
            // Visual feedback - screen shake and impact particles
            camera.shake = Math.max(camera.shake, e.isBoss ? 8 : 4);
            for (let p = 0; p < 10; p++) {
              const pAngle = (p / 10) * Math.PI * 2;
              addParticle({
                x: player.x, y: player.y,
                vx: Math.cos(pAngle) * 4,
                vy: Math.sin(pAngle) * 4,
                life: 20,
                color: '#ff4444',
                size: 5
              });
            }
          }
        } else {
          // Target not walkable - return to start position
          e.x = e.leapStartX;
          e.y = e.leapStartY;
        }
        // Create landing particles
        for (let p = 0; p < 6; p++) {
          const pAngle = (p / 6) * Math.PI * 2;
          addParticle({
            x: e.x, y: e.y,
            vx: Math.cos(pAngle) * 3,
            vy: Math.sin(pAngle) * 3,
            life: 15,
            color: e.color || '#666',
            size: 4
          });
        }
      } else {
        // Interpolate position with arc - DON'T update actual position until landing
        // Just store visual position for drawing
        const t = e.leapProgress;
        const arcHeight = TILE * 2 * Math.sin(t * Math.PI); // Parabolic arc
        e.visualX = e.leapStartX + (e.leapTargetX - e.leapStartX) * t;
        e.visualY = e.leapStartY + (e.leapTargetY - e.leapStartY) * t - arcHeight;
      }
      continue; // Skip normal movement while leaping
    } else {
      // Clear visual position when not leaping
      e.visualX = undefined;
      e.visualY = undefined;
    }
    
    // Safety check: if enemy somehow got into an unwalkable position, push them out
    if (!isWalkable(e.x, e.y)) {
      // Try to find nearest walkable position
      let found = false;
      for (let r = TILE; r < TILE * 5 && !found; r += TILE / 2) {
        for (let a = 0; a < Math.PI * 2; a += Math.PI / 8) {
          const tx = e.x + Math.cos(a) * r;
          const ty = e.y + Math.sin(a) * r;
          if (isWalkable(tx, ty)) {
            e.x = tx;
            e.y = ty;
            found = true;
            break;
          }
        }
      }
      // Only kill if we truly can't find a valid position
      if (!found) {
        e.unreachable = true;
        e.dead = true;
        e.hp = 0;
        continue;
      }
    }
    
    // Update root/stun/frozen timers
    if (e.rooted > 0) e.rooted -= dt;
    if (e.stunned > 0) e.stunned -= dt;
    if (e.frozen > 0) e.frozen -= dt;
    
    // Can't move or attack if rooted, stunned, or frozen
    if (e.rooted > 0 || e.stunned > 0 || e.frozen > 0) {
      continue;
    }
    
    // Apply slow to movement
    let moveSlowMult = 1.0;
    if (e.slowed > 0 && e.slowAmount) {
      moveSlowMult = 1.0 - e.slowAmount;
    }
    // Apply caltrop slow (stacks with other slows)
    if (e.caltropSlowed && e.caltropSlowAmount) {
      moveSlowMult *= (1.0 - e.caltropSlowAmount);
    }
    
    if (dist < TILE * 1.1) {
      enemyAttack(e);
    } else {
      // Once activated, special enemies chase further than normal enemies
      // GR enemies, Rift Surge enemies, and Echo enemies have extended chase
      const isSpecialEnemy = (e.isRift || e.isEcho || e.isGreaterRift) && e.active;
      const chaseRange = isSpecialEnemy ? TILE * 30 : TILE * 12;
      if (dist < chaseRange) {
        const angle = Math.atan2(player.y - e.y, player.x - e.x);
        // Special enemies are slightly faster to maintain pressure
        const speedMult = isSpecialEnemy ? 1.85 : 1.0;
        const moveSpeed = e.spd * speedMult * moveSlowMult * dt;
        
        // Try direct path first
        const nx = e.x + Math.cos(angle) * moveSpeed;
        const ny = e.y + Math.sin(angle) * moveSpeed;
        
        if (isWalkable(nx, ny)) {
          e.x = nx;
          e.y = ny;
          e.wallFollowDir = null; // Reset wall follow when moving directly
          e.stuckCounter = 0;
          e.enemyPath = null; // Clear path when moving directly
        } else {
          // Direct path blocked - try smart wall navigation
          let moved = false;
          
          // First try axis-aligned movement (slide along walls)
          if (!moved && isWalkable(nx, e.y)) {
            e.x = nx;
            moved = true;
          }
          if (!moved && isWalkable(e.x, ny)) {
            e.y = ny;
            moved = true;
          }
          
          // If axis-aligned doesn't work, use wall-following algorithm
          if (!moved) {
            // Initialize wall follow direction if not set
            if (!e.wallFollowDir) {
              e.wallFollowDir = Math.random() < 0.5 ? 1 : -1;
            }
            
            // Try angles progressively further from direct path
            const tryAngles = [
              angle + (Math.PI / 4) * e.wallFollowDir,
              angle + (Math.PI / 2) * e.wallFollowDir,
              angle + (Math.PI * 3/4) * e.wallFollowDir,
              angle - (Math.PI / 4) * e.wallFollowDir,
              angle - (Math.PI / 2) * e.wallFollowDir,
              angle + Math.PI,
            ];
            
            for (const tryAngle of tryAngles) {
              const tx = e.x + Math.cos(tryAngle) * moveSpeed;
              const ty = e.y + Math.sin(tryAngle) * moveSpeed;
              if (isWalkable(tx, ty)) {
                e.x = tx;
                e.y = ty;
                moved = true;
                break;
              }
            }
            
            // Track stuck counter
            if (!moved) {
              e.stuckCounter = (e.stuckCounter || 0) + 1;
              e.wallFollowDir *= -1;
            } else {
              e.stuckCounter = Math.max(0, (e.stuckCounter || 0) - 1);
            }
          }
          
          // If stuck for a while, use A* pathfinding
          if ((e.stuckCounter || 0) > 20 && (!e.enemyPath || e.enemyPath.length === 0)) {
            // Calculate path to player using A*
            e.enemyPath = findPath(e.x, e.y, player.x, player.y);
            e.pathRecalcTimer = 60; // Recalculate every ~1 second
          }
          
          // Follow calculated path if we have one
          if (e.enemyPath && e.enemyPath.length > 0) {
            const waypoint = e.enemyPath[0];
            const wpDist = Math.hypot(waypoint.x - e.x, waypoint.y - e.y);
            
            // Reached waypoint, move to next
            if (wpDist < TILE * 0.5) {
              e.enemyPath.shift();
              e.stuckCounter = 0;
            } else {
              // Move toward waypoint
              const wpAngle = Math.atan2(waypoint.y - e.y, waypoint.x - e.x);
              const wpx = e.x + Math.cos(wpAngle) * moveSpeed;
              const wpy = e.y + Math.sin(wpAngle) * moveSpeed;
              if (isWalkable(wpx, wpy)) {
                e.x = wpx;
                e.y = wpy;
                e.stuckCounter = 0;
              } else if (isWalkable(wpx, e.y)) {
                e.x = wpx;
                e.stuckCounter = 0;
              } else if (isWalkable(e.x, wpy)) {
                e.y = wpy;
                e.stuckCounter = 0;
              }
            }
            
            // Decrement path recalc timer and recalculate if needed
            e.pathRecalcTimer = (e.pathRecalcTimer || 0) - 1;
            if (e.pathRecalcTimer <= 0) {
              e.enemyPath = null; // Force recalculation next time
            }
          }
        }
      }
    }
  }
  
  // Particles - in-place cleanup
  for (let i = particles.length - 1; i >= 0; i--) {
    const p = particles[i];
    p.x += p.vx * dt;
    p.y += p.vy * dt;
    p.vx *= Math.pow(0.9, dt);
    p.vy *= Math.pow(0.9, dt);
    p.life -= dt;
    if (p.life <= 0) particles.splice(i, 1);
  }
  
  // Progress orbs update (GR boss kill orbs)
  updateProgressOrbs(dt);
  
  // Guardian mechanics and hazards (Greater Rift boss)
  if (greaterRiftActive && greaterRiftGuardianSpawned) {
    processGuardianMechanics(dt);
    updateGuardianHazards(dt);
  }
  
  // Blood fade - faster fade for performance
  for (let i = blood.length - 1; i >= 0; i--) {
    blood[i].alpha *= Math.pow(0.97, dt); // Much faster fade
    if (blood[i].alpha <= 0.05) blood.splice(i, 1);
  }
  
  // Damage numbers - update
  for (let i = damageNumbers.length - 1; i >= 0; i--) {
    const d = damageNumbers[i];
    d.y += d.vy * dt;
    d.life -= dt;
    if (d.life <= 0) damageNumbers.splice(i, 1);
  }
  
  // Loot popups - update
  for (let i = lootPopups.length - 1; i >= 0; i--) {
    const p = lootPopups[i];
    p.y += p.vy * dt;
    p.life -= dt;
    if (p.life <= 0) lootPopups.splice(i, 1);
  }
  
  // Salvage popups - update
  for (let i = salvagePopups.length - 1; i >= 0; i--) {
    const p = salvagePopups[i];
    p.life -= dt;
    if (p.life <= 0) salvagePopups.splice(i, 1);
  }
  
  // Camera
  const camLerp = 1 - Math.pow(0.88, dt);
  camera.x += (player.x - camera.x) * camLerp;
  camera.y += (player.y - camera.y) * camLerp;
  
  // Boss debuff decay (using real seconds)
  if (currentBoss && currentBoss.debuffs) {
    let changed = false;
    for (let i = currentBoss.debuffs.length - 1; i >= 0; i--) {
      currentBoss.debuffs[i].duration -= window.deltaSeconds;
      if (currentBoss.debuffs[i].duration <= 0) {
        currentBoss.debuffs.splice(i, 1);
        changed = true;
      }
    }
    if (changed) updateBossDebuffs();
    updateBossBar();
  }
  
  // Throttle UI updates for performance (every 10 frames)
  if (frame % 10 === 0) updateUI();
}

// ============ RENDER ============
function render() {
  // Skip heavy rendering when tab not visible (background optimization)
  if (document.hidden) {
    // Minimal update - just keep game logic running
    renderMinimap();
    return;
  }
  
  // Dark background
  ctx.fillStyle = biome.fog;
  ctx.fillRect(0, 0, W, H);
  
  ctx.save();
  
  // Camera shake
  const shakeX = camera.shake ? (Math.random() - 0.5) * camera.shake : 0;
  const shakeY = camera.shake ? (Math.random() - 0.5) * camera.shake : 0;
  
  // Apply zoom
  ctx.translate(W / 2 + shakeX, H / 2 + shakeY);
  ctx.scale(camera.zoom, camera.zoom);
  ctx.translate(-camera.x, -camera.y);
  
  // Visible range
  const pad = 2;
  const viewW = W / camera.zoom;
  const viewH = H / camera.zoom;
  const x1 = Math.max(0, Math.floor((camera.x - viewW / 2) / TILE) - pad);
  const x2 = Math.min(map.width, Math.ceil((camera.x + viewW / 2) / TILE) + pad);
  const y1 = Math.max(0, Math.floor((camera.y - viewH / 2) / TILE) - pad);
  const y2 = Math.min(map.height, Math.ceil((camera.y + viewH / 2) / TILE) + pad);
  
  // PASS 1: Floor tiles (optimized - minimal draws)
  for (let y = y1; y < y2; y++) {
    for (let x = x1; x < x2; x++) {
      const tile = map.tiles[y]?.[x];
      if (tile === 1) {
        const tx = x * TILE, ty = y * TILE;
        ctx.fillStyle = (x + y) % 2 ? biome.floor : biome.floorAlt;
        ctx.fillRect(tx, ty, TILE, TILE);
      }
    }
  }
  
  // PASS 2: Wall shadows (simple solid rectangles - no gradients!)
  ctx.fillStyle = 'rgba(0,0,0,0.3)';
  if (map.edgeShadows) {
    for (const shadow of map.edgeShadows) {
      if (shadow.x < (x1 - 1) * TILE || shadow.x > (x2 + 1) * TILE ||
          shadow.y < (y1 - 1) * TILE || shadow.y > (y2 + 1) * TILE) continue;
      
      if (shadow.fromTop) {
        ctx.fillRect(shadow.x, shadow.y, TILE, 8);
      }
      if (shadow.fromLeft) {
        ctx.fillRect(shadow.x, shadow.y, 6, TILE);
      }
    }
  }
  
  // PASS 3: Sparse floor decorations (no transforms for simple ones)
  if (map.decorations) {
    const decorColor = biome.decorColor || '#333';
    for (const d of map.decorations) {
      if (d.x < (x1 - 1) * TILE || d.x > (x2 + 1) * TILE ||
          d.y < (y1 - 1) * TILE || d.y > (y2 + 1) * TILE) continue;
      
      ctx.globalAlpha = d.alpha;
      
      // Simple decorations without rotation for performance
      switch (d.type) {
        case 'bones':
          ctx.fillStyle = '#a8a090';
          ctx.fillRect(d.x - d.size/2, d.y - 0.5, d.size, 1);
          break;
        case 'cracks':
        case 'debris':
        case 'rocks':
          ctx.fillStyle = decorColor;
          ctx.fillRect(d.x - d.size/3, d.y - d.size/3, d.size * 0.6, d.size * 0.6);
          break;
        case 'moss':
        case 'leaves':
        case 'snow':
        case 'sand':
        case 'ice':
        case 'frost':
          ctx.fillStyle = biome.accentColor || '#555';
          ctx.globalAlpha = d.alpha * 0.5;
          ctx.fillRect(d.x - d.size/2, d.y - d.size/2, d.size, d.size);
          break;
        case 'crystals':
        case 'sparkles':
          ctx.fillStyle = biome.accentColor || '#66f';
          ctx.globalAlpha = d.alpha * (0.5 + 0.3 * Math.sin(frame * 0.05 + d.x * 0.1));
          ctx.fillRect(d.x - 2, d.y - d.size/2, 4, d.size);
          break;
        case 'lava_cracks':
        case 'embers':
          ctx.fillStyle = biome.accentColor || '#f60';
          ctx.globalAlpha = d.alpha * (0.4 + 0.4 * Math.sin(frame * 0.04 + d.y * 0.1));
          ctx.fillRect(d.x - d.size/2, d.y - 1, d.size, 2);
          break;
      }
    }
    ctx.globalAlpha = 1;
  }
  
  // PASS 4: Walls (clean, minimal draws)
  for (let y = y1; y < y2; y++) {
    for (let x = x1; x < x2; x++) {
      const tile = map.tiles[y]?.[x];
      if (tile === 2) {
        const tx = x * TILE, ty = y * TILE;
        
        // Wall body
        ctx.fillStyle = biome.wall;
        ctx.fillRect(tx, ty, TILE, TILE);
        
        // Wall top (lighter)
        ctx.fillStyle = biome.wallTop;
        ctx.fillRect(tx, ty, TILE, 5);
        
        // Bottom edge shadow
        ctx.fillStyle = 'rgba(0,0,0,0.25)';
        ctx.fillRect(tx, ty + TILE - 3, TILE, 3);
      }
    }
  }
  
  // PASS 5: Ambient particles (reduced, simple)
  if (ambientParticles) {
    for (const p of ambientParticles) {
      if (p.x < (x1 - 2) * TILE || p.x > (x2 + 2) * TILE ||
          p.y < (y1 - 2) * TILE || p.y > (y2 + 2) * TILE) continue;
      
      p.x += p.vx;
      p.y += p.vy;
      if (p.x < 0) p.x = map.width * TILE;
      if (p.x > map.width * TILE) p.x = 0;
      if (p.y < 0) p.y = map.height * TILE;
      if (p.y > map.height * TILE) p.y = 0;
      
      ctx.globalAlpha = p.alpha * 0.6;
      ctx.fillStyle = p.color;
      ctx.fillRect(p.x - p.size/2, p.y - p.size/2, p.size, p.size);
    }
    ctx.globalAlpha = 1;
  }
  
  // Exit portal (simple, no gradients)
  if (exitPos) {
    ctx.fillStyle = '#1a4466';
    ctx.beginPath();
    ctx.arc(exitPos.x, exitPos.y, 20, 0, Math.PI * 2);
    ctx.fill();
    
    ctx.fillStyle = '#2288bb';
    ctx.beginPath();
    ctx.arc(exitPos.x, exitPos.y, 14, 0, Math.PI * 2);
    ctx.fill();
    
    ctx.fillStyle = '#44aadd';
    ctx.beginPath();
    ctx.arc(exitPos.x, exitPos.y, 8, 0, Math.PI * 2);
    ctx.fill();
    
    // Pulsing center
    const pulse = 4 + Math.sin(frame * 0.08) * 1.5;
    ctx.fillStyle = '#88ddff';
    ctx.beginPath();
    ctx.arc(exitPos.x, exitPos.y, pulse, 0, Math.PI * 2);
    ctx.fill();
  }
  
  // Blood
  for (let i = 0; i < blood.length; i++) {
    const b = blood[i];
    ctx.globalAlpha = b.alpha;
    ctx.fillStyle = '#401010';
    ctx.beginPath();
    ctx.ellipse(b.x, b.y, b.size, b.size * 0.5, 0, 0, Math.PI * 2);
    ctx.fill();
  }
  ctx.globalAlpha = 1;
  
  // Loot with beams and gear-shaped icons (using drop tier system)
  for (let li = 0; li < loot.length; li++) {
    const l = loot[li];
    // Skip if loot is too far from camera (off screen)
    const viewW = W / camera.zoom;
    const viewH = H / camera.zoom;
    if (Math.abs(l.x - camera.x) > viewW || Math.abs(l.y - camera.y) > viewH) continue;
    
    // Calculate drop tier (T1-T5) for visual effects
    const dropTier = calculateDropTier(l);
    
    // Get tier-based visual properties
    const tierVisuals = getDropTierVisuals(dropTier);
    
    const colors = { 
      normal: { main: '#a0a0a0', glow: '#888888', beam: '#666666' }, 
      magic: { main: '#6666ff', glow: '#4444ff', beam: '#3333aa' }, 
      rare: { main: '#ffff00', glow: '#ffcc00', beam: '#aa8800' }, 
      unique: { main: '#ff6600', glow: '#ff4400', beam: '#aa3300' }
    };
    const c = colors[l.rarity];
    
    // Use drop tier to enhance beam/glow (T5 items really pop)
    const tierMult = tierVisuals.glowIntensity;
    const beamHeight = tierVisuals.beamHeight;
    const beamWidth = (l.rarity === 'unique' ? 16 : l.rarity === 'rare' ? 12 : l.rarity === 'magic' ? 8 : 4) * tierMult;
    const pulseSpeed = dropTier >= 4 ? 0.12 : l.rarity === 'unique' ? 0.08 : 0.05;
    
    // Beam - simple solid rectangles with fading alpha (NO gradients)
    const baseAlpha = (dropTier === 5 ? 0.6 : 0.4) + Math.sin(frame * pulseSpeed + l.id * 10) * 0.2;
    
    // Draw beam in 4 segments with decreasing opacity (simulates gradient)
    const segH = beamHeight / 4;
    ctx.fillStyle = c.beam;
    ctx.globalAlpha = baseAlpha * tierMult * 0.8;
    ctx.fillRect(l.x - beamWidth/2, l.y - segH, beamWidth, segH);
    ctx.globalAlpha = baseAlpha * tierMult * 0.5;
    ctx.fillRect(l.x - beamWidth/2, l.y - segH * 2, beamWidth, segH);
    ctx.globalAlpha = baseAlpha * tierMult * 0.3;
    ctx.fillRect(l.x - beamWidth/2, l.y - segH * 3, beamWidth, segH);
    ctx.globalAlpha = baseAlpha * tierMult * 0.15;
    ctx.fillRect(l.x - beamWidth/2, l.y - segH * 4, beamWidth, segH);
    
    // Inner core beam for magic+ (brighter, thinner)
    if (l.rarity !== 'normal' || dropTier >= 3) {
      ctx.fillStyle = c.main;
      ctx.globalAlpha = baseAlpha * tierMult * 0.7;
      ctx.fillRect(l.x - beamWidth/4, l.y - beamHeight * 0.6, beamWidth/2, beamHeight * 0.5);
    }
    
    // Ground glow - simple ellipse (NO gradient)
    const glowSize = (l.rarity === 'unique' ? 28 : l.rarity === 'rare' ? 22 : l.rarity === 'magic' ? 16 : 10) * tierMult;
    ctx.fillStyle = c.glow;
    ctx.globalAlpha = (0.3 + Math.sin(frame * 0.1) * 0.1) * tierMult;
    ctx.beginPath();
    ctx.ellipse(l.x, l.y + 3, glowSize, glowSize * 0.35, 0, 0, Math.PI * 2);
    ctx.fill();
    ctx.globalAlpha = 1;
    
    // T4 drop: subtle orange sparkle effect
    if (dropTier === 4) {
      if (frame % 8 === 0) {
        addParticle({
          x: l.x + (Math.random() - 0.5) * 30,
          y: l.y - 15 + (Math.random() - 0.5) * 20,
          vx: (Math.random() - 0.5) * 2,
          vy: -1 - Math.random() * 1.5,
          life: 25,
          color: Math.random() > 0.5 ? '#ff8844' : '#ffcc88',
          size: 3 + Math.random() * 2
        });
      }
    }
    
    // T5 drop: MAJOR sparkle effect - unmistakable
    if (dropTier === 5) {
      // Constant golden particles
      if (frame % 4 === 0) {
        addParticle({
          x: l.x + (Math.random() - 0.5) * 40,
          y: l.y - 20 + (Math.random() - 0.5) * 30,
          vx: (Math.random() - 0.5) * 3,
          vy: -1.5 - Math.random() * 2,
          life: 30,
          color: Math.random() > 0.5 ? '#ffdd00' : '#ffffff',
          size: 4 + Math.random() * 3
        });
      }
      
      // Pulsing golden ring around item
      const ringPulse = 1 + Math.sin(frame * 0.1) * 0.2;
      const ringSize = 45 * ringPulse;
      ctx.strokeStyle = '#ffdd00';
      ctx.lineWidth = 3;
      ctx.globalAlpha = 0.5 + Math.sin(frame * 0.15) * 0.2;
      ctx.beginPath();
      ctx.arc(l.x, l.y - 5, ringSize, 0, Math.PI * 2);
      ctx.stroke();
      ctx.globalAlpha = 1;
      
      // "★" indicator floating above
      ctx.font = 'bold 12px Inter';
      ctx.fillStyle = '#ffdd00';
      ctx.textAlign = 'center';
      const floatY = Math.sin(frame * 0.08) * 3;
      ctx.fillText('★', l.x, l.y - beamHeight + 20 + floatY);
      ctx.textAlign = 'left';
    }
    
    // Loot item icon (gear-shaped based on item type)
    ctx.save();
    const itemSize = (l.rarity === 'unique' ? 14 : l.rarity === 'rare' ? 12 : l.rarity === 'magic' ? 10 : 8) * tierVisuals.labelScale;
    const bounce = Math.sin(frame * 0.08 + l.id * 5) * 3;
    
    // Draw item shape based on type
    ctx.translate(l.x, l.y - 8 + bounce);
    
    if (l.name.includes('Sword') || l.name.includes('Blade') || l.name.includes('Edge')) {
      // Sword shape
      ctx.fillStyle = c.main;
      ctx.fillRect(-2, -itemSize, 4, itemSize * 1.8);
      ctx.fillRect(-5, itemSize * 0.6, 10, 4);
      ctx.fillStyle = '#333';
      ctx.fillRect(-4, itemSize * 0.8, 8, 3);
    } else if (l.name.includes('Helm') || l.name.includes('Hood') || l.name.includes('Crown')) {
      // Helmet shape
      ctx.fillStyle = c.main;
      ctx.beginPath();
      ctx.arc(0, 0, itemSize * 0.8, Math.PI, 0);
      ctx.rect(-itemSize * 0.8, 0, itemSize * 1.6, itemSize * 0.5);
      ctx.fill();
    } else if (l.name.includes('Ring')) {
      // Ring shape
      ctx.strokeStyle = c.main;
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.arc(0, 0, itemSize * 0.6, 0, Math.PI * 2);
      ctx.stroke();
      ctx.fillStyle = c.glow;
      ctx.beginPath();
      ctx.arc(0, -itemSize * 0.6, 4, 0, Math.PI * 2);
      ctx.fill();
    } else if (l.name.includes('Amulet') || l.name.includes('Pendant')) {
      // Amulet shape
      ctx.fillStyle = c.main;
      ctx.beginPath();
      ctx.moveTo(0, -itemSize);
      ctx.lineTo(itemSize * 0.7, itemSize * 0.3);
      ctx.lineTo(-itemSize * 0.7, itemSize * 0.3);
      ctx.closePath();
      ctx.fill();
    } else if (l.name.includes('Boot') || l.name.includes('Greave')) {
      // Boot shape
      ctx.fillStyle = c.main;
      ctx.fillRect(-3, -itemSize * 0.8, 6, itemSize);
      ctx.fillRect(-3, itemSize * 0.2, 10, 5);
    } else if (l.name.includes('Glove') || l.name.includes('Gauntlet')) {
      // Glove shape
      ctx.fillStyle = c.main;
      ctx.fillRect(-5, -2, 10, 8);
      ctx.fillRect(-5, -itemSize * 0.8, 3, itemSize * 0.6);
      ctx.fillRect(2, -itemSize * 0.8, 3, itemSize * 0.6);
    } else {
      // Default: orb/gem shape for armor/other
      ctx.fillStyle = c.main;
      ctx.beginPath();
      ctx.arc(0, 0, itemSize, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = 'rgba(255,255,255,0.4)';
      ctx.beginPath();
      ctx.arc(-itemSize * 0.3, -itemSize * 0.3, itemSize * 0.4, 0, Math.PI * 2);
      ctx.fill();
    }
    
    ctx.restore();
  }
  
  // Enemies
  for (let i = 0; i < enemies.length; i++) {
    const e = enemies[i];
    ctx.globalAlpha = e.active ? 1 : 0.4;
    
    // Use visual position during leap, otherwise actual position
    const drawX = e.leaping && e.visualX !== undefined ? e.visualX : e.x;
    const drawY = e.leaping && e.visualY !== undefined ? e.visualY : e.y;
    
    // Boss glow (no shadow for performance)
    if (e.isBoss && e.active) {
      ctx.fillStyle = 'rgba(150,40,40,0.4)';
      ctx.beginPath();
      ctx.arc(drawX, drawY, e.size * 1.5, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = 'rgba(200,60,60,0.3)';
      ctx.beginPath();
      ctx.arc(drawX, drawY, e.size * 1.2, 0, Math.PI * 2);
      ctx.fill();
    }
    
    // Leap indicator - show arc and target
    if (e.leaping) {
      ctx.globalAlpha = 0.5;
      // Draw leap trail
      ctx.strokeStyle = e.isBoss ? '#ff4444' : '#ffaa00';
      ctx.lineWidth = 2;
      ctx.setLineDash([5, 5]);
      ctx.beginPath();
      ctx.moveTo(e.leapStartX, e.leapStartY);
      // Draw arc path
      for (let t = 0; t <= 1; t += 0.1) {
        const arcHeight = TILE * 2 * Math.sin(t * Math.PI);
        const px = e.leapStartX + (e.leapTargetX - e.leapStartX) * t;
        const py = e.leapStartY + (e.leapTargetY - e.leapStartY) * t - arcHeight;
        ctx.lineTo(px, py);
      }
      ctx.stroke();
      ctx.setLineDash([]);
      // Draw target circle
      ctx.beginPath();
      ctx.arc(e.leapTargetX, e.leapTargetY, e.size * 0.8, 0, Math.PI * 2);
      ctx.strokeStyle = '#ff4444';
      ctx.lineWidth = 2;
      ctx.stroke();
      ctx.globalAlpha = e.active ? 1 : 0.4;
    }
    
    // Shadow - adjust for leap height
    const leapHeight = e.leaping ? TILE * 2 * Math.sin((e.leapProgress || 0) * Math.PI) : 0;
    const shadowScale = e.leaping ? 1 - leapHeight / (TILE * 4) : 1;
    ctx.fillStyle = 'rgba(0,0,0,0.25)';
    ctx.beginPath();
    const shadowX = e.leaping ? (e.leapStartX + (e.leapTargetX - e.leapStartX) * (e.leapProgress || 0)) : e.x;
    const shadowY = e.leaping ? (e.leapStartY + (e.leapTargetY - e.leapStartY) * (e.leapProgress || 0)) : e.y;
    ctx.ellipse(shadowX, shadowY + e.size * 0.7, e.size * 0.8 * shadowScale, e.size * 0.3 * shadowScale, 0, 0, Math.PI * 2);
    ctx.fill();
    
    // Draw enemy sprite using new system
    // Adjust Y position for leap arc
    const finalDrawY = drawY - leapHeight;
    drawEnemySprite(ctx, e, drawX, finalDrawY, frame);
    
    // Exploding Palm mark indicator - pulsing red/orange glow
    if (e.explodingPalmMark && e.explodingPalmMark > 0) {
      const pulse = 0.4 + Math.sin(frame * 0.15) * 0.3;
      const markRadius = e.size * 1.5 + Math.sin(frame * 0.2) * 5;
      
      // Outer pulsing glow
      ctx.save();
      ctx.globalAlpha = pulse * 0.6;
      ctx.strokeStyle = '#ff4400';
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.arc(drawX, finalDrawY, markRadius, 0, Math.PI * 2);
      ctx.stroke();
      
      // Inner glow
      ctx.globalAlpha = pulse * 0.3;
      ctx.fillStyle = '#ff6600';
      ctx.beginPath();
      ctx.arc(drawX, finalDrawY, e.size * 1.2, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();
    }
    
    // Boss outline
    if (e.isBoss) {
      ctx.strokeStyle = '#ff6666';
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.arc(drawX, finalDrawY, e.size * 1.1, 0, Math.PI * 2);
      ctx.stroke();
    }
    
    // HP bar (not for bosses - they have the big bar)
    if (e.active && !e.isBoss && e.maxHp > 0) {
      const bw = Math.min(e.size * 2, 50);
      const hpPct = Math.max(0, Math.min(1, e.hp / e.maxHp));
      ctx.fillStyle = '#111';
      ctx.fillRect(drawX - bw / 2, finalDrawY - e.size - 12, bw, 5);
      ctx.fillStyle = '#822';
      ctx.fillRect(drawX - bw / 2, finalDrawY - e.size - 12, bw * hpPct, 5);
    }
    
    ctx.globalAlpha = 1;
  }
  
  // Player - Render based on equipped skin
  const bob = player.state === 'moving' ? Math.sin(frame * 0.12) * 1.2 : 0;
  
  ctx.save();
  ctx.translate(player.x, player.y + bob);
  ctx.scale(player.facing, 1);
  
  // Calculate weapon angle - more dramatic swing
  let wAng = 0.1;
  let bodyLean = 0;
  let bodySquash = 1.0; // Vertical squash/stretch
  let bodyStretch = 1.0; // Horizontal stretch
  let armExtend = 0; // Arm extension for punches/thrusts
  let spinRotation = 0; // Full body rotation for spin attacks
  
  // Cyclone active - maintain arms-up pose for entire duration
  if (cycloneActive) {
    wAng = -1.2; // Arms up high
    bodyLean = Math.sin(frame * 0.3) * 0.1; // Gentle sway
    bodySquash = 0.95 + Math.sin(frame * 0.4) * 0.05; // Slight pulse
  } else if (player.atkAnim > 0) {
    const animProgress = player.atkAnim / 20;
    const skillType = player.skillAnimType;
    
    // Different animations based on skill type
    if (skillType === 'cyclone') {
      // Cyclone - arms raised, slight lean into spin, NOT full body rotation
      wAng = -1.2; // Arms up high
      bodyLean = Math.sin(frame * 0.3) * 0.1; // Gentle sway
      bodySquash = 0.95 + Math.sin(frame * 0.4) * 0.05; // Slight pulse
    } else if (skillType === 'spin') {
      // Full body spin for spinning kick etc
      spinRotation = (1 - animProgress) * Math.PI * 2;
      bodySquash = 0.9 + Math.sin(animProgress * Math.PI * 4) * 0.1;
    } else if (skillType === 'palm' || skillType === 'thrust') {
      // Thrust forward with arm extended
      const thrustCurve = Math.sin(animProgress * Math.PI);
      armExtend = thrustCurve * 15;
      bodyLean = thrustCurve * 0.3;
      bodyStretch = 1 + thrustCurve * 0.15;
      bodySquash = 1 - thrustCurve * 0.1;
    } else if (skillType === 'combo') {
      // Multi-hit combo - rapid alternating
      const hitNum = Math.floor((1 - animProgress) * 3);
      const hitProgress = ((1 - animProgress) * 3) % 1;
      wAng = (hitNum % 2 === 0 ? 1 : -1) * Math.sin(hitProgress * Math.PI) * 1.5;
      bodyLean = Math.sin(hitProgress * Math.PI) * 0.2 * (hitNum % 2 === 0 ? 1 : -1);
      armExtend = Math.sin(hitProgress * Math.PI) * 10;
    } else if (skillType === 'flurry') {
      // Rapid punching - alternating fast
      const punchNum = Math.floor((1 - animProgress) * 6);
      const punchProgress = ((1 - animProgress) * 6) % 1;
      armExtend = Math.sin(punchProgress * Math.PI) * 12;
      wAng = (punchNum % 2 === 0 ? 0.3 : -0.3);
      bodyLean = Math.sin(punchProgress * Math.PI * 2) * 0.1;
    } else if (skillType === 'slam') {
      // Ground slam - raise up then smash down
      const slamPhase = animProgress > 0.6 ? (animProgress - 0.6) / 0.4 : animProgress / 0.6;
      if (animProgress > 0.6) {
        // Wind up - rise and lean back
        bodySquash = 1 + slamPhase * 0.2;
        bodyLean = -slamPhase * 0.3;
        wAng = -slamPhase * 1.5;
      } else {
        // Slam down - compress and lean forward
        const slamDown = Math.sin(slamPhase * Math.PI);
        bodySquash = 1 - slamDown * 0.2;
        bodyStretch = 1 + slamDown * 0.15;
        bodyLean = slamDown * 0.4;
        wAng = slamDown * 2.0;
      }
    } else if (skillType === 'nova') {
      // Nova burst - expand outward
      const novaCurve = Math.sin(animProgress * Math.PI);
      bodySquash = 1 - novaCurve * 0.15;
      bodyStretch = 1 + novaCurve * 0.2;
      wAng = novaCurve * 0.5;
      spinRotation = novaCurve * 0.3;
    } else if (skillType === 'punch') {
      // Dynamic punch - alternating fists with body rotation
      const punchCurve = Math.sin(animProgress * Math.PI);
      const punchHand = (player.fistsComboCount || 0) % 2; // Alternate hands
      
      // Arm extension - forward punch motion
      armExtend = punchCurve * 18;
      
      // Body twist into the punch (alternate direction)
      bodyLean = punchCurve * 0.35 * (punchHand === 0 ? 1 : -1);
      
      // Slight forward lunge
      bodyStretch = 1 + punchCurve * 0.15;
      bodySquash = 1 - punchCurve * 0.08;
      
      // Weapon angle follows the punching arm
      wAng = punchCurve * 1.2 * (punchHand === 0 ? 1 : -1);
      
      // On 3rd hit (combo finisher), add extra oomph
      if ((player.fistsComboCount || 0) % 3 === 0 && player.fistsComboCount > 0) {
        bodyLean *= 1.5;
        armExtend *= 1.3;
        wAng *= 1.4;
      }
    } else if (skillType === 'slash') {
      // Weapon slash - wide arc swing
      const slashCurve = animProgress < 0.4 
        ? Math.sin(animProgress * Math.PI / 0.4)
        : Math.sin((animProgress - 0.4) * Math.PI / 0.6) * 0.3;
      wAng = slashCurve * 2.2;
      bodyLean = slashCurve * 0.25;
      bodyStretch = 1 + Math.abs(slashCurve) * 0.1;
    } else if (skillType === 'cast') {
      // Spell casting - arms raise up then thrust forward
      const castCurve = animProgress > 0.5 
        ? Math.sin((animProgress - 0.5) * Math.PI * 2)
        : Math.sin(animProgress * Math.PI);
      wAng = -castCurve * 0.8; // Arms go up
      bodySquash = 1 + castCurve * 0.1;
      armExtend = animProgress < 0.5 ? 0 : (1 - animProgress) * 20;
    } else if (skillType === 'shoot') {
      // Bow draw and release
      const drawCurve = animProgress > 0.3 
        ? Math.sin((animProgress - 0.3) * Math.PI / 0.7)
        : animProgress / 0.3;
      bodyLean = -drawCurve * 0.15; // Lean back while drawing
      armExtend = drawCurve * -8; // Pull back
      wAng = drawCurve * 0.3;
    } else if (skillType === 'roll') {
      // Evasive roll - full rotation
      spinRotation = (1 - animProgress) * Math.PI * 2;
      bodySquash = 0.7 + animProgress * 0.3;
    } else if (skillType === 'teleport') {
      // Teleport - shrink and expand
      const telePhase = animProgress > 0.5 ? (animProgress - 0.5) * 2 : animProgress * 2;
      bodySquash = animProgress > 0.5 ? 0.3 + telePhase * 0.7 : 1 - telePhase * 0.7;
      bodyStretch = bodySquash;
    } else if (skillType === 'slam') {
      // Ground slam - jump up then down
      const slamPhase = animProgress > 0.4 ? (animProgress - 0.4) / 0.6 : animProgress / 0.4;
      if (animProgress > 0.4) {
        bodySquash = 0.8 + slamPhase * 0.2;
        bodyStretch = 1.2 - slamPhase * 0.2;
      } else {
        bodySquash = 1 + slamPhase * 0.3;
        bodyStretch = 1 - slamPhase * 0.2;
      }
      wAng = animProgress > 0.4 ? (1 - slamPhase) * 2 : slamPhase * 2;
    } else if (skillType === 'buff') {
      // Buff - arms raise up with energy
      const buffCurve = Math.sin(animProgress * Math.PI);
      wAng = -buffCurve * 1.2;
      bodySquash = 1 + buffCurve * 0.1;
    } else if (skillType === 'channel') {
      // Channel - steady pose with gentle pulse
      const pulseCurve = Math.sin(animProgress * Math.PI * 3);
      bodySquash = 1 + pulseCurve * 0.05;
      wAng = -0.5 + pulseCurve * 0.1;
    } else {
      // Default swing animation
      const swingCurve = animProgress < 0.5 
        ? Math.sin(animProgress * Math.PI * 2)
        : Math.sin(animProgress * Math.PI) * 0.5;
      wAng = swingCurve * 1.8;
      bodyLean = swingCurve * 0.15;
    }
    
    // Decay skill animation
    player.skillAnimProgress = animProgress;
  }
  
  // Apply body transformations
  if (spinRotation !== 0) {
    ctx.rotate(spinRotation);
  }
  if (bodyLean !== 0) {
    ctx.rotate(bodyLean);
  }
  if (bodySquash !== 1.0 || bodyStretch !== 1.0) {
    ctx.scale(bodyStretch, bodySquash);
  }
  
  // Draw the equipped skin based on class
  if (player.class === 'ranger') {
    drawRangerSkin(ctx, player.skin, wAng, player.state === 'attacking');
  } else if (player.class === 'mage') {
    drawMageSkin(ctx, player.skin, wAng, player.state === 'attacking');
  } else if (player.class === 'warrior') {
    drawWarriorSkin(ctx, player.skin, wAng, player.state === 'attacking');
  } else {
    drawMonkSkin(ctx, player.skin, wAng, player.state === 'attacking');
  }
  
  ctx.restore();

  // Cyclone effect around player
  if (cycloneActive) {
    ctx.save();
    const spinAngle = frame * 0.15;
    for (let i = 0; i < 8; i++) {
      const angle = spinAngle + (i / 8) * Math.PI * 2;
      const dist = 40 + Math.sin(frame * 0.3 + i) * 10;
      ctx.globalAlpha = 0.6;
      ctx.fillStyle = '#88ffaa';
      ctx.beginPath();
      ctx.arc(
        player.x + Math.cos(angle) * dist,
        player.y + Math.sin(angle) * dist,
        6, 0, Math.PI * 2
      );
      ctx.fill();
    }
    // Inner ring
    ctx.strokeStyle = '#44ff66';
    ctx.lineWidth = 3;
    ctx.globalAlpha = 0.4;
    ctx.beginPath();
    ctx.arc(player.x, player.y, 60, 0, Math.PI * 2);
    ctx.stroke();
    ctx.restore();
  }
  
  // Inner Sanctuary zone rendering
  if (player.innerSanctuary) {
    const sanctuary = player.innerSanctuary;
    ctx.save();
    
    // Outer glow ring
    ctx.strokeStyle = '#44ff44';
    ctx.lineWidth = 3;
    ctx.globalAlpha = 0.4 + Math.sin(frame * 0.1) * 0.15;
    ctx.beginPath();
    ctx.arc(sanctuary.x, sanctuary.y, sanctuary.radius, 0, Math.PI * 2);
    ctx.stroke();
    
    // Inner fill
    const gradient = ctx.createRadialGradient(sanctuary.x, sanctuary.y, 0, sanctuary.x, sanctuary.y, sanctuary.radius);
    gradient.addColorStop(0, 'rgba(100, 255, 100, 0.15)');
    gradient.addColorStop(0.7, 'rgba(80, 200, 80, 0.08)');
    gradient.addColorStop(1, 'rgba(60, 150, 60, 0)');
    ctx.fillStyle = gradient;
    ctx.beginPath();
    ctx.arc(sanctuary.x, sanctuary.y, sanctuary.radius, 0, Math.PI * 2);
    ctx.fill();
    
    // Rotating runes
    const runeCount = 6;
    for (let i = 0; i < runeCount; i++) {
      const runeAngle = (frame * 0.02) + (i / runeCount) * Math.PI * 2;
      const runeX = sanctuary.x + Math.cos(runeAngle) * (sanctuary.radius * 0.7);
      const runeY = sanctuary.y + Math.sin(runeAngle) * (sanctuary.radius * 0.7);
      ctx.fillStyle = '#88ff88';
      ctx.globalAlpha = 0.5;
      ctx.beginPath();
      ctx.arc(runeX, runeY, 4, 0, Math.PI * 2);
      ctx.fill();
    }
    
    ctx.restore();
  }
  
  // Skill projectiles (fireballs)
  for (let i = 0; i < skillProjectiles.length; i++) {
    const p = skillProjectiles[i];
    if (p.type === 'fireball') {
      ctx.save();
      ctx.translate(p.x, p.y);
      
      // Glow
      const grd = ctx.createRadialGradient(0, 0, 0, 0, 0, 20);
      grd.addColorStop(0, 'rgba(255,200,50,0.8)');
      grd.addColorStop(0.5, 'rgba(255,100,20,0.4)');
      grd.addColorStop(1, 'rgba(255,50,0,0)');
      ctx.fillStyle = grd;
      ctx.beginPath();
      ctx.arc(0, 0, 20, 0, Math.PI * 2);
      ctx.fill();
      
      // Core
      ctx.fillStyle = '#ffff88';
      ctx.beginPath();
      ctx.arc(0, 0, 8, 0, Math.PI * 2);
      ctx.fill();
      
      ctx.restore();
    } else if (p.type === 'arrow') {
      ctx.save();
      ctx.translate(p.x, p.y);
      ctx.rotate(Math.atan2(p.vy, p.vx));
      
      // Arrow shaft
      ctx.fillStyle = '#8B7355';
      ctx.fillRect(-12, -1.5, 20, 3);
      
      // Arrow head
      ctx.fillStyle = '#aaa';
      ctx.beginPath();
      ctx.moveTo(10, 0);
      ctx.lineTo(6, -4);
      ctx.lineTo(6, 4);
      ctx.closePath();
      ctx.fill();
      
      // Fletching
      ctx.fillStyle = '#654321';
      ctx.beginPath();
      ctx.moveTo(-12, 0);
      ctx.lineTo(-8, -4);
      ctx.lineTo(-8, 0);
      ctx.closePath();
      ctx.fill();
      ctx.beginPath();
      ctx.moveTo(-12, 0);
      ctx.lineTo(-8, 4);
      ctx.lineTo(-8, 0);
      ctx.closePath();
      ctx.fill();
      
      ctx.restore();
    } else if (p.type === 'magicBolt') {
      ctx.save();
      ctx.translate(p.x, p.y);
      
      // Outer glow
      const grd = ctx.createRadialGradient(0, 0, 0, 0, 0, 15);
      grd.addColorStop(0, 'rgba(150,100,255,0.8)');
      grd.addColorStop(0.5, 'rgba(100,50,200,0.4)');
      grd.addColorStop(1, 'rgba(80,40,180,0)');
      ctx.fillStyle = grd;
      ctx.beginPath();
      ctx.arc(0, 0, 15, 0, Math.PI * 2);
      ctx.fill();
      
      // Core
      ctx.fillStyle = '#ddaaff';
      ctx.beginPath();
      ctx.arc(0, 0, 5, 0, Math.PI * 2);
      ctx.fill();
      
      ctx.restore();
    } else if (p.type === 'qiBlast') {
      ctx.save();
      ctx.translate(p.x, p.y);
      const grd = ctx.createRadialGradient(0, 0, 0, 0, 0, 25);
      grd.addColorStop(0, 'rgba(136,221,255,0.9)');
      grd.addColorStop(0.5, 'rgba(68,170,255,0.5)');
      grd.addColorStop(1, 'rgba(40,140,220,0)');
      ctx.fillStyle = grd;
      ctx.beginPath();
      ctx.arc(0, 0, 25, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = '#aaffff';
      ctx.beginPath();
      ctx.arc(0, 0, 8, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();
    } else if (p.type === 'explosiveArrow' || p.type === 'powerArrow') {
      ctx.save();
      ctx.translate(p.x, p.y);
      ctx.rotate(Math.atan2(p.vy, p.vx));
      ctx.fillStyle = p.type === 'explosiveArrow' ? '#aa4422' : '#8B7355';
      ctx.fillRect(-12, -2, 22, 4);
      ctx.fillStyle = p.type === 'explosiveArrow' ? '#ff4400' : '#aaa';
      ctx.beginPath();
      ctx.moveTo(12, 0); ctx.lineTo(7, -5); ctx.lineTo(7, 5);
      ctx.closePath();
      ctx.fill();
      ctx.restore();
    } else if (p.type === 'piercingShot') {
      ctx.save();
      ctx.translate(p.x, p.y);
      ctx.rotate(Math.atan2(p.vy, p.vx));
      ctx.fillStyle = '#aa8844';
      ctx.fillRect(-14, -2, 24, 4);
      ctx.fillStyle = '#ffff44';
      ctx.beginPath();
      ctx.moveTo(12, 0); ctx.lineTo(7, -5); ctx.lineTo(7, 5);
      ctx.closePath();
      ctx.fill();
      ctx.restore();
    } else if (p.type === 'freezingArrow') {
      ctx.save();
      ctx.translate(p.x, p.y);
      ctx.rotate(Math.atan2(p.vy, p.vx));
      ctx.fillStyle = '#4488aa';
      ctx.fillRect(-12, -1.5, 20, 3);
      ctx.fillStyle = '#88ddff';
      ctx.beginPath();
      ctx.moveTo(10, 0); ctx.lineTo(6, -4); ctx.lineTo(6, 4);
      ctx.closePath();
      ctx.fill();
      ctx.restore();
    } else if (p.type === 'chaosOrb') {
      ctx.save();
      ctx.translate(p.x, p.y);
      const grd = ctx.createRadialGradient(0, 0, 0, 0, 0, 20);
      grd.addColorStop(0, 'rgba(170,136,255,0.9)');
      grd.addColorStop(0.5, 'rgba(136,68,255,0.5)');
      grd.addColorStop(1, 'rgba(100,50,200,0)');
      ctx.fillStyle = grd;
      ctx.beginPath();
      ctx.arc(0, 0, 20, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = '#ddbbff';
      ctx.beginPath();
      ctx.arc(0, 0, 7, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();
    } else if (p.type === 'iceSpear') {
      ctx.save();
      ctx.translate(p.x, p.y);
      ctx.rotate(Math.atan2(p.vy, p.vx));
      ctx.fillStyle = '#4488aa';
      ctx.beginPath();
      ctx.moveTo(18, 0); ctx.lineTo(-10, -4); ctx.lineTo(-10, 4);
      ctx.closePath();
      ctx.fill();
      ctx.fillStyle = '#aaddff';
      ctx.beginPath();
      ctx.moveTo(18, 0); ctx.lineTo(0, -2); ctx.lineTo(0, 2);
      ctx.closePath();
      ctx.fill();
      ctx.restore();
    } else if (p.type === 'hungryArrow') {
      // Seeking green arrow
      ctx.save();
      ctx.translate(p.x, p.y);
      ctx.rotate(Math.atan2(p.vy, p.vx));
      ctx.fillStyle = '#557744';
      ctx.fillRect(-12, -1.5, 20, 3);
      ctx.fillStyle = '#88cc88';
      ctx.beginPath();
      ctx.moveTo(10, 0); ctx.lineTo(6, -4); ctx.lineTo(6, 4);
      ctx.closePath();
      ctx.fill();
      // Slight glow for seeking effect
      ctx.fillStyle = 'rgba(136, 204, 136, 0.3)';
      ctx.beginPath();
      ctx.arc(5, 0, 8, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();
    } else if (p.type === 'chakram') {
      // Spinning disc blade
      ctx.save();
      ctx.translate(p.x, p.y);
      ctx.rotate(p.spin || 0);
      
      // Outer ring
      ctx.strokeStyle = '#ffcc44';
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.arc(0, 0, 18, 0, Math.PI * 2);
      ctx.stroke();
      
      // Inner disc
      ctx.fillStyle = '#997722';
      ctx.beginPath();
      ctx.arc(0, 0, 12, 0, Math.PI * 2);
      ctx.fill();
      
      // Blades (4 points)
      ctx.fillStyle = '#ffdd66';
      for (let i = 0; i < 4; i++) {
        const bladeAngle = (i / 4) * Math.PI * 2;
        ctx.beginPath();
        ctx.moveTo(Math.cos(bladeAngle) * 10, Math.sin(bladeAngle) * 10);
        ctx.lineTo(Math.cos(bladeAngle + 0.3) * 22, Math.sin(bladeAngle + 0.3) * 22);
        ctx.lineTo(Math.cos(bladeAngle - 0.3) * 22, Math.sin(bladeAngle - 0.3) * 22);
        ctx.closePath();
        ctx.fill();
      }
      
      // Center gem
      ctx.fillStyle = p.returning ? '#ff6644' : '#44ddff';
      ctx.beginPath();
      ctx.arc(0, 0, 5, 0, Math.PI * 2);
      ctx.fill();
      
      // Glow effect
      ctx.fillStyle = p.returning ? 'rgba(255, 100, 68, 0.3)' : 'rgba(68, 221, 255, 0.3)';
      ctx.beginPath();
      ctx.arc(0, 0, 25, 0, Math.PI * 2);
      ctx.fill();
      
      ctx.restore();
    } else if (p.type === 'multiShot') {
      // Teal spread arrow
      ctx.save();
      ctx.translate(p.x, p.y);
      ctx.rotate(Math.atan2(p.vy, p.vx));
      ctx.fillStyle = '#446655';
      ctx.fillRect(-10, -1, 16, 2);
      ctx.fillStyle = '#88ddbb';
      ctx.beginPath();
      ctx.moveTo(8, 0); ctx.lineTo(4, -3); ctx.lineTo(4, 3);
      ctx.closePath();
      ctx.fill();
      ctx.restore();
    } else if (p.type === 'sentryArrow') {
      // Blue turret arrow
      ctx.save();
      ctx.translate(p.x, p.y);
      ctx.rotate(Math.atan2(p.vy, p.vx));
      ctx.fillStyle = '#445566';
      ctx.fillRect(-10, -1, 16, 2);
      ctx.fillStyle = '#88aaff';
      ctx.beginPath();
      ctx.moveTo(8, 0); ctx.lineTo(4, -3); ctx.lineTo(4, 3);
      ctx.closePath();
      ctx.fill();
      ctx.restore();
    }
  }
  
  // ============ SENTRY TURRETS (Ranger) ============
  if (window.sentries && window.sentries.length > 0) {
    for (const sentry of window.sentries) {
      ctx.save();
      ctx.translate(sentry.x, sentry.y);
      
      // Calculate recoil animation (only when actually fired)
      // Decay justFired over time for smooth animation
      let recoilAmount = 0;
      let stringPull = 0;
      let timeSinceFire = 0;
      if (sentry.justFired) {
        timeSinceFire = sentry.fireTimer || 0;
        recoilAmount = timeSinceFire < 0.1 ? (0.1 - timeSinceFire) * 30 : 0;
        stringPull = timeSinceFire < 0.15 ? Math.sin((0.15 - timeSinceFire) / 0.15 * Math.PI) * 6 : 0;
        // Clear flag after animation completes
        if (timeSinceFire > 0.15) {
          sentry.justFired = false;
        }
      }
      
      // Rotate towards target if has one
      const targetAngle = sentry.lastTargetAngle || 0;
      ctx.rotate(targetAngle * 0.3); // Slight rotation toward target
      
      // Base - metallic with shadow
      ctx.fillStyle = '#333344';
      ctx.beginPath();
      ctx.ellipse(0, 10, 20, 10, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = '#555566';
      ctx.beginPath();
      ctx.ellipse(0, 8, 18, 8, 0, 0, Math.PI * 2);
      ctx.fill();
      
      // Stand with recoil
      ctx.fillStyle = '#444455';
      ctx.fillRect(-6, -5 + recoilAmount * 0.2, 12, 15);
      
      // Crossbow body with recoil
      const bodyRecoil = recoilAmount * 0.5;
      ctx.fillStyle = '#665544';
      ctx.fillRect(-16 + bodyRecoil, -10, 32, 10);
      
      // Metal reinforcement
      ctx.fillStyle = '#888899';
      ctx.fillRect(-8 + bodyRecoil, -11, 16, 3);
      
      // Crossbow arms - flex when firing
      const armFlex = stringPull * 0.05;
      ctx.fillStyle = '#776655';
      ctx.beginPath();
      ctx.moveTo(-16 + bodyRecoil, -8);
      ctx.lineTo(-24 + bodyRecoil, -16 + armFlex * 20);
      ctx.lineTo(-20 + bodyRecoil, -8);
      ctx.closePath();
      ctx.fill();
      ctx.beginPath();
      ctx.moveTo(16 + bodyRecoil, -8);
      ctx.lineTo(24 + bodyRecoil, -16 + armFlex * 20);
      ctx.lineTo(20 + bodyRecoil, -8);
      ctx.closePath();
      ctx.fill();
      
      // String - animated pull back when firing
      ctx.strokeStyle = '#ccc';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(-22 + bodyRecoil, -14 + armFlex * 20);
      ctx.quadraticCurveTo(0 + bodyRecoil, -6 + stringPull, 22 + bodyRecoil, -14 + armFlex * 20);
      ctx.stroke();
      
      // Muzzle flash when just fired
      if (timeSinceFire < 0.08) {
        const flashSize = (0.08 - timeSinceFire) / 0.08;
        ctx.fillStyle = `rgba(255, 200, 100, ${flashSize * 0.8})`;
        ctx.beginPath();
        ctx.arc(20 + bodyRecoil, -10, 8 * flashSize, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = `rgba(255, 255, 200, ${flashSize})`;
        ctx.beginPath();
        ctx.arc(20 + bodyRecoil, -10, 4 * flashSize, 0, Math.PI * 2);
        ctx.fill();
      }
      
      // Glow based on remaining duration (life is in seconds)
      const glowAlpha = Math.min(0.4, sentry.life / 5);
      ctx.fillStyle = `rgba(100, 150, 255, ${glowAlpha})`;
      ctx.beginPath();
      ctx.arc(0, -4, 28, 0, Math.PI * 2);
      ctx.fill();
      
      // Duration indicator ring
      const lifePercent = sentry.life / sentry.maxLife;
      ctx.strokeStyle = `rgba(100, 200, 255, ${0.5 + lifePercent * 0.5})`;
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(0, -4, 26, -Math.PI / 2, -Math.PI / 2 + Math.PI * 2 * lifePercent);
      ctx.stroke();
      
      ctx.restore();
    }
  }
  
  // ============ RAIN OF ARROWS ZONES (Ranger) ============
  if (window.rainZones && window.rainZones.length > 0) {
    for (const zone of window.rainZones) {
      ctx.save();
      ctx.translate(zone.x, zone.y);
      
      // Ground indicator (life is in seconds)
      const alpha = Math.min(0.4, zone.life / 2);  // Fade over 2 seconds
      ctx.fillStyle = `rgba(100, 150, 80, ${alpha})`;
      ctx.beginPath();
      ctx.ellipse(0, 0, zone.radius, zone.radius * 0.5, 0, 0, Math.PI * 2);
      ctx.fill();
      
      // Border
      ctx.strokeStyle = `rgba(80, 120, 60, ${alpha * 1.5})`;
      ctx.lineWidth = 2;
      ctx.stroke();
      
      ctx.restore();
    }
  }
  
  // ============ CALTROPS ZONES (Ranger) ============
  if (window.caltropZones && window.caltropZones.length > 0) {
    for (const zone of window.caltropZones) {
      ctx.save();
      ctx.translate(zone.x, zone.y);
      
      // Ground indicator - metallic gray
      const alpha = Math.min(0.5, zone.life / 3);
      ctx.fillStyle = `rgba(60, 60, 70, ${alpha})`;
      ctx.beginPath();
      ctx.ellipse(0, 0, zone.radius, zone.radius * 0.5, 0, 0, Math.PI * 2);
      ctx.fill();
      
      // Border - warning color
      ctx.strokeStyle = `rgba(150, 100, 50, ${alpha * 1.5})`;
      ctx.lineWidth = 2;
      ctx.setLineDash([5, 5]);
      ctx.stroke();
      ctx.setLineDash([]);
      
      // Draw caltrops (small triangular spikes)
      const caltropCount = 12;
      for (let i = 0; i < caltropCount; i++) {
        const angle = (i / caltropCount) * Math.PI * 2 + zone.life * 0.1;
        const dist = zone.radius * (0.3 + (i % 3) * 0.25);
        const cx = Math.cos(angle) * dist;
        const cy = Math.sin(angle) * dist * 0.5;  // Flatten for isometric
        
        // Individual caltrop
        ctx.fillStyle = `rgba(120, 120, 130, ${alpha * 2})`;
        ctx.beginPath();
        ctx.moveTo(cx, cy - 6);  // Top spike
        ctx.lineTo(cx - 4, cy + 3);
        ctx.lineTo(cx + 4, cy + 3);
        ctx.closePath();
        ctx.fill();
        
        // Metallic highlight
        ctx.fillStyle = `rgba(180, 180, 190, ${alpha})`;
        ctx.beginPath();
        ctx.moveTo(cx, cy - 5);
        ctx.lineTo(cx - 1, cy);
        ctx.lineTo(cx + 1, cy);
        ctx.closePath();
        ctx.fill();
      }
      
      ctx.restore();
    }
  }
  
  // Guardian Hazards (Greater Rift boss mechanics)
  if (greaterRiftActive && guardianHazards.length > 0) {
    drawGuardianHazards(ctx);
  }
  
  // Particles
  for (let i = 0; i < particles.length; i++) {
    const p = particles[i];
    ctx.globalAlpha = p.life / 20;
    ctx.fillStyle = p.color;
    ctx.beginPath();
    ctx.arc(p.x, p.y, p.size * (p.life / 20), 0, Math.PI * 2);
    ctx.fill();
  }
  ctx.globalAlpha = 1;
  
  // Progress orbs (GR boss kill rewards)
  if (progressOrbs.length > 0) {
    renderProgressOrbs(ctx);
  }
  
  // Damage numbers (canvas-rendered)
  ctx.font = 'bold 18px Inter, sans-serif';
  ctx.textAlign = 'center';
  for (let i = 0; i < damageNumbers.length; i++) {
    const d = damageNumbers[i];
    // Format amount - round numbers, keep strings (MISS, DODGE, etc)
    const displayAmount = typeof d.amount === 'number' ? Math.round(d.amount) : d.amount;
    ctx.globalAlpha = Math.min(1, d.life / 20);
    ctx.fillStyle = '#000';
    ctx.fillText(displayAmount, d.x + 1, d.y + 1);
    ctx.fillStyle = d.color;
    ctx.fillText(displayAmount, d.x, d.y);
  }
  ctx.globalAlpha = 1;
  
  // Loot popups (canvas-rendered with full item stats)
  // Sort by priority so better items render on top
  const sortedPopups = [...lootPopups].sort((a, b) => (a.priority || 1) - (b.priority || 1));
  for (let i = 0; i < sortedPopups.length; i++) {
    const p = sortedPopups[i];
    const fadeIn = Math.min(1, (p.maxLife - p.life) / 10); // Quick fade in
    const fadeOut = Math.min(1, p.life / 30); // Slow fade out
    ctx.globalAlpha = Math.min(fadeIn, fadeOut);
    
    // Calculate box dimensions based on content
    const lines = p.lines || [{ text: p.name, color: p.color, size: 14, bold: true }];
    const padding = 10;
    const lineHeight = 16;
    let maxWidth = 0;
    
    // Measure all lines
    for (const line of lines) {
      if (line.type === 'sockets') continue;
      ctx.font = `${line.bold ? 'bold ' : ''}${line.size || 12}px Inter, sans-serif`;
      const w = ctx.measureText(line.text).width;
      if (line.tier) {
        // Add space for tier indicator
        maxWidth = Math.max(maxWidth, w + 30);
      } else {
        maxWidth = Math.max(maxWidth, w);
      }
    }
    
    const boxWidth = maxWidth + padding * 2;
    const boxHeight = lines.length * lineHeight + padding * 2;
    const boxX = p.x - boxWidth / 2;
    const boxY = p.y - boxHeight / 2;
    
    // Background box with rarity glow
    ctx.fillStyle = 'rgba(20,20,30,0.95)';
    ctx.strokeStyle = p.glow;
    ctx.lineWidth = 2;
    
    // Rounded rectangle
    const radius = 6;
    ctx.beginPath();
    ctx.moveTo(boxX + radius, boxY);
    ctx.lineTo(boxX + boxWidth - radius, boxY);
    ctx.quadraticCurveTo(boxX + boxWidth, boxY, boxX + boxWidth, boxY + radius);
    ctx.lineTo(boxX + boxWidth, boxY + boxHeight - radius);
    ctx.quadraticCurveTo(boxX + boxWidth, boxY + boxHeight, boxX + boxWidth - radius, boxY + boxHeight);
    ctx.lineTo(boxX + radius, boxY + boxHeight);
    ctx.quadraticCurveTo(boxX, boxY + boxHeight, boxX, boxY + boxHeight - radius);
    ctx.lineTo(boxX, boxY + radius);
    ctx.quadraticCurveTo(boxX, boxY, boxX + radius, boxY);
    ctx.closePath();
    ctx.fill();
    ctx.stroke();
    
    // Extra glow for unique items
    if (p.rarity === 'unique') {
      ctx.strokeStyle = 'rgba(255,136,68,0.4)';
      ctx.lineWidth = 5;
      ctx.stroke();
    } else if (p.rarity === 'rare') {
      ctx.strokeStyle = 'rgba(255,255,68,0.3)';
      ctx.lineWidth = 4;
      ctx.stroke();
    }
    
    // Draw lines
    ctx.textAlign = 'center';
    let yOffset = boxY + padding + 12;
    
    for (const line of lines) {
      if (line.type === 'sockets') {
        // Draw socket circles
        const socketColors = { red: '#ff4444', green: '#44ff44', blue: '#4444ff', white: '#ffffff' };
        const socketCount = line.sockets.length;
        const socketSpacing = 14;
        const startX = p.x - (socketCount - 1) * socketSpacing / 2;
        
        for (let s = 0; s < socketCount; s++) {
          const sx = startX + s * socketSpacing;
          const socket = line.sockets[s];
          
          // Socket background
          ctx.fillStyle = '#222';
          ctx.beginPath();
          ctx.arc(sx, yOffset - 4, 6, 0, Math.PI * 2);
          ctx.fill();
          
          // Socket color ring
          ctx.strokeStyle = socketColors[socket.color] || '#888';
          ctx.lineWidth = 2;
          ctx.stroke();
          
          // Empty socket indicator
          ctx.fillStyle = '#444';
          ctx.beginPath();
          ctx.arc(sx, yOffset - 4, 3, 0, Math.PI * 2);
          ctx.fill();
        }
        yOffset += lineHeight;
      } else {
        ctx.font = `${line.bold ? 'bold ' : ''}${line.size || 12}px Inter, sans-serif`;
        
        // Highlight for damage values
        if (line.highlight) {
          // Split text to highlight the numbers
          const parts = line.text.split(': ');
          if (parts.length === 2) {
            ctx.fillStyle = '#888';
            const labelWidth = ctx.measureText(parts[0] + ': ').width;
            ctx.textAlign = 'left';
            ctx.fillText(parts[0] + ': ', p.x - maxWidth/2, yOffset);
            ctx.fillStyle = '#ffffff';
            ctx.fillText(parts[1], p.x - maxWidth/2 + labelWidth, yOffset);
            ctx.textAlign = 'center';
          } else {
            ctx.fillStyle = line.color;
            ctx.fillText(line.text, p.x, yOffset);
          }
        } else {
          ctx.fillStyle = line.color;
          ctx.fillText(line.text, p.x, yOffset);
        }
        
        // Tier indicator with color coding (T1 = gold, T2 = purple, T3 = blue, T4 = green, T5+ = gray)
        if (line.tier) {
          const tierColors = {
            1: '#ffcc00', // Gold - best tier
            2: '#cc88ff', // Purple
            3: '#4488ff', // Blue
            4: '#44cc44', // Green
            5: '#888888', // Gray
          };
          const tierColor = tierColors[line.tier] || tierColors[5];
          ctx.font = 'bold 9px Inter, sans-serif';
          ctx.fillStyle = tierColor;
          ctx.textAlign = 'right';
          ctx.fillText(`T${line.tier}`, boxX + boxWidth - padding, yOffset);
          ctx.textAlign = 'center';
        }
        
        yOffset += lineHeight;
      }
    }
  }
  ctx.globalAlpha = 1;
  
  // Salvage popups (UI overlay - not affected by camera)
  for (let i = 0; i < salvagePopups.length; i++) {
    const p = salvagePopups[i];
    const fadeIn = Math.min(1, (p.maxLife - p.life) / 10);
    const fadeOut = Math.min(1, p.life / 30);
    ctx.globalAlpha = Math.min(fadeIn, fadeOut);
    
    // Calculate box dimensions
    const lines = p.lines;
    const padding = 10;
    const lineHeight = 18;
    let maxWidth = 0;
    
    for (const line of lines) {
      ctx.font = `${line.bold ? 'bold ' : ''}${line.size || 12}px Inter, sans-serif`;
      maxWidth = Math.max(maxWidth, ctx.measureText(line.text).width);
    }
    
    const boxWidth = maxWidth + padding * 2;
    const boxHeight = lines.length * lineHeight + padding * 2;
    
    // Position in screen space (not world space)
    const screenX = p.x;
    const screenY = p.y - (p.maxLife - p.life) * 0.3; // Float up slightly
    const boxX = screenX - boxWidth / 2;
    const boxY = screenY - boxHeight / 2;
    
    // Background with glow based on reward
    if (p.hasReward) {
      ctx.shadowColor = '#ffaa44';
      ctx.shadowBlur = 15;
    }
    
    ctx.fillStyle = 'rgba(15, 15, 20, 0.95)';
    ctx.strokeStyle = p.hasReward ? '#ffaa44' : '#44aa44';
    ctx.lineWidth = 2;
    
    // Rounded rectangle
    const radius = 8;
    ctx.beginPath();
    ctx.moveTo(boxX + radius, boxY);
    ctx.lineTo(boxX + boxWidth - radius, boxY);
    ctx.quadraticCurveTo(boxX + boxWidth, boxY, boxX + boxWidth, boxY + radius);
    ctx.lineTo(boxX + boxWidth, boxY + boxHeight - radius);
    ctx.quadraticCurveTo(boxX + boxWidth, boxY + boxHeight, boxX + boxWidth - radius, boxY + boxHeight);
    ctx.lineTo(boxX + radius, boxY + boxHeight);
    ctx.quadraticCurveTo(boxX, boxY + boxHeight, boxX, boxY + boxHeight - radius);
    ctx.lineTo(boxX, boxY + radius);
    ctx.quadraticCurveTo(boxX, boxY, boxX + radius, boxY);
    ctx.closePath();
    ctx.fill();
    ctx.stroke();
    
    ctx.shadowBlur = 0;
    
    // Draw lines
    ctx.textAlign = 'center';
    let yOffset = boxY + padding + 14;
    
    for (const line of lines) {
      ctx.font = `${line.bold ? 'bold ' : ''}${line.size || 12}px Inter, sans-serif`;
      ctx.fillStyle = line.color;
      ctx.fillText(line.text, screenX, yOffset);
      yOffset += lineHeight;
    }
  }
  ctx.globalAlpha = 1;
  
  // Debug rendering
  if (debugMode) {
    // Draw path
    if (path.length > 0) {
      ctx.strokeStyle = '#0f0';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(player.x, player.y);
      for (const wp of path) {
        ctx.lineTo(wp.x, wp.y);
      }
      ctx.stroke();
    }
    
    // Draw exit portal entry radius
    if (exitPos) {
      // Draw force-enter radius (1.5 tiles) in green
      ctx.strokeStyle = '#0f0';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(exitPos.x, exitPos.y, TILE * 1.5, 0, Math.PI * 2);
      ctx.stroke();
      
      // Draw normal entry radius (4 tiles) in yellow
      ctx.strokeStyle = '#ff0';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.arc(exitPos.x, exitPos.y, TILE * 4, 0, Math.PI * 2);
      ctx.stroke();
      
      // Distance to portal text (above portal, not player)
      const exitDist = Math.hypot(exitPos.x - player.x, exitPos.y - player.y);
      ctx.fillStyle = '#ff0';
      ctx.font = 'bold 14px monospace';
      ctx.textAlign = 'center';
      ctx.fillText(`${Math.round(exitDist)}px`, exitPos.x, exitPos.y - 50);
      ctx.textAlign = 'left';
    }
    
    // Player hitbox
    ctx.strokeStyle = '#f00';
    ctx.lineWidth = 1;
    ctx.strokeRect(player.x - PLAYER_RADIUS, player.y - PLAYER_RADIUS, PLAYER_RADIUS * 2, PLAYER_RADIUS * 2);
    
    // Player state text (above player's head)
    ctx.fillStyle = '#0f0';
    ctx.font = '11px monospace';
    ctx.fillText(`${player.state} | path:${path.length}`, player.x - 40, player.y - 40);
  }
  
  ctx.restore();
  
  renderMinimap();
}

function renderMinimap() {
  mmCtx.fillStyle = '#0a0a0f';
  mmCtx.fillRect(0, 0, 180, 180);
  
  // Dynamic scale based on map size
  const scale = Math.min(2.5, 160 / Math.max(map.width, map.height));
  const ox = 90 - (player.x / TILE) * scale;
  const oy = 90 - (player.y / TILE) * scale;
  
  for (let y = 0; y < map.height; y++) {
    for (let x = 0; x < map.width; x++) {
      if (!map.explored[y]?.[x]) continue;
      const t = map.tiles[y][x];
      if (t === 1) {
        mmCtx.fillStyle = '#3a3535';
        mmCtx.fillRect(ox + x * scale, oy + y * scale, scale, scale);
      } else if (t === 2) {
        mmCtx.fillStyle = '#4a4545';
        mmCtx.fillRect(ox + x * scale, oy + y * scale, scale, scale);
      }
    }
  }
  
  if (exitPos) {
    mmCtx.fillStyle = '#5af';
    mmCtx.beginPath();
    mmCtx.arc(ox + (exitPos.x / TILE) * scale, oy + (exitPos.y / TILE) * scale, 3, 0, Math.PI * 2);
    mmCtx.fill();
  }
  
  mmCtx.fillStyle = '#c44';
  for (let i = 0; i < enemies.length; i++) {
    const e = enemies[i];
    if (e.active) {
      mmCtx.beginPath();
      mmCtx.arc(ox + (e.x / TILE) * scale, oy + (e.y / TILE) * scale, 2, 0, Math.PI * 2);
      mmCtx.fill();
    }
  }
  
  mmCtx.fillStyle = '#4f4';
  mmCtx.beginPath();
  mmCtx.arc(90, 90, 4, 0, Math.PI * 2);
  mmCtx.fill();
}

// ============ HELPERS ============
function spawnParticles(x, y, n, color) {
  const maxToSpawn = Math.min(n, MAX_PARTICLES - particles.length);
  for (let i = 0; i < maxToSpawn; i++) {
    addParticle({
      x, y,
      vx: (Math.random() - 0.5) * 5,
      vy: (Math.random() - 0.5) * 5,
      color,
      size: 2 + Math.random() * 3,
      life: 15 + Math.random() * 10,
    });
  }
}

function showDamage(x, y, amount, color) {
  if (damageNumbers.length >= MAX_DAMAGE_NUMBERS) {
    damageNumbers.shift();
  }
  damageNumbers.push({
    x, y,
    amount,
    color,
    life: 45,
    vy: -2
  });
}

function addLog(msg, type) {
  const log = DOM.log || document.getElementById('combatLog');
  if (!log) return;
  const div = document.createElement('div');
  div.className = `log-${type}`;
  div.textContent = msg;
  log.appendChild(div);
  log.scrollTop = log.scrollHeight;
  while (log.children.length > 40) log.removeChild(log.firstChild);
}

// ============ BUFF/DEBUFF BAR SYSTEM ============
// Collect all active buffs/debuffs on the player
function getActiveBuffs() {
  const buffs = [];
  
  // Energy Armor (Mage defensive)
  if (player.energyArmorDuration && player.energyArmorDuration > 0) {
    buffs.push({
      id: 'energyArmor',
      icon: '🛡️',
      name: 'Energy Armor',
      desc: `+${Math.floor(player.energyArmorBonus * 100)}% Shield, ${Math.floor(player.energyArmorDR * 100)}% DR`,
      duration: player.energyArmorDuration,
      type: 'buff'
    });
  }
  
  // War Cry (Warrior buff)
  if (player.warCryDuration && player.warCryDuration > 0) {
    buffs.push({
      id: 'warCry',
      icon: '📢',
      name: 'War Cry',
      desc: `+${Math.floor((player.warCryBonus || 0.25) * 100)}% Damage`,
      duration: player.warCryDuration,
      type: 'buff'
    });
  }
  
  // Cyclone Active (Monk)
  if (cycloneActive && player.cycloneDuration && player.cycloneDuration > 0) {
    buffs.push({
      id: 'cyclone',
      icon: '🌀',
      name: 'Cyclone',
      desc: 'Spinning and damaging nearby enemies',
      duration: player.cycloneDuration,
      type: 'buff'
    });
  }
  
  // Potion cooldowns as debuffs
  if (potions.life.cooldown > 0) {
    buffs.push({
      id: 'lifePotionCD',
      icon: '❤️',
      name: 'Life Potion Cooldown',
      desc: 'Cannot use life potion',
      duration: potions.life.cooldown,
      type: 'debuff'
    });
  }
  
  if (potions.mana.cooldown > 0) {
    buffs.push({
      id: 'manaPotionCD',
      icon: '💧',
      name: 'Mana Potion Cooldown',
      desc: 'Cannot use mana potion',
      duration: potions.mana.cooldown,
      type: 'debuff'
    });
  }
  
  return buffs;
}

// Buff bar cache to prevent memory leak from recreating elements every frame
let buffBarCache = { state: '', elements: new Map() };

// Update the buff bar display - OPTIMIZED to avoid memory leak
function updateBuffBar() {
  const buffBar = DOM.buffBar || document.getElementById('buffBar');
  if (!buffBar) return;
  
  const buffs = getActiveBuffs();
  
  // Create a state string to detect actual changes (include duration for timer updates)
  const newState = buffs.map(b => `${b.id}:${b.duration.toFixed(1)}`).join(',');
  
  // Skip DOM manipulation if nothing changed
  if (newState === buffBarCache.state) return;
  buffBarCache.state = newState;
  
  // Track which buff IDs are currently active
  const currentIds = new Set(buffs.map(b => b.id));
  
  // Remove elements for buffs that are no longer active
  buffBarCache.elements.forEach((el, id) => {
    if (!currentIds.has(id)) {
      el.remove();
      buffBarCache.elements.delete(id);
    }
  });
  
  // Update existing or create new elements
  buffs.forEach(buff => {
    let buffEl = buffBarCache.elements.get(buff.id);
    
    if (!buffEl) {
      // Create new element only if it doesn't exist
      buffEl = document.createElement('div');
      buffEl.className = `buff-icon ${buff.type}`;
      
      // Tooltip events - only added once per element!
      buffEl.addEventListener('mouseenter', showBuffTooltip);
      buffEl.addEventListener('mouseleave', hideBuffTooltip);
      
      buffBarCache.elements.set(buff.id, buffEl);
      buffBar.appendChild(buffEl);
    }
    
    // Update class in case type changed
    buffEl.className = `buff-icon ${buff.type}`;
    
    // Update content
    buffEl.innerHTML = `
      <span>${buff.icon}</span>
      ${buff.duration > 0 ? `<span class="buff-duration">${buff.duration.toFixed(1)}</span>` : ''}
    `;
    
    // Store buff data for tooltip
    buffEl.dataset.buffId = buff.id;
    buffEl.dataset.buffName = buff.name;
    buffEl.dataset.buffDesc = buff.desc;
    buffEl.dataset.buffDuration = buff.duration;
    buffEl.dataset.buffType = buff.type;
  });
}

// Show buff tooltip
function showBuffTooltip(event) {
  const tooltip = DOM.buffTooltip || document.getElementById('buffTooltip');
  if (!tooltip) return;
  
  const el = event.currentTarget;
  const nameEl = DOM.buffTooltipName || document.getElementById('buffTooltipName');
  const descEl = DOM.buffTooltipDesc || document.getElementById('buffTooltipDesc');
  const timeEl = DOM.buffTooltipTime || document.getElementById('buffTooltipTime');
  
  nameEl.textContent = el.dataset.buffName;
  nameEl.className = `buff-tooltip-name ${el.dataset.buffType}`;
  descEl.textContent = el.dataset.buffDesc;
  
  const duration = parseFloat(el.dataset.buffDuration);
  if (duration < 0) {
    timeEl.textContent = 'Permanent (while equipped)';
  } else {
    timeEl.textContent = `${duration.toFixed(1)}s remaining`;
  }
  
  tooltip.classList.add('visible');
  
  // Position above the buff icon
  const rect = el.getBoundingClientRect();
  tooltip.style.left = rect.left + 'px';
  tooltip.style.top = (rect.top - tooltip.offsetHeight - 8) + 'px';
}

// Hide buff tooltip
function hideBuffTooltip() {
  const tooltip = DOM.buffTooltip || document.getElementById('buffTooltip');
  if (tooltip) tooltip.classList.remove('visible');
}

function updateUI() {
  // Calculate total pool (HP + Shield) for bar display
  const totalPool = player.maxHp + player.shield;
  
  // Health bar width = HP as percentage of TOTAL pool (not just maxHP)
  // This way shield + health fill the bar proportionally
  const healthPct = (player.hp / totalPool * 100);
  const shieldPct = (player.currentShield / totalPool * 100);
  
  // Position health bar AFTER the shield bar (using cached elements)
  if (DOM.healthBar) {
    DOM.healthBar.style.width = healthPct + '%';
    DOM.healthBar.style.left = shieldPct + '%';
  }
  
  // Shield overlay from left
  if (DOM.shieldBar) {
    if (player.shield > 0) {
      DOM.shieldBar.style.width = shieldPct + '%';
    } else {
      DOM.shieldBar.style.width = '0%';
      if (DOM.healthBar) DOM.healthBar.style.left = '0%';
    }
  }
  
  if (DOM.manaBar) DOM.manaBar.style.width = (player.mana / player.maxMana * 100) + '%';
  
  // Show combined HP+Shield when player has shield capacity
  if (DOM.healthText) {
    if (player.shield > 0) {
      const currentTotal = Math.floor(player.hp) + Math.floor(player.currentShield);
      const maxTotal = player.maxHp + player.shield;
      DOM.healthText.textContent = `${currentTotal}/${maxTotal}`;
    } else {
      DOM.healthText.textContent = `${Math.floor(player.hp)}/${player.maxHp}`;
    }
  }
  if (DOM.manaText) DOM.manaText.textContent = `${Math.floor(player.mana)}/${player.maxMana}`;
  if (DOM.lifeOnHitText) DOM.lifeOnHitText.textContent = `+${player.lifeOnHit}/hit`;
  if (DOM.manaOnHitText) DOM.manaOnHitText.textContent = `+${player.manaOnHit}/hit`;
  
  if (DOM.expBar) DOM.expBar.style.width = (player.exp / player.expToLevel * 100) + '%';
  if (DOM.levelBadge) DOM.levelBadge.textContent = player.level;
  
  // Update portrait ring to show XP progress
  if (DOM.portraitRing) {
    const expPct = (player.exp / player.expToLevel * 100) + '%';
    DOM.portraitRing.style.setProperty('--exp-pct', expPct);
  }
  
  // Update debug panel if visible
  if (debugMode) {
    updateDebugPanel();
  }
  
  // Update buff/debuff bar
  updateBuffBar();
}

function updateDebugPanel() {
  const panel = DOM.debugPanel || document.getElementById('debugPanel');
  if (!panel) return;
  
  panel.classList.toggle('visible', debugMode);
  
  // Test mode indicator
  const testEl = DOM.dbgTestMode || document.getElementById('dbgTestMode');
  if (testEl) testEl.style.display = testMode ? 'block' : 'none';
  
  const stateEl = DOM.dbgState || document.getElementById('dbgState');
  const posEl = DOM.dbgPos || document.getElementById('dbgPos');
  if (stateEl) stateEl.textContent = player.state;
  if (posEl) posEl.textContent = `${Math.floor(player.x)}, ${Math.floor(player.y)}`;
  
  // Target info
  const active = enemies.filter(e => e.active && !e.dead);
  const targetEl = document.getElementById('dbgTarget');
  if (targetEl) {
    if (active.length > 0) {
      const nearest = active.sort((a, b) => 
        Math.hypot(a.x - player.x, a.y - player.y) - Math.hypot(b.x - player.x, b.y - player.y)
      )[0];
      const dist = Math.hypot(nearest.x - player.x, nearest.y - player.y);
      targetEl.textContent = `enemy (${Math.floor(dist)}px)`;
    } else if (exitPos && map.rooms.every(r => r.cleared)) {
      targetEl.textContent = 'exit portal';
    } else {
      targetEl.textContent = 'exploring';
    }
  }
  
  const pathEl = document.getElementById('dbgPath');
  if (pathEl) {
    pathEl.textContent = path.length === 0 ? '0 (FAIL!)' : path.length;
    pathEl.style.color = path.length === 0 ? '#f00' : '#0f0';
  }
  
  // Combat info
  const combatEl = document.getElementById('dbgCombat');
  if (combatEl) {
    const isRanged = player.class === 'ranger' || player.class === 'mage';
    const atkRange = isRanged ? TILE * 8 : TILE * 1.5;
    
    // Include close enemies even if unreachable
    let active = enemies.filter(e => e.active && !e.dead && !e.unreachable);
    if (active.length === 0) {
      active = enemies.filter(e => e.active && !e.dead && Math.hypot(e.x - player.x, e.y - player.y) < atkRange);
    }
    
    if (active.length > 0) {
      active.sort((a, b) => Math.hypot(a.x - player.x, a.y - player.y) - Math.hypot(b.x - player.x, b.y - player.y));
      const nearest = active[0];
      const dist = Math.hypot(nearest.x - player.x, nearest.y - player.y);
      const hasLOS = hasLineOfSight(player.x, player.y, nearest.x, nearest.y);
      const inRange = dist < atkRange;
      const tooClose = isRanged && dist < TILE * 3.5;
      
      let status = [];
      if (hasLOS) status.push('LOS✓');
      else status.push('LOS✗');
      if (inRange) status.push('RNG✓');
      if (tooClose) status.push('KITE');
      if (nearest.unreachable) status.push('UNREACH');
      status.push(`${Math.floor(dist)}px`);
      
      combatEl.textContent = status.join(' ');
      combatEl.style.color = hasLOS ? '#0f0' : '#f80';
    } else {
      combatEl.textContent = 'no enemies';
      combatEl.style.color = '#888';
    }
  }
  
  if (exitPos) {
    document.getElementById('dbgExit').textContent = `${Math.floor(exitPos.x)}, ${Math.floor(exitPos.y)}`;
    const exitDist = Math.hypot(exitPos.x - player.x, exitPos.y - player.y);
    const exitTiles = (exitDist / TILE).toFixed(1);
    document.getElementById('dbgExitDist').textContent = `${Math.floor(exitDist)}px (${exitTiles} tiles)`;
  } else {
    document.getElementById('dbgExit').textContent = 'none';
    document.getElementById('dbgExitDist').textContent = '-';
  }
  
  const cleared = map.rooms.filter(r => r.cleared).length;
  document.getElementById('dbgCleared').textContent = `${cleared}/${map.rooms.length}`;
  document.getElementById('dbgEnemies').textContent = enemies.filter(e => !e.dead).length;
  document.getElementById('dbgStuck').textContent = (window.lastStuckCheck || 0) + ' (pos: ' + (window.positionHistory ? window.positionHistory.length : 0) + ')';
  document.getElementById('dbgEntering').textContent = enteringPortal;
  document.getElementById('dbgEntering').style.color = enteringPortal ? '#f00' : '#0f0';
  document.getElementById('dbgTimeout').textContent = Math.floor(window.portalTimeout || 0);
  
  // Warning message
  const warn = document.getElementById('dbgWarn');
  if (exitPos) {
    const exitDist = Math.hypot(exitPos.x - player.x, exitPos.y - player.y);
    const allCleared = map.rooms.every(r => r.cleared);
    
    if (enteringPortal) {
      warn.textContent = '⏳ enteringPortal=true (waiting)';
      warn.className = 'debug-line debug-warn';
    } else if (!allCleared && exitDist < TILE * 4) {
      warn.textContent = '❌ Rooms not cleared!';
      warn.className = 'debug-line debug-error';
    } else if (allCleared && exitDist < TILE * 4) {
      warn.textContent = '⚠️ SHOULD ENTER NOW!';
      warn.className = 'debug-line debug-error';
    } else if (allCleared && exitDist < TILE * 6) {
      warn.textContent = '⚠️ Close to portal';
      warn.className = 'debug-line debug-warn';
    } else {
      warn.textContent = '';
    }
  } else {
    warn.textContent = '';
  }
}

function updateStats() {
  document.getElementById('statDamage').textContent = `${player.minDmg}-${player.maxDmg}`;
  document.getElementById('statArmor').textContent = player.armor;
  document.getElementById('statKills').textContent = player.kills;
  document.getElementById('statGold').textContent = player.gold;
}

// ========== SAVE/LOAD GAME SYSTEM ==========
function getCharacterSaveKey() {
  // Generate unique key for current character based on name and class
  if (selectedCharacter !== null && characters[selectedCharacter]) {
    const char = characters[selectedCharacter];
    return `poe2idle_char_${char.name}_${char.class.toLowerCase()}`;
  }
  return null;
}

function saveGame() {
  try {
    // ========== ACCOUNT-WIDE DATA (shared across all characters) ==========
    const accountData = {
      version: 2,
      timestamp: Date.now(),
      // Shared resources
      gold: player.gold,
      stashItems: stashItems,           // Stash tab items
      stashCurrency: stash,             // Crafting materials
      gemInventory: gemInventory,       // Support gems
      shards: shards,                   // Shard currencies
      greaterRiftKeys: greaterRiftKeys, // GR keys
      // Character list for menu
      characterList: characters
    };
    localStorage.setItem('poe2idle_account', JSON.stringify(accountData));
    
    // ========== PER-CHARACTER DATA ==========
    const charKey = getCharacterSaveKey();
    if (charKey) {
      const charData = {
        version: 2,
        timestamp: Date.now(),
        player: {
          class: player.class,
          level: player.level,
          exp: player.exp,
          expToLevel: player.expToLevel,
          kills: player.kills,
          totalCrafts: player.totalCrafts || 0,
          skin: player.skin,
          echoCores: player.echoCores || 0,
          currency: player.currency || {}
        },
        dungeonLevel: dungeon.level,
        dungeonDifficulty: currentDifficulty,
        equipment: equipment,
        inventory: inventoryItems,
        equippedSkills: equippedSkills,
        skillAIPriority: skillAIPriority,
        overflow: overflowItems,
        overflowCapacity: overflowCapacity,
        passiveTree: {
          allocated: Array.from(allocatedPassives),
          points: passivePoints,
          spent: passivePointsSpent
        },
        greaterRiftHighest: greaterRiftHighest
      };
      localStorage.setItem(charKey, JSON.stringify(charData));
      
      // Update character in list with current level
      if (selectedCharacter !== null && characters[selectedCharacter]) {
        characters[selectedCharacter].level = player.level;
        characters[selectedCharacter].skin = player.skin;
      }
    }
    
    console.log('Game saved');
    
    // Steam integration: trigger cloud save (debounced)
    onGameSave_Steam();
  } catch (e) {
    console.error('Failed to save game:', e);
  }
}

function loadAccountData() {
  // Load account-wide shared data
  try {
    const accountStr = localStorage.getItem('poe2idle_account');
    if (!accountStr) return false;
    
    const accountData = JSON.parse(accountStr);
    
    // Restore shared resources
    if (accountData.gold !== undefined) player.gold = accountData.gold;
    
    if (accountData.stashItems) {
      stashItems.length = 0;
      stashItems.push(...accountData.stashItems);
      stashGridNeedsRebuild = true;
    }
    
    if (accountData.stashCurrency) {
      Object.assign(stash, accountData.stashCurrency);
    }
    
    if (accountData.gemInventory && Array.isArray(accountData.gemInventory)) {
      gemInventory.length = 0;
      gemInventory.push(...accountData.gemInventory);
    }
    
    if (accountData.shards) {
      shards = { ...shards, ...accountData.shards };
    }
    
    if (accountData.greaterRiftKeys !== undefined) {
      greaterRiftKeys = accountData.greaterRiftKeys;
    }
    
    // Restore character list
    if (accountData.characterList && Array.isArray(accountData.characterList)) {
      characters.length = 0;
      characters.push(...accountData.characterList);
    }
    
    return true;
  } catch (e) {
    console.error('Failed to load account data:', e);
    return false;
  }
}

function loadCharacterData() {
  // Load per-character data for currently selected character
  const charKey = getCharacterSaveKey();
  if (!charKey) return false;
  
  try {
    const charStr = localStorage.getItem(charKey);
    if (!charStr) {
      // No save for this character - start fresh
      resetCharacterData();
      return false;
    }
    
    const charData = JSON.parse(charStr);
    
    // Restore player stats (but NOT gold - that's account-wide)
    if (charData.player) {
      player.class = charData.player.class;
      player.level = charData.player.level;
      player.exp = charData.player.exp || 0;
      player.expToLevel = charData.player.expToLevel || 100;
      player.kills = charData.player.kills || 0;
      player.totalCrafts = charData.player.totalCrafts || 0;
      player.skin = charData.player.skin || 'default';
      player.echoCores = charData.player.echoCores || 0;
      player.currency = charData.player.currency || {};
    }
    
    // Restore dungeon progress
    if (charData.dungeonLevel !== undefined) {
      dungeon.level = charData.dungeonLevel;
    }
    if (charData.dungeonDifficulty && DUNGEON_DIFFICULTIES[charData.dungeonDifficulty]) {
      currentDifficulty = charData.dungeonDifficulty;
    }
    
    // Restore equipment (always clear first to avoid cross-contamination)
    Object.keys(equipment).forEach(slot => equipment[slot] = null);
    if (charData.equipment) {
      Object.assign(equipment, charData.equipment);
    }
    
    // Restore inventory (always clear first)
    inventoryItems.length = 0;
    gridNeedsRebuild = true;
    if (charData.inventory) {
      inventoryItems.push(...charData.inventory);
    }
    
    // Restore equipped skills (always clear first)
    equippedSkills.length = 0;
    if (charData.equippedSkills && Array.isArray(charData.equippedSkills)) {
      equippedSkills.length = 0;
      equippedSkills.push(...charData.equippedSkills);
    }
    
    // Restore AI priority settings (always reset first)
    skillAIPriority = [2, 2, 2, 2, 2];
    if (charData.skillAIPriority && Array.isArray(charData.skillAIPriority)) {
      skillAIPriority = [...charData.skillAIPriority];
      while (skillAIPriority.length < 5) skillAIPriority.push(2);
    }
    
    // Restore overflow items (always clear first)
    overflowItems = [];
    overflowCapacity = OVERFLOW_BASE_CAPACITY;
    if (charData.overflow) {
      overflowItems = charData.overflow;
      sortOverflowByTier();
    }
    if (charData.overflowCapacity !== undefined) {
      overflowCapacity = charData.overflowCapacity;
    }
    
    // Restore passive tree (always reset first)
    allocatedPassives = new Set();
    passivePoints = 0;
    passivePointsSpent = 0;
    if (charData.passiveTree) {
      allocatedPassives = new Set(charData.passiveTree.allocated || []);
      passivePoints = charData.passiveTree.points || 0;
      passivePointsSpent = charData.passiveTree.spent || 0;
    }
    
    // Restore GR highest (always reset first)
    greaterRiftHighest = {};
    if (charData.greaterRiftHighest) {
      greaterRiftHighest = charData.greaterRiftHighest;
    }
    
    // Run migrations on loaded data
    migrateUniquesToRare();
    migrateItemImages();
    migrateArmorImplicits();
    reregisterUniqueEffects();
    
    console.log('Character data loaded:', charKey);
    return true;
  } catch (e) {
    console.error('Failed to load character data:', e);
    return false;
  }
}

function resetCharacterData() {
  // Reset all per-character data for a new character
  // Clear equipment
  Object.keys(equipment).forEach(slot => equipment[slot] = null);
  
  // Clear inventory
  inventoryItems.length = 0;
  gridNeedsRebuild = true;
  
  // Clear overflow
  overflowItems = [];
  overflowCapacity = OVERFLOW_BASE_CAPACITY;
  
  // Reset skills to class defaults
  const defaultSkills = DEFAULT_EQUIPPED_SKILLS[player.class] || DEFAULT_EQUIPPED_SKILLS.monk;
  equippedSkills.length = 0;
  equippedSkills.push(...defaultSkills);
  
  // Reset AI priority
  skillAIPriority = [2, 2, 2, 2, 2];
  
  // Reset passive tree
  allocatedPassives = new Set();
  passivePoints = Math.max(0, player.level - 1);
  passivePointsSpent = 0;
  
  // Reset dungeon
  dungeon.level = 1;
  currentDifficulty = 'easy'; // New characters start on Easy
  
  // Reset GR highest for this character
  greaterRiftHighest = {};
  
  // Reset player stats (keep gold from account)
  player.exp = 0;
  player.expToLevel = 100;
  player.kills = 0;
  player.echoCores = 0;
  player.currency = {};
  
  console.log('Character data reset for new character');
}

function loadGame() {
  // First load account-wide data
  loadAccountData();
  
  // Then load character-specific data if a character is selected
  if (selectedCharacter !== null) {
    loadCharacterData();
  }
  
  // MIGRATION: Handle old single-save format
  migrateOldSaveFormat();
  
  // MIGRATION: Ensure echo shards exist
  if (shards.echo === undefined || shards.echo === 0) {
    shards.echo = 100;
  }
  
  // Start with full HP, mana
  player.hp = player.maxHp;
  player.mana = player.maxMana;
  potions.life.cooldown = 0;
  potions.mana.cooldown = 0;
  updatePotionUI();
  updateShardDisplay();
  updateAllAIPipDisplays();
  
  console.log('Game loaded from save');
  return true;
}

function migrateOldSaveFormat() {
  // Check for old single-save format and migrate to new format
  try {
    const oldSaveStr = localStorage.getItem('poe2idle_save');
    if (!oldSaveStr) return;
    
    const oldSave = JSON.parse(oldSaveStr);
    if (!oldSave || oldSave.version >= 2) return; // Already migrated
    
    console.log('Migrating old save format...');
    
    // Extract account-wide data from old save
    if (oldSave.player?.gold !== undefined) player.gold = oldSave.player.gold;
    if (oldSave.stash) stashItems.push(...oldSave.stash);
    if (oldSave.stashCurrency) Object.assign(stash, oldSave.stashCurrency);
    if (oldSave.gemInventory) gemInventory.push(...oldSave.gemInventory);
    if (oldSave.shards) Object.assign(shards, oldSave.shards);
    if (oldSave.greaterRift?.keys) greaterRiftKeys = oldSave.greaterRift.keys;
    
    // Save in new format
    saveGame();
    
    // Remove old save key
    localStorage.removeItem('poe2idle_save');
    
    console.log('Migration complete');
  } catch (e) {
    console.error('Failed to migrate old save:', e);
  }
}

// Convert any ORPHAN unique items to rare (items marked unique but not in registry)
// Proper uniques from UNIQUE_ITEMS registry are kept as-is
function migrateUniquesToRare() {
  let converted = 0;
  
  const isProperUnique = (item) => item && item.isUnique && item.uniqueId && UNIQUE_ITEMS[item.uniqueId];
  
  // Convert equipment
  Object.keys(equipment).forEach(slot => {
    const item = equipment[slot];
    if (item && item.rarity === 'unique' && !isProperUnique(item)) {
      item.rarity = 'rare';
      converted++;
    }
  });
  
  // Convert inventory
  inventoryItems.forEach(item => {
    if (item && item.rarity === 'unique' && !isProperUnique(item)) {
      item.rarity = 'rare';
      converted++;
    }
  });
  
  // Convert stash
  stashItems.forEach(item => {
    if (item && item.rarity === 'unique' && !isProperUnique(item)) {
      item.rarity = 'rare';
      converted++;
    }
  });
  
  // Convert ground loot
  loot.forEach(item => {
    if (item && item.rarity === 'unique' && !isProperUnique(item)) {
      item.rarity = 'rare';
      converted++;
    }
  });
  
  // Convert overflow items
  overflowItems.forEach(item => {
    if (item && item.rarity === 'unique' && !isProperUnique(item)) {
      item.rarity = 'rare';
      converted++;
    }
  });
  
  if (converted > 0) {
    console.log(`Migrated ${converted} orphan unique items to rare`);
  }
}

// Assign images to items that should have them (for items loaded from old saves)
function migrateItemImages() {
  let updated = 0;
  
  const assignImageAndStats = (item) => {
    if (!item) return;
    
    // Assign image if missing
    if (!item.image) {
      const img = getItemImage(item.name);
      if (img) {
        item.image = img;
        updated++;
      }
    }
    
    // Fix base stats if missing for armor items
    const slot = getItemSlot(item.name);
    if (['body', 'helmet', 'gloves', 'boots'].includes(slot)) {
      const baseLevel = item.baseLevel || 1;
      const armorBaseType = getArmorBaseType(item.name);
      
      // Only set if not already set
      if (!item.baseArmor && !item.baseDodge && !item.baseShield) {
        const baseArmor = 20 + baseLevel * 3;
        const baseDodge = 15 + baseLevel * 2;
        const baseShield = 12 + baseLevel * 2;
        
        if (armorBaseType === 'str') item.baseArmor = baseArmor;
        else if (armorBaseType === 'dex') item.baseDodge = baseDodge;
        else if (armorBaseType === 'int') item.baseShield = baseShield;
        else if (armorBaseType === 'str_dex') { item.baseArmor = Math.floor(baseArmor * 0.55); item.baseDodge = Math.floor(baseDodge * 0.55); }
        else if (armorBaseType === 'str_int') { item.baseArmor = Math.floor(baseArmor * 0.55); item.baseShield = Math.floor(baseShield * 0.55); }
        else if (armorBaseType === 'dex_int') { item.baseDodge = Math.floor(baseDodge * 0.55); item.baseShield = Math.floor(baseShield * 0.55); }
      }
    }
  };
  
  // Update equipment
  Object.values(equipment).forEach(assignImageAndStats);
  
  // Update inventory
  inventoryItems.forEach(assignImageAndStats);
  
  // Update stash
  stashItems.forEach(assignImageAndStats);
  
  // Update ground loot
  loot.forEach(assignImageAndStats);
  
  // Update overflow items
  overflowItems.forEach(assignImageAndStats);
  
  if (updated > 0) {
    console.log(`Assigned images to ${updated} items`);
  }
}

// MIGRATION: Remove defense implicits from armor (base defense IS the identity)
function migrateArmorImplicits() {
  let removed = 0;
  
  const removeDefenseImplicit = (item) => {
    if (!item || !item.mods || !item.mods.implicit) return;
    
    const slot = getItemSlot(item.name);
    if (!['body', 'helmet', 'gloves', 'boots'].includes(slot)) return;
    
    // Check if implicit is a defense stat (redundant with base)
    const implicitStat = item.mods.implicit.stat || '';
    if (implicitStat.includes('Armor') || 
        implicitStat.includes('Armor') ||
        implicitStat.includes('Dodge') || 
        implicitStat.includes('Energy Shield') ||
        implicitStat.includes('Shield')) {
      item.mods.implicit = null;
      removed++;
    }
  };
  
  // Update equipment
  Object.values(equipment).forEach(removeDefenseImplicit);
  
  // Update inventory
  inventoryItems.forEach(removeDefenseImplicit);
  
  // Update stash
  stashItems.forEach(removeDefenseImplicit);
  
  // Update ground loot
  loot.forEach(removeDefenseImplicit);
  
  // Update overflow items
  overflowItems.forEach(removeDefenseImplicit);
  
  if (removed > 0) {
    console.log(`Removed ${removed} redundant defense implicits from armor`);
  }
}

function clearSave() {
  // Clear account data
  localStorage.removeItem('poe2idle_account');
  localStorage.removeItem('poe2idle_save'); // Old format
  
  // Clear all character saves
  const keysToRemove = [];
  for (let i = 0; i < localStorage.length; i++) {
    const key = localStorage.key(i);
    if (key && key.startsWith('poe2idle_char_')) {
      keysToRemove.push(key);
    }
  }
  keysToRemove.forEach(key => localStorage.removeItem(key));
  
  console.log('All saves cleared');
}

// ========== STEAM API INTEGRATION ==========
// Works with steamworks.js via window.steamapi (set up in preload.js)

// Achievement IDs - must match Steamworks configuration
window.ACHIEVEMENTS = {
  // Progress achievements
  FIRST_KILL: 'FIRST_KILL',
  KILL_100: 'KILL_100',
  KILL_1000: 'KILL_1000',
  KILL_10000: 'KILL_10000',
  
  // Level achievements
  LEVEL_10: 'LEVEL_10',
  LEVEL_25: 'LEVEL_25',
  LEVEL_50: 'LEVEL_50',
  LEVEL_75: 'LEVEL_75',
  LEVEL_100: 'LEVEL_100',
  
  // Greater Rift achievements
  GR_COMPLETE_1: 'GR_COMPLETE_1',
  GR_COMPLETE_10: 'GR_COMPLETE_10',
  GR_COMPLETE_25: 'GR_COMPLETE_25',
  GR_COMPLETE_50: 'GR_COMPLETE_50',
  GR_COMPLETE_100: 'GR_COMPLETE_100',
  
  // Class achievements
  PLAY_MONK: 'PLAY_MONK',
  PLAY_WARRIOR: 'PLAY_WARRIOR',
  PLAY_RANGER: 'PLAY_RANGER',
  PLAY_MAGE: 'PLAY_MAGE',
  
  // Difficulty achievements
  BEAT_EASY: 'BEAT_EASY',
  BEAT_NORMAL: 'BEAT_NORMAL',
  BEAT_HARD: 'BEAT_HARD',
  BEAT_ELITE: 'BEAT_ELITE',
  BEAT_NIGHTMARE: 'BEAT_NIGHTMARE',
  
  // Gold achievements
  GOLD_10K: 'GOLD_10K',
  GOLD_100K: 'GOLD_100K',
  GOLD_1M: 'GOLD_1M',
  
  // Item achievements
  EQUIP_RARE: 'EQUIP_RARE',
  EQUIP_UNIQUE: 'EQUIP_UNIQUE',
  FULL_RARE_SET: 'FULL_RARE_SET',
  
  // Crafting achievements
  CRAFT_FIRST: 'CRAFT_FIRST',
  CRAFT_100: 'CRAFT_100',
  
  // Passive tree achievements
  ALLOCATE_10: 'ALLOCATE_10',
  ALLOCATE_50: 'ALLOCATE_50',
  ALLOCATE_100: 'ALLOCATE_100',
  
  // Special achievements
  SURVIVE_DEATH: 'SURVIVE_DEATH',
  PLAY_1_HOUR: 'PLAY_1_HOUR',
  PLAY_10_HOURS: 'PLAY_10_HOURS',
  PLAY_100_HOURS: 'PLAY_100_HOURS'
};

// Leaderboard names - must match what you create in Steamworks
window.STEAM_LEADERBOARDS = {
  HIGHEST_LEVEL: 'highest_level',
  HIGHEST_GR: 'highest_gr',
  TOTAL_KILLS: 'total_kills',
  FASTEST_GR10: 'fastest_gr10',
  FASTEST_GR25: 'fastest_gr25',
  FASTEST_GR50: 'fastest_gr50'
};

// Helper to unlock achievement via steamworks.js (async)
window.unlockAchievement = async (achievementId) => {
  if (window.steamapi) {
    try {
      const isLoaded = await window.steamapi.isLoaded();
      if (isLoaded) {
        await window.steamapi.activateAchievement(achievementId);
        console.log('🏆 Achievement unlocked:', achievementId);
        // Show in-game notification
        const achName = achievementId.replace(/_/g, ' ').toLowerCase().replace(/\b\w/g, c => c.toUpperCase());
        showToast('🏆', 'Achievement Unlocked!', achName, 'legendary');
      }
    } catch (e) {
      console.error('Achievement error:', e);
    }
  }
};

// Steam Cloud save helper
window.steamCloudSave = async (data) => {
  if (window.steamapi) {
    try {
      const isLoaded = await window.steamapi.isLoaded();
      if (isLoaded) {
        await window.steamapi.cloudSave('corefall_save.json', data);
        console.log('☁️ Steam Cloud: Save uploaded');
        return true;
      }
    } catch (e) {
      console.error('Steam Cloud save error:', e);
    }
  }
  return false;
};

// Steam Cloud load helper
window.steamCloudLoad = async () => {
  if (window.steamapi && window.steamapi.cloudLoad) {
    try {
      const isLoaded = await window.steamapi.isLoaded();
      if (isLoaded) {
        const data = await window.steamapi.cloudLoad('corefall_save.json');
        if (data) {
          console.log('☁️ Steam Cloud: Save downloaded');
          return data;
        }
      }
    } catch (e) {
      console.error('Steam Cloud load error:', e);
    }
  }
  return null;
};

// Submit score to Steam leaderboards
window.submitToSteamLeaderboard = async (leaderboardName, score) => {
  if (!window.steamapi) return;
  
  try {
    const isLoaded = await window.steamapi.isLoaded();
    if (!isLoaded) return;
    
    await window.steamapi.uploadLeaderboardScore(leaderboardName, Math.floor(score));
    console.log(`📊 Leaderboard ${leaderboardName}: ${score}`);
  } catch (e) {
    console.error('Steam Leaderboard error:', e);
  }
};

// Check and trigger achievements based on game state
async function checkSteamAchievements() {
  if (!window.steamapi) return;
  
  try {
    const isLoaded = await window.steamapi.isLoaded();
    if (!isLoaded) return;
    
    // Kill achievements
    const totalKills = player.kills || 0;
    if (totalKills >= 1) window.unlockAchievement(window.ACHIEVEMENTS.FIRST_KILL);
    if (totalKills >= 100) window.unlockAchievement(window.ACHIEVEMENTS.KILL_100);
    if (totalKills >= 1000) window.unlockAchievement(window.ACHIEVEMENTS.KILL_1000);
    if (totalKills >= 10000) window.unlockAchievement(window.ACHIEVEMENTS.KILL_10000);
    
    // Level achievements
    if (player.level >= 10) window.unlockAchievement(window.ACHIEVEMENTS.LEVEL_10);
    if (player.level >= 25) window.unlockAchievement(window.ACHIEVEMENTS.LEVEL_25);
    if (player.level >= 50) window.unlockAchievement(window.ACHIEVEMENTS.LEVEL_50);
    if (player.level >= 75) window.unlockAchievement(window.ACHIEVEMENTS.LEVEL_75);
    if (player.level >= 100) window.unlockAchievement(window.ACHIEVEMENTS.LEVEL_100);
    
    // Class achievements (level 10+)
    if (player.level >= 10) {
      if (player.class === 'monk') window.unlockAchievement(window.ACHIEVEMENTS.PLAY_MONK);
      if (player.class === 'warrior') window.unlockAchievement(window.ACHIEVEMENTS.PLAY_WARRIOR);
      if (player.class === 'ranger') window.unlockAchievement(window.ACHIEVEMENTS.PLAY_RANGER);
      if (player.class === 'mage') window.unlockAchievement(window.ACHIEVEMENTS.PLAY_MAGE);
    }
    
    // Gold achievements
    if (player.gold >= 10000) window.unlockAchievement(window.ACHIEVEMENTS.GOLD_10K);
    if (player.gold >= 100000) window.unlockAchievement(window.ACHIEVEMENTS.GOLD_100K);
    if (player.gold >= 1000000) window.unlockAchievement(window.ACHIEVEMENTS.GOLD_1M);
    
    // Passive tree achievements
    if (passivePointsSpent >= 10) window.unlockAchievement(window.ACHIEVEMENTS.ALLOCATE_10);
    if (passivePointsSpent >= 50) window.unlockAchievement(window.ACHIEVEMENTS.ALLOCATE_50);
    if (passivePointsSpent >= 100) window.unlockAchievement(window.ACHIEVEMENTS.ALLOCATE_100);
    
    // GR achievements
    const highestGR = Math.max(...Object.values(greaterRiftHighest || {}), 0);
    if (highestGR >= 1) window.unlockAchievement(window.ACHIEVEMENTS.GR_COMPLETE_1);
    if (highestGR >= 10) window.unlockAchievement(window.ACHIEVEMENTS.GR_COMPLETE_10);
    if (highestGR >= 25) window.unlockAchievement(window.ACHIEVEMENTS.GR_COMPLETE_25);
    if (highestGR >= 50) window.unlockAchievement(window.ACHIEVEMENTS.GR_COMPLETE_50);
    if (highestGR >= 100) window.unlockAchievement(window.ACHIEVEMENTS.GR_COMPLETE_100);
    
    // Item achievements
    const hasRare = Object.values(equipment).some(item => item && item.rarity === 'rare');
    const hasUnique = Object.values(equipment).some(item => item && item.rarity === 'unique');
    if (hasRare) window.unlockAchievement(window.ACHIEVEMENTS.EQUIP_RARE);
    if (hasUnique) window.unlockAchievement(window.ACHIEVEMENTS.EQUIP_UNIQUE);
    
    // Full rare set
    const slots = ['weapon', 'helmet', 'body', 'gloves', 'boots', 'amulet', 'ring1', 'ring2'];
    const allRare = slots.every(slot => equipment[slot] && (equipment[slot].rarity === 'rare' || equipment[slot].rarity === 'unique'));
    if (allRare) window.unlockAchievement(window.ACHIEVEMENTS.FULL_RARE_SET);
    
  } catch (e) {
    console.error('Achievement check error:', e);
  }
}

// Update all leaderboards with current stats
async function updateSteamLeaderboards() {
  if (!window.steamapi) return;
  
  try {
    const isLoaded = await window.steamapi.isLoaded();
    if (!isLoaded) return;
    
    console.log('📊 Submitting to Steam Leaderboards...');
    
    // Submit highest level
    await window.submitToSteamLeaderboard(window.STEAM_LEADERBOARDS.HIGHEST_LEVEL, player.level);
    
    // Submit highest GR
    const highestGR = Math.max(...Object.values(greaterRiftHighest || {}), 0);
    if (highestGR > 0) {
      await window.submitToSteamLeaderboard(window.STEAM_LEADERBOARDS.HIGHEST_GR, highestGR);
    }
    
    // Submit total kills
    if (player.kills > 0) {
      await window.submitToSteamLeaderboard(window.STEAM_LEADERBOARDS.TOTAL_KILLS, player.kills);
    }
    
    console.log('✅ Steam Leaderboards updated');
  } catch (e) {
    console.error('Leaderboard update error:', e);
  }
}

// Periodic achievement/leaderboard checks
let steamCheckInterval = null;
function startSteamChecks() {
  if (steamCheckInterval) return;
  
  steamCheckInterval = setInterval(() => {
    if (gameState === 'playing') {
      checkSteamAchievements();
    }
  }, 30000); // Check every 30 seconds
}
startSteamChecks();

// Auto-save to cloud periodically
let cloudSaveInterval = null;
function startCloudAutoSave() {
  if (cloudSaveInterval) return;
  
  cloudSaveInterval = setInterval(async () => {
    if (window.steamapi) {
      try {
        const isLoaded = await window.steamapi.isLoaded();
        if (isLoaded) {
          // Get all save data
          const saveData = {
            version: 2,
            timestamp: Date.now(),
            account: localStorage.getItem('poe2idle_account'),
            characters: {}
          };
          
          // Get all character saves
          for (let i = 0; i < localStorage.length; i++) {
            const key = localStorage.key(i);
            if (key && key.startsWith('poe2idle_char_')) {
              saveData.characters[key] = localStorage.getItem(key);
            }
          }
          
          await window.steamCloudSave(JSON.stringify(saveData));
        }
      } catch (e) {
        console.error('Cloud auto-save error:', e);
      }
    }
  }, 300000); // Save to cloud every 5 minutes
}
startCloudAutoSave();

// ========== STEAM INTEGRATION HOOKS ==========
// Call these from appropriate places in the game

// Call when player levels up
function onLevelUp_Steam() {
  checkSteamAchievements();
  window.submitToSteamLeaderboard(window.STEAM_LEADERBOARDS.HIGHEST_LEVEL, player.level);
}

// Call when GR is completed
function onGRCompleted_Steam(level, timeSeconds) {
  window.unlockAchievement(window.ACHIEVEMENTS.GR_COMPLETE_1);
  if (level >= 10) window.unlockAchievement(window.ACHIEVEMENTS.GR_COMPLETE_10);
  if (level >= 25) window.unlockAchievement(window.ACHIEVEMENTS.GR_COMPLETE_25);
  if (level >= 50) window.unlockAchievement(window.ACHIEVEMENTS.GR_COMPLETE_50);
  if (level >= 100) window.unlockAchievement(window.ACHIEVEMENTS.GR_COMPLETE_100);
  
  window.submitToSteamLeaderboard(window.STEAM_LEADERBOARDS.HIGHEST_GR, level);
  
  // Submit time-based leaderboards (lower is better, so invert for descending sort)
  if (level === 10) {
    window.submitToSteamLeaderboard(window.STEAM_LEADERBOARDS.FASTEST_GR10, Math.floor(1000000 - timeSeconds));
  }
  if (level === 25) {
    window.submitToSteamLeaderboard(window.STEAM_LEADERBOARDS.FASTEST_GR25, Math.floor(1000000 - timeSeconds));
  }
  if (level === 50) {
    window.submitToSteamLeaderboard(window.STEAM_LEADERBOARDS.FASTEST_GR50, Math.floor(1000000 - timeSeconds));
  }
}

// Call when dungeon is cleared
function onDungeonCleared_Steam(difficulty) {
  if (difficulty === 'easy') window.unlockAchievement(window.ACHIEVEMENTS.BEAT_EASY);
  if (difficulty === 'normal') window.unlockAchievement(window.ACHIEVEMENTS.BEAT_NORMAL);
  if (difficulty === 'hard') window.unlockAchievement(window.ACHIEVEMENTS.BEAT_HARD);
  if (difficulty === 'elite') window.unlockAchievement(window.ACHIEVEMENTS.BEAT_ELITE);
  if (difficulty === 'nightmare') window.unlockAchievement(window.ACHIEVEMENTS.BEAT_NIGHTMARE);
}

// Call when player dies
function onPlayerDeath_Steam() {
  window.unlockAchievement(window.ACHIEVEMENTS.SURVIVE_DEATH);
}

// Call when enemy is killed
function onEnemyKilled_Steam() {
  // Check achievements every 100 kills to avoid spam
  if (player.kills % 100 === 0) {
    checkSteamAchievements();
    window.submitToSteamLeaderboard(window.STEAM_LEADERBOARDS.TOTAL_KILLS, player.kills);
  }
}

// Call when crafting orb is used
function onCraftingUsed_Steam(totalCrafts) {
  if (totalCrafts >= 1) window.unlockAchievement(window.ACHIEVEMENTS.CRAFT_FIRST);
  if (totalCrafts >= 100) window.unlockAchievement(window.ACHIEVEMENTS.CRAFT_100);
}

// Call when item is equipped
function onItemEquipped_Steam() {
  checkSteamAchievements();
}

// Call when game saves
function onGameSave_Steam() {
  // Debounce cloud saves
  if (!onGameSave_Steam.timeout) {
    onGameSave_Steam.timeout = setTimeout(async () => {
      if (window.steamapi) {
        try {
          const isLoaded = await window.steamapi.isLoaded();
          if (isLoaded) {
            const saveData = {
              version: 2,
              timestamp: Date.now(),
              account: localStorage.getItem('poe2idle_account'),
              characters: {}
            };
            
            for (let i = 0; i < localStorage.length; i++) {
              const key = localStorage.key(i);
              if (key && key.startsWith('poe2idle_char_')) {
                saveData.characters[key] = localStorage.getItem(key);
              }
            }
            
            await window.steamCloudSave(JSON.stringify(saveData));
          }
        } catch (e) {
          console.error('Cloud save error:', e);
        }
      }
      onGameSave_Steam.timeout = null;
    }, 10000); // Wait 10s after last save before cloud sync
  }
}

// ========== END STEAM API INTEGRATION ==========

// ========== BACKGROUND/OFFLINE PROCESSING FOR ELECTRON/STEAM ==========
// This system ensures the game continues running when minimized or in background
// Critical for idle games on Steam

let lastTime = performance.now();
const TARGET_FPS = 60;
const FRAME_TIME = 1000 / TARGET_FPS; // ~16.67ms per frame
let backgroundInterval = null;
let isTabVisible = true;
let isWindowFocused = true;
let lastSaveTime = Date.now();

/* ==================== BACKGROUND/MINIMIZED MODE SYSTEM ====================
 * 
 * This game continues to run when the window is minimized or in the background.
 * The system uses multiple layers to ensure the game never stops:
 * 
 * LAYER 1 - Main Loop (requestAnimationFrame):
 *   - Runs at full 60 FPS when window is visible and focused
 *   - Handles both game updates AND rendering
 *   - May be throttled by browser when window is hidden
 * 
 * LAYER 2 - Background Interval (setInterval):
 *   - Activates when window is minimized or hidden
 *   - Runs at 30 FPS (smoother than typical idle games)
 *   - Handles game updates only (no rendering)
 *   - Serves as backup when requestAnimationFrame is throttled
 * 
 * LAYER 3 - Fallback Interval (setInterval):
 *   - ALWAYS runs at 5 FPS regardless of window state
 *   - Safety net for edge cases where visibility events don't fire
 *   - Only takes over if both other loops aren't running
 * 
 * STATE TRACKING:
 *   - isTabVisible: Tracks document.hidden state (browser tab visibility)
 *   - isWindowFocused: Tracks window focus (may not be reliable across platforms)
 *   - backgroundInterval: The interval handle for background updates
 * 
 * ELECTRON INTEGRATION:
 *   - Uses IPC events for reliable minimize/restore detection
 *   - Avoids blur/focus events which can cause black screen issues
 *   - Requires backgroundThrottling: false in webPreferences
 * 
 * AUTO-SAVE:
 *   - Saves immediately when entering background mode
 *   - Auto-saves every 30 seconds during background mode
 *   - Saves on page unload
 * 
 * PERFORMANCE:
 *   - Delta time is capped at 100ms to prevent physics issues
 *   - Time is reset when exiting background to avoid huge jumps
 *   - Background FPS can be adjusted based on performance needs
 * 
 * ========================================================================== */

// Track when game went to background for minimized window
const BACKGROUND_FPS = 30; // FPS when minimized (33ms interval - smoother gameplay)
const ALWAYS_ON_INTERVAL = 200; // Fallback interval that always runs (5fps)

// Main game loop - ALWAYS runs via requestAnimationFrame
// Only rendering is skipped when window is hidden/minimized
let statsDashboardUpdateCounter = 0;

function loop(currentTime) {
  if (!currentTime) currentTime = performance.now();
  
  const deltaTime = currentTime - lastTime;
  // Cap delta to prevent huge jumps (max 100ms = 10fps minimum)
  const cappedDelta = Math.min(deltaTime, 100);
  const dt = cappedDelta / FRAME_TIME; // Normalized delta (1.0 = 60fps, 2.0 = 30fps)
  lastTime = currentTime;
  
  if (gameState === 'playing') {
    update(dt);
    // Always render unless document is hidden (minimized to tray)
    // This fixes black screen on window resize
    if (!document.hidden) {
      render();
    }
    
    // Update stats dashboard every 30 frames (~0.5 sec)
    statsDashboardUpdateCounter++;
    if (statsDashboardUpdateCounter >= 30) {
      statsDashboardUpdateCounter = 0;
      updateStatsDashboard();
    }
  }
  
  // Auto-save every 30 seconds
  if (Date.now() - lastSaveTime > 30000) {
    saveGame();
    lastSaveTime = Date.now();
  }
  
  // Always request next frame - game loop never stops
  requestAnimationFrame(loop);
}

// Background loop - runs via setInterval when minimized/hidden
function backgroundLoop() {
  const currentTime = performance.now();
  const deltaTime = currentTime - lastTime;
  // Cap delta to prevent huge jumps
  const cappedDelta = Math.min(deltaTime, 100);
  const dt = cappedDelta / FRAME_TIME;
  lastTime = currentTime;
  
  if (gameState === 'playing') {
    update(dt);
  }
  
  // Auto-save in background too
  if (Date.now() - lastSaveTime > 30000) {
    saveGame();
    lastSaveTime = Date.now();
  }
}

// Fallback loop - ALWAYS runs to ensure game never stops completely
// This catches edge cases where visibility/focus events don't fire
let fallbackInterval = null;
function ensureFallbackRunning() {
  if (!fallbackInterval) {
    fallbackInterval = setInterval(() => {
      // Only process if no other loop is actively running
      if (!isTabVisible || !isWindowFocused) {
        // Background loop should be handling this, but just in case
        if (!backgroundInterval) {
          backgroundLoop();
        }
      }
    }, ALWAYS_ON_INTERVAL);
  }
}

// Switch to background mode when window is minimized
function enterBackgroundMode() {
  console.log('Entering background mode');
  
  isTabVisible = false;
  isWindowFocused = false;
  
  // Auto-save when minimizing to ensure progress is preserved
  saveGame();
  
  // Background interval is backup for when requestAnimationFrame is throttled
  // (e.g., minimized to system tray)
  if (!backgroundInterval) {
    backgroundInterval = setInterval(backgroundLoop, 1000 / BACKGROUND_FPS);
    console.log('Background interval started (backup)');
  }
}

// Return to foreground mode
function exitBackgroundMode() {
  console.log('Exiting background mode');
  
  isTabVisible = true;
  isWindowFocused = true;
  
  // Stop background interval (main loop handles everything now)
  if (backgroundInterval) {
    clearInterval(backgroundInterval);
    backgroundInterval = null;
    console.log('Background interval stopped');
  }
  
  // Reset time to avoid huge delta jump when returning
  lastTime = performance.now();
}

// Handle visibility change (browser tabs / minimize)
document.addEventListener('visibilitychange', function() {
  if (document.hidden) {
    enterBackgroundMode();
  } else {
    exitBackgroundMode();
  }
});

// Note: blur/focus events removed - they fire during normal window interactions
// like resizing and can cause the black screen issue. 
// The visibility change handler is sufficient for browser tabs.
// Electron uses IPC events below which are more reliable.

// Electron-specific: handle window minimize/restore
// These events are available when running in Electron
if (typeof require !== 'undefined') {
  try {
    const { ipcRenderer } = require('electron');
    if (ipcRenderer) {
      ipcRenderer.on('window-minimized', () => {
        console.log('Electron: window minimized');
        enterBackgroundMode();
      });
      ipcRenderer.on('window-restored', () => {
        console.log('Electron: window restored');
        exitBackgroundMode();
      });
      // Note: blur/focus handlers removed - they can cause black screen during window interactions
      console.log('Electron IPC listeners registered');
    }
  } catch (e) {
    // Not running in Electron, that's fine
    console.log('Not running in Electron environment');
  }
}

// Handle page unload - save game
window.addEventListener('beforeunload', function() {
  saveGame();
});

// Initialize
initInventoryGrid();
initStashGrid();
initDOMCache(); // Cache DOM elements for performance

// Load account-wide aspects (before character load)
loadUnlockedAspects();

// Load account data first (character list, shared resources)
loadAccountData();

// Now initialize menu with loaded character list
initMenu();

// Apply aspects to character after load
applyActiveAspects();

// Start the fallback interval (always running as safety net)
ensureFallbackRunning();

// Start the main loop
requestAnimationFrame(loop);

console.log('===== Game Initialized =====');
console.log('Main loop: 60 FPS (requestAnimationFrame)');
console.log('Background mode: 30 FPS (when minimized)');
console.log('Fallback safety: 5 FPS (always running)');
console.log('Auto-save: Every 30 seconds + on minimize');
console.log('===========================');

// ========== ELECTRON MAIN PROCESS SETUP NOTES ==========
// For Electron/Steam, add this to your main.js:
//
// mainWindow.on('minimize', () => {
//   mainWindow.webContents.send('window-minimized');
// });
// mainWindow.on('restore', () => {
//   mainWindow.webContents.send('window-restored');
// });
//
// Note: focus/blur handlers removed to prevent black screen during window interactions
//
// Also set backgroundThrottling: false in webPreferences:
// webPreferences: {
//   backgroundThrottling: false,
//   nodeIntegration: true,
//   contextIsolation: false
// }
</script>

<!-- Resistance Tooltip (outside char-panel for proper fixed positioning) -->
<div class="res-tooltip" id="resTooltip">
  <div class="res-tooltip-title" id="resTooltipTitle">Fire Resistance</div>
  <div class="res-tooltip-desc" id="resTooltipDesc">Reduces Fire damage taken by this percentage. Negative values increase damage taken.</div>
  <div class="res-tooltip-cap">Maximum Resistance is capped at 70% by default. The number in brackets shows your uncapped total.</div>
</div>

<!-- Bar Tooltip (Health/Mana breakdown) -->
<div id="barTooltip">
  <div class="bar-tooltip-title" id="barTooltipTitle">
    <span class="name">Life</span>
    <span class="current">100/200</span>
  </div>
  <div id="barTooltipContent"></div>
</div>

<!-- Debuff Tooltip -->
<div class="debuff-tooltip" id="debuffTooltip">
  <div class="debuff-tooltip-name" id="debuffTooltipName">Burning</div>
  <div class="debuff-tooltip-desc" id="debuffTooltipDesc">Burns the enemy for fire damage over time</div>
  <div class="debuff-tooltip-stacks" id="debuffTooltipStacks">Stacks: 1</div>
</div>

<!-- Death Screen -->
<div class="death-screen" id="deathScreen">
  <div class="death-title">YOU DIED</div>
  <div class="death-report">
    <div class="death-killer" id="deathKiller">Slain by Unknown</div>
    <div class="death-damage" id="deathDamage">Fatal blow: 0 damage</div>
    <div class="death-penalty" id="deathPenalty">Lost 0 gold (2% penalty)</div>
    <div class="death-timer" id="deathTimer">10</div>
    <div class="death-timer-label">Respawning in...</div>
  </div>
</div>

<!-- Uncontrolled Core Confirmation Modal -->
<div class="confirm-modal-overlay" id="uncontrolledModal" style="display: none;">
  <div class="confirm-modal">
    <div class="confirm-modal-icon">🔴</div>
    <div class="confirm-modal-title">Uncontrolled Core</div>
    <div class="confirm-modal-warning">⚠️ WARNING ⚠️</div>
    <div class="confirm-modal-text">
      This will make the item <span style="color: #ff6666; font-weight: bold;">IMMUTABLE</span> - it can never be modified again!
    </div>
    <div class="confirm-modal-effects">
      Possible outcomes:
      <ul>
        <li style="color: #8f8;">Add powerful implicit mod</li>
        <li style="color: #8f8;">Add extra socket</li>
        <li style="color: #ff8;">Transform into different item</li>
        <li style="color: #f88;">Brick - become useless</li>
      </ul>
    </div>
    <div class="confirm-modal-buttons">
      <button class="confirm-btn cancel" onclick="closeUncontrolledModal()">Cancel</button>
      <button class="confirm-btn confirm" onclick="applyUncontrolled()">Use Uncontrolled Core</button>
    </div>
  </div>
</div>

</body>
</html>
